# Generated by cloudcoil-model-codegen v0.5.6
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import (
    Annotated,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class CertSecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CertSecretRef"]:
            return CertSecretRef

        def build(self) -> "CertSecretRef":
            return CertSecretRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["CertSecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CertSecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CertSecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CertSecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CertSecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referent.
    """


class ProxySecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProxySecretRef"]:
            return ProxySecretRef

        def build(self) -> "ProxySecretRef":
            return ProxySecretRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["ProxySecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProxySecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProxySecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProxySecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProxySecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referent.
    """


class SecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretRef"]:
            return SecretRef

        def build(self) -> "SecretRef":
            return SecretRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["SecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referent.
    """


class Sts(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Sts"]:
            return Sts

        def build(self) -> "Sts":
            return Sts(**self._attrs)

        @overload
        def cert_secret_ref(
            self, value_or_callback: Optional[CertSecretRef], /
        ) -> "Sts.Builder": ...

        @overload
        def cert_secret_ref(
            self,
            value_or_callback: Callable[
                [CertSecretRef.Builder], CertSecretRef.Builder | CertSecretRef
            ],
            /,
        ) -> "Sts.Builder": ...

        @overload
        def cert_secret_ref(
            self, value_or_callback: Never = ...
        ) -> "CertSecretRef.BuilderContext": ...

        def cert_secret_ref(self, value_or_callback=None, /):
            """
            CertSecretRef can be given the name of a Secret containing
            either or both of

            - a PEM-encoded client certificate (`tls.crt`) and private
            key (`tls.key`);
            - a PEM-encoded CA certificate (`ca.crt`)

            and whichever are supplied, will be used for connecting to the
            STS endpoint. The client cert and key are useful if you are
            authenticating with a certificate; the CA cert is useful if
            you are using a self-signed server certificate. The Secret must
            be of type `Opaque` or `kubernetes.io/tls`.

            This field is only supported for the `ldap` provider.
            """
            if self._in_context and value_or_callback is None:
                context = CertSecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert_secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CertSecretRef.builder())
                if isinstance(output, CertSecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert_secret_ref", value)

        def endpoint(self, value: str, /) -> Self:
            """
            Endpoint is the HTTP/S endpoint of the Security Token Service from
            where temporary credentials will be fetched.
            """
            return self._set("endpoint", value)

        def provider(self, value: Literal["aws", "ldap"], /) -> Self:
            """
            Provider of the Security Token Service.
            """
            return self._set("provider", value)

        @overload
        def secret_ref(self, value_or_callback: Optional[SecretRef], /) -> "Sts.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "Sts.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            SecretRef specifies the Secret containing authentication credentials
            for the STS endpoint. This Secret must contain the fields `username`
            and `password` and is supported only for the `ldap` provider.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

    class BuilderContext(BuilderContextBase["Sts.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Sts.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Sts."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Sts", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Sts.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cert_secret_ref: Annotated[Optional[CertSecretRef], Field(alias="certSecretRef")] = None
    """
    CertSecretRef can be given the name of a Secret containing
    either or both of

    - a PEM-encoded client certificate (`tls.crt`) and private
    key (`tls.key`);
    - a PEM-encoded CA certificate (`ca.crt`)

    and whichever are supplied, will be used for connecting to the
    STS endpoint. The client cert and key are useful if you are
    authenticating with a certificate; the CA cert is useful if
    you are using a self-signed server certificate. The Secret must
    be of type `Opaque` or `kubernetes.io/tls`.

    This field is only supported for the `ldap` provider.
    """
    endpoint: Annotated[str, Field(pattern="^(http|https)://.*$")]
    """
    Endpoint is the HTTP/S endpoint of the Security Token Service from
    where temporary credentials will be fetched.
    """
    provider: Literal["aws", "ldap"]
    """
    Provider of the Security Token Service.
    """
    secret_ref: Annotated[Optional[SecretRef], Field(alias="secretRef")] = None
    """
    SecretRef specifies the Secret containing authentication credentials
    for the STS endpoint. This Secret must contain the fields `username`
    and `password` and is supported only for the `ldap` provider.
    """


class BucketSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BucketSpec"]:
            return BucketSpec

        def build(self) -> "BucketSpec":
            return BucketSpec(**self._attrs)

        def bucket_name(self, value: str, /) -> Self:
            """
            BucketName is the name of the object storage bucket.
            """
            return self._set("bucket_name", value)

        @overload
        def cert_secret_ref(
            self, value_or_callback: Optional[CertSecretRef], /
        ) -> "BucketSpec.Builder": ...

        @overload
        def cert_secret_ref(
            self,
            value_or_callback: Callable[
                [CertSecretRef.Builder], CertSecretRef.Builder | CertSecretRef
            ],
            /,
        ) -> "BucketSpec.Builder": ...

        @overload
        def cert_secret_ref(
            self, value_or_callback: Never = ...
        ) -> "CertSecretRef.BuilderContext": ...

        def cert_secret_ref(self, value_or_callback=None, /):
            """
            CertSecretRef can be given the name of a Secret containing
            either or both of

            - a PEM-encoded client certificate (`tls.crt`) and private
            key (`tls.key`);
            - a PEM-encoded CA certificate (`ca.crt`)

            and whichever are supplied, will be used for connecting to the
            bucket. The client cert and key are useful if you are
            authenticating with a certificate; the CA cert is useful if
            you are using a self-signed server certificate. The Secret must
            be of type `Opaque` or `kubernetes.io/tls`.

            This field is only supported for the `generic` provider.
            """
            if self._in_context and value_or_callback is None:
                context = CertSecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert_secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CertSecretRef.builder())
                if isinstance(output, CertSecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert_secret_ref", value)

        def endpoint(self, value: str, /) -> Self:
            """
            Endpoint is the object storage address the BucketName is located at.
            """
            return self._set("endpoint", value)

        def ignore(self, value: Optional[str], /) -> Self:
            """
            Ignore overrides the set of excluded patterns in the .sourceignore format
            (which is the same as .gitignore). If not provided, a default will be used,
            consult the documentation for your version to find out what those are.
            """
            return self._set("ignore", value)

        def insecure(self, value: Optional[bool], /) -> Self:
            """
            Insecure allows connecting to a non-TLS HTTP Endpoint.
            """
            return self._set("insecure", value)

        def interval(self, value: str, /) -> Self:
            """
            Interval at which the Bucket Endpoint is checked for updates.
            This interval is approximate and may be subject to jitter to ensure
            efficient use of resources.
            """
            return self._set("interval", value)

        def prefix(self, value: Optional[str], /) -> Self:
            """
            Prefix to use for server-side filtering of files in the Bucket.
            """
            return self._set("prefix", value)

        def provider(self, value: Optional[Literal["generic", "aws", "gcp", "azure"]], /) -> Self:
            """
            Provider of the object storage bucket.
            Defaults to 'generic', which expects an S3 (API) compatible object
            storage.
            """
            return self._set("provider", value)

        @overload
        def proxy_secret_ref(
            self, value_or_callback: Optional[ProxySecretRef], /
        ) -> "BucketSpec.Builder": ...

        @overload
        def proxy_secret_ref(
            self,
            value_or_callback: Callable[
                [ProxySecretRef.Builder], ProxySecretRef.Builder | ProxySecretRef
            ],
            /,
        ) -> "BucketSpec.Builder": ...

        @overload
        def proxy_secret_ref(
            self, value_or_callback: Never = ...
        ) -> "ProxySecretRef.BuilderContext": ...

        def proxy_secret_ref(self, value_or_callback=None, /):
            """
            ProxySecretRef specifies the Secret containing the proxy configuration
            to use while communicating with the Bucket server.
            """
            if self._in_context and value_or_callback is None:
                context = ProxySecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "proxy_secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProxySecretRef.builder())
                if isinstance(output, ProxySecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("proxy_secret_ref", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            Region of the Endpoint where the BucketName is located in.
            """
            return self._set("region", value)

        @overload
        def secret_ref(self, value_or_callback: Optional[SecretRef], /) -> "BucketSpec.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "BucketSpec.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            SecretRef specifies the Secret containing authentication credentials
            for the Bucket.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        @overload
        def sts(self, value_or_callback: Optional[Sts], /) -> "BucketSpec.Builder": ...

        @overload
        def sts(
            self, value_or_callback: Callable[[Sts.Builder], Sts.Builder | Sts], /
        ) -> "BucketSpec.Builder": ...

        @overload
        def sts(self, value_or_callback: Never = ...) -> "Sts.BuilderContext": ...

        def sts(self, value_or_callback=None, /):
            """
            STS specifies the required configuration to use a Security Token
            Service for fetching temporary credentials to authenticate in a
            Bucket provider.

            This field is only supported for the `aws` and `generic` providers.
            """
            if self._in_context and value_or_callback is None:
                context = Sts.BuilderContext()
                context._parent_builder = self
                context._field_name = "sts"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sts.builder())
                if isinstance(output, Sts.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sts", value)

        def suspend(self, value: Optional[bool], /) -> Self:
            """
            Suspend tells the controller to suspend the reconciliation of this
            Bucket.
            """
            return self._set("suspend", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout for fetch operations, defaults to 60s.
            """
            return self._set("timeout", value)

    class BuilderContext(BuilderContextBase["BucketSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BucketSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BucketSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BucketSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BucketSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    bucket_name: Annotated[str, Field(alias="bucketName")]
    """
    BucketName is the name of the object storage bucket.
    """
    cert_secret_ref: Annotated[Optional[CertSecretRef], Field(alias="certSecretRef")] = None
    """
    CertSecretRef can be given the name of a Secret containing
    either or both of

    - a PEM-encoded client certificate (`tls.crt`) and private
    key (`tls.key`);
    - a PEM-encoded CA certificate (`ca.crt`)

    and whichever are supplied, will be used for connecting to the
    bucket. The client cert and key are useful if you are
    authenticating with a certificate; the CA cert is useful if
    you are using a self-signed server certificate. The Secret must
    be of type `Opaque` or `kubernetes.io/tls`.

    This field is only supported for the `generic` provider.
    """
    endpoint: str
    """
    Endpoint is the object storage address the BucketName is located at.
    """
    ignore: Optional[str] = None
    """
    Ignore overrides the set of excluded patterns in the .sourceignore format
    (which is the same as .gitignore). If not provided, a default will be used,
    consult the documentation for your version to find out what those are.
    """
    insecure: Optional[bool] = None
    """
    Insecure allows connecting to a non-TLS HTTP Endpoint.
    """
    interval: Annotated[str, Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$")]
    """
    Interval at which the Bucket Endpoint is checked for updates.
    This interval is approximate and may be subject to jitter to ensure
    efficient use of resources.
    """
    prefix: Optional[str] = None
    """
    Prefix to use for server-side filtering of files in the Bucket.
    """
    provider: Optional[Literal["generic", "aws", "gcp", "azure"]] = "generic"
    """
    Provider of the object storage bucket.
    Defaults to 'generic', which expects an S3 (API) compatible object
    storage.
    """
    proxy_secret_ref: Annotated[Optional[ProxySecretRef], Field(alias="proxySecretRef")] = None
    """
    ProxySecretRef specifies the Secret containing the proxy configuration
    to use while communicating with the Bucket server.
    """
    region: Optional[str] = None
    """
    Region of the Endpoint where the BucketName is located in.
    """
    secret_ref: Annotated[Optional[SecretRef], Field(alias="secretRef")] = None
    """
    SecretRef specifies the Secret containing authentication credentials
    for the Bucket.
    """
    sts: Optional[Sts] = None
    """
    STS specifies the required configuration to use a Security Token
    Service for fetching temporary credentials to authenticate in a
    Bucket provider.

    This field is only supported for the `aws` and `generic` providers.
    """
    suspend: Optional[bool] = None
    """
    Suspend tells the controller to suspend the reconciliation of this
    Bucket.
    """
    timeout: Annotated[Optional[str], Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m))+$")] = "60s"
    """
    Timeout for fetch operations, defaults to 60s.
    """


class Artifact(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Artifact"]:
            return Artifact

        def build(self) -> "Artifact":
            return Artifact(**self._attrs)

        def digest(self, value: Optional[str], /) -> Self:
            """
            Digest is the digest of the file in the form of '<algorithm>:<checksum>'.
            """
            return self._set("digest", value)

        def last_update_time(self, value: datetime, /) -> Self:
            """
            LastUpdateTime is the timestamp corresponding to the last update of the
            Artifact.
            """
            return self._set("last_update_time", value)

        def metadata(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Metadata holds upstream information such as OCI annotations.
            """
            return self._set("metadata", value)

        def path(self, value: str, /) -> Self:
            """
            Path is the relative file path of the Artifact. It can be used to locate
            the file in the root of the Artifact storage on the local file system of
            the controller managing the Source.
            """
            return self._set("path", value)

        def revision(self, value: str, /) -> Self:
            """
            Revision is a human-readable identifier traceable in the origin source
            system. It can be a Git commit SHA, Git tag, a Helm chart version, etc.
            """
            return self._set("revision", value)

        def size(self, value: Optional[int], /) -> Self:
            """
            Size is the number of bytes in the file.
            """
            return self._set("size", value)

        def url(self, value: str, /) -> Self:
            """
            URL is the HTTP address of the Artifact as exposed by the controller
            managing the Source. It can be used to retrieve the Artifact for
            consumption, e.g. by another controller applying the Artifact contents.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["Artifact.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Artifact.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Artifact."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Artifact", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Artifact.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    digest: Annotated[
        Optional[str], Field(pattern="^[a-z0-9]+(?:[.+_-][a-z0-9]+)*:[a-zA-Z0-9=_-]+$")
    ] = None
    """
    Digest is the digest of the file in the form of '<algorithm>:<checksum>'.
    """
    last_update_time: Annotated[datetime, Field(alias="lastUpdateTime")]
    """
    LastUpdateTime is the timestamp corresponding to the last update of the
    Artifact.
    """
    metadata: Optional[Dict[str, str]] = None
    """
    Metadata holds upstream information such as OCI annotations.
    """
    path: str
    """
    Path is the relative file path of the Artifact. It can be used to locate
    the file in the root of the Artifact storage on the local file system of
    the controller managing the Source.
    """
    revision: str
    """
    Revision is a human-readable identifier traceable in the origin source
    system. It can be a Git commit SHA, Git tag, a Helm chart version, etc.
    """
    size: Optional[int] = None
    """
    Size is the number of bytes in the file.
    """
    url: str
    """
    URL is the HTTP address of the Artifact as exposed by the controller
    managing the Source. It can be used to retrieve the Artifact for
    consumption, e.g. by another controller applying the Artifact contents.
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: datetime, /) -> Self:
            """
            lastTransitionTime is the last time the condition transitioned from one status to another.
            This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
            """
            return self._set("last_transition_time", value)

        def message(self, value: str, /) -> Self:
            """
            message is a human readable message indicating details about the transition.
            This may be an empty string.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            observedGeneration represents the .metadata.generation that the condition was set based upon.
            For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
            with respect to the current state of the instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: str, /) -> Self:
            """
            reason contains a programmatic identifier indicating the reason for the condition's last transition.
            Producers of specific condition types may define expected values and meanings for this field,
            and whether the values are considered a guaranteed API.
            The value should be a CamelCase string.
            This field may not be empty.
            """
            return self._set("reason", value)

        def status(self, value: Literal["True", "False", "Unknown"], /) -> Self:
            """
            status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            type of condition in CamelCase or in foo.example.com/CamelCase.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[datetime, Field(alias="lastTransitionTime")]
    """
    lastTransitionTime is the last time the condition transitioned from one status to another.
    This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    """
    message: Annotated[str, Field(max_length=32768)]
    """
    message is a human readable message indicating details about the transition.
    This may be an empty string.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration", ge=0)] = None
    """
    observedGeneration represents the .metadata.generation that the condition was set based upon.
    For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
    with respect to the current state of the instance.
    """
    reason: Annotated[
        str,
        Field(
            max_length=1024,
            min_length=1,
            pattern="^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$",
        ),
    ]
    """
    reason contains a programmatic identifier indicating the reason for the condition's last transition.
    Producers of specific condition types may define expected values and meanings for this field,
    and whether the values are considered a guaranteed API.
    The value should be a CamelCase string.
    This field may not be empty.
    """
    status: Literal["True", "False", "Unknown"]
    """
    status of the condition, one of True, False, Unknown.
    """
    type: Annotated[
        str,
        Field(
            max_length=316,
            pattern="^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$",
        ),
    ]
    """
    type of condition in CamelCase or in foo.example.com/CamelCase.
    """


class BucketStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BucketStatus"]:
            return BucketStatus

        def build(self) -> "BucketStatus":
            return BucketStatus(**self._attrs)

        @overload
        def artifact(self, value_or_callback: Optional[Artifact], /) -> "BucketStatus.Builder": ...

        @overload
        def artifact(
            self,
            value_or_callback: Callable[[Artifact.Builder], Artifact.Builder | Artifact],
            /,
        ) -> "BucketStatus.Builder": ...

        @overload
        def artifact(self, value_or_callback: Never = ...) -> "Artifact.BuilderContext": ...

        def artifact(self, value_or_callback=None, /):
            """
            Artifact represents the last successful Bucket reconciliation.
            """
            if self._in_context and value_or_callback is None:
                context = Artifact.BuilderContext()
                context._parent_builder = self
                context._field_name = "artifact"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Artifact.builder())
                if isinstance(output, Artifact.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("artifact", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "BucketStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "BucketStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions holds the conditions for the Bucket.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def last_handled_reconcile_at(self, value: Optional[str], /) -> Self:
            """
            LastHandledReconcileAt holds the value of the most recent
            reconcile request value, so a change of the annotation value
            can be detected.
            """
            return self._set("last_handled_reconcile_at", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the last observed generation of the Bucket object.
            """
            return self._set("observed_generation", value)

        def observed_ignore(self, value: Optional[str], /) -> Self:
            """
            ObservedIgnore is the observed exclusion patterns used for constructing
            the source artifact.
            """
            return self._set("observed_ignore", value)

        def url(self, value: Optional[str], /) -> Self:
            """
            URL is the dynamic fetch link for the latest Artifact.
            It is provided on a "best effort" basis, and using the precise
            BucketStatus.Artifact data is recommended.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["BucketStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BucketStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BucketStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BucketStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BucketStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    artifact: Optional[Artifact] = None
    """
    Artifact represents the last successful Bucket reconciliation.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions holds the conditions for the Bucket.
    """
    last_handled_reconcile_at: Annotated[Optional[str], Field(alias="lastHandledReconcileAt")] = (
        None
    )
    """
    LastHandledReconcileAt holds the value of the most recent
    reconcile request value, so a change of the annotation value
    can be detected.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the last observed generation of the Bucket object.
    """
    observed_ignore: Annotated[Optional[str], Field(alias="observedIgnore")] = None
    """
    ObservedIgnore is the observed exclusion patterns used for constructing
    the source artifact.
    """
    url: Optional[str] = None
    """
    URL is the dynamic fetch link for the latest Artifact.
    It is provided on a "best effort" basis, and using the precise
    BucketStatus.Artifact data is recommended.
    """


class Repository(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Repository"]:
            return Repository

        def build(self) -> "Repository":
            return Repository(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["Repository.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Repository.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Repository."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Repository", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Repository.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referent.
    """


class Include(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Include"]:
            return Include

        def build(self) -> "Include":
            return Include(**self._attrs)

        def from_path(self, value: Optional[str], /) -> Self:
            """
            FromPath specifies the path to copy contents from, defaults to the root
            of the Artifact.
            """
            return self._set("from_path", value)

        @overload
        def repository(self, value_or_callback: Repository, /) -> "Include.Builder": ...

        @overload
        def repository(
            self,
            value_or_callback: Callable[[Repository.Builder], Repository.Builder | Repository],
            /,
        ) -> "Include.Builder": ...

        @overload
        def repository(self, value_or_callback: Never = ...) -> "Repository.BuilderContext": ...

        def repository(self, value_or_callback=None, /):
            """
            GitRepositoryRef specifies the GitRepository which Artifact contents
            must be included.
            """
            if self._in_context and value_or_callback is None:
                context = Repository.BuilderContext()
                context._parent_builder = self
                context._field_name = "repository"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Repository.builder())
                if isinstance(output, Repository.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("repository", value)

        def to_path(self, value: Optional[str], /) -> Self:
            """
            ToPath specifies the path to copy contents to, defaults to the name of
            the GitRepositoryRef.
            """
            return self._set("to_path", value)

    class BuilderContext(BuilderContextBase["Include.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Include.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Include."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Include", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Include.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    from_path: Annotated[Optional[str], Field(alias="fromPath")] = None
    """
    FromPath specifies the path to copy contents from, defaults to the root
    of the Artifact.
    """
    repository: Repository
    """
    GitRepositoryRef specifies the GitRepository which Artifact contents
    must be included.
    """
    to_path: Annotated[Optional[str], Field(alias="toPath")] = None
    """
    ToPath specifies the path to copy contents to, defaults to the name of
    the GitRepositoryRef.
    """


class Ref(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ref"]:
            return Ref

        def build(self) -> "Ref":
            return Ref(**self._attrs)

        def branch(self, value: Optional[str], /) -> Self:
            """
            Branch to check out, defaults to 'master' if no other field is defined.
            """
            return self._set("branch", value)

        def commit(self, value: Optional[str], /) -> Self:
            """
            Commit SHA to check out, takes precedence over all reference fields.

            This can be combined with Branch to shallow clone the branch, in which
            the commit is expected to exist.
            """
            return self._set("commit", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the reference to check out; takes precedence over Branch, Tag and SemVer.

            It must be a valid Git reference: https://git-scm.com/docs/git-check-ref-format#_description
            Examples: "refs/heads/main", "refs/tags/v0.1.0", "refs/pull/420/head", "refs/merge-requests/1/head"
            """
            return self._set("name", value)

        def semver(self, value: Optional[str], /) -> Self:
            """
            SemVer tag expression to check out, takes precedence over Tag.
            """
            return self._set("semver", value)

        def tag(self, value: Optional[str], /) -> Self:
            """
            Tag to check out, takes precedence over Branch.
            """
            return self._set("tag", value)

    class BuilderContext(BuilderContextBase["Ref.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ref.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ref."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ref", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ref.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    branch: Optional[str] = None
    """
    Branch to check out, defaults to 'master' if no other field is defined.
    """
    commit: Optional[str] = None
    """
    Commit SHA to check out, takes precedence over all reference fields.

    This can be combined with Branch to shallow clone the branch, in which
    the commit is expected to exist.
    """
    name: Optional[str] = None
    """
    Name of the reference to check out; takes precedence over Branch, Tag and SemVer.

    It must be a valid Git reference: https://git-scm.com/docs/git-check-ref-format#_description
    Examples: "refs/heads/main", "refs/tags/v0.1.0", "refs/pull/420/head", "refs/merge-requests/1/head"
    """
    semver: Optional[str] = None
    """
    SemVer tag expression to check out, takes precedence over Tag.
    """
    tag: Optional[str] = None
    """
    Tag to check out, takes precedence over Branch.
    """


class Verify(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Verify"]:
            return Verify

        def build(self) -> "Verify":
            return Verify(**self._attrs)

        def mode(self, value: Optional[Literal["head", "HEAD", "Tag", "TagAndHEAD"]], /) -> Self:
            """
            Mode specifies which Git object(s) should be verified.

            The variants "head" and "HEAD" both imply the same thing, i.e. verify
            the commit that the HEAD of the Git repository points to. The variant
            "head" solely exists to ensure backwards compatibility.
            """
            return self._set("mode", value)

        @overload
        def secret_ref(self, value_or_callback: SecretRef, /) -> "Verify.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "Verify.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            SecretRef specifies the Secret containing the public keys of trusted Git
            authors.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

    class BuilderContext(BuilderContextBase["Verify.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Verify.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Verify."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Verify", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Verify.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    mode: Optional[Literal["head", "HEAD", "Tag", "TagAndHEAD"]] = "HEAD"
    """
    Mode specifies which Git object(s) should be verified.

    The variants "head" and "HEAD" both imply the same thing, i.e. verify
    the commit that the HEAD of the Git repository points to. The variant
    "head" solely exists to ensure backwards compatibility.
    """
    secret_ref: Annotated[SecretRef, Field(alias="secretRef")]
    """
    SecretRef specifies the Secret containing the public keys of trusted Git
    authors.
    """


class GitRepositorySpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GitRepositorySpec"]:
            return GitRepositorySpec

        def build(self) -> "GitRepositorySpec":
            return GitRepositorySpec(**self._attrs)

        def ignore(self, value: Optional[str], /) -> Self:
            """
            Ignore overrides the set of excluded patterns in the .sourceignore format
            (which is the same as .gitignore). If not provided, a default will be used,
            consult the documentation for your version to find out what those are.
            """
            return self._set("ignore", value)

        @overload
        def include(self, value_or_callback: List[Include], /) -> "GitRepositorySpec.Builder": ...

        @overload
        def include(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Include, Include.Builder]],
                GenericListBuilder[Include, Include.Builder] | List[Include],
            ],
            /,
        ) -> "GitRepositorySpec.Builder": ...

        @overload
        def include(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Include.Builder]: ...

        def include(self, value_or_callback=None, /):
            """
            Include specifies a list of GitRepository resources which Artifacts
            should be included in the Artifact produced for this GitRepository.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Include.Builder]()
                context._parent_builder = self
                context._field_name = "include"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Include.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("include", value)

        def interval(self, value: str, /) -> Self:
            """
            Interval at which the GitRepository URL is checked for updates.
            This interval is approximate and may be subject to jitter to ensure
            efficient use of resources.
            """
            return self._set("interval", value)

        def provider(self, value: Optional[Literal["generic", "azure", "github"]], /) -> Self:
            """
            Provider used for authentication, can be 'azure', 'github', 'generic'.
            When not specified, defaults to 'generic'.
            """
            return self._set("provider", value)

        @overload
        def proxy_secret_ref(
            self, value_or_callback: Optional[ProxySecretRef], /
        ) -> "GitRepositorySpec.Builder": ...

        @overload
        def proxy_secret_ref(
            self,
            value_or_callback: Callable[
                [ProxySecretRef.Builder], ProxySecretRef.Builder | ProxySecretRef
            ],
            /,
        ) -> "GitRepositorySpec.Builder": ...

        @overload
        def proxy_secret_ref(
            self, value_or_callback: Never = ...
        ) -> "ProxySecretRef.BuilderContext": ...

        def proxy_secret_ref(self, value_or_callback=None, /):
            """
            ProxySecretRef specifies the Secret containing the proxy configuration
            to use while communicating with the Git server.
            """
            if self._in_context and value_or_callback is None:
                context = ProxySecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "proxy_secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProxySecretRef.builder())
                if isinstance(output, ProxySecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("proxy_secret_ref", value)

        def recurse_submodules(self, value: Optional[bool], /) -> Self:
            """
            RecurseSubmodules enables the initialization of all submodules within
            the GitRepository as cloned from the URL, using their default settings.
            """
            return self._set("recurse_submodules", value)

        @overload
        def ref(self, value_or_callback: Optional[Ref], /) -> "GitRepositorySpec.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "GitRepositorySpec.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Reference specifies the Git reference to resolve and monitor for
            changes, defaults to the 'master' branch.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        @overload
        def secret_ref(
            self, value_or_callback: Optional[SecretRef], /
        ) -> "GitRepositorySpec.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "GitRepositorySpec.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            SecretRef specifies the Secret containing authentication credentials for
            the GitRepository.
            For HTTPS repositories the Secret must contain 'username' and 'password'
            fields for basic auth or 'bearerToken' field for token auth.
            For SSH repositories the Secret must contain 'identity'
            and 'known_hosts' fields.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def suspend(self, value: Optional[bool], /) -> Self:
            """
            Suspend tells the controller to suspend the reconciliation of this
            GitRepository.
            """
            return self._set("suspend", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout for Git operations like cloning, defaults to 60s.
            """
            return self._set("timeout", value)

        def url(self, value: str, /) -> Self:
            """
            URL specifies the Git repository URL, it can be an HTTP/S or SSH address.
            """
            return self._set("url", value)

        @overload
        def verify(self, value_or_callback: Optional[Verify], /) -> "GitRepositorySpec.Builder": ...

        @overload
        def verify(
            self,
            value_or_callback: Callable[[Verify.Builder], Verify.Builder | Verify],
            /,
        ) -> "GitRepositorySpec.Builder": ...

        @overload
        def verify(self, value_or_callback: Never = ...) -> "Verify.BuilderContext": ...

        def verify(self, value_or_callback=None, /):
            """
            Verification specifies the configuration to verify the Git commit
            signature(s).
            """
            if self._in_context and value_or_callback is None:
                context = Verify.BuilderContext()
                context._parent_builder = self
                context._field_name = "verify"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Verify.builder())
                if isinstance(output, Verify.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("verify", value)

    class BuilderContext(BuilderContextBase["GitRepositorySpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GitRepositorySpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GitRepositorySpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GitRepositorySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GitRepositorySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ignore: Optional[str] = None
    """
    Ignore overrides the set of excluded patterns in the .sourceignore format
    (which is the same as .gitignore). If not provided, a default will be used,
    consult the documentation for your version to find out what those are.
    """
    include: Optional[List[Include]] = None
    """
    Include specifies a list of GitRepository resources which Artifacts
    should be included in the Artifact produced for this GitRepository.
    """
    interval: Annotated[str, Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$")]
    """
    Interval at which the GitRepository URL is checked for updates.
    This interval is approximate and may be subject to jitter to ensure
    efficient use of resources.
    """
    provider: Optional[Literal["generic", "azure", "github"]] = None
    """
    Provider used for authentication, can be 'azure', 'github', 'generic'.
    When not specified, defaults to 'generic'.
    """
    proxy_secret_ref: Annotated[Optional[ProxySecretRef], Field(alias="proxySecretRef")] = None
    """
    ProxySecretRef specifies the Secret containing the proxy configuration
    to use while communicating with the Git server.
    """
    recurse_submodules: Annotated[Optional[bool], Field(alias="recurseSubmodules")] = None
    """
    RecurseSubmodules enables the initialization of all submodules within
    the GitRepository as cloned from the URL, using their default settings.
    """
    ref: Optional[Ref] = None
    """
    Reference specifies the Git reference to resolve and monitor for
    changes, defaults to the 'master' branch.
    """
    secret_ref: Annotated[Optional[SecretRef], Field(alias="secretRef")] = None
    """
    SecretRef specifies the Secret containing authentication credentials for
    the GitRepository.
    For HTTPS repositories the Secret must contain 'username' and 'password'
    fields for basic auth or 'bearerToken' field for token auth.
    For SSH repositories the Secret must contain 'identity'
    and 'known_hosts' fields.
    """
    suspend: Optional[bool] = None
    """
    Suspend tells the controller to suspend the reconciliation of this
    GitRepository.
    """
    timeout: Annotated[Optional[str], Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m))+$")] = "60s"
    """
    Timeout for Git operations like cloning, defaults to 60s.
    """
    url: Annotated[str, Field(pattern="^(http|https|ssh)://.*$")]
    """
    URL specifies the Git repository URL, it can be an HTTP/S or SSH address.
    """
    verify: Optional[Verify] = None
    """
    Verification specifies the configuration to verify the Git commit
    signature(s).
    """


class IncludedArtifact(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IncludedArtifact"]:
            return IncludedArtifact

        def build(self) -> "IncludedArtifact":
            return IncludedArtifact(**self._attrs)

        def digest(self, value: Optional[str], /) -> Self:
            """
            Digest is the digest of the file in the form of '<algorithm>:<checksum>'.
            """
            return self._set("digest", value)

        def last_update_time(self, value: datetime, /) -> Self:
            """
            LastUpdateTime is the timestamp corresponding to the last update of the
            Artifact.
            """
            return self._set("last_update_time", value)

        def metadata(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Metadata holds upstream information such as OCI annotations.
            """
            return self._set("metadata", value)

        def path(self, value: str, /) -> Self:
            """
            Path is the relative file path of the Artifact. It can be used to locate
            the file in the root of the Artifact storage on the local file system of
            the controller managing the Source.
            """
            return self._set("path", value)

        def revision(self, value: str, /) -> Self:
            """
            Revision is a human-readable identifier traceable in the origin source
            system. It can be a Git commit SHA, Git tag, a Helm chart version, etc.
            """
            return self._set("revision", value)

        def size(self, value: Optional[int], /) -> Self:
            """
            Size is the number of bytes in the file.
            """
            return self._set("size", value)

        def url(self, value: str, /) -> Self:
            """
            URL is the HTTP address of the Artifact as exposed by the controller
            managing the Source. It can be used to retrieve the Artifact for
            consumption, e.g. by another controller applying the Artifact contents.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["IncludedArtifact.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IncludedArtifact.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IncludedArtifact."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IncludedArtifact", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IncludedArtifact.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    digest: Annotated[
        Optional[str], Field(pattern="^[a-z0-9]+(?:[.+_-][a-z0-9]+)*:[a-zA-Z0-9=_-]+$")
    ] = None
    """
    Digest is the digest of the file in the form of '<algorithm>:<checksum>'.
    """
    last_update_time: Annotated[datetime, Field(alias="lastUpdateTime")]
    """
    LastUpdateTime is the timestamp corresponding to the last update of the
    Artifact.
    """
    metadata: Optional[Dict[str, str]] = None
    """
    Metadata holds upstream information such as OCI annotations.
    """
    path: str
    """
    Path is the relative file path of the Artifact. It can be used to locate
    the file in the root of the Artifact storage on the local file system of
    the controller managing the Source.
    """
    revision: str
    """
    Revision is a human-readable identifier traceable in the origin source
    system. It can be a Git commit SHA, Git tag, a Helm chart version, etc.
    """
    size: Optional[int] = None
    """
    Size is the number of bytes in the file.
    """
    url: str
    """
    URL is the HTTP address of the Artifact as exposed by the controller
    managing the Source. It can be used to retrieve the Artifact for
    consumption, e.g. by another controller applying the Artifact contents.
    """


class ObservedInclude(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ObservedInclude"]:
            return ObservedInclude

        def build(self) -> "ObservedInclude":
            return ObservedInclude(**self._attrs)

        def from_path(self, value: Optional[str], /) -> Self:
            """
            FromPath specifies the path to copy contents from, defaults to the root
            of the Artifact.
            """
            return self._set("from_path", value)

        @overload
        def repository(self, value_or_callback: Repository, /) -> "ObservedInclude.Builder": ...

        @overload
        def repository(
            self,
            value_or_callback: Callable[[Repository.Builder], Repository.Builder | Repository],
            /,
        ) -> "ObservedInclude.Builder": ...

        @overload
        def repository(self, value_or_callback: Never = ...) -> "Repository.BuilderContext": ...

        def repository(self, value_or_callback=None, /):
            """
            GitRepositoryRef specifies the GitRepository which Artifact contents
            must be included.
            """
            if self._in_context and value_or_callback is None:
                context = Repository.BuilderContext()
                context._parent_builder = self
                context._field_name = "repository"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Repository.builder())
                if isinstance(output, Repository.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("repository", value)

        def to_path(self, value: Optional[str], /) -> Self:
            """
            ToPath specifies the path to copy contents to, defaults to the name of
            the GitRepositoryRef.
            """
            return self._set("to_path", value)

    class BuilderContext(BuilderContextBase["ObservedInclude.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ObservedInclude.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ObservedInclude."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ObservedInclude", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ObservedInclude.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    from_path: Annotated[Optional[str], Field(alias="fromPath")] = None
    """
    FromPath specifies the path to copy contents from, defaults to the root
    of the Artifact.
    """
    repository: Repository
    """
    GitRepositoryRef specifies the GitRepository which Artifact contents
    must be included.
    """
    to_path: Annotated[Optional[str], Field(alias="toPath")] = None
    """
    ToPath specifies the path to copy contents to, defaults to the name of
    the GitRepositoryRef.
    """


class GitRepositoryStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GitRepositoryStatus"]:
            return GitRepositoryStatus

        def build(self) -> "GitRepositoryStatus":
            return GitRepositoryStatus(**self._attrs)

        @overload
        def artifact(
            self, value_or_callback: Optional[Artifact], /
        ) -> "GitRepositoryStatus.Builder": ...

        @overload
        def artifact(
            self,
            value_or_callback: Callable[[Artifact.Builder], Artifact.Builder | Artifact],
            /,
        ) -> "GitRepositoryStatus.Builder": ...

        @overload
        def artifact(self, value_or_callback: Never = ...) -> "Artifact.BuilderContext": ...

        def artifact(self, value_or_callback=None, /):
            """
            Artifact represents the last successful GitRepository reconciliation.
            """
            if self._in_context and value_or_callback is None:
                context = Artifact.BuilderContext()
                context._parent_builder = self
                context._field_name = "artifact"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Artifact.builder())
                if isinstance(output, Artifact.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("artifact", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "GitRepositoryStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "GitRepositoryStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions holds the conditions for the GitRepository.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        @overload
        def included_artifacts(
            self, value_or_callback: List[IncludedArtifact], /
        ) -> "GitRepositoryStatus.Builder": ...

        @overload
        def included_artifacts(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[IncludedArtifact, IncludedArtifact.Builder]],
                GenericListBuilder[IncludedArtifact, IncludedArtifact.Builder]
                | List[IncludedArtifact],
            ],
            /,
        ) -> "GitRepositoryStatus.Builder": ...

        @overload
        def included_artifacts(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[IncludedArtifact.Builder]: ...

        def included_artifacts(self, value_or_callback=None, /):
            """
            IncludedArtifacts contains a list of the last successfully included
            Artifacts as instructed by GitRepositorySpec.Include.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[IncludedArtifact.Builder]()
                context._parent_builder = self
                context._field_name = "included_artifacts"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IncludedArtifact.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("included_artifacts", value)

        def last_handled_reconcile_at(self, value: Optional[str], /) -> Self:
            """
            LastHandledReconcileAt holds the value of the most recent
            reconcile request value, so a change of the annotation value
            can be detected.
            """
            return self._set("last_handled_reconcile_at", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the last observed generation of the GitRepository
            object.
            """
            return self._set("observed_generation", value)

        def observed_ignore(self, value: Optional[str], /) -> Self:
            """
            ObservedIgnore is the observed exclusion patterns used for constructing
            the source artifact.
            """
            return self._set("observed_ignore", value)

        @overload
        def observed_include(
            self, value_or_callback: List[ObservedInclude], /
        ) -> "GitRepositoryStatus.Builder": ...

        @overload
        def observed_include(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ObservedInclude, ObservedInclude.Builder]],
                GenericListBuilder[ObservedInclude, ObservedInclude.Builder]
                | List[ObservedInclude],
            ],
            /,
        ) -> "GitRepositoryStatus.Builder": ...

        @overload
        def observed_include(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ObservedInclude.Builder]: ...

        def observed_include(self, value_or_callback=None, /):
            """
            ObservedInclude is the observed list of GitRepository resources used to
            produce the current Artifact.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ObservedInclude.Builder]()
                context._parent_builder = self
                context._field_name = "observed_include"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ObservedInclude.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("observed_include", value)

        def observed_recurse_submodules(self, value: Optional[bool], /) -> Self:
            """
            ObservedRecurseSubmodules is the observed resource submodules
            configuration used to produce the current Artifact.
            """
            return self._set("observed_recurse_submodules", value)

        def source_verification_mode(self, value: Optional[str], /) -> Self:
            """
            SourceVerificationMode is the last used verification mode indicating
            which Git object(s) have been verified.
            """
            return self._set("source_verification_mode", value)

    class BuilderContext(BuilderContextBase["GitRepositoryStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GitRepositoryStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GitRepositoryStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GitRepositoryStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GitRepositoryStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    artifact: Optional[Artifact] = None
    """
    Artifact represents the last successful GitRepository reconciliation.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions holds the conditions for the GitRepository.
    """
    included_artifacts: Annotated[
        Optional[List[IncludedArtifact]], Field(alias="includedArtifacts")
    ] = None
    """
    IncludedArtifacts contains a list of the last successfully included
    Artifacts as instructed by GitRepositorySpec.Include.
    """
    last_handled_reconcile_at: Annotated[Optional[str], Field(alias="lastHandledReconcileAt")] = (
        None
    )
    """
    LastHandledReconcileAt holds the value of the most recent
    reconcile request value, so a change of the annotation value
    can be detected.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the last observed generation of the GitRepository
    object.
    """
    observed_ignore: Annotated[Optional[str], Field(alias="observedIgnore")] = None
    """
    ObservedIgnore is the observed exclusion patterns used for constructing
    the source artifact.
    """
    observed_include: Annotated[Optional[List[ObservedInclude]], Field(alias="observedInclude")] = (
        None
    )
    """
    ObservedInclude is the observed list of GitRepository resources used to
    produce the current Artifact.
    """
    observed_recurse_submodules: Annotated[
        Optional[bool], Field(alias="observedRecurseSubmodules")
    ] = None
    """
    ObservedRecurseSubmodules is the observed resource submodules
    configuration used to produce the current Artifact.
    """
    source_verification_mode: Annotated[Optional[str], Field(alias="sourceVerificationMode")] = None
    """
    SourceVerificationMode is the last used verification mode indicating
    which Git object(s) have been verified.
    """


class SourceRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SourceRef"]:
            return SourceRef

        def build(self) -> "SourceRef":
            return SourceRef(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Literal["HelmRepository", "GitRepository", "Bucket"], /) -> Self:
            """
            Kind of the referent, valid values are ('HelmRepository', 'GitRepository',
            'Bucket').
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["SourceRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SourceRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SourceRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SourceRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SourceRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion of the referent.
    """
    kind: Literal["HelmRepository", "GitRepository", "Bucket"]
    """
    Kind of the referent, valid values are ('HelmRepository', 'GitRepository',
    'Bucket').
    """
    name: str
    """
    Name of the referent.
    """


class MatchOidcIdentity(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchOidcIdentity"]:
            return MatchOidcIdentity

        def build(self) -> "MatchOidcIdentity":
            return MatchOidcIdentity(**self._attrs)

        def issuer(self, value: str, /) -> Self:
            """
            Issuer specifies the regex pattern to match against to verify
            the OIDC issuer in the Fulcio certificate. The pattern must be a
            valid Go regular expression.
            """
            return self._set("issuer", value)

        def subject(self, value: str, /) -> Self:
            """
            Subject specifies the regex pattern to match against to verify
            the identity subject in the Fulcio certificate. The pattern must
            be a valid Go regular expression.
            """
            return self._set("subject", value)

    class BuilderContext(BuilderContextBase["MatchOidcIdentity.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchOidcIdentity.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchOidcIdentity."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchOidcIdentity", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchOidcIdentity.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    issuer: str
    """
    Issuer specifies the regex pattern to match against to verify
    the OIDC issuer in the Fulcio certificate. The pattern must be a
    valid Go regular expression.
    """
    subject: str
    """
    Subject specifies the regex pattern to match against to verify
    the identity subject in the Fulcio certificate. The pattern must
    be a valid Go regular expression.
    """


class VerifyModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VerifyModel"]:
            return VerifyModel

        def build(self) -> "VerifyModel":
            return VerifyModel(**self._attrs)

        @overload
        def match_oidc_identity(
            self, value_or_callback: List[MatchOidcIdentity], /
        ) -> "VerifyModel.Builder": ...

        @overload
        def match_oidc_identity(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchOidcIdentity, MatchOidcIdentity.Builder]],
                GenericListBuilder[MatchOidcIdentity, MatchOidcIdentity.Builder]
                | List[MatchOidcIdentity],
            ],
            /,
        ) -> "VerifyModel.Builder": ...

        @overload
        def match_oidc_identity(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchOidcIdentity.Builder]: ...

        def match_oidc_identity(self, value_or_callback=None, /):
            """
            MatchOIDCIdentity specifies the identity matching criteria to use
            while verifying an OCI artifact which was signed using Cosign keyless
            signing. The artifact's identity is deemed to be verified if any of the
            specified matchers match against the identity.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchOidcIdentity.Builder]()
                context._parent_builder = self
                context._field_name = "match_oidc_identity"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchOidcIdentity.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_oidc_identity", value)

        def provider(self, value: Optional[Literal["cosign", "notation"]], /) -> Self:
            """
            Provider specifies the technology used to sign the OCI Artifact.
            """
            return self._set("provider", value)

        @overload
        def secret_ref(
            self, value_or_callback: Optional[SecretRef], /
        ) -> "VerifyModel.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "VerifyModel.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            SecretRef specifies the Kubernetes Secret containing the
            trusted public keys.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

    class BuilderContext(BuilderContextBase["VerifyModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VerifyModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VerifyModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VerifyModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VerifyModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_oidc_identity: Annotated[
        Optional[List[MatchOidcIdentity]], Field(alias="matchOIDCIdentity")
    ] = None
    """
    MatchOIDCIdentity specifies the identity matching criteria to use
    while verifying an OCI artifact which was signed using Cosign keyless
    signing. The artifact's identity is deemed to be verified if any of the
    specified matchers match against the identity.
    """
    provider: Optional[Literal["cosign", "notation"]] = "cosign"
    """
    Provider specifies the technology used to sign the OCI Artifact.
    """
    secret_ref: Annotated[Optional[SecretRef], Field(alias="secretRef")] = None
    """
    SecretRef specifies the Kubernetes Secret containing the
    trusted public keys.
    """


class HelmChartSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HelmChartSpec"]:
            return HelmChartSpec

        def build(self) -> "HelmChartSpec":
            return HelmChartSpec(**self._attrs)

        def chart(self, value: str, /) -> Self:
            """
            Chart is the name or path the Helm chart is available at in the
            SourceRef.
            """
            return self._set("chart", value)

        def ignore_missing_values_files(self, value: Optional[bool], /) -> Self:
            """
            IgnoreMissingValuesFiles controls whether to silently ignore missing values
            files rather than failing.
            """
            return self._set("ignore_missing_values_files", value)

        def interval(self, value: str, /) -> Self:
            """
            Interval at which the HelmChart SourceRef is checked for updates.
            This interval is approximate and may be subject to jitter to ensure
            efficient use of resources.
            """
            return self._set("interval", value)

        def reconcile_strategy(
            self, value: Optional[Literal["ChartVersion", "Revision"]], /
        ) -> Self:
            """
            ReconcileStrategy determines what enables the creation of a new artifact.
            Valid values are ('ChartVersion', 'Revision').
            See the documentation of the values for an explanation on their behavior.
            Defaults to ChartVersion when omitted.
            """
            return self._set("reconcile_strategy", value)

        @overload
        def source_ref(self, value_or_callback: SourceRef, /) -> "HelmChartSpec.Builder": ...

        @overload
        def source_ref(
            self,
            value_or_callback: Callable[[SourceRef.Builder], SourceRef.Builder | SourceRef],
            /,
        ) -> "HelmChartSpec.Builder": ...

        @overload
        def source_ref(self, value_or_callback: Never = ...) -> "SourceRef.BuilderContext": ...

        def source_ref(self, value_or_callback=None, /):
            """
            SourceRef is the reference to the Source the chart is available at.
            """
            if self._in_context and value_or_callback is None:
                context = SourceRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "source_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SourceRef.builder())
                if isinstance(output, SourceRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("source_ref", value)

        def suspend(self, value: Optional[bool], /) -> Self:
            """
            Suspend tells the controller to suspend the reconciliation of this
            source.
            """
            return self._set("suspend", value)

        def values_files(self, value: Optional[List[str]], /) -> Self:
            """
            ValuesFiles is an alternative list of values files to use as the chart
            values (values.yaml is not included by default), expected to be a
            relative path in the SourceRef.
            Values files are merged in the order of this list with the last file
            overriding the first. Ignored when omitted.
            """
            return self._set("values_files", value)

        @overload
        def verify(
            self, value_or_callback: Optional[VerifyModel], /
        ) -> "HelmChartSpec.Builder": ...

        @overload
        def verify(
            self,
            value_or_callback: Callable[[VerifyModel.Builder], VerifyModel.Builder | VerifyModel],
            /,
        ) -> "HelmChartSpec.Builder": ...

        @overload
        def verify(self, value_or_callback: Never = ...) -> "VerifyModel.BuilderContext": ...

        def verify(self, value_or_callback=None, /):
            """
            Verify contains the secret name containing the trusted public keys
            used to verify the signature and specifies which provider to use to check
            whether OCI image is authentic.
            This field is only supported when using HelmRepository source with spec.type 'oci'.
            Chart dependencies, which are not bundled in the umbrella chart artifact, are not verified.
            """
            if self._in_context and value_or_callback is None:
                context = VerifyModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "verify"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VerifyModel.builder())
                if isinstance(output, VerifyModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("verify", value)

        def version(self, value: Optional[str], /) -> Self:
            """
            Version is the chart version semver expression, ignored for charts from
            GitRepository and Bucket sources. Defaults to latest when omitted.
            """
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["HelmChartSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HelmChartSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HelmChartSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HelmChartSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmChartSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    chart: str
    """
    Chart is the name or path the Helm chart is available at in the
    SourceRef.
    """
    ignore_missing_values_files: Annotated[
        Optional[bool], Field(alias="ignoreMissingValuesFiles")
    ] = None
    """
    IgnoreMissingValuesFiles controls whether to silently ignore missing values
    files rather than failing.
    """
    interval: Annotated[str, Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$")]
    """
    Interval at which the HelmChart SourceRef is checked for updates.
    This interval is approximate and may be subject to jitter to ensure
    efficient use of resources.
    """
    reconcile_strategy: Annotated[
        Optional[Literal["ChartVersion", "Revision"]], Field(alias="reconcileStrategy")
    ] = "ChartVersion"
    """
    ReconcileStrategy determines what enables the creation of a new artifact.
    Valid values are ('ChartVersion', 'Revision').
    See the documentation of the values for an explanation on their behavior.
    Defaults to ChartVersion when omitted.
    """
    source_ref: Annotated[SourceRef, Field(alias="sourceRef")]
    """
    SourceRef is the reference to the Source the chart is available at.
    """
    suspend: Optional[bool] = None
    """
    Suspend tells the controller to suspend the reconciliation of this
    source.
    """
    values_files: Annotated[Optional[List[str]], Field(alias="valuesFiles")] = None
    """
    ValuesFiles is an alternative list of values files to use as the chart
    values (values.yaml is not included by default), expected to be a
    relative path in the SourceRef.
    Values files are merged in the order of this list with the last file
    overriding the first. Ignored when omitted.
    """
    verify: Optional[VerifyModel] = None
    """
    Verify contains the secret name containing the trusted public keys
    used to verify the signature and specifies which provider to use to check
    whether OCI image is authentic.
    This field is only supported when using HelmRepository source with spec.type 'oci'.
    Chart dependencies, which are not bundled in the umbrella chart artifact, are not verified.
    """
    version: Optional[str] = "*"
    """
    Version is the chart version semver expression, ignored for charts from
    GitRepository and Bucket sources. Defaults to latest when omitted.
    """


class HelmChartStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HelmChartStatus"]:
            return HelmChartStatus

        def build(self) -> "HelmChartStatus":
            return HelmChartStatus(**self._attrs)

        @overload
        def artifact(
            self, value_or_callback: Optional[Artifact], /
        ) -> "HelmChartStatus.Builder": ...

        @overload
        def artifact(
            self,
            value_or_callback: Callable[[Artifact.Builder], Artifact.Builder | Artifact],
            /,
        ) -> "HelmChartStatus.Builder": ...

        @overload
        def artifact(self, value_or_callback: Never = ...) -> "Artifact.BuilderContext": ...

        def artifact(self, value_or_callback=None, /):
            """
            Artifact represents the output of the last successful reconciliation.
            """
            if self._in_context and value_or_callback is None:
                context = Artifact.BuilderContext()
                context._parent_builder = self
                context._field_name = "artifact"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Artifact.builder())
                if isinstance(output, Artifact.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("artifact", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "HelmChartStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "HelmChartStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions holds the conditions for the HelmChart.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def last_handled_reconcile_at(self, value: Optional[str], /) -> Self:
            """
            LastHandledReconcileAt holds the value of the most recent
            reconcile request value, so a change of the annotation value
            can be detected.
            """
            return self._set("last_handled_reconcile_at", value)

        def observed_chart_name(self, value: Optional[str], /) -> Self:
            """
            ObservedChartName is the last observed chart name as specified by the
            resolved chart reference.
            """
            return self._set("observed_chart_name", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the last observed generation of the HelmChart
            object.
            """
            return self._set("observed_generation", value)

        def observed_source_artifact_revision(self, value: Optional[str], /) -> Self:
            """
            ObservedSourceArtifactRevision is the last observed Artifact.Revision
            of the HelmChartSpec.SourceRef.
            """
            return self._set("observed_source_artifact_revision", value)

        def observed_values_files(self, value: Optional[List[str]], /) -> Self:
            """
            ObservedValuesFiles are the observed value files of the last successful
            reconciliation.
            It matches the chart in the last successfully reconciled artifact.
            """
            return self._set("observed_values_files", value)

        def url(self, value: Optional[str], /) -> Self:
            """
            URL is the dynamic fetch link for the latest Artifact.
            It is provided on a "best effort" basis, and using the precise
            BucketStatus.Artifact data is recommended.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["HelmChartStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HelmChartStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HelmChartStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HelmChartStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmChartStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    artifact: Optional[Artifact] = None
    """
    Artifact represents the output of the last successful reconciliation.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions holds the conditions for the HelmChart.
    """
    last_handled_reconcile_at: Annotated[Optional[str], Field(alias="lastHandledReconcileAt")] = (
        None
    )
    """
    LastHandledReconcileAt holds the value of the most recent
    reconcile request value, so a change of the annotation value
    can be detected.
    """
    observed_chart_name: Annotated[Optional[str], Field(alias="observedChartName")] = None
    """
    ObservedChartName is the last observed chart name as specified by the
    resolved chart reference.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the last observed generation of the HelmChart
    object.
    """
    observed_source_artifact_revision: Annotated[
        Optional[str], Field(alias="observedSourceArtifactRevision")
    ] = None
    """
    ObservedSourceArtifactRevision is the last observed Artifact.Revision
    of the HelmChartSpec.SourceRef.
    """
    observed_values_files: Annotated[Optional[List[str]], Field(alias="observedValuesFiles")] = None
    """
    ObservedValuesFiles are the observed value files of the last successful
    reconciliation.
    It matches the chart in the last successfully reconciled artifact.
    """
    url: Optional[str] = None
    """
    URL is the dynamic fetch link for the latest Artifact.
    It is provided on a "best effort" basis, and using the precise
    BucketStatus.Artifact data is recommended.
    """


class NamespaceSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NamespaceSelector"]:
            return NamespaceSelector

        def build(self) -> "NamespaceSelector":
            return NamespaceSelector(**self._attrs)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["NamespaceSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NamespaceSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NamespaceSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NamespaceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamespaceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class AccessFrom(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AccessFrom"]:
            return AccessFrom

        def build(self) -> "AccessFrom":
            return AccessFrom(**self._attrs)

        @overload
        def namespace_selectors(
            self, value_or_callback: List[NamespaceSelector], /
        ) -> "AccessFrom.Builder": ...

        @overload
        def namespace_selectors(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[NamespaceSelector, NamespaceSelector.Builder]],
                GenericListBuilder[NamespaceSelector, NamespaceSelector.Builder]
                | List[NamespaceSelector],
            ],
            /,
        ) -> "AccessFrom.Builder": ...

        @overload
        def namespace_selectors(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[NamespaceSelector.Builder]: ...

        def namespace_selectors(self, value_or_callback=None, /):
            """
            NamespaceSelectors is the list of namespace selectors to which this ACL applies.
            Items in this list are evaluated using a logical OR operation.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[NamespaceSelector.Builder]()
                context._parent_builder = self
                context._field_name = "namespace_selectors"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamespaceSelector.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("namespace_selectors", value)

    class BuilderContext(BuilderContextBase["AccessFrom.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AccessFrom.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AccessFrom."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AccessFrom", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AccessFrom.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    namespace_selectors: Annotated[List[NamespaceSelector], Field(alias="namespaceSelectors")]
    """
    NamespaceSelectors is the list of namespace selectors to which this ACL applies.
    Items in this list are evaluated using a logical OR operation.
    """


class HelmRepositorySpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HelmRepositorySpec"]:
            return HelmRepositorySpec

        def build(self) -> "HelmRepositorySpec":
            return HelmRepositorySpec(**self._attrs)

        @overload
        def access_from(
            self, value_or_callback: Optional[AccessFrom], /
        ) -> "HelmRepositorySpec.Builder": ...

        @overload
        def access_from(
            self,
            value_or_callback: Callable[[AccessFrom.Builder], AccessFrom.Builder | AccessFrom],
            /,
        ) -> "HelmRepositorySpec.Builder": ...

        @overload
        def access_from(self, value_or_callback: Never = ...) -> "AccessFrom.BuilderContext": ...

        def access_from(self, value_or_callback=None, /):
            """
            AccessFrom specifies an Access Control List for allowing cross-namespace
            references to this object.
            NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
            """
            if self._in_context and value_or_callback is None:
                context = AccessFrom.BuilderContext()
                context._parent_builder = self
                context._field_name = "access_from"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AccessFrom.builder())
                if isinstance(output, AccessFrom.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("access_from", value)

        @overload
        def cert_secret_ref(
            self, value_or_callback: Optional[CertSecretRef], /
        ) -> "HelmRepositorySpec.Builder": ...

        @overload
        def cert_secret_ref(
            self,
            value_or_callback: Callable[
                [CertSecretRef.Builder], CertSecretRef.Builder | CertSecretRef
            ],
            /,
        ) -> "HelmRepositorySpec.Builder": ...

        @overload
        def cert_secret_ref(
            self, value_or_callback: Never = ...
        ) -> "CertSecretRef.BuilderContext": ...

        def cert_secret_ref(self, value_or_callback=None, /):
            """
            CertSecretRef can be given the name of a Secret containing
            either or both of

            - a PEM-encoded client certificate (`tls.crt`) and private
            key (`tls.key`);
            - a PEM-encoded CA certificate (`ca.crt`)

            and whichever are supplied, will be used for connecting to the
            registry. The client cert and key are useful if you are
            authenticating with a certificate; the CA cert is useful if
            you are using a self-signed server certificate. The Secret must
            be of type `Opaque` or `kubernetes.io/tls`.

            It takes precedence over the values specified in the Secret referred
            to by `.spec.secretRef`.
            """
            if self._in_context and value_or_callback is None:
                context = CertSecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert_secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CertSecretRef.builder())
                if isinstance(output, CertSecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert_secret_ref", value)

        def insecure(self, value: Optional[bool], /) -> Self:
            """
            Insecure allows connecting to a non-TLS HTTP container registry.
            This field is only taken into account if the .spec.type field is set to 'oci'.
            """
            return self._set("insecure", value)

        def interval(self, value: Optional[str], /) -> Self:
            """
            Interval at which the HelmRepository URL is checked for updates.
            This interval is approximate and may be subject to jitter to ensure
            efficient use of resources.
            """
            return self._set("interval", value)

        def pass_credentials(self, value: Optional[bool], /) -> Self:
            """
            PassCredentials allows the credentials from the SecretRef to be passed
            on to a host that does not match the host as defined in URL.
            This may be required if the host of the advertised chart URLs in the
            index differ from the defined URL.
            Enabling this should be done with caution, as it can potentially result
            in credentials getting stolen in a MITM-attack.
            """
            return self._set("pass_credentials", value)

        def provider(self, value: Optional[Literal["generic", "aws", "azure", "gcp"]], /) -> Self:
            """
            Provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'.
            This field is optional, and only taken into account if the .spec.type field is set to 'oci'.
            When not specified, defaults to 'generic'.
            """
            return self._set("provider", value)

        @overload
        def secret_ref(
            self, value_or_callback: Optional[SecretRef], /
        ) -> "HelmRepositorySpec.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "HelmRepositorySpec.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            SecretRef specifies the Secret containing authentication credentials
            for the HelmRepository.
            For HTTP/S basic auth the secret must contain 'username' and 'password'
            fields.
            Support for TLS auth using the 'certFile' and 'keyFile', and/or 'caFile'
            keys is deprecated. Please use `.spec.certSecretRef` instead.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def suspend(self, value: Optional[bool], /) -> Self:
            """
            Suspend tells the controller to suspend the reconciliation of this
            HelmRepository.
            """
            return self._set("suspend", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout is used for the index fetch operation for an HTTPS helm repository,
            and for remote OCI Repository operations like pulling for an OCI helm
            chart by the associated HelmChart.
            Its default value is 60s.
            """
            return self._set("timeout", value)

        def type(self, value: Optional[Literal["default", "oci"]], /) -> Self:
            """
            Type of the HelmRepository.
            When this field is set to  "oci", the URL field value must be prefixed with "oci://".
            """
            return self._set("type", value)

        def url(self, value: str, /) -> Self:
            """
            URL of the Helm repository, a valid URL contains at least a protocol and
            host.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["HelmRepositorySpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HelmRepositorySpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HelmRepositorySpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HelmRepositorySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmRepositorySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_from: Annotated[Optional[AccessFrom], Field(alias="accessFrom")] = None
    """
    AccessFrom specifies an Access Control List for allowing cross-namespace
    references to this object.
    NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
    """
    cert_secret_ref: Annotated[Optional[CertSecretRef], Field(alias="certSecretRef")] = None
    """
    CertSecretRef can be given the name of a Secret containing
    either or both of

    - a PEM-encoded client certificate (`tls.crt`) and private
    key (`tls.key`);
    - a PEM-encoded CA certificate (`ca.crt`)

    and whichever are supplied, will be used for connecting to the
    registry. The client cert and key are useful if you are
    authenticating with a certificate; the CA cert is useful if
    you are using a self-signed server certificate. The Secret must
    be of type `Opaque` or `kubernetes.io/tls`.

    It takes precedence over the values specified in the Secret referred
    to by `.spec.secretRef`.
    """
    insecure: Optional[bool] = None
    """
    Insecure allows connecting to a non-TLS HTTP container registry.
    This field is only taken into account if the .spec.type field is set to 'oci'.
    """
    interval: Annotated[Optional[str], Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$")] = None
    """
    Interval at which the HelmRepository URL is checked for updates.
    This interval is approximate and may be subject to jitter to ensure
    efficient use of resources.
    """
    pass_credentials: Annotated[Optional[bool], Field(alias="passCredentials")] = None
    """
    PassCredentials allows the credentials from the SecretRef to be passed
    on to a host that does not match the host as defined in URL.
    This may be required if the host of the advertised chart URLs in the
    index differ from the defined URL.
    Enabling this should be done with caution, as it can potentially result
    in credentials getting stolen in a MITM-attack.
    """
    provider: Optional[Literal["generic", "aws", "azure", "gcp"]] = "generic"
    """
    Provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'.
    This field is optional, and only taken into account if the .spec.type field is set to 'oci'.
    When not specified, defaults to 'generic'.
    """
    secret_ref: Annotated[Optional[SecretRef], Field(alias="secretRef")] = None
    """
    SecretRef specifies the Secret containing authentication credentials
    for the HelmRepository.
    For HTTP/S basic auth the secret must contain 'username' and 'password'
    fields.
    Support for TLS auth using the 'certFile' and 'keyFile', and/or 'caFile'
    keys is deprecated. Please use `.spec.certSecretRef` instead.
    """
    suspend: Optional[bool] = None
    """
    Suspend tells the controller to suspend the reconciliation of this
    HelmRepository.
    """
    timeout: Annotated[Optional[str], Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m))+$")] = None
    """
    Timeout is used for the index fetch operation for an HTTPS helm repository,
    and for remote OCI Repository operations like pulling for an OCI helm
    chart by the associated HelmChart.
    Its default value is 60s.
    """
    type: Optional[Literal["default", "oci"]] = None
    """
    Type of the HelmRepository.
    When this field is set to  "oci", the URL field value must be prefixed with "oci://".
    """
    url: Annotated[str, Field(pattern="^(http|https|oci)://.*$")]
    """
    URL of the Helm repository, a valid URL contains at least a protocol and
    host.
    """


class HelmRepositoryStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HelmRepositoryStatus"]:
            return HelmRepositoryStatus

        def build(self) -> "HelmRepositoryStatus":
            return HelmRepositoryStatus(**self._attrs)

        @overload
        def artifact(
            self, value_or_callback: Optional[Artifact], /
        ) -> "HelmRepositoryStatus.Builder": ...

        @overload
        def artifact(
            self,
            value_or_callback: Callable[[Artifact.Builder], Artifact.Builder | Artifact],
            /,
        ) -> "HelmRepositoryStatus.Builder": ...

        @overload
        def artifact(self, value_or_callback: Never = ...) -> "Artifact.BuilderContext": ...

        def artifact(self, value_or_callback=None, /):
            """
            Artifact represents the last successful HelmRepository reconciliation.
            """
            if self._in_context and value_or_callback is None:
                context = Artifact.BuilderContext()
                context._parent_builder = self
                context._field_name = "artifact"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Artifact.builder())
                if isinstance(output, Artifact.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("artifact", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "HelmRepositoryStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "HelmRepositoryStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions holds the conditions for the HelmRepository.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def last_handled_reconcile_at(self, value: Optional[str], /) -> Self:
            """
            LastHandledReconcileAt holds the value of the most recent
            reconcile request value, so a change of the annotation value
            can be detected.
            """
            return self._set("last_handled_reconcile_at", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the last observed generation of the HelmRepository
            object.
            """
            return self._set("observed_generation", value)

        def url(self, value: Optional[str], /) -> Self:
            """
            URL is the dynamic fetch link for the latest Artifact.
            It is provided on a "best effort" basis, and using the precise
            HelmRepositoryStatus.Artifact data is recommended.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["HelmRepositoryStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HelmRepositoryStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HelmRepositoryStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HelmRepositoryStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmRepositoryStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    artifact: Optional[Artifact] = None
    """
    Artifact represents the last successful HelmRepository reconciliation.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions holds the conditions for the HelmRepository.
    """
    last_handled_reconcile_at: Annotated[Optional[str], Field(alias="lastHandledReconcileAt")] = (
        None
    )
    """
    LastHandledReconcileAt holds the value of the most recent
    reconcile request value, so a change of the annotation value
    can be detected.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the last observed generation of the HelmRepository
    object.
    """
    url: Optional[str] = None
    """
    URL is the dynamic fetch link for the latest Artifact.
    It is provided on a "best effort" basis, and using the precise
    HelmRepositoryStatus.Artifact data is recommended.
    """


class Bucket(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Bucket"]:
            return Bucket

        def build(self) -> "Bucket":
            return Bucket(**self._attrs)

        def api_version(self, value: Optional[Literal["source.toolkit.fluxcd.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Bucket"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Bucket.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Bucket.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[BucketSpec], /) -> "Bucket.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[BucketSpec.Builder], BucketSpec.Builder | BucketSpec],
            /,
        ) -> "Bucket.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "BucketSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BucketSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BucketSpec.builder())
                if isinstance(output, BucketSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[BucketStatus], /) -> "Bucket.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [BucketStatus.Builder], BucketStatus.Builder | BucketStatus
            ],
            /,
        ) -> "Bucket.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "BucketStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BucketStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BucketStatus.builder())
                if isinstance(output, BucketStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Bucket.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Bucket.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Bucket."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Bucket", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Bucket.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["source.toolkit.fluxcd.io/v1"]], Field(alias="apiVersion")
    ] = "source.toolkit.fluxcd.io/v1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Bucket"]] = "Bucket"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[BucketSpec] = None
    status: Optional[BucketStatus] = None


class GitRepository(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GitRepository"]:
            return GitRepository

        def build(self) -> "GitRepository":
            return GitRepository(**self._attrs)

        def api_version(self, value: Optional[Literal["source.toolkit.fluxcd.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["GitRepository"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "GitRepository.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "GitRepository.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[GitRepositorySpec], /
        ) -> "GitRepository.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [GitRepositorySpec.Builder],
                GitRepositorySpec.Builder | GitRepositorySpec,
            ],
            /,
        ) -> "GitRepository.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "GitRepositorySpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = GitRepositorySpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GitRepositorySpec.builder())
                if isinstance(output, GitRepositorySpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[GitRepositoryStatus], /
        ) -> "GitRepository.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [GitRepositoryStatus.Builder],
                GitRepositoryStatus.Builder | GitRepositoryStatus,
            ],
            /,
        ) -> "GitRepository.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "GitRepositoryStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = GitRepositoryStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GitRepositoryStatus.builder())
                if isinstance(output, GitRepositoryStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["GitRepository.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GitRepository.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GitRepository."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GitRepository", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GitRepository.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["source.toolkit.fluxcd.io/v1"]], Field(alias="apiVersion")
    ] = "source.toolkit.fluxcd.io/v1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["GitRepository"]] = "GitRepository"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[GitRepositorySpec] = None
    status: Optional[GitRepositoryStatus] = None


class HelmChart(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HelmChart"]:
            return HelmChart

        def build(self) -> "HelmChart":
            return HelmChart(**self._attrs)

        def api_version(self, value: Optional[Literal["source.toolkit.fluxcd.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["HelmChart"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "HelmChart.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "HelmChart.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[HelmChartSpec], /) -> "HelmChart.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [HelmChartSpec.Builder], HelmChartSpec.Builder | HelmChartSpec
            ],
            /,
        ) -> "HelmChart.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "HelmChartSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = HelmChartSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HelmChartSpec.builder())
                if isinstance(output, HelmChartSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[HelmChartStatus], /
        ) -> "HelmChart.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [HelmChartStatus.Builder], HelmChartStatus.Builder | HelmChartStatus
            ],
            /,
        ) -> "HelmChart.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "HelmChartStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = HelmChartStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HelmChartStatus.builder())
                if isinstance(output, HelmChartStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["HelmChart.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HelmChart.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HelmChart."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HelmChart", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmChart.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["source.toolkit.fluxcd.io/v1"]], Field(alias="apiVersion")
    ] = "source.toolkit.fluxcd.io/v1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["HelmChart"]] = "HelmChart"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[HelmChartSpec] = None
    status: Optional[HelmChartStatus] = None


class HelmRepository(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HelmRepository"]:
            return HelmRepository

        def build(self) -> "HelmRepository":
            return HelmRepository(**self._attrs)

        def api_version(self, value: Optional[Literal["source.toolkit.fluxcd.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["HelmRepository"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "HelmRepository.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "HelmRepository.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[HelmRepositorySpec], /
        ) -> "HelmRepository.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [HelmRepositorySpec.Builder],
                HelmRepositorySpec.Builder | HelmRepositorySpec,
            ],
            /,
        ) -> "HelmRepository.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "HelmRepositorySpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = HelmRepositorySpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HelmRepositorySpec.builder())
                if isinstance(output, HelmRepositorySpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[HelmRepositoryStatus], /
        ) -> "HelmRepository.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [HelmRepositoryStatus.Builder],
                HelmRepositoryStatus.Builder | HelmRepositoryStatus,
            ],
            /,
        ) -> "HelmRepository.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "HelmRepositoryStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = HelmRepositoryStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HelmRepositoryStatus.builder())
                if isinstance(output, HelmRepositoryStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["HelmRepository.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HelmRepository.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HelmRepository."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HelmRepository", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmRepository.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["source.toolkit.fluxcd.io/v1"]], Field(alias="apiVersion")
    ] = "source.toolkit.fluxcd.io/v1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["HelmRepository"]] = "HelmRepository"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[HelmRepositorySpec] = None
    status: Optional[HelmRepositoryStatus] = None
