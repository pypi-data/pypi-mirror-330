# Generated by cloudcoil-model-codegen v0.5.6
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import (
    Annotated,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class FilterTags(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FilterTags"]:
            return FilterTags

        def build(self) -> "FilterTags":
            return FilterTags(**self._attrs)

        def extract(self, value: Optional[str], /) -> Self:
            """
            Extract allows a capture group to be extracted from the specified regular
            expression pattern, useful before tag evaluation.
            """
            return self._set("extract", value)

        def pattern(self, value: Optional[str], /) -> Self:
            """
            Pattern specifies a regular expression pattern used to filter for image
            tags.
            """
            return self._set("pattern", value)

    class BuilderContext(BuilderContextBase["FilterTags.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FilterTags.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FilterTags."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FilterTags", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FilterTags.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    extract: Optional[str] = None
    """
    Extract allows a capture group to be extracted from the specified regular
    expression pattern, useful before tag evaluation.
    """
    pattern: Optional[str] = None
    """
    Pattern specifies a regular expression pattern used to filter for image
    tags.
    """


class ImageRepositoryRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImageRepositoryRef"]:
            return ImageRepositoryRef

        def build(self) -> "ImageRepositoryRef":
            return ImageRepositoryRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent, when not specified it acts as LocalObjectReference.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["ImageRepositoryRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImageRepositoryRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImageRepositoryRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImageRepositoryRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageRepositoryRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referent.
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent, when not specified it acts as LocalObjectReference.
    """


class Alphabetical(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Alphabetical"]:
            return Alphabetical

        def build(self) -> "Alphabetical":
            return Alphabetical(**self._attrs)

        def order(self, value: Optional[Literal["asc", "desc"]], /) -> Self:
            """
            Order specifies the sorting order of the tags. Given the letters of the
            alphabet as tags, ascending order would select Z, and descending order
            would select A.
            """
            return self._set("order", value)

    class BuilderContext(BuilderContextBase["Alphabetical.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Alphabetical.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Alphabetical."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Alphabetical", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Alphabetical.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    order: Optional[Literal["asc", "desc"]] = "asc"
    """
    Order specifies the sorting order of the tags. Given the letters of the
    alphabet as tags, ascending order would select Z, and descending order
    would select A.
    """


class Numerical(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Numerical"]:
            return Numerical

        def build(self) -> "Numerical":
            return Numerical(**self._attrs)

        def order(self, value: Optional[Literal["asc", "desc"]], /) -> Self:
            """
            Order specifies the sorting order of the tags. Given the integer values
            from 0 to 9 as tags, ascending order would select 9, and descending order
            would select 0.
            """
            return self._set("order", value)

    class BuilderContext(BuilderContextBase["Numerical.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Numerical.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Numerical."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Numerical", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Numerical.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    order: Optional[Literal["asc", "desc"]] = "asc"
    """
    Order specifies the sorting order of the tags. Given the integer values
    from 0 to 9 as tags, ascending order would select 9, and descending order
    would select 0.
    """


class Semver(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Semver"]:
            return Semver

        def build(self) -> "Semver":
            return Semver(**self._attrs)

        def range(self, value: str, /) -> Self:
            """
            Range gives a semver range for the image tag; the highest
            version within the range that's a tag yields the latest image.
            """
            return self._set("range", value)

    class BuilderContext(BuilderContextBase["Semver.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Semver.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Semver."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Semver", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Semver.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    range: str
    """
    Range gives a semver range for the image tag; the highest
    version within the range that's a tag yields the latest image.
    """


class Policy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Policy"]:
            return Policy

        def build(self) -> "Policy":
            return Policy(**self._attrs)

        @overload
        def alphabetical(
            self, value_or_callback: Optional[Alphabetical], /
        ) -> "Policy.Builder": ...

        @overload
        def alphabetical(
            self,
            value_or_callback: Callable[
                [Alphabetical.Builder], Alphabetical.Builder | Alphabetical
            ],
            /,
        ) -> "Policy.Builder": ...

        @overload
        def alphabetical(self, value_or_callback: Never = ...) -> "Alphabetical.BuilderContext": ...

        def alphabetical(self, value_or_callback=None, /):
            """
            Alphabetical set of rules to use for alphabetical ordering of the tags.
            """
            if self._in_context and value_or_callback is None:
                context = Alphabetical.BuilderContext()
                context._parent_builder = self
                context._field_name = "alphabetical"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Alphabetical.builder())
                if isinstance(output, Alphabetical.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("alphabetical", value)

        @overload
        def numerical(self, value_or_callback: Optional[Numerical], /) -> "Policy.Builder": ...

        @overload
        def numerical(
            self,
            value_or_callback: Callable[[Numerical.Builder], Numerical.Builder | Numerical],
            /,
        ) -> "Policy.Builder": ...

        @overload
        def numerical(self, value_or_callback: Never = ...) -> "Numerical.BuilderContext": ...

        def numerical(self, value_or_callback=None, /):
            """
            Numerical set of rules to use for numerical ordering of the tags.
            """
            if self._in_context and value_or_callback is None:
                context = Numerical.BuilderContext()
                context._parent_builder = self
                context._field_name = "numerical"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Numerical.builder())
                if isinstance(output, Numerical.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("numerical", value)

        @overload
        def semver(self, value_or_callback: Optional[Semver], /) -> "Policy.Builder": ...

        @overload
        def semver(
            self,
            value_or_callback: Callable[[Semver.Builder], Semver.Builder | Semver],
            /,
        ) -> "Policy.Builder": ...

        @overload
        def semver(self, value_or_callback: Never = ...) -> "Semver.BuilderContext": ...

        def semver(self, value_or_callback=None, /):
            """
            SemVer gives a semantic version range to check against the tags
            available.
            """
            if self._in_context and value_or_callback is None:
                context = Semver.BuilderContext()
                context._parent_builder = self
                context._field_name = "semver"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Semver.builder())
                if isinstance(output, Semver.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("semver", value)

    class BuilderContext(BuilderContextBase["Policy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Policy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Policy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Policy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Policy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    alphabetical: Optional[Alphabetical] = None
    """
    Alphabetical set of rules to use for alphabetical ordering of the tags.
    """
    numerical: Optional[Numerical] = None
    """
    Numerical set of rules to use for numerical ordering of the tags.
    """
    semver: Optional[Semver] = None
    """
    SemVer gives a semantic version range to check against the tags
    available.
    """


class ImagePolicySpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImagePolicySpec"]:
            return ImagePolicySpec

        def build(self) -> "ImagePolicySpec":
            return ImagePolicySpec(**self._attrs)

        @overload
        def filter_tags(
            self, value_or_callback: Optional[FilterTags], /
        ) -> "ImagePolicySpec.Builder": ...

        @overload
        def filter_tags(
            self,
            value_or_callback: Callable[[FilterTags.Builder], FilterTags.Builder | FilterTags],
            /,
        ) -> "ImagePolicySpec.Builder": ...

        @overload
        def filter_tags(self, value_or_callback: Never = ...) -> "FilterTags.BuilderContext": ...

        def filter_tags(self, value_or_callback=None, /):
            """
            FilterTags enables filtering for only a subset of tags based on a set of
            rules. If no rules are provided, all the tags from the repository will be
            ordered and compared.
            """
            if self._in_context and value_or_callback is None:
                context = FilterTags.BuilderContext()
                context._parent_builder = self
                context._field_name = "filter_tags"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FilterTags.builder())
                if isinstance(output, FilterTags.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("filter_tags", value)

        @overload
        def image_repository_ref(
            self, value_or_callback: ImageRepositoryRef, /
        ) -> "ImagePolicySpec.Builder": ...

        @overload
        def image_repository_ref(
            self,
            value_or_callback: Callable[
                [ImageRepositoryRef.Builder],
                ImageRepositoryRef.Builder | ImageRepositoryRef,
            ],
            /,
        ) -> "ImagePolicySpec.Builder": ...

        @overload
        def image_repository_ref(
            self, value_or_callback: Never = ...
        ) -> "ImageRepositoryRef.BuilderContext": ...

        def image_repository_ref(self, value_or_callback=None, /):
            """
            ImageRepositoryRef points at the object specifying the image
            being scanned
            """
            if self._in_context and value_or_callback is None:
                context = ImageRepositoryRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "image_repository_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImageRepositoryRef.builder())
                if isinstance(output, ImageRepositoryRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("image_repository_ref", value)

        @overload
        def policy(self, value_or_callback: Policy, /) -> "ImagePolicySpec.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "ImagePolicySpec.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policy gives the particulars of the policy to be followed in
            selecting the most recent image
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["ImagePolicySpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImagePolicySpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImagePolicySpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImagePolicySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImagePolicySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    filter_tags: Annotated[Optional[FilterTags], Field(alias="filterTags")] = None
    """
    FilterTags enables filtering for only a subset of tags based on a set of
    rules. If no rules are provided, all the tags from the repository will be
    ordered and compared.
    """
    image_repository_ref: Annotated[ImageRepositoryRef, Field(alias="imageRepositoryRef")]
    """
    ImageRepositoryRef points at the object specifying the image
    being scanned
    """
    policy: Policy
    """
    Policy gives the particulars of the policy to be followed in
    selecting the most recent image
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: datetime, /) -> Self:
            """
            lastTransitionTime is the last time the condition transitioned from one status to another.
            This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
            """
            return self._set("last_transition_time", value)

        def message(self, value: str, /) -> Self:
            """
            message is a human readable message indicating details about the transition.
            This may be an empty string.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            observedGeneration represents the .metadata.generation that the condition was set based upon.
            For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
            with respect to the current state of the instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: str, /) -> Self:
            """
            reason contains a programmatic identifier indicating the reason for the condition's last transition.
            Producers of specific condition types may define expected values and meanings for this field,
            and whether the values are considered a guaranteed API.
            The value should be a CamelCase string.
            This field may not be empty.
            """
            return self._set("reason", value)

        def status(self, value: Literal["True", "False", "Unknown"], /) -> Self:
            """
            status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            type of condition in CamelCase or in foo.example.com/CamelCase.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[datetime, Field(alias="lastTransitionTime")]
    """
    lastTransitionTime is the last time the condition transitioned from one status to another.
    This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    """
    message: Annotated[str, Field(max_length=32768)]
    """
    message is a human readable message indicating details about the transition.
    This may be an empty string.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration", ge=0)] = None
    """
    observedGeneration represents the .metadata.generation that the condition was set based upon.
    For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
    with respect to the current state of the instance.
    """
    reason: Annotated[
        str,
        Field(
            max_length=1024,
            min_length=1,
            pattern="^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$",
        ),
    ]
    """
    reason contains a programmatic identifier indicating the reason for the condition's last transition.
    Producers of specific condition types may define expected values and meanings for this field,
    and whether the values are considered a guaranteed API.
    The value should be a CamelCase string.
    This field may not be empty.
    """
    status: Literal["True", "False", "Unknown"]
    """
    status of the condition, one of True, False, Unknown.
    """
    type: Annotated[
        str,
        Field(
            max_length=316,
            pattern="^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$",
        ),
    ]
    """
    type of condition in CamelCase or in foo.example.com/CamelCase.
    """


class ImagePolicyStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImagePolicyStatus"]:
            return ImagePolicyStatus

        def build(self) -> "ImagePolicyStatus":
            return ImagePolicyStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "ImagePolicyStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "ImagePolicyStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def latest_image(self, value: Optional[str], /) -> Self:
            """
            LatestImage gives the first in the list of images scanned by
            the image repository, when filtered and ordered according to
            the policy.
            """
            return self._set("latest_image", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["ImagePolicyStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImagePolicyStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImagePolicyStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImagePolicyStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImagePolicyStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    latest_image: Annotated[Optional[str], Field(alias="latestImage")] = None
    """
    LatestImage gives the first in the list of images scanned by
    the image repository, when filtered and ordered according to
    the policy.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None


class NamespaceSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NamespaceSelector"]:
            return NamespaceSelector

        def build(self) -> "NamespaceSelector":
            return NamespaceSelector(**self._attrs)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["NamespaceSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NamespaceSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NamespaceSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NamespaceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamespaceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class AccessFrom(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AccessFrom"]:
            return AccessFrom

        def build(self) -> "AccessFrom":
            return AccessFrom(**self._attrs)

        @overload
        def namespace_selectors(
            self, value_or_callback: List[NamespaceSelector], /
        ) -> "AccessFrom.Builder": ...

        @overload
        def namespace_selectors(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[NamespaceSelector, NamespaceSelector.Builder]],
                GenericListBuilder[NamespaceSelector, NamespaceSelector.Builder]
                | List[NamespaceSelector],
            ],
            /,
        ) -> "AccessFrom.Builder": ...

        @overload
        def namespace_selectors(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[NamespaceSelector.Builder]: ...

        def namespace_selectors(self, value_or_callback=None, /):
            """
            NamespaceSelectors is the list of namespace selectors to which this ACL applies.
            Items in this list are evaluated using a logical OR operation.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[NamespaceSelector.Builder]()
                context._parent_builder = self
                context._field_name = "namespace_selectors"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamespaceSelector.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("namespace_selectors", value)

    class BuilderContext(BuilderContextBase["AccessFrom.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AccessFrom.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AccessFrom."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AccessFrom", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AccessFrom.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    namespace_selectors: Annotated[List[NamespaceSelector], Field(alias="namespaceSelectors")]
    """
    NamespaceSelectors is the list of namespace selectors to which this ACL applies.
    Items in this list are evaluated using a logical OR operation.
    """


class CertSecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CertSecretRef"]:
            return CertSecretRef

        def build(self) -> "CertSecretRef":
            return CertSecretRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["CertSecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CertSecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CertSecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CertSecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CertSecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referent.
    """


class SecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretRef"]:
            return SecretRef

        def build(self) -> "SecretRef":
            return SecretRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["SecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referent.
    """


class ImageRepositorySpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImageRepositorySpec"]:
            return ImageRepositorySpec

        def build(self) -> "ImageRepositorySpec":
            return ImageRepositorySpec(**self._attrs)

        @overload
        def access_from(
            self, value_or_callback: Optional[AccessFrom], /
        ) -> "ImageRepositorySpec.Builder": ...

        @overload
        def access_from(
            self,
            value_or_callback: Callable[[AccessFrom.Builder], AccessFrom.Builder | AccessFrom],
            /,
        ) -> "ImageRepositorySpec.Builder": ...

        @overload
        def access_from(self, value_or_callback: Never = ...) -> "AccessFrom.BuilderContext": ...

        def access_from(self, value_or_callback=None, /):
            """
            AccessFrom defines an ACL for allowing cross-namespace references
            to the ImageRepository object based on the caller's namespace labels.
            """
            if self._in_context and value_or_callback is None:
                context = AccessFrom.BuilderContext()
                context._parent_builder = self
                context._field_name = "access_from"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AccessFrom.builder())
                if isinstance(output, AccessFrom.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("access_from", value)

        @overload
        def cert_secret_ref(
            self, value_or_callback: Optional[CertSecretRef], /
        ) -> "ImageRepositorySpec.Builder": ...

        @overload
        def cert_secret_ref(
            self,
            value_or_callback: Callable[
                [CertSecretRef.Builder], CertSecretRef.Builder | CertSecretRef
            ],
            /,
        ) -> "ImageRepositorySpec.Builder": ...

        @overload
        def cert_secret_ref(
            self, value_or_callback: Never = ...
        ) -> "CertSecretRef.BuilderContext": ...

        def cert_secret_ref(self, value_or_callback=None, /):
            """
            CertSecretRef can be given the name of a secret containing
            either or both of

             - a PEM-encoded client certificate (`certFile`) and private
             key (`keyFile`);
             - a PEM-encoded CA certificate (`caFile`)

             and whichever are supplied, will be used for connecting to the
             registry. The client cert and key are useful if you are
             authenticating with a certificate; the CA cert is useful if
             you are using a self-signed server certificate.
            """
            if self._in_context and value_or_callback is None:
                context = CertSecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert_secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CertSecretRef.builder())
                if isinstance(output, CertSecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert_secret_ref", value)

        def exclusion_list(self, value: Optional[List[str]], /) -> Self:
            """
            ExclusionList is a list of regex strings used to exclude certain tags
            from being stored in the database.
            """
            return self._set("exclusion_list", value)

        def image(self, value: str, /) -> Self:
            """
            Image is the name of the image repository
            """
            return self._set("image", value)

        def interval(self, value: str, /) -> Self:
            """
            Interval is the length of time to wait between
            scans of the image repository.
            """
            return self._set("interval", value)

        @overload
        def secret_ref(
            self, value_or_callback: Optional[SecretRef], /
        ) -> "ImageRepositorySpec.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "ImageRepositorySpec.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            SecretRef can be given the name of a secret containing
            credentials to use for the image registry. The secret should be
            created with `kubectl create secret docker-registry`, or the
            equivalent.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def service_account_name(self, value: Optional[str], /) -> Self:
            """
            ServiceAccountName is the name of the Kubernetes ServiceAccount used to authenticate
            the image pull if the service account has attached pull secrets.
            """
            return self._set("service_account_name", value)

        def suspend(self, value: Optional[bool], /) -> Self:
            """
            This flag tells the controller to suspend subsequent image scans.
            It does not apply to already started scans. Defaults to false.
            """
            return self._set("suspend", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout for image scanning.
            Defaults to 'Interval' duration.
            """
            return self._set("timeout", value)

    class BuilderContext(BuilderContextBase["ImageRepositorySpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImageRepositorySpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImageRepositorySpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImageRepositorySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageRepositorySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_from: Annotated[Optional[AccessFrom], Field(alias="accessFrom")] = None
    """
    AccessFrom defines an ACL for allowing cross-namespace references
    to the ImageRepository object based on the caller's namespace labels.
    """
    cert_secret_ref: Annotated[Optional[CertSecretRef], Field(alias="certSecretRef")] = None
    """
    CertSecretRef can be given the name of a secret containing
    either or both of

     - a PEM-encoded client certificate (`certFile`) and private
     key (`keyFile`);
     - a PEM-encoded CA certificate (`caFile`)

     and whichever are supplied, will be used for connecting to the
     registry. The client cert and key are useful if you are
     authenticating with a certificate; the CA cert is useful if
     you are using a self-signed server certificate.
    """
    exclusion_list: Annotated[Optional[List[str]], Field(alias="exclusionList")] = None
    """
    ExclusionList is a list of regex strings used to exclude certain tags
    from being stored in the database.
    """
    image: str
    """
    Image is the name of the image repository
    """
    interval: Annotated[str, Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$")]
    """
    Interval is the length of time to wait between
    scans of the image repository.
    """
    secret_ref: Annotated[Optional[SecretRef], Field(alias="secretRef")] = None
    """
    SecretRef can be given the name of a secret containing
    credentials to use for the image registry. The secret should be
    created with `kubectl create secret docker-registry`, or the
    equivalent.
    """
    service_account_name: Annotated[
        Optional[str], Field(alias="serviceAccountName", max_length=253)
    ] = None
    """
    ServiceAccountName is the name of the Kubernetes ServiceAccount used to authenticate
    the image pull if the service account has attached pull secrets.
    """
    suspend: Optional[bool] = None
    """
    This flag tells the controller to suspend subsequent image scans.
    It does not apply to already started scans. Defaults to false.
    """
    timeout: Annotated[Optional[str], Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m))+$")] = None
    """
    Timeout for image scanning.
    Defaults to 'Interval' duration.
    """


class LastScanResult(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LastScanResult"]:
            return LastScanResult

        def build(self) -> "LastScanResult":
            return LastScanResult(**self._attrs)

        def scan_time(self, value: Optional[datetime], /) -> Self:
            return self._set("scan_time", value)

        def tag_count(self, value: int, /) -> Self:
            return self._set("tag_count", value)

    class BuilderContext(BuilderContextBase["LastScanResult.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LastScanResult.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LastScanResult."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LastScanResult", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LastScanResult.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    scan_time: Annotated[Optional[datetime], Field(alias="scanTime")] = None
    tag_count: Annotated[int, Field(alias="tagCount")]


class ImageRepositoryStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImageRepositoryStatus"]:
            return ImageRepositoryStatus

        def build(self) -> "ImageRepositoryStatus":
            return ImageRepositoryStatus(**self._attrs)

        def canonical_image_name(self, value: Optional[str], /) -> Self:
            """
            CanonicalName is the name of the image repository with all the
            implied bits made explicit; e.g., `docker.io/library/alpine`
            rather than `alpine`.
            """
            return self._set("canonical_image_name", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "ImageRepositoryStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "ImageRepositoryStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def last_handled_reconcile_at(self, value: Optional[str], /) -> Self:
            """
            LastHandledReconcileAt holds the value of the most recent
            reconcile request value, so a change of the annotation value
            can be detected.
            """
            return self._set("last_handled_reconcile_at", value)

        @overload
        def last_scan_result(
            self, value_or_callback: Optional[LastScanResult], /
        ) -> "ImageRepositoryStatus.Builder": ...

        @overload
        def last_scan_result(
            self,
            value_or_callback: Callable[
                [LastScanResult.Builder], LastScanResult.Builder | LastScanResult
            ],
            /,
        ) -> "ImageRepositoryStatus.Builder": ...

        @overload
        def last_scan_result(
            self, value_or_callback: Never = ...
        ) -> "LastScanResult.BuilderContext": ...

        def last_scan_result(self, value_or_callback=None, /):
            """
            LastScanResult contains the number of fetched tags.
            """
            if self._in_context and value_or_callback is None:
                context = LastScanResult.BuilderContext()
                context._parent_builder = self
                context._field_name = "last_scan_result"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LastScanResult.builder())
                if isinstance(output, LastScanResult.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("last_scan_result", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the last reconciled generation.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["ImageRepositoryStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImageRepositoryStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImageRepositoryStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImageRepositoryStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageRepositoryStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    canonical_image_name: Annotated[Optional[str], Field(alias="canonicalImageName")] = None
    """
    CanonicalName is the name of the image repository with all the
    implied bits made explicit; e.g., `docker.io/library/alpine`
    rather than `alpine`.
    """
    conditions: Optional[List[Condition]] = None
    last_handled_reconcile_at: Annotated[Optional[str], Field(alias="lastHandledReconcileAt")] = (
        None
    )
    """
    LastHandledReconcileAt holds the value of the most recent
    reconcile request value, so a change of the annotation value
    can be detected.
    """
    last_scan_result: Annotated[Optional[LastScanResult], Field(alias="lastScanResult")] = None
    """
    LastScanResult contains the number of fetched tags.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the last reconciled generation.
    """


class Ref(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ref"]:
            return Ref

        def build(self) -> "Ref":
            return Ref(**self._attrs)

        def branch(self, value: Optional[str], /) -> Self:
            """
            Branch to check out, defaults to 'master' if no other field is defined.
            """
            return self._set("branch", value)

        def commit(self, value: Optional[str], /) -> Self:
            """
            Commit SHA to check out, takes precedence over all reference fields.

            This can be combined with Branch to shallow clone the branch, in which
            the commit is expected to exist.
            """
            return self._set("commit", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the reference to check out; takes precedence over Branch, Tag and SemVer.

            It must be a valid Git reference: https://git-scm.com/docs/git-check-ref-format#_description
            Examples: "refs/heads/main", "refs/tags/v0.1.0", "refs/pull/420/head", "refs/merge-requests/1/head"
            """
            return self._set("name", value)

        def semver(self, value: Optional[str], /) -> Self:
            """
            SemVer tag expression to check out, takes precedence over Tag.
            """
            return self._set("semver", value)

        def tag(self, value: Optional[str], /) -> Self:
            """
            Tag to check out, takes precedence over Branch.
            """
            return self._set("tag", value)

    class BuilderContext(BuilderContextBase["Ref.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ref.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ref."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ref", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ref.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    branch: Optional[str] = None
    """
    Branch to check out, defaults to 'master' if no other field is defined.
    """
    commit: Optional[str] = None
    """
    Commit SHA to check out, takes precedence over all reference fields.

    This can be combined with Branch to shallow clone the branch, in which
    the commit is expected to exist.
    """
    name: Optional[str] = None
    """
    Name of the reference to check out; takes precedence over Branch, Tag and SemVer.

    It must be a valid Git reference: https://git-scm.com/docs/git-check-ref-format#_description
    Examples: "refs/heads/main", "refs/tags/v0.1.0", "refs/pull/420/head", "refs/merge-requests/1/head"
    """
    semver: Optional[str] = None
    """
    SemVer tag expression to check out, takes precedence over Tag.
    """
    tag: Optional[str] = None
    """
    Tag to check out, takes precedence over Branch.
    """


class Checkout(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Checkout"]:
            return Checkout

        def build(self) -> "Checkout":
            return Checkout(**self._attrs)

        @overload
        def ref(self, value_or_callback: Ref, /) -> "Checkout.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "Checkout.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Reference gives a branch, tag or commit to clone from the Git
            repository.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

    class BuilderContext(BuilderContextBase["Checkout.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Checkout.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Checkout."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Checkout", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Checkout.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Ref
    """
    Reference gives a branch, tag or commit to clone from the Git
    repository.
    """


class Author(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Author"]:
            return Author

        def build(self) -> "Author":
            return Author(**self._attrs)

        def email(self, value: str, /) -> Self:
            """
            Email gives the email to provide when making a commit.
            """
            return self._set("email", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name gives the name to provide when making a commit.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["Author.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Author.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Author."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Author", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Author.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    email: str
    """
    Email gives the email to provide when making a commit.
    """
    name: Optional[str] = None
    """
    Name gives the name to provide when making a commit.
    """


class SigningKey(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SigningKey"]:
            return SigningKey

        def build(self) -> "SigningKey":
            return SigningKey(**self._attrs)

        @overload
        def secret_ref(self, value_or_callback: SecretRef, /) -> "SigningKey.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "SigningKey.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            SecretRef holds the name to a secret that contains a 'git.asc' key
            corresponding to the ASCII Armored file containing the GPG signing
            keypair as the value. It must be in the same namespace as the
            ImageUpdateAutomation.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

    class BuilderContext(BuilderContextBase["SigningKey.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SigningKey.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SigningKey."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SigningKey", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SigningKey.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secret_ref: Annotated[SecretRef, Field(alias="secretRef")]
    """
    SecretRef holds the name to a secret that contains a 'git.asc' key
    corresponding to the ASCII Armored file containing the GPG signing
    keypair as the value. It must be in the same namespace as the
    ImageUpdateAutomation.
    """


class Commit(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Commit"]:
            return Commit

        def build(self) -> "Commit":
            return Commit(**self._attrs)

        @overload
        def author(self, value_or_callback: Author, /) -> "Commit.Builder": ...

        @overload
        def author(
            self,
            value_or_callback: Callable[[Author.Builder], Author.Builder | Author],
            /,
        ) -> "Commit.Builder": ...

        @overload
        def author(self, value_or_callback: Never = ...) -> "Author.BuilderContext": ...

        def author(self, value_or_callback=None, /):
            """
            Author gives the email and optionally the name to use as the
            author of commits.
            """
            if self._in_context and value_or_callback is None:
                context = Author.BuilderContext()
                context._parent_builder = self
                context._field_name = "author"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Author.builder())
                if isinstance(output, Author.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("author", value)

        def message_template(self, value: Optional[str], /) -> Self:
            """
            MessageTemplate provides a template for the commit message,
            into which will be interpolated the details of the change made.
            """
            return self._set("message_template", value)

        @overload
        def signing_key(self, value_or_callback: Optional[SigningKey], /) -> "Commit.Builder": ...

        @overload
        def signing_key(
            self,
            value_or_callback: Callable[[SigningKey.Builder], SigningKey.Builder | SigningKey],
            /,
        ) -> "Commit.Builder": ...

        @overload
        def signing_key(self, value_or_callback: Never = ...) -> "SigningKey.BuilderContext": ...

        def signing_key(self, value_or_callback=None, /):
            """
            SigningKey provides the option to sign commits with a GPG key
            """
            if self._in_context and value_or_callback is None:
                context = SigningKey.BuilderContext()
                context._parent_builder = self
                context._field_name = "signing_key"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SigningKey.builder())
                if isinstance(output, SigningKey.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("signing_key", value)

    class BuilderContext(BuilderContextBase["Commit.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Commit.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Commit."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Commit", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Commit.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    author: Author
    """
    Author gives the email and optionally the name to use as the
    author of commits.
    """
    message_template: Annotated[Optional[str], Field(alias="messageTemplate")] = None
    """
    MessageTemplate provides a template for the commit message,
    into which will be interpolated the details of the change made.
    """
    signing_key: Annotated[Optional[SigningKey], Field(alias="signingKey")] = None
    """
    SigningKey provides the option to sign commits with a GPG key
    """


class Push(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Push"]:
            return Push

        def build(self) -> "Push":
            return Push(**self._attrs)

        def branch(self, value: Optional[str], /) -> Self:
            """
            Branch specifies that commits should be pushed to the branch
            named. The branch is created using `.spec.checkout.branch` as the
            starting point, if it doesn't already exist.
            """
            return self._set("branch", value)

        def options(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Options specifies the push options that are sent to the Git
            server when performing a push operation. For details, see:
            https://git-scm.com/docs/git-push#Documentation/git-push.txt---push-optionltoptiongt
            """
            return self._set("options", value)

        def refspec(self, value: Optional[str], /) -> Self:
            """
            Refspec specifies the Git Refspec to use for a push operation.
            If both Branch and Refspec are provided, then the commit is pushed
            to the branch and also using the specified refspec.
            For more details about Git Refspecs, see:
            https://git-scm.com/book/en/v2/Git-Internals-The-Refspec
            """
            return self._set("refspec", value)

    class BuilderContext(BuilderContextBase["Push.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Push.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Push."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Push", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Push.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    branch: Optional[str] = None
    """
    Branch specifies that commits should be pushed to the branch
    named. The branch is created using `.spec.checkout.branch` as the
    starting point, if it doesn't already exist.
    """
    options: Optional[Dict[str, str]] = None
    """
    Options specifies the push options that are sent to the Git
    server when performing a push operation. For details, see:
    https://git-scm.com/docs/git-push#Documentation/git-push.txt---push-optionltoptiongt
    """
    refspec: Optional[str] = None
    """
    Refspec specifies the Git Refspec to use for a push operation.
    If both Branch and Refspec are provided, then the commit is pushed
    to the branch and also using the specified refspec.
    For more details about Git Refspecs, see:
    https://git-scm.com/book/en/v2/Git-Internals-The-Refspec
    """


class Git(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Git"]:
            return Git

        def build(self) -> "Git":
            return Git(**self._attrs)

        @overload
        def checkout(self, value_or_callback: Optional[Checkout], /) -> "Git.Builder": ...

        @overload
        def checkout(
            self,
            value_or_callback: Callable[[Checkout.Builder], Checkout.Builder | Checkout],
            /,
        ) -> "Git.Builder": ...

        @overload
        def checkout(self, value_or_callback: Never = ...) -> "Checkout.BuilderContext": ...

        def checkout(self, value_or_callback=None, /):
            """
            Checkout gives the parameters for cloning the git repository,
            ready to make changes. If not present, the `spec.ref` field from the
            referenced `GitRepository` or its default will be used.
            """
            if self._in_context and value_or_callback is None:
                context = Checkout.BuilderContext()
                context._parent_builder = self
                context._field_name = "checkout"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Checkout.builder())
                if isinstance(output, Checkout.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("checkout", value)

        @overload
        def commit(self, value_or_callback: Commit, /) -> "Git.Builder": ...

        @overload
        def commit(
            self,
            value_or_callback: Callable[[Commit.Builder], Commit.Builder | Commit],
            /,
        ) -> "Git.Builder": ...

        @overload
        def commit(self, value_or_callback: Never = ...) -> "Commit.BuilderContext": ...

        def commit(self, value_or_callback=None, /):
            """
            Commit specifies how to commit to the git repository.
            """
            if self._in_context and value_or_callback is None:
                context = Commit.BuilderContext()
                context._parent_builder = self
                context._field_name = "commit"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Commit.builder())
                if isinstance(output, Commit.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("commit", value)

        @overload
        def push(self, value_or_callback: Optional[Push], /) -> "Git.Builder": ...

        @overload
        def push(
            self, value_or_callback: Callable[[Push.Builder], Push.Builder | Push], /
        ) -> "Git.Builder": ...

        @overload
        def push(self, value_or_callback: Never = ...) -> "Push.BuilderContext": ...

        def push(self, value_or_callback=None, /):
            """
            Push specifies how and where to push commits made by the
            automation. If missing, commits are pushed (back) to
            `.spec.checkout.branch` or its default.
            """
            if self._in_context and value_or_callback is None:
                context = Push.BuilderContext()
                context._parent_builder = self
                context._field_name = "push"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Push.builder())
                if isinstance(output, Push.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("push", value)

    class BuilderContext(BuilderContextBase["Git.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Git.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Git."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Git", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Git.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    checkout: Optional[Checkout] = None
    """
    Checkout gives the parameters for cloning the git repository,
    ready to make changes. If not present, the `spec.ref` field from the
    referenced `GitRepository` or its default will be used.
    """
    commit: Commit
    """
    Commit specifies how to commit to the git repository.
    """
    push: Optional[Push] = None
    """
    Push specifies how and where to push commits made by the
    automation. If missing, commits are pushed (back) to
    `.spec.checkout.branch` or its default.
    """


class SourceRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SourceRef"]:
            return SourceRef

        def build(self) -> "SourceRef":
            return SourceRef(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["GitRepository"]], /) -> Self:
            """
            Kind of the referent.
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent, defaults to the namespace of the Kubernetes resource object that contains the reference.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["SourceRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SourceRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SourceRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SourceRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SourceRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    kind: Optional[Literal["GitRepository"]] = "GitRepository"
    """
    Kind of the referent.
    """
    name: str
    """
    Name of the referent.
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent, defaults to the namespace of the Kubernetes resource object that contains the reference.
    """


class Update(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Update"]:
            return Update

        def build(self) -> "Update":
            return Update(**self._attrs)

        def path(self, value: Optional[str], /) -> Self:
            """
            Path to the directory containing the manifests to be updated.
            Defaults to 'None', which translates to the root path
            of the GitRepositoryRef.
            """
            return self._set("path", value)

        def strategy(self, value: Optional[Literal["Setters"]], /) -> Self:
            """
            Strategy names the strategy to be used.
            """
            return self._set("strategy", value)

    class BuilderContext(BuilderContextBase["Update.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Update.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Update."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Update", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Update.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    path: Optional[str] = None
    """
    Path to the directory containing the manifests to be updated.
    Defaults to 'None', which translates to the root path
    of the GitRepositoryRef.
    """
    strategy: Optional[Literal["Setters"]] = "Setters"
    """
    Strategy names the strategy to be used.
    """


class ImageUpdateAutomationSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImageUpdateAutomationSpec"]:
            return ImageUpdateAutomationSpec

        def build(self) -> "ImageUpdateAutomationSpec":
            return ImageUpdateAutomationSpec(**self._attrs)

        @overload
        def git(
            self, value_or_callback: Optional[Git], /
        ) -> "ImageUpdateAutomationSpec.Builder": ...

        @overload
        def git(
            self, value_or_callback: Callable[[Git.Builder], Git.Builder | Git], /
        ) -> "ImageUpdateAutomationSpec.Builder": ...

        @overload
        def git(self, value_or_callback: Never = ...) -> "Git.BuilderContext": ...

        def git(self, value_or_callback=None, /):
            """
            GitSpec contains all the git-specific definitions. This is
            technically optional, but in practice mandatory until there are
            other kinds of source allowed.
            """
            if self._in_context and value_or_callback is None:
                context = Git.BuilderContext()
                context._parent_builder = self
                context._field_name = "git"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Git.builder())
                if isinstance(output, Git.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("git", value)

        def interval(self, value: str, /) -> Self:
            """
            Interval gives an lower bound for how often the automation
            run should be attempted.
            """
            return self._set("interval", value)

        @overload
        def source_ref(
            self, value_or_callback: SourceRef, /
        ) -> "ImageUpdateAutomationSpec.Builder": ...

        @overload
        def source_ref(
            self,
            value_or_callback: Callable[[SourceRef.Builder], SourceRef.Builder | SourceRef],
            /,
        ) -> "ImageUpdateAutomationSpec.Builder": ...

        @overload
        def source_ref(self, value_or_callback: Never = ...) -> "SourceRef.BuilderContext": ...

        def source_ref(self, value_or_callback=None, /):
            """
            SourceRef refers to the resource giving access details
            to a git repository.
            """
            if self._in_context and value_or_callback is None:
                context = SourceRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "source_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SourceRef.builder())
                if isinstance(output, SourceRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("source_ref", value)

        def suspend(self, value: Optional[bool], /) -> Self:
            """
            Suspend tells the controller to not run this automation, until
            it is unset (or set to false). Defaults to false.
            """
            return self._set("suspend", value)

        @overload
        def update(
            self, value_or_callback: Optional[Update], /
        ) -> "ImageUpdateAutomationSpec.Builder": ...

        @overload
        def update(
            self,
            value_or_callback: Callable[[Update.Builder], Update.Builder | Update],
            /,
        ) -> "ImageUpdateAutomationSpec.Builder": ...

        @overload
        def update(self, value_or_callback: Never = ...) -> "Update.BuilderContext": ...

        def update(self, value_or_callback=None, /):
            """
            Update gives the specification for how to update the files in
            the repository. This can be left empty, to use the default
            value.
            """
            if self._in_context and value_or_callback is None:
                context = Update.BuilderContext()
                context._parent_builder = self
                context._field_name = "update"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Update.builder())
                if isinstance(output, Update.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("update", value)

    class BuilderContext(BuilderContextBase["ImageUpdateAutomationSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImageUpdateAutomationSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImageUpdateAutomationSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImageUpdateAutomationSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageUpdateAutomationSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    git: Optional[Git] = None
    """
    GitSpec contains all the git-specific definitions. This is
    technically optional, but in practice mandatory until there are
    other kinds of source allowed.
    """
    interval: Annotated[str, Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$")]
    """
    Interval gives an lower bound for how often the automation
    run should be attempted.
    """
    source_ref: Annotated[SourceRef, Field(alias="sourceRef")]
    """
    SourceRef refers to the resource giving access details
    to a git repository.
    """
    suspend: Optional[bool] = None
    """
    Suspend tells the controller to not run this automation, until
    it is unset (or set to false). Defaults to false.
    """
    update: Annotated[Optional[Update], Field()] = {"strategy": "Setters"}
    """
    Update gives the specification for how to update the files in
    the repository. This can be left empty, to use the default
    value.
    """


class ImageUpdateAutomationStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImageUpdateAutomationStatus"]:
            return ImageUpdateAutomationStatus

        def build(self) -> "ImageUpdateAutomationStatus":
            return ImageUpdateAutomationStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "ImageUpdateAutomationStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "ImageUpdateAutomationStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def last_automation_run_time(self, value: Optional[datetime], /) -> Self:
            """
            LastAutomationRunTime records the last time the controller ran
            this automation through to completion (even if no updates were
            made).
            """
            return self._set("last_automation_run_time", value)

        def last_handled_reconcile_at(self, value: Optional[str], /) -> Self:
            """
            LastHandledReconcileAt holds the value of the most recent
            reconcile request value, so a change of the annotation value
            can be detected.
            """
            return self._set("last_handled_reconcile_at", value)

        def last_push_commit(self, value: Optional[str], /) -> Self:
            """
            LastPushCommit records the SHA1 of the last commit made by the
            controller, for this automation object
            """
            return self._set("last_push_commit", value)

        def last_push_time(self, value: Optional[datetime], /) -> Self:
            """
            LastPushTime records the time of the last pushed change.
            """
            return self._set("last_push_time", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["ImageUpdateAutomationStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImageUpdateAutomationStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImageUpdateAutomationStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImageUpdateAutomationStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageUpdateAutomationStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    last_automation_run_time: Annotated[
        Optional[datetime], Field(alias="lastAutomationRunTime")
    ] = None
    """
    LastAutomationRunTime records the last time the controller ran
    this automation through to completion (even if no updates were
    made).
    """
    last_handled_reconcile_at: Annotated[Optional[str], Field(alias="lastHandledReconcileAt")] = (
        None
    )
    """
    LastHandledReconcileAt holds the value of the most recent
    reconcile request value, so a change of the annotation value
    can be detected.
    """
    last_push_commit: Annotated[Optional[str], Field(alias="lastPushCommit")] = None
    """
    LastPushCommit records the SHA1 of the last commit made by the
    controller, for this automation object
    """
    last_push_time: Annotated[Optional[datetime], Field(alias="lastPushTime")] = None
    """
    LastPushTime records the time of the last pushed change.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None


class ImagePolicy(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImagePolicy"]:
            return ImagePolicy

        def build(self) -> "ImagePolicy":
            return ImagePolicy(**self._attrs)

        def api_version(
            self, value: Optional[Literal["image.toolkit.fluxcd.io/v1beta1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ImagePolicy"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ImagePolicy.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ImagePolicy.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[ImagePolicySpec], /
        ) -> "ImagePolicy.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ImagePolicySpec.Builder], ImagePolicySpec.Builder | ImagePolicySpec
            ],
            /,
        ) -> "ImagePolicy.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ImagePolicySpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ImagePolicySpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImagePolicySpec.builder())
                if isinstance(output, ImagePolicySpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ImagePolicyStatus], /
        ) -> "ImagePolicy.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ImagePolicyStatus.Builder],
                ImagePolicyStatus.Builder | ImagePolicyStatus,
            ],
            /,
        ) -> "ImagePolicy.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "ImagePolicyStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ImagePolicyStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImagePolicyStatus.builder())
                if isinstance(output, ImagePolicyStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["ImagePolicy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImagePolicy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImagePolicy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImagePolicy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImagePolicy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["image.toolkit.fluxcd.io/v1beta1"]], Field(alias="apiVersion")
    ] = "image.toolkit.fluxcd.io/v1beta1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ImagePolicy"]] = "ImagePolicy"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[ImagePolicySpec] = None
    status: Optional[ImagePolicyStatus] = None


class ImageRepository(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImageRepository"]:
            return ImageRepository

        def build(self) -> "ImageRepository":
            return ImageRepository(**self._attrs)

        def api_version(
            self, value: Optional[Literal["image.toolkit.fluxcd.io/v1beta1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ImageRepository"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ImageRepository.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ImageRepository.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[ImageRepositorySpec], /
        ) -> "ImageRepository.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ImageRepositorySpec.Builder],
                ImageRepositorySpec.Builder | ImageRepositorySpec,
            ],
            /,
        ) -> "ImageRepository.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ImageRepositorySpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ImageRepositorySpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImageRepositorySpec.builder())
                if isinstance(output, ImageRepositorySpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ImageRepositoryStatus], /
        ) -> "ImageRepository.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ImageRepositoryStatus.Builder],
                ImageRepositoryStatus.Builder | ImageRepositoryStatus,
            ],
            /,
        ) -> "ImageRepository.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "ImageRepositoryStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ImageRepositoryStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImageRepositoryStatus.builder())
                if isinstance(output, ImageRepositoryStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["ImageRepository.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImageRepository.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImageRepository."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImageRepository", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageRepository.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["image.toolkit.fluxcd.io/v1beta1"]], Field(alias="apiVersion")
    ] = "image.toolkit.fluxcd.io/v1beta1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ImageRepository"]] = "ImageRepository"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[ImageRepositorySpec] = None
    status: Optional[ImageRepositoryStatus] = None


class ImageUpdateAutomation(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImageUpdateAutomation"]:
            return ImageUpdateAutomation

        def build(self) -> "ImageUpdateAutomation":
            return ImageUpdateAutomation(**self._attrs)

        def api_version(
            self, value: Optional[Literal["image.toolkit.fluxcd.io/v1beta1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ImageUpdateAutomation"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ImageUpdateAutomation.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ImageUpdateAutomation.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[ImageUpdateAutomationSpec], /
        ) -> "ImageUpdateAutomation.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ImageUpdateAutomationSpec.Builder],
                ImageUpdateAutomationSpec.Builder | ImageUpdateAutomationSpec,
            ],
            /,
        ) -> "ImageUpdateAutomation.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "ImageUpdateAutomationSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ImageUpdateAutomationSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImageUpdateAutomationSpec.builder())
                if isinstance(output, ImageUpdateAutomationSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ImageUpdateAutomationStatus], /
        ) -> "ImageUpdateAutomation.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ImageUpdateAutomationStatus.Builder],
                ImageUpdateAutomationStatus.Builder | ImageUpdateAutomationStatus,
            ],
            /,
        ) -> "ImageUpdateAutomation.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "ImageUpdateAutomationStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ImageUpdateAutomationStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImageUpdateAutomationStatus.builder())
                if isinstance(output, ImageUpdateAutomationStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["ImageUpdateAutomation.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImageUpdateAutomation.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImageUpdateAutomation."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImageUpdateAutomation", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageUpdateAutomation.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["image.toolkit.fluxcd.io/v1beta1"]], Field(alias="apiVersion")
    ] = "image.toolkit.fluxcd.io/v1beta1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ImageUpdateAutomation"]] = "ImageUpdateAutomation"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[ImageUpdateAutomationSpec] = None
    status: Optional[ImageUpdateAutomationStatus] = None
