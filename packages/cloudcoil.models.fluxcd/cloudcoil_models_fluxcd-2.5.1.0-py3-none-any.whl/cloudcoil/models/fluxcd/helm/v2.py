# Generated by cloudcoil-model-codegen v0.5.6
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class Metadata(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Metadata"]:
            return Metadata

        def build(self) -> "Metadata":
            return Metadata(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations is an unstructured key value map stored with a resource that may be
            set by external tools to store and retrieve arbitrary metadata. They are not
            queryable and should be preserved when modifying objects.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
            """
            return self._set("annotations", value)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Map of string keys and values that can be used to organize and categorize
            (scope and select) objects.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
            """
            return self._set("labels", value)

    class BuilderContext(BuilderContextBase["Metadata.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Metadata.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Metadata."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Metadata", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Metadata.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, str]] = None
    """
    Annotations is an unstructured key value map stored with a resource that may be
    set by external tools to store and retrieve arbitrary metadata. They are not
    queryable and should be preserved when modifying objects.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
    """
    labels: Optional[Dict[str, str]] = None
    """
    Map of string keys and values that can be used to organize and categorize
    (scope and select) objects.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    """


class SourceRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SourceRef"]:
            return SourceRef

        def build(self) -> "SourceRef":
            return SourceRef(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Literal["HelmRepository", "GitRepository", "Bucket"], /) -> Self:
            """
            Kind of the referent.
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["SourceRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SourceRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SourceRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SourceRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SourceRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion of the referent.
    """
    kind: Literal["HelmRepository", "GitRepository", "Bucket"]
    """
    Kind of the referent.
    """
    name: Annotated[str, Field(max_length=253, min_length=1)]
    """
    Name of the referent.
    """
    namespace: Annotated[Optional[str], Field(max_length=63, min_length=1)] = None
    """
    Namespace of the referent.
    """


class SecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretRef"]:
            return SecretRef

        def build(self) -> "SecretRef":
            return SecretRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["SecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referent.
    """


class Verify(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Verify"]:
            return Verify

        def build(self) -> "Verify":
            return Verify(**self._attrs)

        def provider(self, value: Optional[Literal["cosign", "notation"]], /) -> Self:
            """
            Provider specifies the technology used to sign the OCI Helm chart.
            """
            return self._set("provider", value)

        @overload
        def secret_ref(self, value_or_callback: Optional[SecretRef], /) -> "Verify.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "Verify.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            SecretRef specifies the Kubernetes Secret containing the
            trusted public keys.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

    class BuilderContext(BuilderContextBase["Verify.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Verify.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Verify."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Verify", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Verify.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    provider: Optional[Literal["cosign", "notation"]] = "cosign"
    """
    Provider specifies the technology used to sign the OCI Helm chart.
    """
    secret_ref: Annotated[Optional[SecretRef], Field(alias="secretRef")] = None
    """
    SecretRef specifies the Kubernetes Secret containing the
    trusted public keys.
    """


class Spec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Spec"]:
            return Spec

        def build(self) -> "Spec":
            return Spec(**self._attrs)

        def chart(self, value: str, /) -> Self:
            """
            The name or path the Helm chart is available at in the SourceRef.
            """
            return self._set("chart", value)

        def ignore_missing_values_files(self, value: Optional[bool], /) -> Self:
            """
            IgnoreMissingValuesFiles controls whether to silently ignore missing values files rather than failing.
            """
            return self._set("ignore_missing_values_files", value)

        def interval(self, value: Optional[str], /) -> Self:
            """
            Interval at which to check the v1.Source for updates. Defaults to
            'HelmReleaseSpec.Interval'.
            """
            return self._set("interval", value)

        def reconcile_strategy(
            self, value: Optional[Literal["ChartVersion", "Revision"]], /
        ) -> Self:
            """
            Determines what enables the creation of a new artifact. Valid values are
            ('ChartVersion', 'Revision').
            See the documentation of the values for an explanation on their behavior.
            Defaults to ChartVersion when omitted.
            """
            return self._set("reconcile_strategy", value)

        @overload
        def source_ref(self, value_or_callback: SourceRef, /) -> "Spec.Builder": ...

        @overload
        def source_ref(
            self,
            value_or_callback: Callable[[SourceRef.Builder], SourceRef.Builder | SourceRef],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def source_ref(self, value_or_callback: Never = ...) -> "SourceRef.BuilderContext": ...

        def source_ref(self, value_or_callback=None, /):
            """
            The name and namespace of the v1.Source the chart is available at.
            """
            if self._in_context and value_or_callback is None:
                context = SourceRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "source_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SourceRef.builder())
                if isinstance(output, SourceRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("source_ref", value)

        def values_files(self, value: Optional[List[str]], /) -> Self:
            """
            Alternative list of values files to use as the chart values (values.yaml
            is not included by default), expected to be a relative path in the SourceRef.
            Values files are merged in the order of this list with the last file overriding
            the first. Ignored when omitted.
            """
            return self._set("values_files", value)

        @overload
        def verify(self, value_or_callback: Optional[Verify], /) -> "Spec.Builder": ...

        @overload
        def verify(
            self,
            value_or_callback: Callable[[Verify.Builder], Verify.Builder | Verify],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def verify(self, value_or_callback: Never = ...) -> "Verify.BuilderContext": ...

        def verify(self, value_or_callback=None, /):
            """
            Verify contains the secret name containing the trusted public keys
            used to verify the signature and specifies which provider to use to check
            whether OCI image is authentic.
            This field is only supported for OCI sources.
            Chart dependencies, which are not bundled in the umbrella chart artifact,
            are not verified.
            """
            if self._in_context and value_or_callback is None:
                context = Verify.BuilderContext()
                context._parent_builder = self
                context._field_name = "verify"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Verify.builder())
                if isinstance(output, Verify.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("verify", value)

        def version(self, value: Optional[str], /) -> Self:
            """
            Version semver expression, ignored for charts from v1.GitRepository and
            v1beta2.Bucket sources. Defaults to latest when omitted.
            """
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["Spec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Spec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Spec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Spec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Spec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    chart: Annotated[str, Field(max_length=2048, min_length=1)]
    """
    The name or path the Helm chart is available at in the SourceRef.
    """
    ignore_missing_values_files: Annotated[
        Optional[bool], Field(alias="ignoreMissingValuesFiles")
    ] = None
    """
    IgnoreMissingValuesFiles controls whether to silently ignore missing values files rather than failing.
    """
    interval: Annotated[Optional[str], Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$")] = None
    """
    Interval at which to check the v1.Source for updates. Defaults to
    'HelmReleaseSpec.Interval'.
    """
    reconcile_strategy: Annotated[
        Optional[Literal["ChartVersion", "Revision"]], Field(alias="reconcileStrategy")
    ] = "ChartVersion"
    """
    Determines what enables the creation of a new artifact. Valid values are
    ('ChartVersion', 'Revision').
    See the documentation of the values for an explanation on their behavior.
    Defaults to ChartVersion when omitted.
    """
    source_ref: Annotated[SourceRef, Field(alias="sourceRef")]
    """
    The name and namespace of the v1.Source the chart is available at.
    """
    values_files: Annotated[Optional[List[str]], Field(alias="valuesFiles")] = None
    """
    Alternative list of values files to use as the chart values (values.yaml
    is not included by default), expected to be a relative path in the SourceRef.
    Values files are merged in the order of this list with the last file overriding
    the first. Ignored when omitted.
    """
    verify: Optional[Verify] = None
    """
    Verify contains the secret name containing the trusted public keys
    used to verify the signature and specifies which provider to use to check
    whether OCI image is authentic.
    This field is only supported for OCI sources.
    Chart dependencies, which are not bundled in the umbrella chart artifact,
    are not verified.
    """
    version: Optional[str] = "*"
    """
    Version semver expression, ignored for charts from v1.GitRepository and
    v1beta2.Bucket sources. Defaults to latest when omitted.
    """


class Chart(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Chart"]:
            return Chart

        def build(self) -> "Chart":
            return Chart(**self._attrs)

        @overload
        def metadata(self, value_or_callback: Optional[Metadata], /) -> "Chart.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[[Metadata.Builder], Metadata.Builder | Metadata],
            /,
        ) -> "Chart.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "Metadata.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            """
            ObjectMeta holds the template for metadata like labels and annotations.
            """
            if self._in_context and value_or_callback is None:
                context = Metadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Metadata.builder())
                if isinstance(output, Metadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Spec, /) -> "Chart.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Callable[[Spec.Builder], Spec.Builder | Spec], /
        ) -> "Chart.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "Spec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            """
            Spec holds the template for the v1.HelmChartSpec for this HelmRelease.
            """
            if self._in_context and value_or_callback is None:
                context = Spec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Spec.builder())
                if isinstance(output, Spec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["Chart.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Chart.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Chart."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Chart", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Chart.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    metadata: Optional[Metadata] = None
    """
    ObjectMeta holds the template for metadata like labels and annotations.
    """
    spec: Spec
    """
    Spec holds the template for the v1.HelmChartSpec for this HelmRelease.
    """


class ChartRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ChartRef"]:
            return ChartRef

        def build(self) -> "ChartRef":
            return ChartRef(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Literal["OCIRepository", "HelmChart"], /) -> Self:
            """
            Kind of the referent.
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent, defaults to the namespace of the Kubernetes
            resource object that contains the reference.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["ChartRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ChartRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ChartRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ChartRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ChartRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion of the referent.
    """
    kind: Literal["OCIRepository", "HelmChart"]
    """
    Kind of the referent.
    """
    name: Annotated[str, Field(max_length=253, min_length=1)]
    """
    Name of the referent.
    """
    namespace: Annotated[Optional[str], Field(max_length=63, min_length=1)] = None
    """
    Namespace of the referent, defaults to the namespace of the Kubernetes
    resource object that contains the reference.
    """


class DependsOn(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DependsOn"]:
            return DependsOn

        def build(self) -> "DependsOn":
            return DependsOn(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent, when not specified it acts as LocalObjectReference.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["DependsOn.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DependsOn.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DependsOn."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DependsOn", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DependsOn.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referent.
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent, when not specified it acts as LocalObjectReference.
    """


class Target(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Target"]:
            return Target

        def build(self) -> "Target":
            return Target(**self._attrs)

        def annotation_selector(self, value: Optional[str], /) -> Self:
            """
            AnnotationSelector is a string that follows the label selection expression
            https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api
            It matches with the resource annotations.
            """
            return self._set("annotation_selector", value)

        def group(self, value: Optional[str], /) -> Self:
            """
            Group is the API group to select resources from.
            Together with Version and Kind it is capable of unambiguously identifying and/or selecting resources.
            https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
            """
            return self._set("group", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the API Group to select resources from.
            Together with Group and Version it is capable of unambiguously
            identifying and/or selecting resources.
            https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
            """
            return self._set("kind", value)

        def label_selector(self, value: Optional[str], /) -> Self:
            """
            LabelSelector is a string that follows the label selection expression
            https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api
            It matches with the resource labels.
            """
            return self._set("label_selector", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name to match resources with.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace to select resources from.
            """
            return self._set("namespace", value)

        def version(self, value: Optional[str], /) -> Self:
            """
            Version of the API Group to select resources from.
            Together with Group and Kind it is capable of unambiguously identifying and/or selecting resources.
            https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
            """
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["Target.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Target.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Target."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Target", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Target.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotation_selector: Annotated[Optional[str], Field(alias="annotationSelector")] = None
    """
    AnnotationSelector is a string that follows the label selection expression
    https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api
    It matches with the resource annotations.
    """
    group: Optional[str] = None
    """
    Group is the API group to select resources from.
    Together with Version and Kind it is capable of unambiguously identifying and/or selecting resources.
    https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
    """
    kind: Optional[str] = None
    """
    Kind of the API Group to select resources from.
    Together with Group and Version it is capable of unambiguously
    identifying and/or selecting resources.
    https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
    """
    label_selector: Annotated[Optional[str], Field(alias="labelSelector")] = None
    """
    LabelSelector is a string that follows the label selection expression
    https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api
    It matches with the resource labels.
    """
    name: Optional[str] = None
    """
    Name to match resources with.
    """
    namespace: Optional[str] = None
    """
    Namespace to select resources from.
    """
    version: Optional[str] = None
    """
    Version of the API Group to select resources from.
    Together with Group and Kind it is capable of unambiguously identifying and/or selecting resources.
    https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
    """


class Ignore(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ignore"]:
            return Ignore

        def build(self) -> "Ignore":
            return Ignore(**self._attrs)

        def paths(self, value: List[str], /) -> Self:
            """
            Paths is a list of JSON Pointer (RFC 6901) paths to be excluded from
            consideration in a Kubernetes object.
            """
            return self._set("paths", value)

        @overload
        def target(self, value_or_callback: Optional[Target], /) -> "Ignore.Builder": ...

        @overload
        def target(
            self,
            value_or_callback: Callable[[Target.Builder], Target.Builder | Target],
            /,
        ) -> "Ignore.Builder": ...

        @overload
        def target(self, value_or_callback: Never = ...) -> "Target.BuilderContext": ...

        def target(self, value_or_callback=None, /):
            """
            Target is a selector for specifying Kubernetes objects to which this
            rule applies.
            If Target is not set, the Paths will be ignored for all Kubernetes
            objects within the manifest of the Helm release.
            """
            if self._in_context and value_or_callback is None:
                context = Target.BuilderContext()
                context._parent_builder = self
                context._field_name = "target"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Target.builder())
                if isinstance(output, Target.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("target", value)

    class BuilderContext(BuilderContextBase["Ignore.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ignore.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ignore."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ignore", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ignore.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    paths: List[str]
    """
    Paths is a list of JSON Pointer (RFC 6901) paths to be excluded from
    consideration in a Kubernetes object.
    """
    target: Optional[Target] = None
    """
    Target is a selector for specifying Kubernetes objects to which this
    rule applies.
    If Target is not set, the Paths will be ignored for all Kubernetes
    objects within the manifest of the Helm release.
    """


class DriftDetection(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DriftDetection"]:
            return DriftDetection

        def build(self) -> "DriftDetection":
            return DriftDetection(**self._attrs)

        @overload
        def ignore(self, value_or_callback: List[Ignore], /) -> "DriftDetection.Builder": ...

        @overload
        def ignore(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Ignore, Ignore.Builder]],
                GenericListBuilder[Ignore, Ignore.Builder] | List[Ignore],
            ],
            /,
        ) -> "DriftDetection.Builder": ...

        @overload
        def ignore(self, value_or_callback: Never = ...) -> ListBuilderContext[Ignore.Builder]: ...

        def ignore(self, value_or_callback=None, /):
            """
            Ignore contains a list of rules for specifying which changes to ignore
            during diffing.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Ignore.Builder]()
                context._parent_builder = self
                context._field_name = "ignore"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ignore.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("ignore", value)

        def mode(self, value: Optional[Literal["enabled", "warn", "disabled"]], /) -> Self:
            """
            Mode defines how differences should be handled between the Helm manifest
            and the manifest currently applied to the cluster.
            If not explicitly set, it defaults to DiffModeDisabled.
            """
            return self._set("mode", value)

    class BuilderContext(BuilderContextBase["DriftDetection.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DriftDetection.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DriftDetection."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DriftDetection", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DriftDetection.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ignore: Optional[List[Ignore]] = None
    """
    Ignore contains a list of rules for specifying which changes to ignore
    during diffing.
    """
    mode: Optional[Literal["enabled", "warn", "disabled"]] = None
    """
    Mode defines how differences should be handled between the Helm manifest
    and the manifest currently applied to the cluster.
    If not explicitly set, it defaults to DiffModeDisabled.
    """


class Remediation(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Remediation"]:
            return Remediation

        def build(self) -> "Remediation":
            return Remediation(**self._attrs)

        def ignore_test_failures(self, value: Optional[bool], /) -> Self:
            """
            IgnoreTestFailures tells the controller to skip remediation when the Helm
            tests are run after an install action but fail. Defaults to
            'Test.IgnoreFailures'.
            """
            return self._set("ignore_test_failures", value)

        def remediate_last_failure(self, value: Optional[bool], /) -> Self:
            """
            RemediateLastFailure tells the controller to remediate the last failure, when
            no retries remain. Defaults to 'false'.
            """
            return self._set("remediate_last_failure", value)

        def retries(self, value: Optional[int], /) -> Self:
            """
            Retries is the number of retries that should be attempted on failures before
            bailing. Remediation, using an uninstall, is performed between each attempt.
            Defaults to '0', a negative integer equals to unlimited retries.
            """
            return self._set("retries", value)

    class BuilderContext(BuilderContextBase["Remediation.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Remediation.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Remediation."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Remediation", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Remediation.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ignore_test_failures: Annotated[Optional[bool], Field(alias="ignoreTestFailures")] = None
    """
    IgnoreTestFailures tells the controller to skip remediation when the Helm
    tests are run after an install action but fail. Defaults to
    'Test.IgnoreFailures'.
    """
    remediate_last_failure: Annotated[Optional[bool], Field(alias="remediateLastFailure")] = None
    """
    RemediateLastFailure tells the controller to remediate the last failure, when
    no retries remain. Defaults to 'false'.
    """
    retries: Optional[int] = None
    """
    Retries is the number of retries that should be attempted on failures before
    bailing. Remediation, using an uninstall, is performed between each attempt.
    Defaults to '0', a negative integer equals to unlimited retries.
    """


class Install(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Install"]:
            return Install

        def build(self) -> "Install":
            return Install(**self._attrs)

        def crds(self, value: Optional[Literal["Skip", "Create", "CreateReplace"]], /) -> Self:
            """
            CRDs upgrade CRDs from the Helm Chart's crds directory according
            to the CRD upgrade policy provided here. Valid values are `Skip`,
            `Create` or `CreateReplace`. Default is `Create` and if omitted
            CRDs are installed but not updated.

            Skip: do neither install nor replace (update) any CRDs.

            Create: new CRDs are created, existing CRDs are neither updated nor deleted.

            CreateReplace: new CRDs are created, existing CRDs are updated (replaced)
            but not deleted.

            By default, CRDs are applied (installed) during Helm install action.
            With this option users can opt in to CRD replace existing CRDs on Helm
            install actions, which is not (yet) natively supported by Helm.
            https://helm.sh/docs/chart_best_practices/custom_resource_definitions.
            """
            return self._set("crds", value)

        def create_namespace(self, value: Optional[bool], /) -> Self:
            """
            CreateNamespace tells the Helm install action to create the
            HelmReleaseSpec.TargetNamespace if it does not exist yet.
            On uninstall, the namespace will not be garbage collected.
            """
            return self._set("create_namespace", value)

        def disable_hooks(self, value: Optional[bool], /) -> Self:
            """
            DisableHooks prevents hooks from running during the Helm install action.
            """
            return self._set("disable_hooks", value)

        def disable_open_api_validation(self, value: Optional[bool], /) -> Self:
            """
            DisableOpenAPIValidation prevents the Helm install action from validating
            rendered templates against the Kubernetes OpenAPI Schema.
            """
            return self._set("disable_open_api_validation", value)

        def disable_schema_validation(self, value: Optional[bool], /) -> Self:
            """
            DisableSchemaValidation prevents the Helm install action from validating
            the values against the JSON Schema.
            """
            return self._set("disable_schema_validation", value)

        def disable_take_ownership(self, value: Optional[bool], /) -> Self:
            """
            DisableTakeOwnership disables taking ownership of existing resources
            during the Helm install action. Defaults to false.
            """
            return self._set("disable_take_ownership", value)

        def disable_wait(self, value: Optional[bool], /) -> Self:
            """
            DisableWait disables the waiting for resources to be ready after a Helm
            install has been performed.
            """
            return self._set("disable_wait", value)

        def disable_wait_for_jobs(self, value: Optional[bool], /) -> Self:
            """
            DisableWaitForJobs disables waiting for jobs to complete after a Helm
            install has been performed.
            """
            return self._set("disable_wait_for_jobs", value)

        @overload
        def remediation(self, value_or_callback: Optional[Remediation], /) -> "Install.Builder": ...

        @overload
        def remediation(
            self,
            value_or_callback: Callable[[Remediation.Builder], Remediation.Builder | Remediation],
            /,
        ) -> "Install.Builder": ...

        @overload
        def remediation(self, value_or_callback: Never = ...) -> "Remediation.BuilderContext": ...

        def remediation(self, value_or_callback=None, /):
            """
            Remediation holds the remediation configuration for when the Helm install
            action for the HelmRelease fails. The default is to not perform any action.
            """
            if self._in_context and value_or_callback is None:
                context = Remediation.BuilderContext()
                context._parent_builder = self
                context._field_name = "remediation"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Remediation.builder())
                if isinstance(output, Remediation.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("remediation", value)

        def replace(self, value: Optional[bool], /) -> Self:
            """
            Replace tells the Helm install action to re-use the 'ReleaseName', but only
            if that name is a deleted release which remains in the history.
            """
            return self._set("replace", value)

        def skip_cr_ds(self, value: Optional[bool], /) -> Self:
            """
            SkipCRDs tells the Helm install action to not install any CRDs. By default,
            CRDs are installed if not already present.

            Deprecated use CRD policy (`crds`) attribute with value `Skip` instead.
            """
            return self._set("skip_cr_ds", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout is the time to wait for any individual Kubernetes operation (like
            Jobs for hooks) during the performance of a Helm install action. Defaults to
            'HelmReleaseSpec.Timeout'.
            """
            return self._set("timeout", value)

    class BuilderContext(BuilderContextBase["Install.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Install.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Install."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Install", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Install.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    crds: Optional[Literal["Skip", "Create", "CreateReplace"]] = None
    """
    CRDs upgrade CRDs from the Helm Chart's crds directory according
    to the CRD upgrade policy provided here. Valid values are `Skip`,
    `Create` or `CreateReplace`. Default is `Create` and if omitted
    CRDs are installed but not updated.

    Skip: do neither install nor replace (update) any CRDs.

    Create: new CRDs are created, existing CRDs are neither updated nor deleted.

    CreateReplace: new CRDs are created, existing CRDs are updated (replaced)
    but not deleted.

    By default, CRDs are applied (installed) during Helm install action.
    With this option users can opt in to CRD replace existing CRDs on Helm
    install actions, which is not (yet) natively supported by Helm.
    https://helm.sh/docs/chart_best_practices/custom_resource_definitions.
    """
    create_namespace: Annotated[Optional[bool], Field(alias="createNamespace")] = None
    """
    CreateNamespace tells the Helm install action to create the
    HelmReleaseSpec.TargetNamespace if it does not exist yet.
    On uninstall, the namespace will not be garbage collected.
    """
    disable_hooks: Annotated[Optional[bool], Field(alias="disableHooks")] = None
    """
    DisableHooks prevents hooks from running during the Helm install action.
    """
    disable_open_api_validation: Annotated[
        Optional[bool], Field(alias="disableOpenAPIValidation")
    ] = None
    """
    DisableOpenAPIValidation prevents the Helm install action from validating
    rendered templates against the Kubernetes OpenAPI Schema.
    """
    disable_schema_validation: Annotated[Optional[bool], Field(alias="disableSchemaValidation")] = (
        None
    )
    """
    DisableSchemaValidation prevents the Helm install action from validating
    the values against the JSON Schema.
    """
    disable_take_ownership: Annotated[Optional[bool], Field(alias="disableTakeOwnership")] = None
    """
    DisableTakeOwnership disables taking ownership of existing resources
    during the Helm install action. Defaults to false.
    """
    disable_wait: Annotated[Optional[bool], Field(alias="disableWait")] = None
    """
    DisableWait disables the waiting for resources to be ready after a Helm
    install has been performed.
    """
    disable_wait_for_jobs: Annotated[Optional[bool], Field(alias="disableWaitForJobs")] = None
    """
    DisableWaitForJobs disables waiting for jobs to complete after a Helm
    install has been performed.
    """
    remediation: Optional[Remediation] = None
    """
    Remediation holds the remediation configuration for when the Helm install
    action for the HelmRelease fails. The default is to not perform any action.
    """
    replace: Optional[bool] = None
    """
    Replace tells the Helm install action to re-use the 'ReleaseName', but only
    if that name is a deleted release which remains in the history.
    """
    skip_cr_ds: Annotated[Optional[bool], Field(alias="skipCRDs")] = None
    """
    SkipCRDs tells the Helm install action to not install any CRDs. By default,
    CRDs are installed if not already present.

    Deprecated use CRD policy (`crds`) attribute with value `Skip` instead.
    """
    timeout: Annotated[Optional[str], Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$")] = None
    """
    Timeout is the time to wait for any individual Kubernetes operation (like
    Jobs for hooks) during the performance of a Helm install action. Defaults to
    'HelmReleaseSpec.Timeout'.
    """


class SecretRefModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretRefModel"]:
            return SecretRefModel

        def build(self) -> "SecretRefModel":
            return SecretRefModel(**self._attrs)

        def key(self, value: Optional[str], /) -> Self:
            """
            Key in the Secret, when not specified an implementation-specific default key is used.
            """
            return self._set("key", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the Secret.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["SecretRefModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretRefModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretRefModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretRefModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRefModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[str] = None
    """
    Key in the Secret, when not specified an implementation-specific default key is used.
    """
    name: str
    """
    Name of the Secret.
    """


class KubeConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["KubeConfig"]:
            return KubeConfig

        def build(self) -> "KubeConfig":
            return KubeConfig(**self._attrs)

        @overload
        def secret_ref(self, value_or_callback: SecretRefModel, /) -> "KubeConfig.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[
                [SecretRefModel.Builder], SecretRefModel.Builder | SecretRefModel
            ],
            /,
        ) -> "KubeConfig.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRefModel.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            SecretRef holds the name of a secret that contains a key with
            the kubeconfig file as the value. If no key is set, the key will default
            to 'value'.
            It is recommended that the kubeconfig is self-contained, and the secret
            is regularly updated if credentials such as a cloud-access-token expire.
            Cloud specific `cmd-path` auth helpers will not function without adding
            binaries and credentials to the Pod that is responsible for reconciling
            Kubernetes resources.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRefModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRefModel.builder())
                if isinstance(output, SecretRefModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

    class BuilderContext(BuilderContextBase["KubeConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = KubeConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for KubeConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["KubeConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KubeConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secret_ref: Annotated[SecretRefModel, Field(alias="secretRef")]
    """
    SecretRef holds the name of a secret that contains a key with
    the kubeconfig file as the value. If no key is set, the key will default
    to 'value'.
    It is recommended that the kubeconfig is self-contained, and the secret
    is regularly updated if credentials such as a cloud-access-token expire.
    Cloud specific `cmd-path` auth helpers will not function without adding
    binaries and credentials to the Pod that is responsible for reconciling
    Kubernetes resources.
    """


class Image(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Image"]:
            return Image

        def build(self) -> "Image":
            return Image(**self._attrs)

        def digest(self, value: Optional[str], /) -> Self:
            """
            Digest is the value used to replace the original image tag.
            If digest is present NewTag value is ignored.
            """
            return self._set("digest", value)

        def name(self, value: str, /) -> Self:
            """
            Name is a tag-less image name.
            """
            return self._set("name", value)

        def new_name(self, value: Optional[str], /) -> Self:
            """
            NewName is the value used to replace the original name.
            """
            return self._set("new_name", value)

        def new_tag(self, value: Optional[str], /) -> Self:
            """
            NewTag is the value used to replace the original tag.
            """
            return self._set("new_tag", value)

    class BuilderContext(BuilderContextBase["Image.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Image.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Image."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Image", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Image.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    digest: Optional[str] = None
    """
    Digest is the value used to replace the original image tag.
    If digest is present NewTag value is ignored.
    """
    name: str
    """
    Name is a tag-less image name.
    """
    new_name: Annotated[Optional[str], Field(alias="newName")] = None
    """
    NewName is the value used to replace the original name.
    """
    new_tag: Annotated[Optional[str], Field(alias="newTag")] = None
    """
    NewTag is the value used to replace the original tag.
    """


class Patch(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Patch"]:
            return Patch

        def build(self) -> "Patch":
            return Patch(**self._attrs)

        def patch(self, value: str, /) -> Self:
            """
            Patch contains an inline StrategicMerge patch or an inline JSON6902 patch with
            an array of operation objects.
            """
            return self._set("patch", value)

        @overload
        def target(self, value_or_callback: Optional[Target], /) -> "Patch.Builder": ...

        @overload
        def target(
            self,
            value_or_callback: Callable[[Target.Builder], Target.Builder | Target],
            /,
        ) -> "Patch.Builder": ...

        @overload
        def target(self, value_or_callback: Never = ...) -> "Target.BuilderContext": ...

        def target(self, value_or_callback=None, /):
            """
            Target points to the resources that the patch document should be applied to.
            """
            if self._in_context and value_or_callback is None:
                context = Target.BuilderContext()
                context._parent_builder = self
                context._field_name = "target"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Target.builder())
                if isinstance(output, Target.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("target", value)

    class BuilderContext(BuilderContextBase["Patch.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Patch.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Patch."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Patch", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Patch.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    patch: str
    """
    Patch contains an inline StrategicMerge patch or an inline JSON6902 patch with
    an array of operation objects.
    """
    target: Optional[Target] = None
    """
    Target points to the resources that the patch document should be applied to.
    """


class Kustomize(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Kustomize"]:
            return Kustomize

        def build(self) -> "Kustomize":
            return Kustomize(**self._attrs)

        @overload
        def images(self, value_or_callback: List[Image], /) -> "Kustomize.Builder": ...

        @overload
        def images(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Image, Image.Builder]],
                GenericListBuilder[Image, Image.Builder] | List[Image],
            ],
            /,
        ) -> "Kustomize.Builder": ...

        @overload
        def images(self, value_or_callback: Never = ...) -> ListBuilderContext[Image.Builder]: ...

        def images(self, value_or_callback=None, /):
            """
            Images is a list of (image name, new name, new tag or digest)
            for changing image names, tags or digests. This can also be achieved with a
            patch, but this operator is simpler to specify.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Image.Builder]()
                context._parent_builder = self
                context._field_name = "images"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Image.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("images", value)

        @overload
        def patches(self, value_or_callback: List[Patch], /) -> "Kustomize.Builder": ...

        @overload
        def patches(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Patch, Patch.Builder]],
                GenericListBuilder[Patch, Patch.Builder] | List[Patch],
            ],
            /,
        ) -> "Kustomize.Builder": ...

        @overload
        def patches(self, value_or_callback: Never = ...) -> ListBuilderContext[Patch.Builder]: ...

        def patches(self, value_or_callback=None, /):
            """
            Strategic merge and JSON patches, defined as inline YAML objects,
            capable of targeting objects based on kind, label and annotation selectors.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Patch.Builder]()
                context._parent_builder = self
                context._field_name = "patches"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Patch.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("patches", value)

    class BuilderContext(BuilderContextBase["Kustomize.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Kustomize.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Kustomize."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Kustomize", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Kustomize.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    images: Optional[List[Image]] = None
    """
    Images is a list of (image name, new name, new tag or digest)
    for changing image names, tags or digests. This can also be achieved with a
    patch, but this operator is simpler to specify.
    """
    patches: Optional[List[Patch]] = None
    """
    Strategic merge and JSON patches, defined as inline YAML objects,
    capable of targeting objects based on kind, label and annotation selectors.
    """


class PostRenderer(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PostRenderer"]:
            return PostRenderer

        def build(self) -> "PostRenderer":
            return PostRenderer(**self._attrs)

        @overload
        def kustomize(
            self, value_or_callback: Optional[Kustomize], /
        ) -> "PostRenderer.Builder": ...

        @overload
        def kustomize(
            self,
            value_or_callback: Callable[[Kustomize.Builder], Kustomize.Builder | Kustomize],
            /,
        ) -> "PostRenderer.Builder": ...

        @overload
        def kustomize(self, value_or_callback: Never = ...) -> "Kustomize.BuilderContext": ...

        def kustomize(self, value_or_callback=None, /):
            """
            Kustomization to apply as PostRenderer.
            """
            if self._in_context and value_or_callback is None:
                context = Kustomize.BuilderContext()
                context._parent_builder = self
                context._field_name = "kustomize"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Kustomize.builder())
                if isinstance(output, Kustomize.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("kustomize", value)

    class BuilderContext(BuilderContextBase["PostRenderer.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PostRenderer.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PostRenderer."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PostRenderer", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PostRenderer.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    kustomize: Optional[Kustomize] = None
    """
    Kustomization to apply as PostRenderer.
    """


class Rollback(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Rollback"]:
            return Rollback

        def build(self) -> "Rollback":
            return Rollback(**self._attrs)

        def cleanup_on_fail(self, value: Optional[bool], /) -> Self:
            """
            CleanupOnFail allows deletion of new resources created during the Helm
            rollback action when it fails.
            """
            return self._set("cleanup_on_fail", value)

        def disable_hooks(self, value: Optional[bool], /) -> Self:
            """
            DisableHooks prevents hooks from running during the Helm rollback action.
            """
            return self._set("disable_hooks", value)

        def disable_wait(self, value: Optional[bool], /) -> Self:
            """
            DisableWait disables the waiting for resources to be ready after a Helm
            rollback has been performed.
            """
            return self._set("disable_wait", value)

        def disable_wait_for_jobs(self, value: Optional[bool], /) -> Self:
            """
            DisableWaitForJobs disables waiting for jobs to complete after a Helm
            rollback has been performed.
            """
            return self._set("disable_wait_for_jobs", value)

        def force(self, value: Optional[bool], /) -> Self:
            """
            Force forces resource updates through a replacement strategy.
            """
            return self._set("force", value)

        def recreate(self, value: Optional[bool], /) -> Self:
            """
            Recreate performs pod restarts for the resource if applicable.
            """
            return self._set("recreate", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout is the time to wait for any individual Kubernetes operation (like
            Jobs for hooks) during the performance of a Helm rollback action. Defaults to
            'HelmReleaseSpec.Timeout'.
            """
            return self._set("timeout", value)

    class BuilderContext(BuilderContextBase["Rollback.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Rollback.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Rollback."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Rollback", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Rollback.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cleanup_on_fail: Annotated[Optional[bool], Field(alias="cleanupOnFail")] = None
    """
    CleanupOnFail allows deletion of new resources created during the Helm
    rollback action when it fails.
    """
    disable_hooks: Annotated[Optional[bool], Field(alias="disableHooks")] = None
    """
    DisableHooks prevents hooks from running during the Helm rollback action.
    """
    disable_wait: Annotated[Optional[bool], Field(alias="disableWait")] = None
    """
    DisableWait disables the waiting for resources to be ready after a Helm
    rollback has been performed.
    """
    disable_wait_for_jobs: Annotated[Optional[bool], Field(alias="disableWaitForJobs")] = None
    """
    DisableWaitForJobs disables waiting for jobs to complete after a Helm
    rollback has been performed.
    """
    force: Optional[bool] = None
    """
    Force forces resource updates through a replacement strategy.
    """
    recreate: Optional[bool] = None
    """
    Recreate performs pod restarts for the resource if applicable.
    """
    timeout: Annotated[Optional[str], Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$")] = None
    """
    Timeout is the time to wait for any individual Kubernetes operation (like
    Jobs for hooks) during the performance of a Helm rollback action. Defaults to
    'HelmReleaseSpec.Timeout'.
    """


class Filter(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Filter"]:
            return Filter

        def build(self) -> "Filter":
            return Filter(**self._attrs)

        def exclude(self, value: Optional[bool], /) -> Self:
            """
            Exclude specifies whether the named test should be excluded.
            """
            return self._set("exclude", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of the test.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["Filter.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Filter.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Filter."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Filter", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Filter.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exclude: Optional[bool] = None
    """
    Exclude specifies whether the named test should be excluded.
    """
    name: Annotated[str, Field(max_length=253, min_length=1)]
    """
    Name is the name of the test.
    """


class Test(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Test"]:
            return Test

        def build(self) -> "Test":
            return Test(**self._attrs)

        def enable(self, value: Optional[bool], /) -> Self:
            """
            Enable enables Helm test actions for this HelmRelease after an Helm install
            or upgrade action has been performed.
            """
            return self._set("enable", value)

        @overload
        def filters(self, value_or_callback: List[Filter], /) -> "Test.Builder": ...

        @overload
        def filters(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Filter, Filter.Builder]],
                GenericListBuilder[Filter, Filter.Builder] | List[Filter],
            ],
            /,
        ) -> "Test.Builder": ...

        @overload
        def filters(self, value_or_callback: Never = ...) -> ListBuilderContext[Filter.Builder]: ...

        def filters(self, value_or_callback=None, /):
            """
            Filters is a list of tests to run or exclude from running.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Filter.Builder]()
                context._parent_builder = self
                context._field_name = "filters"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Filter.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("filters", value)

        def ignore_failures(self, value: Optional[bool], /) -> Self:
            """
            IgnoreFailures tells the controller to skip remediation when the Helm tests
            are run but fail. Can be overwritten for tests run after install or upgrade
            actions in 'Install.IgnoreTestFailures' and 'Upgrade.IgnoreTestFailures'.
            """
            return self._set("ignore_failures", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout is the time to wait for any individual Kubernetes operation during
            the performance of a Helm test action. Defaults to 'HelmReleaseSpec.Timeout'.
            """
            return self._set("timeout", value)

    class BuilderContext(BuilderContextBase["Test.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Test.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Test."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Test", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Test.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    enable: Optional[bool] = None
    """
    Enable enables Helm test actions for this HelmRelease after an Helm install
    or upgrade action has been performed.
    """
    filters: Optional[List[Filter]] = None
    """
    Filters is a list of tests to run or exclude from running.
    """
    ignore_failures: Annotated[Optional[bool], Field(alias="ignoreFailures")] = None
    """
    IgnoreFailures tells the controller to skip remediation when the Helm tests
    are run but fail. Can be overwritten for tests run after install or upgrade
    actions in 'Install.IgnoreTestFailures' and 'Upgrade.IgnoreTestFailures'.
    """
    timeout: Annotated[Optional[str], Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$")] = None
    """
    Timeout is the time to wait for any individual Kubernetes operation during
    the performance of a Helm test action. Defaults to 'HelmReleaseSpec.Timeout'.
    """


class Uninstall(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Uninstall"]:
            return Uninstall

        def build(self) -> "Uninstall":
            return Uninstall(**self._attrs)

        def deletion_propagation(
            self, value: Optional[Literal["background", "foreground", "orphan"]], /
        ) -> Self:
            """
            DeletionPropagation specifies the deletion propagation policy when
            a Helm uninstall is performed.
            """
            return self._set("deletion_propagation", value)

        def disable_hooks(self, value: Optional[bool], /) -> Self:
            """
            DisableHooks prevents hooks from running during the Helm rollback action.
            """
            return self._set("disable_hooks", value)

        def disable_wait(self, value: Optional[bool], /) -> Self:
            """
            DisableWait disables waiting for all the resources to be deleted after
            a Helm uninstall is performed.
            """
            return self._set("disable_wait", value)

        def keep_history(self, value: Optional[bool], /) -> Self:
            """
            KeepHistory tells Helm to remove all associated resources and mark the
            release as deleted, but retain the release history.
            """
            return self._set("keep_history", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout is the time to wait for any individual Kubernetes operation (like
            Jobs for hooks) during the performance of a Helm uninstall action. Defaults
            to 'HelmReleaseSpec.Timeout'.
            """
            return self._set("timeout", value)

    class BuilderContext(BuilderContextBase["Uninstall.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Uninstall.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Uninstall."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Uninstall", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Uninstall.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deletion_propagation: Annotated[
        Optional[Literal["background", "foreground", "orphan"]],
        Field(alias="deletionPropagation"),
    ] = "background"
    """
    DeletionPropagation specifies the deletion propagation policy when
    a Helm uninstall is performed.
    """
    disable_hooks: Annotated[Optional[bool], Field(alias="disableHooks")] = None
    """
    DisableHooks prevents hooks from running during the Helm rollback action.
    """
    disable_wait: Annotated[Optional[bool], Field(alias="disableWait")] = None
    """
    DisableWait disables waiting for all the resources to be deleted after
    a Helm uninstall is performed.
    """
    keep_history: Annotated[Optional[bool], Field(alias="keepHistory")] = None
    """
    KeepHistory tells Helm to remove all associated resources and mark the
    release as deleted, but retain the release history.
    """
    timeout: Annotated[Optional[str], Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$")] = None
    """
    Timeout is the time to wait for any individual Kubernetes operation (like
    Jobs for hooks) during the performance of a Helm uninstall action. Defaults
    to 'HelmReleaseSpec.Timeout'.
    """


class RemediationModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RemediationModel"]:
            return RemediationModel

        def build(self) -> "RemediationModel":
            return RemediationModel(**self._attrs)

        def ignore_test_failures(self, value: Optional[bool], /) -> Self:
            """
            IgnoreTestFailures tells the controller to skip remediation when the Helm
            tests are run after an upgrade action but fail.
            Defaults to 'Test.IgnoreFailures'.
            """
            return self._set("ignore_test_failures", value)

        def remediate_last_failure(self, value: Optional[bool], /) -> Self:
            """
            RemediateLastFailure tells the controller to remediate the last failure, when
            no retries remain. Defaults to 'false' unless 'Retries' is greater than 0.
            """
            return self._set("remediate_last_failure", value)

        def retries(self, value: Optional[int], /) -> Self:
            """
            Retries is the number of retries that should be attempted on failures before
            bailing. Remediation, using 'Strategy', is performed between each attempt.
            Defaults to '0', a negative integer equals to unlimited retries.
            """
            return self._set("retries", value)

        def strategy(self, value: Optional[Literal["rollback", "uninstall"]], /) -> Self:
            """
            Strategy to use for failure remediation. Defaults to 'rollback'.
            """
            return self._set("strategy", value)

    class BuilderContext(BuilderContextBase["RemediationModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RemediationModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RemediationModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RemediationModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RemediationModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ignore_test_failures: Annotated[Optional[bool], Field(alias="ignoreTestFailures")] = None
    """
    IgnoreTestFailures tells the controller to skip remediation when the Helm
    tests are run after an upgrade action but fail.
    Defaults to 'Test.IgnoreFailures'.
    """
    remediate_last_failure: Annotated[Optional[bool], Field(alias="remediateLastFailure")] = None
    """
    RemediateLastFailure tells the controller to remediate the last failure, when
    no retries remain. Defaults to 'false' unless 'Retries' is greater than 0.
    """
    retries: Optional[int] = None
    """
    Retries is the number of retries that should be attempted on failures before
    bailing. Remediation, using 'Strategy', is performed between each attempt.
    Defaults to '0', a negative integer equals to unlimited retries.
    """
    strategy: Optional[Literal["rollback", "uninstall"]] = None
    """
    Strategy to use for failure remediation. Defaults to 'rollback'.
    """


class Upgrade(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Upgrade"]:
            return Upgrade

        def build(self) -> "Upgrade":
            return Upgrade(**self._attrs)

        def cleanup_on_fail(self, value: Optional[bool], /) -> Self:
            """
            CleanupOnFail allows deletion of new resources created during the Helm
            upgrade action when it fails.
            """
            return self._set("cleanup_on_fail", value)

        def crds(self, value: Optional[Literal["Skip", "Create", "CreateReplace"]], /) -> Self:
            """
            CRDs upgrade CRDs from the Helm Chart's crds directory according
            to the CRD upgrade policy provided here. Valid values are `Skip`,
            `Create` or `CreateReplace`. Default is `Skip` and if omitted
            CRDs are neither installed nor upgraded.

            Skip: do neither install nor replace (update) any CRDs.

            Create: new CRDs are created, existing CRDs are neither updated nor deleted.

            CreateReplace: new CRDs are created, existing CRDs are updated (replaced)
            but not deleted.

            By default, CRDs are not applied during Helm upgrade action. With this
            option users can opt-in to CRD upgrade, which is not (yet) natively supported by Helm.
            https://helm.sh/docs/chart_best_practices/custom_resource_definitions.
            """
            return self._set("crds", value)

        def disable_hooks(self, value: Optional[bool], /) -> Self:
            """
            DisableHooks prevents hooks from running during the Helm upgrade action.
            """
            return self._set("disable_hooks", value)

        def disable_open_api_validation(self, value: Optional[bool], /) -> Self:
            """
            DisableOpenAPIValidation prevents the Helm upgrade action from validating
            rendered templates against the Kubernetes OpenAPI Schema.
            """
            return self._set("disable_open_api_validation", value)

        def disable_schema_validation(self, value: Optional[bool], /) -> Self:
            """
            DisableSchemaValidation prevents the Helm upgrade action from validating
            the values against the JSON Schema.
            """
            return self._set("disable_schema_validation", value)

        def disable_take_ownership(self, value: Optional[bool], /) -> Self:
            """
            DisableTakeOwnership disables taking ownership of existing resources
            during the Helm upgrade action. Defaults to false.
            """
            return self._set("disable_take_ownership", value)

        def disable_wait(self, value: Optional[bool], /) -> Self:
            """
            DisableWait disables the waiting for resources to be ready after a Helm
            upgrade has been performed.
            """
            return self._set("disable_wait", value)

        def disable_wait_for_jobs(self, value: Optional[bool], /) -> Self:
            """
            DisableWaitForJobs disables waiting for jobs to complete after a Helm
            upgrade has been performed.
            """
            return self._set("disable_wait_for_jobs", value)

        def force(self, value: Optional[bool], /) -> Self:
            """
            Force forces resource updates through a replacement strategy.
            """
            return self._set("force", value)

        def preserve_values(self, value: Optional[bool], /) -> Self:
            """
            PreserveValues will make Helm reuse the last release's values and merge in
            overrides from 'Values'. Setting this flag makes the HelmRelease
            non-declarative.
            """
            return self._set("preserve_values", value)

        @overload
        def remediation(
            self, value_or_callback: Optional[RemediationModel], /
        ) -> "Upgrade.Builder": ...

        @overload
        def remediation(
            self,
            value_or_callback: Callable[
                [RemediationModel.Builder], RemediationModel.Builder | RemediationModel
            ],
            /,
        ) -> "Upgrade.Builder": ...

        @overload
        def remediation(
            self, value_or_callback: Never = ...
        ) -> "RemediationModel.BuilderContext": ...

        def remediation(self, value_or_callback=None, /):
            """
            Remediation holds the remediation configuration for when the Helm upgrade
            action for the HelmRelease fails. The default is to not perform any action.
            """
            if self._in_context and value_or_callback is None:
                context = RemediationModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "remediation"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RemediationModel.builder())
                if isinstance(output, RemediationModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("remediation", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout is the time to wait for any individual Kubernetes operation (like
            Jobs for hooks) during the performance of a Helm upgrade action. Defaults to
            'HelmReleaseSpec.Timeout'.
            """
            return self._set("timeout", value)

    class BuilderContext(BuilderContextBase["Upgrade.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Upgrade.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Upgrade."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Upgrade", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Upgrade.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cleanup_on_fail: Annotated[Optional[bool], Field(alias="cleanupOnFail")] = None
    """
    CleanupOnFail allows deletion of new resources created during the Helm
    upgrade action when it fails.
    """
    crds: Optional[Literal["Skip", "Create", "CreateReplace"]] = None
    """
    CRDs upgrade CRDs from the Helm Chart's crds directory according
    to the CRD upgrade policy provided here. Valid values are `Skip`,
    `Create` or `CreateReplace`. Default is `Skip` and if omitted
    CRDs are neither installed nor upgraded.

    Skip: do neither install nor replace (update) any CRDs.

    Create: new CRDs are created, existing CRDs are neither updated nor deleted.

    CreateReplace: new CRDs are created, existing CRDs are updated (replaced)
    but not deleted.

    By default, CRDs are not applied during Helm upgrade action. With this
    option users can opt-in to CRD upgrade, which is not (yet) natively supported by Helm.
    https://helm.sh/docs/chart_best_practices/custom_resource_definitions.
    """
    disable_hooks: Annotated[Optional[bool], Field(alias="disableHooks")] = None
    """
    DisableHooks prevents hooks from running during the Helm upgrade action.
    """
    disable_open_api_validation: Annotated[
        Optional[bool], Field(alias="disableOpenAPIValidation")
    ] = None
    """
    DisableOpenAPIValidation prevents the Helm upgrade action from validating
    rendered templates against the Kubernetes OpenAPI Schema.
    """
    disable_schema_validation: Annotated[Optional[bool], Field(alias="disableSchemaValidation")] = (
        None
    )
    """
    DisableSchemaValidation prevents the Helm upgrade action from validating
    the values against the JSON Schema.
    """
    disable_take_ownership: Annotated[Optional[bool], Field(alias="disableTakeOwnership")] = None
    """
    DisableTakeOwnership disables taking ownership of existing resources
    during the Helm upgrade action. Defaults to false.
    """
    disable_wait: Annotated[Optional[bool], Field(alias="disableWait")] = None
    """
    DisableWait disables the waiting for resources to be ready after a Helm
    upgrade has been performed.
    """
    disable_wait_for_jobs: Annotated[Optional[bool], Field(alias="disableWaitForJobs")] = None
    """
    DisableWaitForJobs disables waiting for jobs to complete after a Helm
    upgrade has been performed.
    """
    force: Optional[bool] = None
    """
    Force forces resource updates through a replacement strategy.
    """
    preserve_values: Annotated[Optional[bool], Field(alias="preserveValues")] = None
    """
    PreserveValues will make Helm reuse the last release's values and merge in
    overrides from 'Values'. Setting this flag makes the HelmRelease
    non-declarative.
    """
    remediation: Optional[RemediationModel] = None
    """
    Remediation holds the remediation configuration for when the Helm upgrade
    action for the HelmRelease fails. The default is to not perform any action.
    """
    timeout: Annotated[Optional[str], Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$")] = None
    """
    Timeout is the time to wait for any individual Kubernetes operation (like
    Jobs for hooks) during the performance of a Helm upgrade action. Defaults to
    'HelmReleaseSpec.Timeout'.
    """


class ValuesFrom(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ValuesFrom"]:
            return ValuesFrom

        def build(self) -> "ValuesFrom":
            return ValuesFrom(**self._attrs)

        def kind(self, value: Literal["Secret", "ConfigMap"], /) -> Self:
            """
            Kind of the values referent, valid values are ('Secret', 'ConfigMap').
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the values referent. Should reside in the same namespace as the
            referring resource.
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Optional marks this ValuesReference as optional. When set, a not found error
            for the values reference is ignored, but any ValuesKey, TargetPath or
            transient error will still result in a reconciliation failure.
            """
            return self._set("optional", value)

        def target_path(self, value: Optional[str], /) -> Self:
            """
            TargetPath is the YAML dot notation path the value should be merged at. When
            set, the ValuesKey is expected to be a single flat value. Defaults to 'None',
            which results in the values getting merged at the root.
            """
            return self._set("target_path", value)

        def values_key(self, value: Optional[str], /) -> Self:
            """
            ValuesKey is the data key where the values.yaml or a specific value can be
            found at. Defaults to 'values.yaml'.
            """
            return self._set("values_key", value)

    class BuilderContext(BuilderContextBase["ValuesFrom.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ValuesFrom.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ValuesFrom."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ValuesFrom", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ValuesFrom.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    kind: Literal["Secret", "ConfigMap"]
    """
    Kind of the values referent, valid values are ('Secret', 'ConfigMap').
    """
    name: Annotated[str, Field(max_length=253, min_length=1)]
    """
    Name of the values referent. Should reside in the same namespace as the
    referring resource.
    """
    optional: Optional[bool] = None
    """
    Optional marks this ValuesReference as optional. When set, a not found error
    for the values reference is ignored, but any ValuesKey, TargetPath or
    transient error will still result in a reconciliation failure.
    """
    target_path: Annotated[
        Optional[str],
        Field(
            alias="targetPath",
            max_length=250,
            pattern="^([a-zA-Z0-9_\\-.\\\\\\/]|\\[[0-9]{1,5}\\])+$",
        ),
    ] = None
    """
    TargetPath is the YAML dot notation path the value should be merged at. When
    set, the ValuesKey is expected to be a single flat value. Defaults to 'None',
    which results in the values getting merged at the root.
    """
    values_key: Annotated[
        Optional[str],
        Field(alias="valuesKey", max_length=253, pattern="^[\\-._a-zA-Z0-9]+$"),
    ] = None
    """
    ValuesKey is the data key where the values.yaml or a specific value can be
    found at. Defaults to 'values.yaml'.
    """


class HelmReleaseSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HelmReleaseSpec"]:
            return HelmReleaseSpec

        def build(self) -> "HelmReleaseSpec":
            return HelmReleaseSpec(**self._attrs)

        @overload
        def chart(self, value_or_callback: Optional[Chart], /) -> "HelmReleaseSpec.Builder": ...

        @overload
        def chart(
            self, value_or_callback: Callable[[Chart.Builder], Chart.Builder | Chart], /
        ) -> "HelmReleaseSpec.Builder": ...

        @overload
        def chart(self, value_or_callback: Never = ...) -> "Chart.BuilderContext": ...

        def chart(self, value_or_callback=None, /):
            """
            Chart defines the template of the v1.HelmChart that should be created
            for this HelmRelease.
            """
            if self._in_context and value_or_callback is None:
                context = Chart.BuilderContext()
                context._parent_builder = self
                context._field_name = "chart"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Chart.builder())
                if isinstance(output, Chart.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("chart", value)

        @overload
        def chart_ref(
            self, value_or_callback: Optional[ChartRef], /
        ) -> "HelmReleaseSpec.Builder": ...

        @overload
        def chart_ref(
            self,
            value_or_callback: Callable[[ChartRef.Builder], ChartRef.Builder | ChartRef],
            /,
        ) -> "HelmReleaseSpec.Builder": ...

        @overload
        def chart_ref(self, value_or_callback: Never = ...) -> "ChartRef.BuilderContext": ...

        def chart_ref(self, value_or_callback=None, /):
            """
            ChartRef holds a reference to a source controller resource containing the
            Helm chart artifact.
            """
            if self._in_context and value_or_callback is None:
                context = ChartRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "chart_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ChartRef.builder())
                if isinstance(output, ChartRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("chart_ref", value)

        @overload
        def depends_on(
            self, value_or_callback: List[DependsOn], /
        ) -> "HelmReleaseSpec.Builder": ...

        @overload
        def depends_on(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[DependsOn, DependsOn.Builder]],
                GenericListBuilder[DependsOn, DependsOn.Builder] | List[DependsOn],
            ],
            /,
        ) -> "HelmReleaseSpec.Builder": ...

        @overload
        def depends_on(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[DependsOn.Builder]: ...

        def depends_on(self, value_or_callback=None, /):
            """
            DependsOn may contain a meta.NamespacedObjectReference slice with
            references to HelmRelease resources that must be ready before this HelmRelease
            can be reconciled.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[DependsOn.Builder]()
                context._parent_builder = self
                context._field_name = "depends_on"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DependsOn.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("depends_on", value)

        @overload
        def drift_detection(
            self, value_or_callback: Optional[DriftDetection], /
        ) -> "HelmReleaseSpec.Builder": ...

        @overload
        def drift_detection(
            self,
            value_or_callback: Callable[
                [DriftDetection.Builder], DriftDetection.Builder | DriftDetection
            ],
            /,
        ) -> "HelmReleaseSpec.Builder": ...

        @overload
        def drift_detection(
            self, value_or_callback: Never = ...
        ) -> "DriftDetection.BuilderContext": ...

        def drift_detection(self, value_or_callback=None, /):
            """
            DriftDetection holds the configuration for detecting and handling
            differences between the manifest in the Helm storage and the resources
            currently existing in the cluster.
            """
            if self._in_context and value_or_callback is None:
                context = DriftDetection.BuilderContext()
                context._parent_builder = self
                context._field_name = "drift_detection"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DriftDetection.builder())
                if isinstance(output, DriftDetection.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("drift_detection", value)

        @overload
        def install(self, value_or_callback: Optional[Install], /) -> "HelmReleaseSpec.Builder": ...

        @overload
        def install(
            self,
            value_or_callback: Callable[[Install.Builder], Install.Builder | Install],
            /,
        ) -> "HelmReleaseSpec.Builder": ...

        @overload
        def install(self, value_or_callback: Never = ...) -> "Install.BuilderContext": ...

        def install(self, value_or_callback=None, /):
            """
            Install holds the configuration for Helm install actions for this HelmRelease.
            """
            if self._in_context and value_or_callback is None:
                context = Install.BuilderContext()
                context._parent_builder = self
                context._field_name = "install"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Install.builder())
                if isinstance(output, Install.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("install", value)

        def interval(self, value: str, /) -> Self:
            """
            Interval at which to reconcile the Helm release.
            """
            return self._set("interval", value)

        @overload
        def kube_config(
            self, value_or_callback: Optional[KubeConfig], /
        ) -> "HelmReleaseSpec.Builder": ...

        @overload
        def kube_config(
            self,
            value_or_callback: Callable[[KubeConfig.Builder], KubeConfig.Builder | KubeConfig],
            /,
        ) -> "HelmReleaseSpec.Builder": ...

        @overload
        def kube_config(self, value_or_callback: Never = ...) -> "KubeConfig.BuilderContext": ...

        def kube_config(self, value_or_callback=None, /):
            """
            KubeConfig for reconciling the HelmRelease on a remote cluster.
            When used in combination with HelmReleaseSpec.ServiceAccountName,
            forces the controller to act on behalf of that Service Account at the
            target cluster.
            If the --default-service-account flag is set, its value will be used as
            a controller level fallback for when HelmReleaseSpec.ServiceAccountName
            is empty.
            """
            if self._in_context and value_or_callback is None:
                context = KubeConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "kube_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KubeConfig.builder())
                if isinstance(output, KubeConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("kube_config", value)

        def max_history(self, value: Optional[int], /) -> Self:
            """
            MaxHistory is the number of revisions saved by Helm for this HelmRelease.
            Use '0' for an unlimited number of revisions; defaults to '5'.
            """
            return self._set("max_history", value)

        def persistent_client(self, value: Optional[bool], /) -> Self:
            """
            PersistentClient tells the controller to use a persistent Kubernetes
            client for this release. When enabled, the client will be reused for the
            duration of the reconciliation, instead of being created and destroyed
            for each (step of a) Helm action.

            This can improve performance, but may cause issues with some Helm charts
            that for example do create Custom Resource Definitions during installation
            outside Helm's CRD lifecycle hooks, which are then not observed to be
            available by e.g. post-install hooks.

            If not set, it defaults to true.
            """
            return self._set("persistent_client", value)

        @overload
        def post_renderers(
            self, value_or_callback: List[PostRenderer], /
        ) -> "HelmReleaseSpec.Builder": ...

        @overload
        def post_renderers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PostRenderer, PostRenderer.Builder]],
                GenericListBuilder[PostRenderer, PostRenderer.Builder] | List[PostRenderer],
            ],
            /,
        ) -> "HelmReleaseSpec.Builder": ...

        @overload
        def post_renderers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PostRenderer.Builder]: ...

        def post_renderers(self, value_or_callback=None, /):
            """
            PostRenderers holds an array of Helm PostRenderers, which will be applied in order
            of their definition.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PostRenderer.Builder]()
                context._parent_builder = self
                context._field_name = "post_renderers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PostRenderer.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("post_renderers", value)

        def release_name(self, value: Optional[str], /) -> Self:
            """
            ReleaseName used for the Helm release. Defaults to a composition of
            '[TargetNamespace-]Name'.
            """
            return self._set("release_name", value)

        @overload
        def rollback(
            self, value_or_callback: Optional[Rollback], /
        ) -> "HelmReleaseSpec.Builder": ...

        @overload
        def rollback(
            self,
            value_or_callback: Callable[[Rollback.Builder], Rollback.Builder | Rollback],
            /,
        ) -> "HelmReleaseSpec.Builder": ...

        @overload
        def rollback(self, value_or_callback: Never = ...) -> "Rollback.BuilderContext": ...

        def rollback(self, value_or_callback=None, /):
            """
            Rollback holds the configuration for Helm rollback actions for this HelmRelease.
            """
            if self._in_context and value_or_callback is None:
                context = Rollback.BuilderContext()
                context._parent_builder = self
                context._field_name = "rollback"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Rollback.builder())
                if isinstance(output, Rollback.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("rollback", value)

        def service_account_name(self, value: Optional[str], /) -> Self:
            """
            The name of the Kubernetes service account to impersonate
            when reconciling this HelmRelease.
            """
            return self._set("service_account_name", value)

        def storage_namespace(self, value: Optional[str], /) -> Self:
            """
            StorageNamespace used for the Helm storage.
            Defaults to the namespace of the HelmRelease.
            """
            return self._set("storage_namespace", value)

        def suspend(self, value: Optional[bool], /) -> Self:
            """
            Suspend tells the controller to suspend reconciliation for this HelmRelease,
            it does not apply to already started reconciliations. Defaults to false.
            """
            return self._set("suspend", value)

        def target_namespace(self, value: Optional[str], /) -> Self:
            """
            TargetNamespace to target when performing operations for the HelmRelease.
            Defaults to the namespace of the HelmRelease.
            """
            return self._set("target_namespace", value)

        @overload
        def test(self, value_or_callback: Optional[Test], /) -> "HelmReleaseSpec.Builder": ...

        @overload
        def test(
            self, value_or_callback: Callable[[Test.Builder], Test.Builder | Test], /
        ) -> "HelmReleaseSpec.Builder": ...

        @overload
        def test(self, value_or_callback: Never = ...) -> "Test.BuilderContext": ...

        def test(self, value_or_callback=None, /):
            """
            Test holds the configuration for Helm test actions for this HelmRelease.
            """
            if self._in_context and value_or_callback is None:
                context = Test.BuilderContext()
                context._parent_builder = self
                context._field_name = "test"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Test.builder())
                if isinstance(output, Test.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("test", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout is the time to wait for any individual Kubernetes operation (like Jobs
            for hooks) during the performance of a Helm action. Defaults to '5m0s'.
            """
            return self._set("timeout", value)

        @overload
        def uninstall(
            self, value_or_callback: Optional[Uninstall], /
        ) -> "HelmReleaseSpec.Builder": ...

        @overload
        def uninstall(
            self,
            value_or_callback: Callable[[Uninstall.Builder], Uninstall.Builder | Uninstall],
            /,
        ) -> "HelmReleaseSpec.Builder": ...

        @overload
        def uninstall(self, value_or_callback: Never = ...) -> "Uninstall.BuilderContext": ...

        def uninstall(self, value_or_callback=None, /):
            """
            Uninstall holds the configuration for Helm uninstall actions for this HelmRelease.
            """
            if self._in_context and value_or_callback is None:
                context = Uninstall.BuilderContext()
                context._parent_builder = self
                context._field_name = "uninstall"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Uninstall.builder())
                if isinstance(output, Uninstall.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("uninstall", value)

        @overload
        def upgrade(self, value_or_callback: Optional[Upgrade], /) -> "HelmReleaseSpec.Builder": ...

        @overload
        def upgrade(
            self,
            value_or_callback: Callable[[Upgrade.Builder], Upgrade.Builder | Upgrade],
            /,
        ) -> "HelmReleaseSpec.Builder": ...

        @overload
        def upgrade(self, value_or_callback: Never = ...) -> "Upgrade.BuilderContext": ...

        def upgrade(self, value_or_callback=None, /):
            """
            Upgrade holds the configuration for Helm upgrade actions for this HelmRelease.
            """
            if self._in_context and value_or_callback is None:
                context = Upgrade.BuilderContext()
                context._parent_builder = self
                context._field_name = "upgrade"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Upgrade.builder())
                if isinstance(output, Upgrade.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("upgrade", value)

        def values(self, value: Optional[Any], /) -> Self:
            """
            Values holds the values for this Helm release.
            """
            return self._set("values", value)

        @overload
        def values_from(
            self, value_or_callback: List[ValuesFrom], /
        ) -> "HelmReleaseSpec.Builder": ...

        @overload
        def values_from(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ValuesFrom, ValuesFrom.Builder]],
                GenericListBuilder[ValuesFrom, ValuesFrom.Builder] | List[ValuesFrom],
            ],
            /,
        ) -> "HelmReleaseSpec.Builder": ...

        @overload
        def values_from(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ValuesFrom.Builder]: ...

        def values_from(self, value_or_callback=None, /):
            """
            ValuesFrom holds references to resources containing Helm values for this HelmRelease,
            and information about how they should be merged.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ValuesFrom.Builder]()
                context._parent_builder = self
                context._field_name = "values_from"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ValuesFrom.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("values_from", value)

    class BuilderContext(BuilderContextBase["HelmReleaseSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HelmReleaseSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HelmReleaseSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HelmReleaseSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmReleaseSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    chart: Optional[Chart] = None
    """
    Chart defines the template of the v1.HelmChart that should be created
    for this HelmRelease.
    """
    chart_ref: Annotated[Optional[ChartRef], Field(alias="chartRef")] = None
    """
    ChartRef holds a reference to a source controller resource containing the
    Helm chart artifact.
    """
    depends_on: Annotated[Optional[List[DependsOn]], Field(alias="dependsOn")] = None
    """
    DependsOn may contain a meta.NamespacedObjectReference slice with
    references to HelmRelease resources that must be ready before this HelmRelease
    can be reconciled.
    """
    drift_detection: Annotated[Optional[DriftDetection], Field(alias="driftDetection")] = None
    """
    DriftDetection holds the configuration for detecting and handling
    differences between the manifest in the Helm storage and the resources
    currently existing in the cluster.
    """
    install: Optional[Install] = None
    """
    Install holds the configuration for Helm install actions for this HelmRelease.
    """
    interval: Annotated[str, Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$")]
    """
    Interval at which to reconcile the Helm release.
    """
    kube_config: Annotated[Optional[KubeConfig], Field(alias="kubeConfig")] = None
    """
    KubeConfig for reconciling the HelmRelease on a remote cluster.
    When used in combination with HelmReleaseSpec.ServiceAccountName,
    forces the controller to act on behalf of that Service Account at the
    target cluster.
    If the --default-service-account flag is set, its value will be used as
    a controller level fallback for when HelmReleaseSpec.ServiceAccountName
    is empty.
    """
    max_history: Annotated[Optional[int], Field(alias="maxHistory")] = None
    """
    MaxHistory is the number of revisions saved by Helm for this HelmRelease.
    Use '0' for an unlimited number of revisions; defaults to '5'.
    """
    persistent_client: Annotated[Optional[bool], Field(alias="persistentClient")] = None
    """
    PersistentClient tells the controller to use a persistent Kubernetes
    client for this release. When enabled, the client will be reused for the
    duration of the reconciliation, instead of being created and destroyed
    for each (step of a) Helm action.

    This can improve performance, but may cause issues with some Helm charts
    that for example do create Custom Resource Definitions during installation
    outside Helm's CRD lifecycle hooks, which are then not observed to be
    available by e.g. post-install hooks.

    If not set, it defaults to true.
    """
    post_renderers: Annotated[Optional[List[PostRenderer]], Field(alias="postRenderers")] = None
    """
    PostRenderers holds an array of Helm PostRenderers, which will be applied in order
    of their definition.
    """
    release_name: Annotated[
        Optional[str], Field(alias="releaseName", max_length=53, min_length=1)
    ] = None
    """
    ReleaseName used for the Helm release. Defaults to a composition of
    '[TargetNamespace-]Name'.
    """
    rollback: Optional[Rollback] = None
    """
    Rollback holds the configuration for Helm rollback actions for this HelmRelease.
    """
    service_account_name: Annotated[
        Optional[str], Field(alias="serviceAccountName", max_length=253, min_length=1)
    ] = None
    """
    The name of the Kubernetes service account to impersonate
    when reconciling this HelmRelease.
    """
    storage_namespace: Annotated[
        Optional[str], Field(alias="storageNamespace", max_length=63, min_length=1)
    ] = None
    """
    StorageNamespace used for the Helm storage.
    Defaults to the namespace of the HelmRelease.
    """
    suspend: Optional[bool] = None
    """
    Suspend tells the controller to suspend reconciliation for this HelmRelease,
    it does not apply to already started reconciliations. Defaults to false.
    """
    target_namespace: Annotated[
        Optional[str], Field(alias="targetNamespace", max_length=63, min_length=1)
    ] = None
    """
    TargetNamespace to target when performing operations for the HelmRelease.
    Defaults to the namespace of the HelmRelease.
    """
    test: Optional[Test] = None
    """
    Test holds the configuration for Helm test actions for this HelmRelease.
    """
    timeout: Annotated[Optional[str], Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$")] = None
    """
    Timeout is the time to wait for any individual Kubernetes operation (like Jobs
    for hooks) during the performance of a Helm action. Defaults to '5m0s'.
    """
    uninstall: Optional[Uninstall] = None
    """
    Uninstall holds the configuration for Helm uninstall actions for this HelmRelease.
    """
    upgrade: Optional[Upgrade] = None
    """
    Upgrade holds the configuration for Helm upgrade actions for this HelmRelease.
    """
    values: Optional[Any] = None
    """
    Values holds the values for this Helm release.
    """
    values_from: Annotated[Optional[List[ValuesFrom]], Field(alias="valuesFrom")] = None
    """
    ValuesFrom holds references to resources containing Helm values for this HelmRelease,
    and information about how they should be merged.
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: datetime, /) -> Self:
            """
            lastTransitionTime is the last time the condition transitioned from one status to another.
            This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
            """
            return self._set("last_transition_time", value)

        def message(self, value: str, /) -> Self:
            """
            message is a human readable message indicating details about the transition.
            This may be an empty string.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            observedGeneration represents the .metadata.generation that the condition was set based upon.
            For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
            with respect to the current state of the instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: str, /) -> Self:
            """
            reason contains a programmatic identifier indicating the reason for the condition's last transition.
            Producers of specific condition types may define expected values and meanings for this field,
            and whether the values are considered a guaranteed API.
            The value should be a CamelCase string.
            This field may not be empty.
            """
            return self._set("reason", value)

        def status(self, value: Literal["True", "False", "Unknown"], /) -> Self:
            """
            status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            type of condition in CamelCase or in foo.example.com/CamelCase.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[datetime, Field(alias="lastTransitionTime")]
    """
    lastTransitionTime is the last time the condition transitioned from one status to another.
    This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    """
    message: Annotated[str, Field(max_length=32768)]
    """
    message is a human readable message indicating details about the transition.
    This may be an empty string.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration", ge=0)] = None
    """
    observedGeneration represents the .metadata.generation that the condition was set based upon.
    For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
    with respect to the current state of the instance.
    """
    reason: Annotated[
        str,
        Field(
            max_length=1024,
            min_length=1,
            pattern="^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$",
        ),
    ]
    """
    reason contains a programmatic identifier indicating the reason for the condition's last transition.
    Producers of specific condition types may define expected values and meanings for this field,
    and whether the values are considered a guaranteed API.
    The value should be a CamelCase string.
    This field may not be empty.
    """
    status: Literal["True", "False", "Unknown"]
    """
    status of the condition, one of True, False, Unknown.
    """
    type: Annotated[
        str,
        Field(
            max_length=316,
            pattern="^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$",
        ),
    ]
    """
    type of condition in CamelCase or in foo.example.com/CamelCase.
    """


class TestHooks(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TestHooks"]:
            return TestHooks

        def build(self) -> "TestHooks":
            return TestHooks(**self._attrs)

        def last_completed(self, value: Optional[datetime], /) -> Self:
            """
            LastCompleted is the time the test hook last completed.
            """
            return self._set("last_completed", value)

        def last_started(self, value: Optional[datetime], /) -> Self:
            """
            LastStarted is the time the test hook was last started.
            """
            return self._set("last_started", value)

        def phase(self, value: Optional[str], /) -> Self:
            """
            Phase the test hook was observed to be in.
            """
            return self._set("phase", value)

    class BuilderContext(BuilderContextBase["TestHooks.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TestHooks.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TestHooks."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TestHooks", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TestHooks.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_completed: Annotated[Optional[datetime], Field(alias="lastCompleted")] = None
    """
    LastCompleted is the time the test hook last completed.
    """
    last_started: Annotated[Optional[datetime], Field(alias="lastStarted")] = None
    """
    LastStarted is the time the test hook was last started.
    """
    phase: Optional[str] = None
    """
    Phase the test hook was observed to be in.
    """


class History(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["History"]:
            return History

        def build(self) -> "History":
            return History(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion is the API version of the Snapshot.
            Provisional: when the calculation method of the Digest field is changed,
            this field will be used to distinguish between the old and new methods.
            """
            return self._set("api_version", value)

        def app_version(self, value: Optional[str], /) -> Self:
            """
            AppVersion is the chart app version of the release object in storage.
            """
            return self._set("app_version", value)

        def chart_name(self, value: str, /) -> Self:
            """
            ChartName is the chart name of the release object in storage.
            """
            return self._set("chart_name", value)

        def chart_version(self, value: str, /) -> Self:
            """
            ChartVersion is the chart version of the release object in
            storage.
            """
            return self._set("chart_version", value)

        def config_digest(self, value: str, /) -> Self:
            """
            ConfigDigest is the checksum of the config (better known as
            "values") of the release object in storage.
            It has the format of `<algo>:<checksum>`.
            """
            return self._set("config_digest", value)

        def deleted(self, value: Optional[datetime], /) -> Self:
            """
            Deleted is when the release was deleted.
            """
            return self._set("deleted", value)

        def digest(self, value: str, /) -> Self:
            """
            Digest is the checksum of the release object in storage.
            It has the format of `<algo>:<checksum>`.
            """
            return self._set("digest", value)

        def first_deployed(self, value: datetime, /) -> Self:
            """
            FirstDeployed is when the release was first deployed.
            """
            return self._set("first_deployed", value)

        def last_deployed(self, value: datetime, /) -> Self:
            """
            LastDeployed is when the release was last deployed.
            """
            return self._set("last_deployed", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of the release.
            """
            return self._set("name", value)

        def namespace(self, value: str, /) -> Self:
            """
            Namespace is the namespace the release is deployed to.
            """
            return self._set("namespace", value)

        def oci_digest(self, value: Optional[str], /) -> Self:
            """
            OCIDigest is the digest of the OCI artifact associated with the release.
            """
            return self._set("oci_digest", value)

        def status(self, value: str, /) -> Self:
            """
            Status is the current state of the release.
            """
            return self._set("status", value)

        def test_hooks(self, value: Optional[Dict[str, TestHooks]], /) -> Self:
            """
            TestHooks is the list of test hooks for the release as observed to be
            run by the controller.
            """
            return self._set("test_hooks", value)

        def version(self, value: int, /) -> Self:
            """
            Version is the version of the release object in storage.
            """
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["History.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = History.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for History."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["History", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use History.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion is the API version of the Snapshot.
    Provisional: when the calculation method of the Digest field is changed,
    this field will be used to distinguish between the old and new methods.
    """
    app_version: Annotated[Optional[str], Field(alias="appVersion")] = None
    """
    AppVersion is the chart app version of the release object in storage.
    """
    chart_name: Annotated[str, Field(alias="chartName")]
    """
    ChartName is the chart name of the release object in storage.
    """
    chart_version: Annotated[str, Field(alias="chartVersion")]
    """
    ChartVersion is the chart version of the release object in
    storage.
    """
    config_digest: Annotated[str, Field(alias="configDigest")]
    """
    ConfigDigest is the checksum of the config (better known as
    "values") of the release object in storage.
    It has the format of `<algo>:<checksum>`.
    """
    deleted: Optional[datetime] = None
    """
    Deleted is when the release was deleted.
    """
    digest: str
    """
    Digest is the checksum of the release object in storage.
    It has the format of `<algo>:<checksum>`.
    """
    first_deployed: Annotated[datetime, Field(alias="firstDeployed")]
    """
    FirstDeployed is when the release was first deployed.
    """
    last_deployed: Annotated[datetime, Field(alias="lastDeployed")]
    """
    LastDeployed is when the release was last deployed.
    """
    name: str
    """
    Name is the name of the release.
    """
    namespace: str
    """
    Namespace is the namespace the release is deployed to.
    """
    oci_digest: Annotated[Optional[str], Field(alias="ociDigest")] = None
    """
    OCIDigest is the digest of the OCI artifact associated with the release.
    """
    status: str
    """
    Status is the current state of the release.
    """
    test_hooks: Annotated[Optional[Dict[str, TestHooks]], Field(alias="testHooks")] = None
    """
    TestHooks is the list of test hooks for the release as observed to be
    run by the controller.
    """
    version: int
    """
    Version is the version of the release object in storage.
    """


class HelmReleaseStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HelmReleaseStatus"]:
            return HelmReleaseStatus

        def build(self) -> "HelmReleaseStatus":
            return HelmReleaseStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "HelmReleaseStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "HelmReleaseStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions holds the conditions for the HelmRelease.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def failures(self, value: Optional[int], /) -> Self:
            """
            Failures is the reconciliation failure count against the latest desired
            state. It is reset after a successful reconciliation.
            """
            return self._set("failures", value)

        def helm_chart(self, value: Optional[str], /) -> Self:
            """
            HelmChart is the namespaced name of the HelmChart resource created by
            the controller for the HelmRelease.
            """
            return self._set("helm_chart", value)

        @overload
        def history(self, value_or_callback: List[History], /) -> "HelmReleaseStatus.Builder": ...

        @overload
        def history(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[History, History.Builder]],
                GenericListBuilder[History, History.Builder] | List[History],
            ],
            /,
        ) -> "HelmReleaseStatus.Builder": ...

        @overload
        def history(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[History.Builder]: ...

        def history(self, value_or_callback=None, /):
            """
            History holds the history of Helm releases performed for this HelmRelease
            up to the last successfully completed release.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[History.Builder]()
                context._parent_builder = self
                context._field_name = "history"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(History.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("history", value)

        def install_failures(self, value: Optional[int], /) -> Self:
            """
            InstallFailures is the install failure count against the latest desired
            state. It is reset after a successful reconciliation.
            """
            return self._set("install_failures", value)

        def last_attempted_config_digest(self, value: Optional[str], /) -> Self:
            """
            LastAttemptedConfigDigest is the digest for the config (better known as
            "values") of the last reconciliation attempt.
            """
            return self._set("last_attempted_config_digest", value)

        def last_attempted_generation(self, value: Optional[int], /) -> Self:
            """
            LastAttemptedGeneration is the last generation the controller attempted
            to reconcile.
            """
            return self._set("last_attempted_generation", value)

        def last_attempted_release_action(
            self, value: Optional[Literal["install", "upgrade"]], /
        ) -> Self:
            """
            LastAttemptedReleaseAction is the last release action performed for this
            HelmRelease. It is used to determine the active remediation strategy.
            """
            return self._set("last_attempted_release_action", value)

        def last_attempted_revision(self, value: Optional[str], /) -> Self:
            """
            LastAttemptedRevision is the Source revision of the last reconciliation
            attempt. For OCIRepository  sources, the 12 first characters of the digest are
            appended to the chart version e.g. "1.2.3+1234567890ab".
            """
            return self._set("last_attempted_revision", value)

        def last_attempted_revision_digest(self, value: Optional[str], /) -> Self:
            """
            LastAttemptedRevisionDigest is the digest of the last reconciliation attempt.
            This is only set for OCIRepository sources.
            """
            return self._set("last_attempted_revision_digest", value)

        def last_attempted_values_checksum(self, value: Optional[str], /) -> Self:
            """
            LastAttemptedValuesChecksum is the SHA1 checksum for the values of the last
            reconciliation attempt.
            Deprecated: Use LastAttemptedConfigDigest instead.
            """
            return self._set("last_attempted_values_checksum", value)

        def last_handled_force_at(self, value: Optional[str], /) -> Self:
            """
            LastHandledForceAt holds the value of the most recent force request
            value, so a change of the annotation value can be detected.
            """
            return self._set("last_handled_force_at", value)

        def last_handled_reconcile_at(self, value: Optional[str], /) -> Self:
            """
            LastHandledReconcileAt holds the value of the most recent
            reconcile request value, so a change of the annotation value
            can be detected.
            """
            return self._set("last_handled_reconcile_at", value)

        def last_handled_reset_at(self, value: Optional[str], /) -> Self:
            """
            LastHandledResetAt holds the value of the most recent reset request
            value, so a change of the annotation value can be detected.
            """
            return self._set("last_handled_reset_at", value)

        def last_release_revision(self, value: Optional[int], /) -> Self:
            """
            LastReleaseRevision is the revision of the last successful Helm release.
            Deprecated: Use History instead.
            """
            return self._set("last_release_revision", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the last observed generation.
            """
            return self._set("observed_generation", value)

        def observed_post_renderers_digest(self, value: Optional[str], /) -> Self:
            """
            ObservedPostRenderersDigest is the digest for the post-renderers of
            the last successful reconciliation attempt.
            """
            return self._set("observed_post_renderers_digest", value)

        def storage_namespace(self, value: Optional[str], /) -> Self:
            """
            StorageNamespace is the namespace of the Helm release storage for the
            current release.
            """
            return self._set("storage_namespace", value)

        def upgrade_failures(self, value: Optional[int], /) -> Self:
            """
            UpgradeFailures is the upgrade failure count against the latest desired
            state. It is reset after a successful reconciliation.
            """
            return self._set("upgrade_failures", value)

    class BuilderContext(BuilderContextBase["HelmReleaseStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HelmReleaseStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HelmReleaseStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HelmReleaseStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmReleaseStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    """
    Conditions holds the conditions for the HelmRelease.
    """
    failures: Optional[int] = None
    """
    Failures is the reconciliation failure count against the latest desired
    state. It is reset after a successful reconciliation.
    """
    helm_chart: Annotated[Optional[str], Field(alias="helmChart")] = None
    """
    HelmChart is the namespaced name of the HelmChart resource created by
    the controller for the HelmRelease.
    """
    history: Optional[List[History]] = None
    """
    History holds the history of Helm releases performed for this HelmRelease
    up to the last successfully completed release.
    """
    install_failures: Annotated[Optional[int], Field(alias="installFailures")] = None
    """
    InstallFailures is the install failure count against the latest desired
    state. It is reset after a successful reconciliation.
    """
    last_attempted_config_digest: Annotated[
        Optional[str], Field(alias="lastAttemptedConfigDigest")
    ] = None
    """
    LastAttemptedConfigDigest is the digest for the config (better known as
    "values") of the last reconciliation attempt.
    """
    last_attempted_generation: Annotated[Optional[int], Field(alias="lastAttemptedGeneration")] = (
        None
    )
    """
    LastAttemptedGeneration is the last generation the controller attempted
    to reconcile.
    """
    last_attempted_release_action: Annotated[
        Optional[Literal["install", "upgrade"]],
        Field(alias="lastAttemptedReleaseAction"),
    ] = None
    """
    LastAttemptedReleaseAction is the last release action performed for this
    HelmRelease. It is used to determine the active remediation strategy.
    """
    last_attempted_revision: Annotated[Optional[str], Field(alias="lastAttemptedRevision")] = None
    """
    LastAttemptedRevision is the Source revision of the last reconciliation
    attempt. For OCIRepository  sources, the 12 first characters of the digest are
    appended to the chart version e.g. "1.2.3+1234567890ab".
    """
    last_attempted_revision_digest: Annotated[
        Optional[str], Field(alias="lastAttemptedRevisionDigest")
    ] = None
    """
    LastAttemptedRevisionDigest is the digest of the last reconciliation attempt.
    This is only set for OCIRepository sources.
    """
    last_attempted_values_checksum: Annotated[
        Optional[str], Field(alias="lastAttemptedValuesChecksum")
    ] = None
    """
    LastAttemptedValuesChecksum is the SHA1 checksum for the values of the last
    reconciliation attempt.
    Deprecated: Use LastAttemptedConfigDigest instead.
    """
    last_handled_force_at: Annotated[Optional[str], Field(alias="lastHandledForceAt")] = None
    """
    LastHandledForceAt holds the value of the most recent force request
    value, so a change of the annotation value can be detected.
    """
    last_handled_reconcile_at: Annotated[Optional[str], Field(alias="lastHandledReconcileAt")] = (
        None
    )
    """
    LastHandledReconcileAt holds the value of the most recent
    reconcile request value, so a change of the annotation value
    can be detected.
    """
    last_handled_reset_at: Annotated[Optional[str], Field(alias="lastHandledResetAt")] = None
    """
    LastHandledResetAt holds the value of the most recent reset request
    value, so a change of the annotation value can be detected.
    """
    last_release_revision: Annotated[Optional[int], Field(alias="lastReleaseRevision")] = None
    """
    LastReleaseRevision is the revision of the last successful Helm release.
    Deprecated: Use History instead.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the last observed generation.
    """
    observed_post_renderers_digest: Annotated[
        Optional[str], Field(alias="observedPostRenderersDigest")
    ] = None
    """
    ObservedPostRenderersDigest is the digest for the post-renderers of
    the last successful reconciliation attempt.
    """
    storage_namespace: Annotated[
        Optional[str], Field(alias="storageNamespace", max_length=63, min_length=1)
    ] = None
    """
    StorageNamespace is the namespace of the Helm release storage for the
    current release.
    """
    upgrade_failures: Annotated[Optional[int], Field(alias="upgradeFailures")] = None
    """
    UpgradeFailures is the upgrade failure count against the latest desired
    state. It is reset after a successful reconciliation.
    """


class HelmRelease(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HelmRelease"]:
            return HelmRelease

        def build(self) -> "HelmRelease":
            return HelmRelease(**self._attrs)

        def api_version(self, value: Optional[Literal["helm.toolkit.fluxcd.io/v2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["HelmRelease"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "HelmRelease.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "HelmRelease.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[HelmReleaseSpec], /
        ) -> "HelmRelease.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [HelmReleaseSpec.Builder], HelmReleaseSpec.Builder | HelmReleaseSpec
            ],
            /,
        ) -> "HelmRelease.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "HelmReleaseSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = HelmReleaseSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HelmReleaseSpec.builder())
                if isinstance(output, HelmReleaseSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[HelmReleaseStatus], /
        ) -> "HelmRelease.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [HelmReleaseStatus.Builder],
                HelmReleaseStatus.Builder | HelmReleaseStatus,
            ],
            /,
        ) -> "HelmRelease.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "HelmReleaseStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = HelmReleaseStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HelmReleaseStatus.builder())
                if isinstance(output, HelmReleaseStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["HelmRelease.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HelmRelease.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HelmRelease."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HelmRelease", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmRelease.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["helm.toolkit.fluxcd.io/v2"]], Field(alias="apiVersion")
    ] = "helm.toolkit.fluxcd.io/v2"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["HelmRelease"]] = "HelmRelease"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[HelmReleaseSpec] = None
    status: Optional[HelmReleaseStatus] = None
