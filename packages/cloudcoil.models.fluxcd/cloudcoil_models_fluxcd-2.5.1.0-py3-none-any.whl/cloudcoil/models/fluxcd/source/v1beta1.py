# Generated by cloudcoil-model-codegen v0.5.6
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import (
    Annotated,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class NamespaceSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NamespaceSelector"]:
            return NamespaceSelector

        def build(self) -> "NamespaceSelector":
            return NamespaceSelector(**self._attrs)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["NamespaceSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NamespaceSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NamespaceSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NamespaceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamespaceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class AccessFrom(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AccessFrom"]:
            return AccessFrom

        def build(self) -> "AccessFrom":
            return AccessFrom(**self._attrs)

        @overload
        def namespace_selectors(
            self, value_or_callback: List[NamespaceSelector], /
        ) -> "AccessFrom.Builder": ...

        @overload
        def namespace_selectors(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[NamespaceSelector, NamespaceSelector.Builder]],
                GenericListBuilder[NamespaceSelector, NamespaceSelector.Builder]
                | List[NamespaceSelector],
            ],
            /,
        ) -> "AccessFrom.Builder": ...

        @overload
        def namespace_selectors(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[NamespaceSelector.Builder]: ...

        def namespace_selectors(self, value_or_callback=None, /):
            """
            NamespaceSelectors is the list of namespace selectors to which this ACL applies.
            Items in this list are evaluated using a logical OR operation.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[NamespaceSelector.Builder]()
                context._parent_builder = self
                context._field_name = "namespace_selectors"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamespaceSelector.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("namespace_selectors", value)

    class BuilderContext(BuilderContextBase["AccessFrom.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AccessFrom.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AccessFrom."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AccessFrom", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AccessFrom.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    namespace_selectors: Annotated[List[NamespaceSelector], Field(alias="namespaceSelectors")]
    """
    NamespaceSelectors is the list of namespace selectors to which this ACL applies.
    Items in this list are evaluated using a logical OR operation.
    """


class SecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretRef"]:
            return SecretRef

        def build(self) -> "SecretRef":
            return SecretRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["SecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referent.
    """


class BucketSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BucketSpec"]:
            return BucketSpec

        def build(self) -> "BucketSpec":
            return BucketSpec(**self._attrs)

        @overload
        def access_from(
            self, value_or_callback: Optional[AccessFrom], /
        ) -> "BucketSpec.Builder": ...

        @overload
        def access_from(
            self,
            value_or_callback: Callable[[AccessFrom.Builder], AccessFrom.Builder | AccessFrom],
            /,
        ) -> "BucketSpec.Builder": ...

        @overload
        def access_from(self, value_or_callback: Never = ...) -> "AccessFrom.BuilderContext": ...

        def access_from(self, value_or_callback=None, /):
            """
            AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
            """
            if self._in_context and value_or_callback is None:
                context = AccessFrom.BuilderContext()
                context._parent_builder = self
                context._field_name = "access_from"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AccessFrom.builder())
                if isinstance(output, AccessFrom.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("access_from", value)

        def bucket_name(self, value: str, /) -> Self:
            """
            The bucket name.
            """
            return self._set("bucket_name", value)

        def endpoint(self, value: str, /) -> Self:
            """
            The bucket endpoint address.
            """
            return self._set("endpoint", value)

        def ignore(self, value: Optional[str], /) -> Self:
            """
            Ignore overrides the set of excluded patterns in the .sourceignore format
            (which is the same as .gitignore). If not provided, a default will be used,
            consult the documentation for your version to find out what those are.
            """
            return self._set("ignore", value)

        def insecure(self, value: Optional[bool], /) -> Self:
            """
            Insecure allows connecting to a non-TLS S3 HTTP endpoint.
            """
            return self._set("insecure", value)

        def interval(self, value: str, /) -> Self:
            """
            The interval at which to check for bucket updates.
            """
            return self._set("interval", value)

        def provider(self, value: Optional[Literal["generic", "aws", "gcp"]], /) -> Self:
            """
            The S3 compatible storage provider name, default ('generic').
            """
            return self._set("provider", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The bucket region.
            """
            return self._set("region", value)

        @overload
        def secret_ref(self, value_or_callback: Optional[SecretRef], /) -> "BucketSpec.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "BucketSpec.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            The name of the secret containing authentication credentials
            for the Bucket.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def suspend(self, value: Optional[bool], /) -> Self:
            """
            This flag tells the controller to suspend the reconciliation of this source.
            """
            return self._set("suspend", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            The timeout for download operations, defaults to 60s.
            """
            return self._set("timeout", value)

    class BuilderContext(BuilderContextBase["BucketSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BucketSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BucketSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BucketSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BucketSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_from: Annotated[Optional[AccessFrom], Field(alias="accessFrom")] = None
    """
    AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
    """
    bucket_name: Annotated[str, Field(alias="bucketName")]
    """
    The bucket name.
    """
    endpoint: str
    """
    The bucket endpoint address.
    """
    ignore: Optional[str] = None
    """
    Ignore overrides the set of excluded patterns in the .sourceignore format
    (which is the same as .gitignore). If not provided, a default will be used,
    consult the documentation for your version to find out what those are.
    """
    insecure: Optional[bool] = None
    """
    Insecure allows connecting to a non-TLS S3 HTTP endpoint.
    """
    interval: str
    """
    The interval at which to check for bucket updates.
    """
    provider: Optional[Literal["generic", "aws", "gcp"]] = "generic"
    """
    The S3 compatible storage provider name, default ('generic').
    """
    region: Optional[str] = None
    """
    The bucket region.
    """
    secret_ref: Annotated[Optional[SecretRef], Field(alias="secretRef")] = None
    """
    The name of the secret containing authentication credentials
    for the Bucket.
    """
    suspend: Optional[bool] = None
    """
    This flag tells the controller to suspend the reconciliation of this source.
    """
    timeout: Optional[str] = "60s"
    """
    The timeout for download operations, defaults to 60s.
    """


class Artifact(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Artifact"]:
            return Artifact

        def build(self) -> "Artifact":
            return Artifact(**self._attrs)

        def checksum(self, value: Optional[str], /) -> Self:
            """
            Checksum is the SHA256 checksum of the artifact.
            """
            return self._set("checksum", value)

        def last_update_time(self, value: datetime, /) -> Self:
            """
            LastUpdateTime is the timestamp corresponding to the last update of this
            artifact.
            """
            return self._set("last_update_time", value)

        def path(self, value: str, /) -> Self:
            """
            Path is the relative file path of this artifact.
            """
            return self._set("path", value)

        def revision(self, value: Optional[str], /) -> Self:
            """
            Revision is a human readable identifier traceable in the origin source
            system. It can be a Git commit SHA, Git tag, a Helm index timestamp, a Helm
            chart version, etc.
            """
            return self._set("revision", value)

        def url(self, value: str, /) -> Self:
            """
            URL is the HTTP address of this artifact.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["Artifact.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Artifact.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Artifact."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Artifact", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Artifact.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    checksum: Optional[str] = None
    """
    Checksum is the SHA256 checksum of the artifact.
    """
    last_update_time: Annotated[datetime, Field(alias="lastUpdateTime")]
    """
    LastUpdateTime is the timestamp corresponding to the last update of this
    artifact.
    """
    path: str
    """
    Path is the relative file path of this artifact.
    """
    revision: Optional[str] = None
    """
    Revision is a human readable identifier traceable in the origin source
    system. It can be a Git commit SHA, Git tag, a Helm index timestamp, a Helm
    chart version, etc.
    """
    url: str
    """
    URL is the HTTP address of this artifact.
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: datetime, /) -> Self:
            """
            lastTransitionTime is the last time the condition transitioned from one status to another.
            This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
            """
            return self._set("last_transition_time", value)

        def message(self, value: str, /) -> Self:
            """
            message is a human readable message indicating details about the transition.
            This may be an empty string.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            observedGeneration represents the .metadata.generation that the condition was set based upon.
            For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
            with respect to the current state of the instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: str, /) -> Self:
            """
            reason contains a programmatic identifier indicating the reason for the condition's last transition.
            Producers of specific condition types may define expected values and meanings for this field,
            and whether the values are considered a guaranteed API.
            The value should be a CamelCase string.
            This field may not be empty.
            """
            return self._set("reason", value)

        def status(self, value: Literal["True", "False", "Unknown"], /) -> Self:
            """
            status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            type of condition in CamelCase or in foo.example.com/CamelCase.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[datetime, Field(alias="lastTransitionTime")]
    """
    lastTransitionTime is the last time the condition transitioned from one status to another.
    This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    """
    message: Annotated[str, Field(max_length=32768)]
    """
    message is a human readable message indicating details about the transition.
    This may be an empty string.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration", ge=0)] = None
    """
    observedGeneration represents the .metadata.generation that the condition was set based upon.
    For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
    with respect to the current state of the instance.
    """
    reason: Annotated[
        str,
        Field(
            max_length=1024,
            min_length=1,
            pattern="^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$",
        ),
    ]
    """
    reason contains a programmatic identifier indicating the reason for the condition's last transition.
    Producers of specific condition types may define expected values and meanings for this field,
    and whether the values are considered a guaranteed API.
    The value should be a CamelCase string.
    This field may not be empty.
    """
    status: Literal["True", "False", "Unknown"]
    """
    status of the condition, one of True, False, Unknown.
    """
    type: Annotated[
        str,
        Field(
            max_length=316,
            pattern="^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$",
        ),
    ]
    """
    type of condition in CamelCase or in foo.example.com/CamelCase.
    """


class BucketStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BucketStatus"]:
            return BucketStatus

        def build(self) -> "BucketStatus":
            return BucketStatus(**self._attrs)

        @overload
        def artifact(self, value_or_callback: Optional[Artifact], /) -> "BucketStatus.Builder": ...

        @overload
        def artifact(
            self,
            value_or_callback: Callable[[Artifact.Builder], Artifact.Builder | Artifact],
            /,
        ) -> "BucketStatus.Builder": ...

        @overload
        def artifact(self, value_or_callback: Never = ...) -> "Artifact.BuilderContext": ...

        def artifact(self, value_or_callback=None, /):
            """
            Artifact represents the output of the last successful Bucket sync.
            """
            if self._in_context and value_or_callback is None:
                context = Artifact.BuilderContext()
                context._parent_builder = self
                context._field_name = "artifact"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Artifact.builder())
                if isinstance(output, Artifact.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("artifact", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "BucketStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "BucketStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions holds the conditions for the Bucket.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def last_handled_reconcile_at(self, value: Optional[str], /) -> Self:
            """
            LastHandledReconcileAt holds the value of the most recent
            reconcile request value, so a change of the annotation value
            can be detected.
            """
            return self._set("last_handled_reconcile_at", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the last observed generation.
            """
            return self._set("observed_generation", value)

        def url(self, value: Optional[str], /) -> Self:
            """
            URL is the download link for the artifact output of the last Bucket sync.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["BucketStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BucketStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BucketStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BucketStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BucketStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    artifact: Optional[Artifact] = None
    """
    Artifact represents the output of the last successful Bucket sync.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions holds the conditions for the Bucket.
    """
    last_handled_reconcile_at: Annotated[Optional[str], Field(alias="lastHandledReconcileAt")] = (
        None
    )
    """
    LastHandledReconcileAt holds the value of the most recent
    reconcile request value, so a change of the annotation value
    can be detected.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the last observed generation.
    """
    url: Optional[str] = None
    """
    URL is the download link for the artifact output of the last Bucket sync.
    """


class Repository(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Repository"]:
            return Repository

        def build(self) -> "Repository":
            return Repository(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["Repository.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Repository.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Repository."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Repository", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Repository.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referent.
    """


class Include(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Include"]:
            return Include

        def build(self) -> "Include":
            return Include(**self._attrs)

        def from_path(self, value: Optional[str], /) -> Self:
            """
            The path to copy contents from, defaults to the root directory.
            """
            return self._set("from_path", value)

        @overload
        def repository(self, value_or_callback: Repository, /) -> "Include.Builder": ...

        @overload
        def repository(
            self,
            value_or_callback: Callable[[Repository.Builder], Repository.Builder | Repository],
            /,
        ) -> "Include.Builder": ...

        @overload
        def repository(self, value_or_callback: Never = ...) -> "Repository.BuilderContext": ...

        def repository(self, value_or_callback=None, /):
            """
            Reference to a GitRepository to include.
            """
            if self._in_context and value_or_callback is None:
                context = Repository.BuilderContext()
                context._parent_builder = self
                context._field_name = "repository"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Repository.builder())
                if isinstance(output, Repository.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("repository", value)

        def to_path(self, value: Optional[str], /) -> Self:
            """
            The path to copy contents to, defaults to the name of the source ref.
            """
            return self._set("to_path", value)

    class BuilderContext(BuilderContextBase["Include.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Include.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Include."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Include", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Include.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    from_path: Annotated[Optional[str], Field(alias="fromPath")] = None
    """
    The path to copy contents from, defaults to the root directory.
    """
    repository: Repository
    """
    Reference to a GitRepository to include.
    """
    to_path: Annotated[Optional[str], Field(alias="toPath")] = None
    """
    The path to copy contents to, defaults to the name of the source ref.
    """


class Ref(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ref"]:
            return Ref

        def build(self) -> "Ref":
            return Ref(**self._attrs)

        def branch(self, value: Optional[str], /) -> Self:
            """
            The Git branch to checkout, defaults to master.
            """
            return self._set("branch", value)

        def commit(self, value: Optional[str], /) -> Self:
            """
            The Git commit SHA to checkout, if specified Tag filters will be ignored.
            """
            return self._set("commit", value)

        def semver(self, value: Optional[str], /) -> Self:
            """
            The Git tag semver expression, takes precedence over Tag.
            """
            return self._set("semver", value)

        def tag(self, value: Optional[str], /) -> Self:
            """
            The Git tag to checkout, takes precedence over Branch.
            """
            return self._set("tag", value)

    class BuilderContext(BuilderContextBase["Ref.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ref.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ref."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ref", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ref.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    branch: Optional[str] = None
    """
    The Git branch to checkout, defaults to master.
    """
    commit: Optional[str] = None
    """
    The Git commit SHA to checkout, if specified Tag filters will be ignored.
    """
    semver: Optional[str] = None
    """
    The Git tag semver expression, takes precedence over Tag.
    """
    tag: Optional[str] = None
    """
    The Git tag to checkout, takes precedence over Branch.
    """


class Verify(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Verify"]:
            return Verify

        def build(self) -> "Verify":
            return Verify(**self._attrs)

        def mode(self, value: Literal["head"], /) -> Self:
            """
            Mode describes what git object should be verified, currently ('head').
            """
            return self._set("mode", value)

        @overload
        def secret_ref(self, value_or_callback: Optional[SecretRef], /) -> "Verify.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "Verify.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            The secret name containing the public keys of all trusted Git authors.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

    class BuilderContext(BuilderContextBase["Verify.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Verify.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Verify."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Verify", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Verify.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    mode: Literal["head"]
    """
    Mode describes what git object should be verified, currently ('head').
    """
    secret_ref: Annotated[Optional[SecretRef], Field(alias="secretRef")] = None
    """
    The secret name containing the public keys of all trusted Git authors.
    """


class GitRepositorySpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GitRepositorySpec"]:
            return GitRepositorySpec

        def build(self) -> "GitRepositorySpec":
            return GitRepositorySpec(**self._attrs)

        @overload
        def access_from(
            self, value_or_callback: Optional[AccessFrom], /
        ) -> "GitRepositorySpec.Builder": ...

        @overload
        def access_from(
            self,
            value_or_callback: Callable[[AccessFrom.Builder], AccessFrom.Builder | AccessFrom],
            /,
        ) -> "GitRepositorySpec.Builder": ...

        @overload
        def access_from(self, value_or_callback: Never = ...) -> "AccessFrom.BuilderContext": ...

        def access_from(self, value_or_callback=None, /):
            """
            AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
            """
            if self._in_context and value_or_callback is None:
                context = AccessFrom.BuilderContext()
                context._parent_builder = self
                context._field_name = "access_from"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AccessFrom.builder())
                if isinstance(output, AccessFrom.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("access_from", value)

        def git_implementation(self, value: Optional[Literal["go-git", "libgit2"]], /) -> Self:
            """
            Determines which git client library to use.
            Defaults to go-git, valid values are ('go-git', 'libgit2').
            """
            return self._set("git_implementation", value)

        def ignore(self, value: Optional[str], /) -> Self:
            """
            Ignore overrides the set of excluded patterns in the .sourceignore format
            (which is the same as .gitignore). If not provided, a default will be used,
            consult the documentation for your version to find out what those are.
            """
            return self._set("ignore", value)

        @overload
        def include(self, value_or_callback: List[Include], /) -> "GitRepositorySpec.Builder": ...

        @overload
        def include(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Include, Include.Builder]],
                GenericListBuilder[Include, Include.Builder] | List[Include],
            ],
            /,
        ) -> "GitRepositorySpec.Builder": ...

        @overload
        def include(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Include.Builder]: ...

        def include(self, value_or_callback=None, /):
            """
            Extra git repositories to map into the repository
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Include.Builder]()
                context._parent_builder = self
                context._field_name = "include"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Include.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("include", value)

        def interval(self, value: str, /) -> Self:
            """
            The interval at which to check for repository updates.
            """
            return self._set("interval", value)

        def recurse_submodules(self, value: Optional[bool], /) -> Self:
            """
            When enabled, after the clone is created, initializes all submodules within,
            using their default settings.
            This option is available only when using the 'go-git' GitImplementation.
            """
            return self._set("recurse_submodules", value)

        @overload
        def ref(self, value_or_callback: Optional[Ref], /) -> "GitRepositorySpec.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "GitRepositorySpec.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            The Git reference to checkout and monitor for changes, defaults to
            master branch.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        @overload
        def secret_ref(
            self, value_or_callback: Optional[SecretRef], /
        ) -> "GitRepositorySpec.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "GitRepositorySpec.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            The secret name containing the Git credentials.
            For HTTPS repositories the secret must contain username and password
            fields.
            For SSH repositories the secret must contain identity and known_hosts
            fields.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def suspend(self, value: Optional[bool], /) -> Self:
            """
            This flag tells the controller to suspend the reconciliation of this source.
            """
            return self._set("suspend", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            The timeout for remote Git operations like cloning, defaults to 60s.
            """
            return self._set("timeout", value)

        def url(self, value: str, /) -> Self:
            """
            The repository URL, can be a HTTP/S or SSH address.
            """
            return self._set("url", value)

        @overload
        def verify(self, value_or_callback: Optional[Verify], /) -> "GitRepositorySpec.Builder": ...

        @overload
        def verify(
            self,
            value_or_callback: Callable[[Verify.Builder], Verify.Builder | Verify],
            /,
        ) -> "GitRepositorySpec.Builder": ...

        @overload
        def verify(self, value_or_callback: Never = ...) -> "Verify.BuilderContext": ...

        def verify(self, value_or_callback=None, /):
            """
            Verify OpenPGP signature for the Git commit HEAD points to.
            """
            if self._in_context and value_or_callback is None:
                context = Verify.BuilderContext()
                context._parent_builder = self
                context._field_name = "verify"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Verify.builder())
                if isinstance(output, Verify.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("verify", value)

    class BuilderContext(BuilderContextBase["GitRepositorySpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GitRepositorySpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GitRepositorySpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GitRepositorySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GitRepositorySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_from: Annotated[Optional[AccessFrom], Field(alias="accessFrom")] = None
    """
    AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
    """
    git_implementation: Annotated[
        Optional[Literal["go-git", "libgit2"]], Field(alias="gitImplementation")
    ] = "go-git"
    """
    Determines which git client library to use.
    Defaults to go-git, valid values are ('go-git', 'libgit2').
    """
    ignore: Optional[str] = None
    """
    Ignore overrides the set of excluded patterns in the .sourceignore format
    (which is the same as .gitignore). If not provided, a default will be used,
    consult the documentation for your version to find out what those are.
    """
    include: Optional[List[Include]] = None
    """
    Extra git repositories to map into the repository
    """
    interval: str
    """
    The interval at which to check for repository updates.
    """
    recurse_submodules: Annotated[Optional[bool], Field(alias="recurseSubmodules")] = None
    """
    When enabled, after the clone is created, initializes all submodules within,
    using their default settings.
    This option is available only when using the 'go-git' GitImplementation.
    """
    ref: Optional[Ref] = None
    """
    The Git reference to checkout and monitor for changes, defaults to
    master branch.
    """
    secret_ref: Annotated[Optional[SecretRef], Field(alias="secretRef")] = None
    """
    The secret name containing the Git credentials.
    For HTTPS repositories the secret must contain username and password
    fields.
    For SSH repositories the secret must contain identity and known_hosts
    fields.
    """
    suspend: Optional[bool] = None
    """
    This flag tells the controller to suspend the reconciliation of this source.
    """
    timeout: Optional[str] = "60s"
    """
    The timeout for remote Git operations like cloning, defaults to 60s.
    """
    url: Annotated[str, Field(pattern="^(http|https|ssh)://.*$")]
    """
    The repository URL, can be a HTTP/S or SSH address.
    """
    verify: Optional[Verify] = None
    """
    Verify OpenPGP signature for the Git commit HEAD points to.
    """


class IncludedArtifact(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IncludedArtifact"]:
            return IncludedArtifact

        def build(self) -> "IncludedArtifact":
            return IncludedArtifact(**self._attrs)

        def checksum(self, value: Optional[str], /) -> Self:
            """
            Checksum is the SHA256 checksum of the artifact.
            """
            return self._set("checksum", value)

        def last_update_time(self, value: datetime, /) -> Self:
            """
            LastUpdateTime is the timestamp corresponding to the last update of this
            artifact.
            """
            return self._set("last_update_time", value)

        def path(self, value: str, /) -> Self:
            """
            Path is the relative file path of this artifact.
            """
            return self._set("path", value)

        def revision(self, value: Optional[str], /) -> Self:
            """
            Revision is a human readable identifier traceable in the origin source
            system. It can be a Git commit SHA, Git tag, a Helm index timestamp, a Helm
            chart version, etc.
            """
            return self._set("revision", value)

        def url(self, value: str, /) -> Self:
            """
            URL is the HTTP address of this artifact.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["IncludedArtifact.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IncludedArtifact.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IncludedArtifact."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IncludedArtifact", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IncludedArtifact.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    checksum: Optional[str] = None
    """
    Checksum is the SHA256 checksum of the artifact.
    """
    last_update_time: Annotated[datetime, Field(alias="lastUpdateTime")]
    """
    LastUpdateTime is the timestamp corresponding to the last update of this
    artifact.
    """
    path: str
    """
    Path is the relative file path of this artifact.
    """
    revision: Optional[str] = None
    """
    Revision is a human readable identifier traceable in the origin source
    system. It can be a Git commit SHA, Git tag, a Helm index timestamp, a Helm
    chart version, etc.
    """
    url: str
    """
    URL is the HTTP address of this artifact.
    """


class GitRepositoryStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GitRepositoryStatus"]:
            return GitRepositoryStatus

        def build(self) -> "GitRepositoryStatus":
            return GitRepositoryStatus(**self._attrs)

        @overload
        def artifact(
            self, value_or_callback: Optional[Artifact], /
        ) -> "GitRepositoryStatus.Builder": ...

        @overload
        def artifact(
            self,
            value_or_callback: Callable[[Artifact.Builder], Artifact.Builder | Artifact],
            /,
        ) -> "GitRepositoryStatus.Builder": ...

        @overload
        def artifact(self, value_or_callback: Never = ...) -> "Artifact.BuilderContext": ...

        def artifact(self, value_or_callback=None, /):
            """
            Artifact represents the output of the last successful repository sync.
            """
            if self._in_context and value_or_callback is None:
                context = Artifact.BuilderContext()
                context._parent_builder = self
                context._field_name = "artifact"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Artifact.builder())
                if isinstance(output, Artifact.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("artifact", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "GitRepositoryStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "GitRepositoryStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions holds the conditions for the GitRepository.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        @overload
        def included_artifacts(
            self, value_or_callback: List[IncludedArtifact], /
        ) -> "GitRepositoryStatus.Builder": ...

        @overload
        def included_artifacts(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[IncludedArtifact, IncludedArtifact.Builder]],
                GenericListBuilder[IncludedArtifact, IncludedArtifact.Builder]
                | List[IncludedArtifact],
            ],
            /,
        ) -> "GitRepositoryStatus.Builder": ...

        @overload
        def included_artifacts(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[IncludedArtifact.Builder]: ...

        def included_artifacts(self, value_or_callback=None, /):
            """
            IncludedArtifacts represents the included artifacts from the last successful repository sync.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[IncludedArtifact.Builder]()
                context._parent_builder = self
                context._field_name = "included_artifacts"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IncludedArtifact.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("included_artifacts", value)

        def last_handled_reconcile_at(self, value: Optional[str], /) -> Self:
            """
            LastHandledReconcileAt holds the value of the most recent
            reconcile request value, so a change of the annotation value
            can be detected.
            """
            return self._set("last_handled_reconcile_at", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the last observed generation.
            """
            return self._set("observed_generation", value)

        def url(self, value: Optional[str], /) -> Self:
            """
            URL is the download link for the artifact output of the last repository
            sync.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["GitRepositoryStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GitRepositoryStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GitRepositoryStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GitRepositoryStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GitRepositoryStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    artifact: Optional[Artifact] = None
    """
    Artifact represents the output of the last successful repository sync.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions holds the conditions for the GitRepository.
    """
    included_artifacts: Annotated[
        Optional[List[IncludedArtifact]], Field(alias="includedArtifacts")
    ] = None
    """
    IncludedArtifacts represents the included artifacts from the last successful repository sync.
    """
    last_handled_reconcile_at: Annotated[Optional[str], Field(alias="lastHandledReconcileAt")] = (
        None
    )
    """
    LastHandledReconcileAt holds the value of the most recent
    reconcile request value, so a change of the annotation value
    can be detected.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the last observed generation.
    """
    url: Optional[str] = None
    """
    URL is the download link for the artifact output of the last repository
    sync.
    """


class SourceRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SourceRef"]:
            return SourceRef

        def build(self) -> "SourceRef":
            return SourceRef(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Literal["HelmRepository", "GitRepository", "Bucket"], /) -> Self:
            """
            Kind of the referent, valid values are ('HelmRepository', 'GitRepository',
            'Bucket').
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["SourceRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SourceRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SourceRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SourceRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SourceRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion of the referent.
    """
    kind: Literal["HelmRepository", "GitRepository", "Bucket"]
    """
    Kind of the referent, valid values are ('HelmRepository', 'GitRepository',
    'Bucket').
    """
    name: str
    """
    Name of the referent.
    """


class HelmChartSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HelmChartSpec"]:
            return HelmChartSpec

        def build(self) -> "HelmChartSpec":
            return HelmChartSpec(**self._attrs)

        @overload
        def access_from(
            self, value_or_callback: Optional[AccessFrom], /
        ) -> "HelmChartSpec.Builder": ...

        @overload
        def access_from(
            self,
            value_or_callback: Callable[[AccessFrom.Builder], AccessFrom.Builder | AccessFrom],
            /,
        ) -> "HelmChartSpec.Builder": ...

        @overload
        def access_from(self, value_or_callback: Never = ...) -> "AccessFrom.BuilderContext": ...

        def access_from(self, value_or_callback=None, /):
            """
            AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
            """
            if self._in_context and value_or_callback is None:
                context = AccessFrom.BuilderContext()
                context._parent_builder = self
                context._field_name = "access_from"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AccessFrom.builder())
                if isinstance(output, AccessFrom.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("access_from", value)

        def chart(self, value: str, /) -> Self:
            """
            The name or path the Helm chart is available at in the SourceRef.
            """
            return self._set("chart", value)

        def interval(self, value: str, /) -> Self:
            """
            The interval at which to check the Source for updates.
            """
            return self._set("interval", value)

        def reconcile_strategy(
            self, value: Optional[Literal["ChartVersion", "Revision"]], /
        ) -> Self:
            """
            Determines what enables the creation of a new artifact. Valid values are
            ('ChartVersion', 'Revision').
            See the documentation of the values for an explanation on their behavior.
            Defaults to ChartVersion when omitted.
            """
            return self._set("reconcile_strategy", value)

        @overload
        def source_ref(self, value_or_callback: SourceRef, /) -> "HelmChartSpec.Builder": ...

        @overload
        def source_ref(
            self,
            value_or_callback: Callable[[SourceRef.Builder], SourceRef.Builder | SourceRef],
            /,
        ) -> "HelmChartSpec.Builder": ...

        @overload
        def source_ref(self, value_or_callback: Never = ...) -> "SourceRef.BuilderContext": ...

        def source_ref(self, value_or_callback=None, /):
            """
            The reference to the Source the chart is available at.
            """
            if self._in_context and value_or_callback is None:
                context = SourceRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "source_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SourceRef.builder())
                if isinstance(output, SourceRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("source_ref", value)

        def suspend(self, value: Optional[bool], /) -> Self:
            """
            This flag tells the controller to suspend the reconciliation of this source.
            """
            return self._set("suspend", value)

        def values_file(self, value: Optional[str], /) -> Self:
            """
            Alternative values file to use as the default chart values, expected to
            be a relative path in the SourceRef. Deprecated in favor of ValuesFiles,
            for backwards compatibility the file defined here is merged before the
            ValuesFiles items. Ignored when omitted.
            """
            return self._set("values_file", value)

        def values_files(self, value: Optional[List[str]], /) -> Self:
            """
            Alternative list of values files to use as the chart values (values.yaml
            is not included by default), expected to be a relative path in the SourceRef.
            Values files are merged in the order of this list with the last file overriding
            the first. Ignored when omitted.
            """
            return self._set("values_files", value)

        def version(self, value: Optional[str], /) -> Self:
            """
            The chart version semver expression, ignored for charts from GitRepository
            and Bucket sources. Defaults to latest when omitted.
            """
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["HelmChartSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HelmChartSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HelmChartSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HelmChartSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmChartSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_from: Annotated[Optional[AccessFrom], Field(alias="accessFrom")] = None
    """
    AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
    """
    chart: str
    """
    The name or path the Helm chart is available at in the SourceRef.
    """
    interval: str
    """
    The interval at which to check the Source for updates.
    """
    reconcile_strategy: Annotated[
        Optional[Literal["ChartVersion", "Revision"]], Field(alias="reconcileStrategy")
    ] = "ChartVersion"
    """
    Determines what enables the creation of a new artifact. Valid values are
    ('ChartVersion', 'Revision').
    See the documentation of the values for an explanation on their behavior.
    Defaults to ChartVersion when omitted.
    """
    source_ref: Annotated[SourceRef, Field(alias="sourceRef")]
    """
    The reference to the Source the chart is available at.
    """
    suspend: Optional[bool] = None
    """
    This flag tells the controller to suspend the reconciliation of this source.
    """
    values_file: Annotated[Optional[str], Field(alias="valuesFile")] = None
    """
    Alternative values file to use as the default chart values, expected to
    be a relative path in the SourceRef. Deprecated in favor of ValuesFiles,
    for backwards compatibility the file defined here is merged before the
    ValuesFiles items. Ignored when omitted.
    """
    values_files: Annotated[Optional[List[str]], Field(alias="valuesFiles")] = None
    """
    Alternative list of values files to use as the chart values (values.yaml
    is not included by default), expected to be a relative path in the SourceRef.
    Values files are merged in the order of this list with the last file overriding
    the first. Ignored when omitted.
    """
    version: Optional[str] = "*"
    """
    The chart version semver expression, ignored for charts from GitRepository
    and Bucket sources. Defaults to latest when omitted.
    """


class HelmChartStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HelmChartStatus"]:
            return HelmChartStatus

        def build(self) -> "HelmChartStatus":
            return HelmChartStatus(**self._attrs)

        @overload
        def artifact(
            self, value_or_callback: Optional[Artifact], /
        ) -> "HelmChartStatus.Builder": ...

        @overload
        def artifact(
            self,
            value_or_callback: Callable[[Artifact.Builder], Artifact.Builder | Artifact],
            /,
        ) -> "HelmChartStatus.Builder": ...

        @overload
        def artifact(self, value_or_callback: Never = ...) -> "Artifact.BuilderContext": ...

        def artifact(self, value_or_callback=None, /):
            """
            Artifact represents the output of the last successful chart sync.
            """
            if self._in_context and value_or_callback is None:
                context = Artifact.BuilderContext()
                context._parent_builder = self
                context._field_name = "artifact"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Artifact.builder())
                if isinstance(output, Artifact.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("artifact", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "HelmChartStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "HelmChartStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions holds the conditions for the HelmChart.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def last_handled_reconcile_at(self, value: Optional[str], /) -> Self:
            """
            LastHandledReconcileAt holds the value of the most recent
            reconcile request value, so a change of the annotation value
            can be detected.
            """
            return self._set("last_handled_reconcile_at", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the last observed generation.
            """
            return self._set("observed_generation", value)

        def url(self, value: Optional[str], /) -> Self:
            """
            URL is the download link for the last chart pulled.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["HelmChartStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HelmChartStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HelmChartStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HelmChartStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmChartStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    artifact: Optional[Artifact] = None
    """
    Artifact represents the output of the last successful chart sync.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions holds the conditions for the HelmChart.
    """
    last_handled_reconcile_at: Annotated[Optional[str], Field(alias="lastHandledReconcileAt")] = (
        None
    )
    """
    LastHandledReconcileAt holds the value of the most recent
    reconcile request value, so a change of the annotation value
    can be detected.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the last observed generation.
    """
    url: Optional[str] = None
    """
    URL is the download link for the last chart pulled.
    """


class HelmRepositorySpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HelmRepositorySpec"]:
            return HelmRepositorySpec

        def build(self) -> "HelmRepositorySpec":
            return HelmRepositorySpec(**self._attrs)

        @overload
        def access_from(
            self, value_or_callback: Optional[AccessFrom], /
        ) -> "HelmRepositorySpec.Builder": ...

        @overload
        def access_from(
            self,
            value_or_callback: Callable[[AccessFrom.Builder], AccessFrom.Builder | AccessFrom],
            /,
        ) -> "HelmRepositorySpec.Builder": ...

        @overload
        def access_from(self, value_or_callback: Never = ...) -> "AccessFrom.BuilderContext": ...

        def access_from(self, value_or_callback=None, /):
            """
            AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
            """
            if self._in_context and value_or_callback is None:
                context = AccessFrom.BuilderContext()
                context._parent_builder = self
                context._field_name = "access_from"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AccessFrom.builder())
                if isinstance(output, AccessFrom.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("access_from", value)

        def interval(self, value: str, /) -> Self:
            """
            The interval at which to check the upstream for updates.
            """
            return self._set("interval", value)

        def pass_credentials(self, value: Optional[bool], /) -> Self:
            """
            PassCredentials allows the credentials from the SecretRef to be passed on to
            a host that does not match the host as defined in URL.
            This may be required if the host of the advertised chart URLs in the index
            differ from the defined URL.
            Enabling this should be done with caution, as it can potentially result in
            credentials getting stolen in a MITM-attack.
            """
            return self._set("pass_credentials", value)

        @overload
        def secret_ref(
            self, value_or_callback: Optional[SecretRef], /
        ) -> "HelmRepositorySpec.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "HelmRepositorySpec.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            The name of the secret containing authentication credentials for the Helm
            repository.
            For HTTP/S basic auth the secret must contain username and
            password fields.
            For TLS the secret must contain a certFile and keyFile, and/or
            caFile fields.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def suspend(self, value: Optional[bool], /) -> Self:
            """
            This flag tells the controller to suspend the reconciliation of this source.
            """
            return self._set("suspend", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            The timeout of index downloading, defaults to 60s.
            """
            return self._set("timeout", value)

        def url(self, value: str, /) -> Self:
            """
            The Helm repository URL, a valid URL contains at least a protocol and host.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["HelmRepositorySpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HelmRepositorySpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HelmRepositorySpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HelmRepositorySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmRepositorySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_from: Annotated[Optional[AccessFrom], Field(alias="accessFrom")] = None
    """
    AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
    """
    interval: str
    """
    The interval at which to check the upstream for updates.
    """
    pass_credentials: Annotated[Optional[bool], Field(alias="passCredentials")] = None
    """
    PassCredentials allows the credentials from the SecretRef to be passed on to
    a host that does not match the host as defined in URL.
    This may be required if the host of the advertised chart URLs in the index
    differ from the defined URL.
    Enabling this should be done with caution, as it can potentially result in
    credentials getting stolen in a MITM-attack.
    """
    secret_ref: Annotated[Optional[SecretRef], Field(alias="secretRef")] = None
    """
    The name of the secret containing authentication credentials for the Helm
    repository.
    For HTTP/S basic auth the secret must contain username and
    password fields.
    For TLS the secret must contain a certFile and keyFile, and/or
    caFile fields.
    """
    suspend: Optional[bool] = None
    """
    This flag tells the controller to suspend the reconciliation of this source.
    """
    timeout: Optional[str] = "60s"
    """
    The timeout of index downloading, defaults to 60s.
    """
    url: str
    """
    The Helm repository URL, a valid URL contains at least a protocol and host.
    """


class HelmRepositoryStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HelmRepositoryStatus"]:
            return HelmRepositoryStatus

        def build(self) -> "HelmRepositoryStatus":
            return HelmRepositoryStatus(**self._attrs)

        @overload
        def artifact(
            self, value_or_callback: Optional[Artifact], /
        ) -> "HelmRepositoryStatus.Builder": ...

        @overload
        def artifact(
            self,
            value_or_callback: Callable[[Artifact.Builder], Artifact.Builder | Artifact],
            /,
        ) -> "HelmRepositoryStatus.Builder": ...

        @overload
        def artifact(self, value_or_callback: Never = ...) -> "Artifact.BuilderContext": ...

        def artifact(self, value_or_callback=None, /):
            """
            Artifact represents the output of the last successful repository sync.
            """
            if self._in_context and value_or_callback is None:
                context = Artifact.BuilderContext()
                context._parent_builder = self
                context._field_name = "artifact"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Artifact.builder())
                if isinstance(output, Artifact.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("artifact", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "HelmRepositoryStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "HelmRepositoryStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions holds the conditions for the HelmRepository.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def last_handled_reconcile_at(self, value: Optional[str], /) -> Self:
            """
            LastHandledReconcileAt holds the value of the most recent
            reconcile request value, so a change of the annotation value
            can be detected.
            """
            return self._set("last_handled_reconcile_at", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the last observed generation.
            """
            return self._set("observed_generation", value)

        def url(self, value: Optional[str], /) -> Self:
            """
            URL is the download link for the last index fetched.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["HelmRepositoryStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HelmRepositoryStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HelmRepositoryStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HelmRepositoryStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmRepositoryStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    artifact: Optional[Artifact] = None
    """
    Artifact represents the output of the last successful repository sync.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions holds the conditions for the HelmRepository.
    """
    last_handled_reconcile_at: Annotated[Optional[str], Field(alias="lastHandledReconcileAt")] = (
        None
    )
    """
    LastHandledReconcileAt holds the value of the most recent
    reconcile request value, so a change of the annotation value
    can be detected.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the last observed generation.
    """
    url: Optional[str] = None
    """
    URL is the download link for the last index fetched.
    """


class Bucket(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Bucket"]:
            return Bucket

        def build(self) -> "Bucket":
            return Bucket(**self._attrs)

        def api_version(
            self, value: Optional[Literal["source.toolkit.fluxcd.io/v1beta1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Bucket"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Bucket.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Bucket.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[BucketSpec], /) -> "Bucket.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[BucketSpec.Builder], BucketSpec.Builder | BucketSpec],
            /,
        ) -> "Bucket.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "BucketSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BucketSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BucketSpec.builder())
                if isinstance(output, BucketSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[BucketStatus], /) -> "Bucket.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [BucketStatus.Builder], BucketStatus.Builder | BucketStatus
            ],
            /,
        ) -> "Bucket.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "BucketStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BucketStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BucketStatus.builder())
                if isinstance(output, BucketStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Bucket.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Bucket.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Bucket."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Bucket", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Bucket.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["source.toolkit.fluxcd.io/v1beta1"]], Field(alias="apiVersion")
    ] = "source.toolkit.fluxcd.io/v1beta1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Bucket"]] = "Bucket"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[BucketSpec] = None
    status: Optional[BucketStatus] = None


class GitRepository(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GitRepository"]:
            return GitRepository

        def build(self) -> "GitRepository":
            return GitRepository(**self._attrs)

        def api_version(
            self, value: Optional[Literal["source.toolkit.fluxcd.io/v1beta1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["GitRepository"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "GitRepository.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "GitRepository.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[GitRepositorySpec], /
        ) -> "GitRepository.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [GitRepositorySpec.Builder],
                GitRepositorySpec.Builder | GitRepositorySpec,
            ],
            /,
        ) -> "GitRepository.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "GitRepositorySpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = GitRepositorySpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GitRepositorySpec.builder())
                if isinstance(output, GitRepositorySpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[GitRepositoryStatus], /
        ) -> "GitRepository.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [GitRepositoryStatus.Builder],
                GitRepositoryStatus.Builder | GitRepositoryStatus,
            ],
            /,
        ) -> "GitRepository.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "GitRepositoryStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = GitRepositoryStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GitRepositoryStatus.builder())
                if isinstance(output, GitRepositoryStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["GitRepository.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GitRepository.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GitRepository."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GitRepository", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GitRepository.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["source.toolkit.fluxcd.io/v1beta1"]], Field(alias="apiVersion")
    ] = "source.toolkit.fluxcd.io/v1beta1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["GitRepository"]] = "GitRepository"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[GitRepositorySpec] = None
    status: Optional[GitRepositoryStatus] = None


class HelmChart(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HelmChart"]:
            return HelmChart

        def build(self) -> "HelmChart":
            return HelmChart(**self._attrs)

        def api_version(
            self, value: Optional[Literal["source.toolkit.fluxcd.io/v1beta1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["HelmChart"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "HelmChart.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "HelmChart.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[HelmChartSpec], /) -> "HelmChart.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [HelmChartSpec.Builder], HelmChartSpec.Builder | HelmChartSpec
            ],
            /,
        ) -> "HelmChart.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "HelmChartSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = HelmChartSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HelmChartSpec.builder())
                if isinstance(output, HelmChartSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[HelmChartStatus], /
        ) -> "HelmChart.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [HelmChartStatus.Builder], HelmChartStatus.Builder | HelmChartStatus
            ],
            /,
        ) -> "HelmChart.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "HelmChartStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = HelmChartStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HelmChartStatus.builder())
                if isinstance(output, HelmChartStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["HelmChart.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HelmChart.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HelmChart."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HelmChart", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmChart.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["source.toolkit.fluxcd.io/v1beta1"]], Field(alias="apiVersion")
    ] = "source.toolkit.fluxcd.io/v1beta1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["HelmChart"]] = "HelmChart"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[HelmChartSpec] = None
    status: Optional[HelmChartStatus] = None


class HelmRepository(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HelmRepository"]:
            return HelmRepository

        def build(self) -> "HelmRepository":
            return HelmRepository(**self._attrs)

        def api_version(
            self, value: Optional[Literal["source.toolkit.fluxcd.io/v1beta1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["HelmRepository"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "HelmRepository.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "HelmRepository.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[HelmRepositorySpec], /
        ) -> "HelmRepository.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [HelmRepositorySpec.Builder],
                HelmRepositorySpec.Builder | HelmRepositorySpec,
            ],
            /,
        ) -> "HelmRepository.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "HelmRepositorySpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = HelmRepositorySpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HelmRepositorySpec.builder())
                if isinstance(output, HelmRepositorySpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[HelmRepositoryStatus], /
        ) -> "HelmRepository.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [HelmRepositoryStatus.Builder],
                HelmRepositoryStatus.Builder | HelmRepositoryStatus,
            ],
            /,
        ) -> "HelmRepository.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "HelmRepositoryStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = HelmRepositoryStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HelmRepositoryStatus.builder())
                if isinstance(output, HelmRepositoryStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["HelmRepository.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HelmRepository.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HelmRepository."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HelmRepository", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmRepository.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["source.toolkit.fluxcd.io/v1beta1"]], Field(alias="apiVersion")
    ] = "source.toolkit.fluxcd.io/v1beta1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["HelmRepository"]] = "HelmRepository"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[HelmRepositorySpec] = None
    status: Optional[HelmRepositoryStatus] = None
