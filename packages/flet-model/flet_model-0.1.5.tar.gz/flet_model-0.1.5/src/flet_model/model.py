from typing import List, Optional, Callable, Any, Union, Dict
import flet as ft
from functools import lru_cache


class Model:
    """Base class for creating view models in Flet applications."""

    route: str = None
    controls: Union[List[ft.Control], Callable[[], List[ft.Control]]] = []
    appbar: Optional[ft.AppBar] = None
    bottom_appbar: Optional[ft.BottomAppBar] = None
    auto_scroll: Optional[bool] = None
    bgcolor: Optional[str] = None
    drawer: Optional[ft.NavigationDrawer] = None
    end_drawer: Optional[ft.NavigationDrawer] = None
    fullscreen_dialog: Optional[bool] = None
    floating_action_button: Optional[ft.FloatingActionButton] = None
    floating_action_button_location: Optional[str] = None
    navigation_bar: Optional[ft.NavigationBar] = None
    horizontal_alignment: ft.CrossAxisAlignment = ft.CrossAxisAlignment.START
    on_scroll_interval: int = 10
    on_keyboard_event: Optional[Callable] = None
    padding: int = 10
    scroll: Optional[bool] = None
    on_scroll: Optional[Callable] = None
    spacing: int = 10
    vertical_alignment: ft.MainAxisAlignment = ft.MainAxisAlignment.START
    overlay_controls: List[ft.Control] = []

    # Class-level cache for event handlers
    _event_handler_cache: Dict[str, Callable] = {}

    def __init__(self, page: ft.Page):
        """Initialize the model with a Flet page instance."""
        self.page = page
        self.view: Optional[ft.View] = None
        self._control_cache = {}
        self.route_data: Dict[str, Any] = {}

    @lru_cache(maxsize=32)
    def get_cached_controls(self) -> List[ft.Control]:
        """Cache and return controls if they're generated by a callable."""
        if callable(self.controls):
            return self.controls()
        return self.controls

    def init(self) -> None:
        """Initialize the model. Override this method for setup logic."""
        pass

    def post_init(self) -> None:
        """Post-initialization hook. Override for logic after view creation."""
        pass

    def create_view(self) -> ft.View:
        """Create and return a Flet View instance based on model properties."""
        # Use cached controls
        controls = self.get_cached_controls()

        # Handle overlay controls efficiently
        if self.overlay_controls:
            self.page.overlay.extend(self.overlay_controls)

        # Efficient event binding
        if self.on_keyboard_event:
            self.page.on_keyboard_event = self.on_keyboard_event
        if self.on_scroll:
            self.page.on_scroll = self.on_scroll

        # Run init in thread
        self.page.run_thread(self.init)

        # Collect all controls that need event binding
        controls_to_bind = []
        controls_to_bind.extend(controls)
        controls_to_bind.extend(self.overlay_controls)
        if self.floating_action_button:
            controls_to_bind.append(self.floating_action_button)
        if self.bottom_appbar:
            controls_to_bind.append(self.bottom_appbar)

        self.bind_event_handlers(controls_to_bind)

        # Create view with all properties
        self.view = ft.View(
            route=self.route,
            controls=controls,
            appbar=self.appbar,
            bottom_appbar=self.bottom_appbar,
            auto_scroll=self.auto_scroll,
            bgcolor=self.bgcolor,
            drawer=self.drawer,
            end_drawer=self.end_drawer,
            fullscreen_dialog=self.fullscreen_dialog,
            floating_action_button=self.floating_action_button,
            floating_action_button_location=self.floating_action_button_location,
            horizontal_alignment=self.horizontal_alignment,
            on_scroll_interval=self.on_scroll_interval,
            padding=self.padding,
            scroll=self.scroll,
            spacing=self.spacing,
            vertical_alignment=self.vertical_alignment,
            navigation_bar=self.navigation_bar,
            on_scroll=self.on_scroll,
        )

        self.page.run_thread(self.post_init)
        return self.view

    def update(self) -> None:
        """Update the view with current model properties."""
        if not self.view:
            return
        # Batch update all properties
        updates = {
            'controls': self.get_cached_controls(),
            'appbar': self.appbar,
            'bottom_appbar': self.bottom_appbar,
            'auto_scroll': self.auto_scroll,
            'bgcolor': self.bgcolor,
            'drawer': self.drawer,
            'end_drawer': self.end_drawer,
            'fullscreen_dialog': self.fullscreen_dialog,
            'floating_action_button': self.floating_action_button,
            'floating_action_button_location': self.floating_action_button_location,
            'horizontal_alignment': self.horizontal_alignment,
            'on_scroll_interval': self.on_scroll_interval,
            'padding': self.padding,
            'scroll': self.scroll,
            'spacing': self.spacing,
            'vertical_alignment': self.vertical_alignment,
            'navigation_bar': self.navigation_bar,
        }

        for attr, value in updates.items():
            if hasattr(self.view, attr):
                setattr(self.view, attr, value)

        self.view.update()

    def bind_event_handlers(self, controls: List[ft.Control]) -> None:
        """Recursively bind event handlers to controls with caching."""
        event_attrs = ('on_click', 'on_hover', 'on_long_press', 'on_change', 'on_dismiss', 'on_submit')

        for control in controls:
            if not control:
                continue

            control_id = id(control)
            if control_id in self._control_cache:
                continue

            self._control_cache[control_id] = True

            for attr in event_attrs:
                if hasattr(control, attr):
                    handler = getattr(control, attr)
                    if isinstance(handler, str) and hasattr(self, handler):
                        # Cache the handler
                        if handler not in self._event_handler_cache:
                            self._event_handler_cache[handler] = getattr(self, handler)
                        setattr(control, attr, self._event_handler_cache[handler])

            # Recursively bind nested controls
            if hasattr(control, 'controls') and control.controls:
                self.bind_event_handlers(control.controls)
            if hasattr(control, 'content') and control.content:
                self.bind_event_handlers([control.content])
            if hasattr(control, 'header') and control.header:
                self.bind_event_handlers([control.header])
            if hasattr(control, 'actions') and control.actions:
                self.bind_event_handlers(control.actions)