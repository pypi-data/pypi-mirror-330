"""
This type stub file was generated by pyright.
"""

from collections.abc import Iterator

if __package__ or "." in __name__:
    ...
else:
    ...

class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""

    __setattr__ = ...

class SwigPyIterator:
    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    __swig_destroy__ = ...
    def value(self): ...
    def incr(self, n=...): ...
    def decr(self, n=...): ...
    def distance(self, x): ...
    def equal(self, x): ...
    def copy(self): ...
    def next(self): ...
    def __next__(self): ...
    def previous(self): ...
    def advance(self, n): ...
    def __eq__(self, x) -> bool: ...
    def __ne__(self, x) -> bool: ...
    def __iadd__(self, n): ...
    def __isub__(self, n): ...
    def __add__(self, n): ...
    def __sub__(self, *args): ...
    def __iter__(self):  # -> Self:
        ...

PackageType_CONDITIONAL: int = ...
PackageType_DEFAULT: int = ...
PackageType_MANDATORY: int = ...
PackageType_OPTIONAL: int = ...

class InvalidPackageType:
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...
    def get_domain_name(self): ...
    def get_name(self): ...

    __swig_destroy__ = ...

def __or__(a, b): ...
def __ior__(a, b): ...
def __and__(a, b): ...
def any(flags): ...
def package_type_from_string(*args): ...
def package_type_to_string(type): ...
def package_types_to_strings(types): ...

class Package:
    thisown = ...
    __repr__ = ...
    def __init__(self, name, type, condition) -> None: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def get_name(self):
        r"""
        :rtype: string
        :return: The Package name.
        Since: 5.0
        """
        ...

    def set_name(self, value): ...
    def get_type(self):
        r"""
        :rtype: int
        :return: The PackageType.
        Since: 5.0
        """
        ...

    def set_type(self, value): ...
    def get_type_string(self):
        r"""
        :rtype: string
        :return: std::string that corresponds to the PackageType.
        Since: 5.0
        """
        ...

    def get_condition(self):
        r"""
        :rtype: string
        :return: The condition (name of package) under which the package gets installed.
        Since: 5.0
        """
        ...

    def set_condition(self, value): ...

    __swig_destroy__ = ...

class GroupId:
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...

    id = ...
    __swig_destroy__ = ...

class Group:
    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    def get_groupid(self):
        r"""
        :rtype: string
        :return: The Group id.
        Since: 5.0
        """
        ...

    def get_name(self):
        r"""
        :rtype: string
        :return: The Group name.
        Since: 5.0
        """
        ...

    def get_description(self):
        r"""
        :rtype: string
        :return: The Group description.
        Since: 5.0
        """
        ...

    def get_translated_name(self, *args): ...
    def get_translated_description(self, *args): ...
    def get_order(self):
        r"""
        :rtype: string
        :return: The Group display order.
        Since: 5.0
        """
        ...

    def get_langonly(self):
        r"""
        :rtype: string
        :return: The Group langonly.
        Since: 5.0
        """
        ...

    def get_uservisible(self):
        r"""
        :rtype: boolean
        :return: `true` if the Group is visible to the users.
        Since: 5.0
        """
        ...

    def get_default(self):
        r"""
        :rtype: boolean
        :return: `true` if the Group is installed by default.
        Since: 5.0
        """
        ...

    def get_packages(self):
        r"""
        :rtype: std::vector< libdnf5::comps::Package,std::allocator< libdnf5::comps::Package > >
        :return: std::vector of Packages belonging to the Group.
        Since: 5.0
        """
        ...

    def get_packages_of_type(self, type):
        r"""
        :rtype: std::vector< libdnf5::comps::Package,std::allocator< libdnf5::comps::Package > >
        :return: std::vector of Packages of given type belonging to the Group.
        :type type: int
        :param type: One of the PackageTypes.
        Since: 5.0
        """
        ...

    def get_repos(self):
        r"""
        :rtype: std::set< std::string,std::less< std::string >,std::allocator< std::string > >
        :return: std::set of names of repositories that contain the Group.
        Since: 5.0
        """
        ...

    def get_installed(self):
        r"""
        :rtype: boolean
        :return: `true` if the Group is installed (belongs to the @System repo).
        Since: 5.0
        """
        ...

    def get_reason(self):
        r"""
        :rtype: int
        :return: Resolved reason why the Group was installed.
                    Groups can be installed due to multiple reasons, only the most significant is returned.
        Since: 5.0
        """
        ...

    def __iadd__(self, rhs):
        r"""
        Merge the Group with another one.
        Since: 5.0
        """
        ...

    def __eq__(self, rhs) -> bool: ...
    def __ne__(self, rhs) -> bool: ...
    def __lt__(self, rhs) -> bool: ...
    def serialize(self, path):
        r"""
        Serialize the Group into an xml file.
        :type path: string
        :param path: Path of the output xml file.
        :raises: utils::xml::XMLSaveError When saving of the file fails.
        Since: 5.0
        """
        ...
    __swig_destroy__ = ...

class VectorPackage:
    thisown = ...
    __repr__ = ...
    def iterator(self): ...
    def __iter__(self): ...
    def __nonzero__(self): ...
    def __bool__(self): ...
    def __len__(self): ...
    def __getslice__(self, i, j): ...
    def __setslice__(self, *args): ...
    def __delslice__(self, i, j): ...
    def __delitem__(self, *args): ...
    def __getitem__(self, *args): ...
    def __setitem__(self, *args): ...
    def pop(self): ...
    def append(self, x): ...
    def empty(self): ...
    def size(self): ...
    def swap(self, v): ...
    def begin(self): ...
    def end(self): ...
    def rbegin(self): ...
    def rend(self): ...
    def clear(self): ...
    def get_allocator(self): ...
    def pop_back(self): ...
    def erase(self, *args): ...
    def __init__(self, *args) -> None: ...
    def push_back(self, x): ...
    def front(self): ...
    def back(self): ...
    def assign(self, n, x): ...
    def insert(self, *args): ...
    def reserve(self, n): ...
    def capacity(self): ...

    __swig_destroy__ = ...

class SetConstIteratorGroup:
    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    def value(self): ...
    def next(self): ...
    def prev(self): ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...

    __swig_destroy__ = ...

class SetGroup:
    r"""
    Set represents set of objects (e.g. repositories, or groups)
    and implements set operations such as unions or differences.
    """

    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    __swig_destroy__ = ...
    def empty(self): ...
    def size(self): ...
    def clear(self): ...
    def add(self, *args): ...
    def remove(self, obj): ...
    def find(self, obj): ...
    def contains(self, obj): ...
    def __ior__(self, other): ...
    def __iand__(self, other): ...
    def __isub__(self, other): ...
    def __ixor__(self, other): ...
    def update(self, other): ...
    def intersection(self, other): ...
    def difference(self, other): ...
    def symmetric_difference(self, other): ...
    def is_subset(self, other): ...
    def is_superset(self, other): ...
    def swap(self, other): ...
    def get_data(self, *args): ...
    def begin(self): ...
    def end(self): ...
    def __len__(self): ...
    def __iter__(self) -> Iterator[Group]: ...

class SackQueryGroup(SetGroup):
    r"""Query is a Set with filtering capabilities."""

    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...
    def filter(self, *args): ...
    def get(self):
        r"""Get a single object. Raise an exception if none or multiple objects match the query."""
        ...

    def list(self):
        r"""List all objects matching the query."""
        ...

    def get_data(self, *args): ...

    __swig_destroy__ = ...

class GroupQuery(SackQueryGroup):
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...
    def filter_groupid(self, *args): ...
    def filter_package_name(self, *args):
        r"""
        Filter groups by packages they contain. Keep only groups that contain packages with given names.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings (package names) the filter is matched against.
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
        Since: 5.12
        """
        ...

    def filter_name(self, *args): ...
    def filter_uservisible(self, value): ...
    def filter_default(self, value): ...
    def filter_installed(self, value): ...

    __swig_destroy__ = ...

class SackGroup:
    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    def size(self): ...
    def get_excludes(self): ...
    def add_excludes(self, value): ...
    def remove_excludes(self, value): ...
    def set_excludes(self, value): ...
    def get_includes(self): ...
    def add_includes(self, value): ...
    def remove_includes(self, value): ...
    def set_includes(self, value): ...
    def get_use_includes(self): ...
    def set_use_includes(self, value): ...

    __swig_destroy__ = ...

class GroupSack(SackGroup):
    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    __swig_destroy__ = ...
    def get_weak_ptr(self):
        r"""Create WeakPtr to GroupSack"""
        ...

    def get_reasons(self): ...

class GroupSackWeakPtr:
    r"""
    WeakPtr is a "smart" pointer. It contains a pointer to resource and to guard of resource.
    WeakPtr pointer can be owner of the resource. However, the resource itself may depend on another resource.
    WeakPtr registers/unregisters itself at the guard of resource. And the resource guard invalidates
    the registered WeakPtrs when the resource is unusable (eg. its dependecny was released).
    Note on thread safety:
    It is safe to create, access and destroy WeakPtrs in multiple threads simultaneously.
    """

    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def __deref__(self):
        r"""Provides access to the managed object. Generates exception if object is not valid."""
        ...

    def get(self):
        r"""Returns a pointer to the managed object. Generates exception if object is not valid."""
        ...

    def is_valid(self):
        r"""Checks if managed object is valid."""
        ...

    def has_same_guard(self, other):
        r"""Checks if the other WeakPtr instance has the same WeakPtrGuard."""
        ...

    def __ref__(self): ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def get_weak_ptr(self):
        r"""Create WeakPtr to GroupSack"""
        ...

    def get_reasons(self): ...
    def size(self): ...
    def get_excludes(self): ...
    def add_excludes(self, value): ...
    def remove_excludes(self, value): ...
    def set_excludes(self, value): ...
    def get_includes(self): ...
    def add_includes(self, value): ...
    def remove_includes(self, value): ...
    def set_includes(self, value): ...
    def get_use_includes(self): ...
    def set_use_includes(self, value): ...

class EnvironmentId:
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...

    id = ...
    __swig_destroy__ = ...

class Environment:
    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    def get_environmentid(self):
        r"""
        :rtype: string
        :return: The Environment id.
        Since: 5.0
        """
        ...

    def get_name(self):
        r"""
        :rtype: string
        :return: The Environment name.
        Since: 5.0
        """
        ...

    def get_description(self):
        r"""
        :rtype: string
        :return: The Environment description.
        Since: 5.0
        """
        ...

    def get_translated_name(self, *args): ...
    def get_translated_description(self, *args): ...
    def get_order(self):
        r"""
        :rtype: string
        :return: The Environment display order.
        Since: 5.0
        """
        ...

    def get_groups(self):
        r"""
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: std::vector of Group ids belonging to the Environment.
        Since: 5.0
        """
        ...

    def get_optional_groups(self):
        r"""
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: std::vector of optional Group ids belonging to the Environment.
        Since: 5.0
        """
        ...

    def get_repos(self):
        r"""
        :rtype: std::set< std::string,std::less< std::string >,std::allocator< std::string > >
        :return: std::set of names of repositories that contain the Environment.
        Since: 5.0
        """
        ...

    def get_installed(self):
        r"""
        :rtype: boolean
        :return: `true` if the Environment is installed (belongs to the @System repo).
        Since: 5.0
        """
        ...

    def get_reason(self):
        r"""
        :rtype: int
        :return: Resolved reason why the Environment was installed.
                    Environments can be installed due to multiple reasons, only the most significant is returned.
        Since: 5.0
        """
        ...

    def __iadd__(self, rhs):
        r"""
        Merge the Environment with another one.
        Since: 5.0
        """
        ...

    def __eq__(self, rhs) -> bool: ...
    def __ne__(self, rhs) -> bool: ...
    def __lt__(self, rhs) -> bool: ...
    def serialize(self, path):
        r"""
        Serialize the Environment into an xml file
        :type path: string
        :param path: Path of the output xml file.
        :raises: utils::xml::XMLSaveError When saving of the file fails.
        Since: 5.0
        """
        ...
    __swig_destroy__ = ...

class SetConstIteratorEnvironment:
    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    def value(self): ...
    def next(self): ...
    def prev(self): ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...

    __swig_destroy__ = ...

class SetEnvironment:
    r"""
    Set represents set of objects (e.g. repositories, or groups)
    and implements set operations such as unions or differences.
    """

    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    __swig_destroy__ = ...
    def empty(self): ...
    def size(self): ...
    def clear(self): ...
    def add(self, *args): ...
    def remove(self, obj): ...
    def find(self, obj): ...
    def contains(self, obj): ...
    def __ior__(self, other): ...
    def __iand__(self, other): ...
    def __isub__(self, other): ...
    def __ixor__(self, other): ...
    def update(self, other): ...
    def intersection(self, other): ...
    def difference(self, other): ...
    def symmetric_difference(self, other): ...
    def is_subset(self, other): ...
    def is_superset(self, other): ...
    def swap(self, other): ...
    def get_data(self, *args): ...
    def begin(self): ...
    def end(self): ...
    def __len__(self): ...

def __eq__(*args) -> bool: ...

class SackQueryEnvironment(SetEnvironment):
    r"""Query is a Set with filtering capabilities."""

    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...
    def filter(self, *args): ...
    def get(self):
        r"""Get a single object. Raise an exception if none or multiple objects match the query."""
        ...

    def list(self):
        r"""List all objects matching the query."""
        ...

    def get_data(self, *args): ...

    __swig_destroy__ = ...

class EnvironmentQuery(SackQueryEnvironment):
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...
    def filter_environmentid(self, *args): ...
    def filter_name(self, *args): ...
    def filter_installed(self, value): ...

    __swig_destroy__ = ...

class SackEnvironment:
    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    def size(self): ...
    def get_excludes(self): ...
    def add_excludes(self, value): ...
    def remove_excludes(self, value): ...
    def set_excludes(self, value): ...
    def get_includes(self): ...
    def add_includes(self, value): ...
    def remove_includes(self, value): ...
    def set_includes(self, value): ...
    def get_use_includes(self): ...
    def set_use_includes(self, value): ...

    __swig_destroy__ = ...

class EnvironmentSack(SackEnvironment):
    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    __swig_destroy__ = ...
    def get_weak_ptr(self):
        r"""Create WeakPtr to EnvironmentSack"""
        ...

    def get_reasons(self): ...

class EnvironmentSackWeakPtr:
    r"""
    WeakPtr is a "smart" pointer. It contains a pointer to resource and to guard of resource.
    WeakPtr pointer can be owner of the resource. However, the resource itself may depend on another resource.
    WeakPtr registers/unregisters itself at the guard of resource. And the resource guard invalidates
    the registered WeakPtrs when the resource is unusable (eg. its dependecny was released).
    Note on thread safety:
    It is safe to create, access and destroy WeakPtrs in multiple threads simultaneously.
    """

    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def __deref__(self):
        r"""Provides access to the managed object. Generates exception if object is not valid."""
        ...

    def get(self):
        r"""Returns a pointer to the managed object. Generates exception if object is not valid."""
        ...

    def is_valid(self):
        r"""Checks if managed object is valid."""
        ...

    def has_same_guard(self, other):
        r"""Checks if the other WeakPtr instance has the same WeakPtrGuard."""
        ...

    def __ref__(self): ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def get_weak_ptr(self):
        r"""Create WeakPtr to EnvironmentSack"""
        ...

    def get_reasons(self): ...
    def size(self): ...
    def get_excludes(self): ...
    def add_excludes(self, value): ...
    def remove_excludes(self, value): ...
    def set_excludes(self, value): ...
    def get_includes(self): ...
    def add_includes(self, value): ...
    def remove_includes(self, value): ...
    def set_includes(self, value): ...
    def get_use_includes(self): ...
    def set_use_includes(self, value): ...

def SetEnvironment__iter__(self):  # -> Iterator:
    ...

class Comps:
    thisown = ...
    __repr__ = ...
    def __init__(self, base) -> None: ...

    __swig_destroy__ = ...
    def get_group_sack(self): ...
    def get_environment_sack(self): ...
    def get_weak_ptr(self): ...
    def get_base(self): ...

class CompsWeakPtr:
    r"""
    WeakPtr is a "smart" pointer. It contains a pointer to resource and to guard of resource.
    WeakPtr pointer can be owner of the resource. However, the resource itself may depend on another resource.
    WeakPtr registers/unregisters itself at the guard of resource. And the resource guard invalidates
    the registered WeakPtrs when the resource is unusable (eg. its dependecny was released).
    Note on thread safety:
    It is safe to create, access and destroy WeakPtrs in multiple threads simultaneously.
    """

    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def __deref__(self):
        r"""Provides access to the managed object. Generates exception if object is not valid."""
        ...

    def get(self):
        r"""Returns a pointer to the managed object. Generates exception if object is not valid."""
        ...

    def is_valid(self):
        r"""Checks if managed object is valid."""
        ...

    def has_same_guard(self, other):
        r"""Checks if the other WeakPtr instance has the same WeakPtrGuard."""
        ...

    def __ref__(self): ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def get_group_sack(self): ...
    def get_environment_sack(self): ...
    def get_weak_ptr(self): ...
    def get_base(self): ...
