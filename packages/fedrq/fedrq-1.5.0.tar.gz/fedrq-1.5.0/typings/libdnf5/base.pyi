"""
This type stub file was generated by pyright.
"""

if __package__ or "." in __name__:
    ...
else:
    ...

class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""

    __setattr__ = ...

class SwigPyIterator:
    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    __swig_destroy__ = ...
    def value(self): ...
    def incr(self, n=...): ...
    def decr(self, n=...): ...
    def distance(self, x): ...
    def equal(self, x): ...
    def copy(self): ...
    def next(self): ...
    def __next__(self): ...
    def previous(self): ...
    def advance(self, n): ...
    def __eq__(self, x) -> bool: ...
    def __ne__(self, x) -> bool: ...
    def __iadd__(self, n): ...
    def __isub__(self, n): ...
    def __add__(self, n): ...
    def __sub__(self, *args): ...
    def __iter__(self):  # -> Self:
        ...

class BaseWeakPtr:
    r"""
    WeakPtr is a "smart" pointer. It contains a pointer to resource and to guard of resource.
    WeakPtr pointer can be owner of the resource. However, the resource itself may depend on another resource.
    WeakPtr registers/unregisters itself at the guard of resource. And the resource guard invalidates
    the registered WeakPtrs when the resource is unusable (eg. its dependecny was released).
    Note on thread safety:
    It is safe to create, access and destroy WeakPtrs in multiple threads simultaneously.
    """

    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def __deref__(self):
        r"""Provides access to the managed object. Generates exception if object is not valid."""
        ...

    def get(self):
        r"""Returns a pointer to the managed object. Generates exception if object is not valid."""
        ...

    def is_valid(self):
        r"""Checks if managed object is valid."""
        ...

    def has_same_guard(self, other):
        r"""Checks if the other WeakPtr instance has the same WeakPtrGuard."""
        ...

    def __ref__(self): ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def set_download_callbacks(self, download_callbacks): ...
    def get_download_callbacks(self): ...
    def lock(self):
        r"""
        Sets the pointer to the locked instance "Base" to "this" instance. Blocks if the pointer is already set.
        Pointer to a locked "Base" instance can be obtained using "get_locked_base()".
        """
        ...

    def unlock(self):
        r"""
        Resets the pointer to a locked "Base" instance to "nullptr".
        Throws an exception if another or no instance is locked.
        """
        ...

    def get_locked_base(self):
        r"""Returns a pointer to a locked "Base" instance or "nullptr" if no instance is locked."""
        ...

    def load_config(self):
        r"""
        Loads main configuration.
        The file defined in the current configuration and files in the drop-in directories are used.
        """
        ...

    def with_config_file_path(self, func):
        r"""
        Deprecated: Don't use it! It will be removed in Fedora 40. It was intended for internal use only.
        Call a function that loads the config file, catching errors appropriately
        """
        ...

    def load_config_from_file(self):
        r"""
        Deprecated: It is redundant. It calls `load_config()`.
        Loads main configuration.
        """
        ...

    def get_config(self):
        r"""
        :rtype: :py:class:`ConfigMain`
        :return: a reference to configuration
        """
        ...

    def get_logger(self): ...
    def get_repo_sack(self): ...
    def get_rpm_package_sack(self): ...
    def setup(self):
        r"""
        Loads libdnf plugins, vars from environment, varsdirs and installroot (releasever, arch) and resolves
        configuration of protected_packages (glob:).
        To prevent differences between configuration and internal Base settings, following configurations
        will be locked: installroot, varsdir.
        The method is supposed to be called after configuration is updated, application plugins applied
        their pre configuration modification in configuration, but before repositories are loaded or any Package
        or Advisory query created.
        Calling the method for the second time result in throwing an exception
        """
        ...

    def is_initialized(self):
        r"""Returns true when setup() (mandatory method in many workflows) was already called"""
        ...

    def get_transaction_history(self): ...
    def get_comps(self): ...
    def get_module_sack(self): ...
    def get_vars(self):
        r"""Gets base variables. They can be used in configuration files. Syntax in the config - ${var_name} or $var_name."""
        ...

    def get_weak_ptr(self): ...

class VarsWeakPtr:
    r"""
    WeakPtr is a "smart" pointer. It contains a pointer to resource and to guard of resource.
    WeakPtr pointer can be owner of the resource. However, the resource itself may depend on another resource.
    WeakPtr registers/unregisters itself at the guard of resource. And the resource guard invalidates
    the registered WeakPtrs when the resource is unusable (eg. its dependecny was released).
    Note on thread safety:
    It is safe to create, access and destroy WeakPtrs in multiple threads simultaneously.
    """

    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def __deref__(self):
        r"""Provides access to the managed object. Generates exception if object is not valid."""
        ...

    def get(self):
        r"""Returns a pointer to the managed object. Generates exception if object is not valid."""
        ...

    def is_valid(self):
        r"""Checks if managed object is valid."""
        ...

    def has_same_guard(self, other):
        r"""Checks if the other WeakPtr instance has the same WeakPtrGuard."""
        ...

    def __ref__(self): ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def substitute(self, text):
        r"""
        Substitute DNF vars in the input text.

        :type text: string
        :param text: The text for substitution
        :rtype: string
        :return: The substituted text
        """
        ...

    def get_variables(self): ...
    def set(self, *args):
        r"""
        Set particular variable to a value

        :type name: string
        :param name: Name of the variable
        :type value: string
        :param value: Value to be stored in variable
        :type prio: int, optional
        :param prio: Source/Priority of the value
        :raises: ReadOnlyVariableError if the variable is read-only
        """
        ...

    def is_read_only(self, name):
        r"""
        Checks whether a variable is read-only

        :type name: string
        :param name: Name of the variable
        :rtype: boolean
        :return: true if the variable is read-only, false if it is writable
        """
        ...

    def contains(self, name):
        r"""
        Checks if there is an variable with name equivalent to name in the container.

        :type name: string
        :param name: Name of the variable
        :rtype: boolean
        :return: true if there is such an element, otherwise false
        """
        ...

    def get_value(self, name):
        r"""
        Get value of particular variable.

        :type name: string
        :param name: Name of the variable
        """
        ...

    def detect_release(self, base, install_root_path): ...

class Base:
    r"""
    Instances of :class:`libdnf5::Base` are the central point of functionality supplied by libdnf5.
    An application will typically create a single instance of this class which it will keep for the run-time needed to accomplish its packaging tasks.
    :class:`.Base` instances are stateful objects owning various data.
    """

    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""Constructs a new Base instance and sets the destination loggers."""
        ...
    __swig_destroy__ = ...
    def set_download_callbacks(self, download_callbacks): ...
    def get_download_callbacks(self): ...
    def lock(self):
        r"""
        Sets the pointer to the locked instance "Base" to "this" instance. Blocks if the pointer is already set.
        Pointer to a locked "Base" instance can be obtained using "get_locked_base()".
        """
        ...

    def unlock(self):
        r"""
        Resets the pointer to a locked "Base" instance to "nullptr".
        Throws an exception if another or no instance is locked.
        """
        ...

    @staticmethod
    def get_locked_base():
        r"""Returns a pointer to a locked "Base" instance or "nullptr" if no instance is locked."""
        ...

    def load_config(self):
        r"""
        Loads main configuration.
        The file defined in the current configuration and files in the drop-in directories are used.
        """
        ...

    def with_config_file_path(self, func):
        r"""
        Deprecated: Don't use it! It will be removed in Fedora 40. It was intended for internal use only.
        Call a function that loads the config file, catching errors appropriately
        """
        ...

    def load_config_from_file(self):
        r"""
        Deprecated: It is redundant. It calls `load_config()`.
        Loads main configuration.
        """
        ...

    def get_config(self):
        r"""
        :rtype: :py:class:`ConfigMain`
        :return: a reference to configuration
        """
        ...

    def get_logger(self): ...
    def get_repo_sack(self): ...
    def get_rpm_package_sack(self): ...
    def setup(self):
        r"""
        Loads libdnf plugins, vars from environment, varsdirs and installroot (releasever, arch) and resolves
        configuration of protected_packages (glob:).
        To prevent differences between configuration and internal Base settings, following configurations
        will be locked: installroot, varsdir.
        The method is supposed to be called after configuration is updated, application plugins applied
        their pre configuration modification in configuration, but before repositories are loaded or any Package
        or Advisory query created.
        Calling the method for the second time result in throwing an exception
        """
        ...

    def is_initialized(self):
        r"""Returns true when setup() (mandatory method in many workflows) was already called"""
        ...

    def get_transaction_history(self): ...
    def get_comps(self): ...
    def get_module_sack(self): ...
    def get_vars(self):
        r"""Gets base variables. They can be used in configuration files. Syntax in the config - ${var_name} or $var_name."""
        ...

    def get_weak_ptr(self): ...

class SolverProblems:
    r"""Represent problems detected by a RPM solver (libsolv)"""

    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def get_problems(self):
        r"""
        Provide information about package solver problems in a vector. Each problem can be transformed to string by
        package_solver_problem_to_string or all problems to a string by all_package_solver_problems_to_string().

        :rtype: std::vector< std::vector< std::pair< libdnf5::ProblemRules,std::vector< std::string,std::allocator< std::string > > >,std::allocator< std::pair< libdnf5::ProblemRules,std::vector< std::string,std::allocator< std::string > > > > >,std::allocator< std::vector< std::pair< libdnf5::ProblemRules,std::vector< std::string,std::allocator< std::string > > >,std::allocator< std::pair< libdnf5::ProblemRules,std::vector< std::string,std::allocator< std::string > > > > > > >
        :return: Vector of problems encountered by the solver. Each problem is described by a vector of "rule breakages"
            (TODO(lukash) try to find a better name for this) stored
            in a `std::pair<libdnf5::ProblemRules, std::vector<std::string>>`, where the first of the pair is a rule breakage
            identifier and the second is a list of string identifiers which are the subjects of the rule breakage. These can
            be rendered into a string by the `problem_to_string()` method.
        """
        ...

    def to_string(self):
        r"""Convert SolverProblems class to string representative;"""
        ...

    @staticmethod
    def problem_to_string(raw):
        r"""Convert particular package solver problem to a string;"""
        ...

class LogEvent:
    r"""Contain information, hint, or a problem created during libdnf5::Goal::resolve()"""

    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def get_action(self):
        r"""
        :rtype: int
        :return: GoalAction for which goal event was created
        """
        ...

    def get_problem(self):
        r"""
        :rtype: int
        :return: GoalProblem that specify the type of report
        """
        ...

    def get_additional_data(self):
        r"""
        :rtype: std::set< std::string,std::less< std::string >,std::allocator< std::string > >
        :return: Additional information (internal), that are required for formatted string
        """
        ...

    def get_job_settings(self):
        r"""
        :rtype: :py:class:`GoalJobSettings`
        :return: GoalJobSetting if it is relevant for the particular GoalProblem
        """
        ...

    def get_spec(self):
        r"""
        :rtype: string
        :return: SPEC if it is relevant for the particular GoalProblem
        """
        ...

    def get_solver_problems(self):
        r"""
        :rtype: :py:class:`SolverProblems`
        :return: SolverProblems if they are relevant for the particular GoalProblem
        """
        ...

    def to_string(self):
        r"""Convert an element from resolve log to string;"""
        ...

class Transaction:
    thisown = ...
    __repr__ = ...
    TransactionRunResult_SUCCESS = ...
    TransactionRunResult_ERROR_RERUN = ...
    TransactionRunResult_ERROR_RESOLVE = ...
    TransactionRunResult_ERROR_LOCK = ...
    TransactionRunResult_ERROR_CHECK = ...
    TransactionRunResult_ERROR_RPM_RUN = ...
    TransactionRunResult_ERROR_GPG_CHECK = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def get_problems(self):
        r"""
        Return basic overview about result of resolving transaction.
        To get complete information, use get_resolve_logs().
        """
        ...

    def get_resolve_logs(self):
        r"""
        Returns information about resolvement of Goal.
        :rtype: std::vector< libdnf5::base::LogEvent,std::allocator< libdnf5::base::LogEvent > >
        :return: A vector of LogEvent instances.
        """
        ...

    def get_resolve_logs_as_strings(self):
        r"""
        Returns information about resolvement of Goal as a list of printable messages
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of string representations of problems.
        """
        ...

    def get_transaction_packages(self):
        r"""
        :rtype: std::vector< libdnf5::base::TransactionPackage,std::allocator< libdnf5::base::TransactionPackage > >
        :return: the transaction packages.
        """
        ...

    def get_transaction_packages_count(self):
        r"""
        :rtype: std::size_t
        :return: the number of transaction packages.
        """
        ...

    def get_transaction_groups(self):
        r"""
        :rtype: std::vector< libdnf5::base::TransactionGroup,std::allocator< libdnf5::base::TransactionGroup > >
        :return: the transaction groups.
        """
        ...

    def get_transaction_modules(self):
        r"""
        :rtype: std::vector< libdnf5::base::TransactionModule,std::allocator< libdnf5::base::TransactionModule > >
        :return: the transaction modules.
        """
        ...

    def get_transaction_environments(self):
        r"""
        :rtype: std::vector< libdnf5::base::TransactionEnvironment,std::allocator< libdnf5::base::TransactionEnvironment > >
        :return: environmental groups that are part of the transaction.
        """
        ...

    def empty(self):
        r"""
        :rtype: boolean
        :return: `true` if the transaction is empty.
        """
        ...

    def download(self):
        r"""
        Download all inbound packages (packages that are being installed on the
        system). Fails immediately on the first package download failure. Will
        try to resume downloads of any partially-downloaded RPMs.

        The destination directory for downloaded RPMs is taken from the `destdir`
        configuration option. If it's not specified, the standard location of
        repo cachedir/packages is used.
        """
        ...

    def test(self):
        r"""
        Check the transaction by running it with RPMTRANS_FLAG_TEST. The import
        of any necessary public keys will be requested, and transaction checks
        will be performed, but no changes to the installed package set will be
        made. These checks are performed automatically by run(); it is
        redundant to call test() before calling run().
        :rtype: int
        :return: An enum describing the result of the transaction
        """
        ...

    def run(self):
        r"""
        Prepare, check and run the transaction.

        All the transaction metadata that was set (`description`, `user_id` or `comment`)
        is stored in the history database.

        To watch progress or trigger actions during specific transactions events,
        setup the `callbacks` object.

        After a successful transaction, any temporarily downloaded packages are removed
        if the 'keepcache' option is set to 'false' and the transaction involved an inbound action.
        Otherwise, the packages are preserved on the disk.

        :rtype: int
        :return: An enum describing the result of running the transaction.
        """
        ...

    def set_callbacks(self, callbacks):
        r"""
        Setup callbacks to be called during rpm transaction.
        :type callbacks: std::unique_ptr< libdnf5::rpm::TransactionCallbacks >
        :param callbacks: Implemented callbacks object.
        """
        ...

    def set_description(self, description):
        r"""
        Setup a description of the transaction.
        :type description: string
        :param description: Value could be the console command for CLI or verbose description for API usage.
        """
        ...

    def set_user_id(self, user_id):
        r"""
        Setup the id of the user that started the transaction. If not set, current login user UID is used.
        :type user_id: int
        :param user_id: UID value.
        """
        ...

    def set_comment(self, comment):
        r"""
        Setup a comment to store in the history database along with the transaction.
        :type comment: string
        :param comment: Any string value.
        """
        ...

    @staticmethod
    def transaction_result_to_string(result):
        r"""Return string representation of the TransactionRunResult enum"""
        ...

    def get_transaction_problems(self):
        r"""Retrieve list of problems that occurred during transaction run attempt"""
        ...

    def check_gpg_signatures(self):
        r"""
        Check signatures of packages in the resolved transaction.

        :rtype: boolean
        :return: True if all packages have correct signatures or checking is turned off with `gpgcheck` option,
            otherwise false. More info about occurred problems can be retrieved using the `get_gpg_signature_problems`
            method.
        """
        ...

    def get_gpg_signature_problems(self):
        r"""Retrieve a list of the problems that occurred during `check_gpg_signatures` procedure."""
        ...

    def serialize(self):
        r"""
        Warning: This method is experimental/unstable and should not be relied on. It may be removed without warning
        Serialize the transaction into a json data format which can be later loaded
        into a `libdnf5::Goal` and replayed.
        """
        ...

class VectorLogEvent:
    thisown = ...
    __repr__ = ...
    def iterator(self): ...
    def __iter__(self): ...
    def __nonzero__(self): ...
    def __bool__(self): ...
    def __len__(self): ...
    def __getslice__(self, i, j): ...
    def __setslice__(self, *args): ...
    def __delslice__(self, i, j): ...
    def __delitem__(self, *args): ...
    def __getitem__(self, *args): ...
    def __setitem__(self, *args): ...
    def pop(self): ...
    def append(self, x): ...
    def empty(self): ...
    def size(self): ...
    def swap(self, v): ...
    def begin(self): ...
    def end(self): ...
    def rbegin(self): ...
    def rend(self): ...
    def clear(self): ...
    def get_allocator(self): ...
    def pop_back(self): ...
    def erase(self, *args): ...
    def __init__(self, *args) -> None: ...
    def push_back(self, x): ...
    def front(self): ...
    def back(self): ...
    def assign(self, n, x): ...
    def insert(self, *args): ...
    def reserve(self, n): ...
    def capacity(self): ...

    __swig_destroy__ = ...

class TransactionPackage:
    r"""Describe transaction operation related to rpm Package"""

    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    def get_package(self):
        r"""
        :rtype: :py:class:`Package`
        :return: the underlying package.
        """
        ...

    def get_action(self):
        r"""
        :rtype: int
        :return: the action being performed on the transaction package.
        """
        ...

    def get_state(self):
        r"""
        :rtype: int
        :return: the state of the package in the transaction.
        """
        ...

    def get_reason(self):
        r"""
        :rtype: int
        :return: the reason of the action being performed on the transaction package.
        """
        ...

    def get_replaces(self):
        r"""
        :rtype: std::vector< libdnf5::rpm::Package,std::allocator< libdnf5::rpm::Package > >
        :return: packages replaced by this transaction package.
        """
        ...

    def get_replaced_by(self):
        r"""
        :rtype: std::vector< libdnf5::rpm::Package,std::allocator< libdnf5::rpm::Package > >
        :return: packages that replace this transaction package (for transaction
            packages that are leaving the system).
        """
        ...

    def get_reason_change_group_id(self):
        r"""
        The REASON_CHANGE action requires group id in case the reason is changed to GROUP
        :rtype: string
        :return: id of group the package belongs to
        """
        ...
    __swig_destroy__ = ...

class VectorBaseTransactionPackage:
    thisown = ...
    __repr__ = ...
    def iterator(self): ...
    def __iter__(self): ...
    def __nonzero__(self): ...
    def __bool__(self): ...
    def __len__(self): ...
    def __getslice__(self, i, j): ...
    def __setslice__(self, *args): ...
    def __delslice__(self, i, j): ...
    def __delitem__(self, *args): ...
    def __getitem__(self, *args): ...
    def __setitem__(self, *args): ...
    def pop(self): ...
    def append(self, x): ...
    def empty(self): ...
    def size(self): ...
    def swap(self, v): ...
    def begin(self): ...
    def end(self): ...
    def rbegin(self): ...
    def rend(self): ...
    def clear(self): ...
    def get_allocator(self): ...
    def pop_back(self): ...
    def erase(self, *args): ...
    def __init__(self, *args) -> None: ...
    def push_back(self, x): ...
    def front(self): ...
    def back(self): ...
    def assign(self, n, x): ...
    def insert(self, *args): ...
    def reserve(self, n): ...
    def capacity(self): ...

    __swig_destroy__ = ...

class Goal:
    r"""Centralized point to perform operations with RPMs, Comps groups, and Modules"""

    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def add_module_enable(self, spec, settings):
        r"""
        Add module enable request to the goal.
        :type spec: string
        :param spec:             A string with module spec to enable.
        :type settings: :py:class:`GoalJobSettings`
        :param settings:  A structure to override default goal settings.
        """
        ...

    def add_module_disable(self, spec, settings):
        r"""
        Add module disable request to the goal.
        :type spec: string
        :param spec:             A string with module spec to disable.
        :type settings: :py:class:`GoalJobSettings`
        :param settings:  A structure to override default goal settings.
        """
        ...

    def add_module_reset(self, spec, settings):
        r"""
        Add module reset request to the goal.
        :type spec: string
        :param spec:             A string with module spec to reset.
        :type settings: :py:class:`GoalJobSettings`
        :param settings:  A structure to override default goal settings.
        """
        ...

    def add_install(self, *args):
        r"""
        High level API for an artifact installation. A spec can be either a package
        specification matched against NEVRA, provides, and file provides, or it can
        be a path to local rpm file, or URL of rpm to be installed.
        By using `` prefix you can also specify a group, environmental group,
        or a module to be installed.
        :type spec: string
        :param spec:  A string with installation spec
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:  A structure to override default goal settings.
        """
        ...

    def add_upgrade(self, *args):
        r"""
        High level API for an artifact upgrade. See `add_install()` for details.
        :type spec: string
        :param spec:      A string with upgrade spec
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:  A structure to override default goal settings.
        :type minimal: boolean, optional
        :param minimal:   Whether to do smallest possible upgrade
        """
        ...

    def add_downgrade(self, *args):
        r"""
        High level API for an artifact downgrade. See `add_install()` for details.
        :type spec: string
        :param spec:      A string with upgrade spec
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:  A structure to override default goal settings.
        """
        ...

    def add_reinstall(self, *args):
        r"""
        High level API for an artifact reinstall. See `add_install()` for details.
        :type spec: string
        :param spec:      A string with reinstall spec
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:  A structure to override default goal settings.
        """
        ...

    def add_remove(self, *args):
        r"""
        High level API for an artifact removal. See `add_install()` for details.
        :type spec: string
        :param spec:      A string with reinstall spec
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:  A structure to override default goal settings.
        """
        ...

    def add_rpm_install(self, *args):
        r"""
        *Overload 1:*
        Add install request to the goal. The `spec` will be resolved to packages in the resolve() call. The operation will not
        result in a reinstall if the requested package is already installed. By default uses
        `clean_requirements_on_remove` set to `false`, which can be overridden in `settings`.

        :type spec: string
        :param spec:      A string describing the Goal install request.
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:  A structure to override default goal settings. The value `from_repo_ids` is not used.

        |

        *Overload 2:*
        Add install request to the goal. The operation will not result in a reinstall when requested package
        with the same NEVRA is already installed. By default uses `clean_requirements_on_remove` set to `false`.

        :type rpm_package: :py:class:`Package`
        :param rpm_package:      A package to be installed.
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:         A structure to override default goal settings. Only `strict`, `best`, and `clean_requirements_on_remove` are used.

        |

        *Overload 3:*
        Add install request to the goal. The operation will not result in a reinstall when requested package
        with the same NEVRA is already installed. By default uses `clean_requirements_on_remove` set to `false`.

        :type rpm_package: :py:class:`Package`
        :param rpm_package:      A package to be installed.
        :param settings:         A structure to override default goal settings. Only `strict`, `best`, and `clean_requirements_on_remove` are used.

        |

        *Overload 4:*
        Add install request to the goal. The operation will not result in a reinstall when requested package
        with the same NEVRA is already installed. By default uses `clean_requirements_on_remove` set to `false`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      A package_set containing candidates for the install action.
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:         A structure to override default goal settings. Only `strict`, `best`, and `clean_requirements_on_remove` are used.

        |

        *Overload 5:*
        Add install request to the goal. The operation will not result in a reinstall when requested package
        with the same NEVRA is already installed. By default uses `clean_requirements_on_remove` set to `false`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      A package_set containing candidates for the install action.
        :param settings:         A structure to override default goal settings. Only `strict`, `best`, and `clean_requirements_on_remove` are used.
        """
        ...

    def add_rpm_install_or_reinstall(self, *args):
        r"""
        *Overload 1:*
        Add install or reinstall request to the goal. By default uses `clean_requirements_on_remove` set to `false`.

        :type rpm_package: :py:class:`Package`
        :param rpm_package:      A package to be installed or reinstalled.
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:         A structure to override default goal settings. Only `strict`, `best`, and `clean_requirements_on_remove` are used.

        |

        *Overload 2:*
        Add install or reinstall request to the goal. By default uses `clean_requirements_on_remove` set to `false`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      A package_set containing candidates for the install or reinstall action.
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:         A structure to override default goal settings. Only `strict`, `best`, and `clean_requirements_on_remove` are used.

        |

        *Overload 3:*
        Add install or reinstall request to the goal. By default uses `clean_requirements_on_remove` set to `false`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      A package_set containing candidates for the install or reinstall action.
        :param settings:         A structure to override default goal settings. Only `strict`, `best`, and `clean_requirements_on_remove` are used.
        """
        ...

    def add_rpm_reinstall(self, *args):
        r"""
        *Overload 1:*
        Add reinstall request to the goal. The `spec` will be resolved to packages in the resolve() call. By default uses
        `clean_requirements_on_remove` set to `false`, which can be overridden in `settings`.

        :type spec: string
        :param spec:      A string describing the Goal reinstall request.
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:  A structure to override default goal settings. The value `from_repo_ids` is not used (not implemented yet).

        |

        *Overload 2:*
        Add reinstall request to the goal. By default uses `clean_requirements_on_remove` set to `false`.

        :type rpm_package: :py:class:`Package`
        :param rpm_package:      A package to be reinstalled.
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:  A structure to override default goal settings. Only `strict`, `best`, and `clean_requirements_on_remove` are used.

        |

        *Overload 3:*
        Add reinstall request to the goal. By default uses `clean_requirements_on_remove` set to `false`.

        :type rpm_package: :py:class:`Package`
        :param rpm_package:      A package to be reinstalled.
        :param settings:  A structure to override default goal settings. Only `strict`, `best`, and `clean_requirements_on_remove` are used.
        """
        ...

    def add_rpm_remove(self, *args):
        r"""
        *Overload 1:*
        Add remove request to the goal. The `spec` will be resolved to packages in the resolve() call. By default uses
        `clean_requirements_on_remove` according to ConfigMain, which can be overridden in `settings`.

        :type spec: string
        :param spec:      A string describing the Goal remove request.
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:  A structure to override default goal settings. Values `strict` and `best` are not used.

        |

        *Overload 2:*
        Add remove request to the goal. By default uses `clean_requirements_on_remove` value from ConfigMain,
        which can be overridden in `settings`.

        :type rpm_package: :py:class:`Package`
        :param rpm_package:      A package to be removed.
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:         A structure to override default goal settings. Only clean_requirements_on_remove is used.

        |

        *Overload 3:*
        Add remove request to the goal. By default uses `clean_requirements_on_remove` value from ConfigMain,
        which can be overridden in `settings`.

        :type rpm_package: :py:class:`Package`
        :param rpm_package:      A package to be removed.
        :param settings:         A structure to override default goal settings. Only clean_requirements_on_remove is used.

        |

        *Overload 4:*
        Add remove request to the goal. By default uses `clean_requirements_on_remove` value from ConfigMain,
        which can be overridden in `settings`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      A package_set containing packages that will be removed
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:         A structure to override default goal settings. Only `clean_requirements_on_remove` is used.

        |

        *Overload 5:*
        Add remove request to the goal. By default uses `clean_requirements_on_remove` value from ConfigMain,
        which can be overridden in `settings`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      A package_set containing packages that will be removed
        :param settings:         A structure to override default goal settings. Only `clean_requirements_on_remove` is used.
        """
        ...

    def add_rpm_upgrade(self, *args):
        r"""
        *Overload 1:*
        Add upgrade request to the goal. The `spec` will be resolved to packages in the resolve() call. By default uses
        `clean_requirements_on_remove` set to `false`, which can be overridden in `settings`.

        :type spec: string
        :param spec:      A string describing the Goal upgrade request.
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:  A structure to override default goal settings. Values  `from_repo_ids` and `strict` are not used.
        :type minimal: boolean, optional
        :param minimal:   Whether to do smallest possible upgrade

        |

        *Overload 2:*
        Add upgrade job of all installed packages to the goal if not limited in `settings`. By default uses
        `clean_requirements_on_remove` set to `false`, which can be overridden in `settings`.

        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:  A structure to override default goal settings. Values `from_repo_ids` and `strict` are not used.
        :type minimal: boolean, optional
        :param minimal:   Whether to do smallest possible upgrade

        |

        *Overload 3:*
        Add upgrade job of all installed packages to the goal if not limited in `settings`. By default uses
        `clean_requirements_on_remove` set to `false`, which can be overridden in `settings`.

        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:  A structure to override default goal settings. Values `from_repo_ids` and `strict` are not used.
        :param minimal:   Whether to do smallest possible upgrade

        |

        *Overload 4:*
        Add upgrade job of all installed packages to the goal if not limited in `settings`. By default uses
        `clean_requirements_on_remove` set to `false`, which can be overridden in `settings`.

        :param settings:  A structure to override default goal settings. Values `from_repo_ids` and `strict` are not used.
        :param minimal:   Whether to do smallest possible upgrade

        |

        *Overload 5:*
        Add upgrade request to the goal. By default uses `clean_requirements_on_remove` set to `false`,
        which can be overridden in `settings`.
        Supports obsoletes and architecture change to/from "noarch".

        :type rpm_package: :py:class:`Package`
        :param rpm_package:      A package that will be used as candidate for the upgrade action.
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:         A structure to override default goal settings. Only `clean_requirements_on_remove` and `best` values are used.
        :type minimal: boolean, optional
        :param minimal:          Whether to do smallest possible upgrade

        |

        *Overload 6:*
        Add upgrade request to the goal. By default uses `clean_requirements_on_remove` set to `false`,
        which can be overridden in `settings`.
        Supports obsoletes and architecture change to/from "noarch".

        :type rpm_package: :py:class:`Package`
        :param rpm_package:      A package that will be used as candidate for the upgrade action.
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:         A structure to override default goal settings. Only `clean_requirements_on_remove` and `best` values are used.
        :param minimal:          Whether to do smallest possible upgrade

        |

        *Overload 7:*
        Add upgrade request to the goal. By default uses `clean_requirements_on_remove` set to `false`,
        which can be overridden in `settings`.
        Supports obsoletes and architecture change to/from "noarch".

        :type rpm_package: :py:class:`Package`
        :param rpm_package:      A package that will be used as candidate for the upgrade action.
        :param settings:         A structure to override default goal settings. Only `clean_requirements_on_remove` and `best` values are used.
        :param minimal:          Whether to do smallest possible upgrade

        |

        *Overload 8:*
        Add upgrade request to the goal. By default uses `clean_requirements_on_remove` set to `false`,
        which can be overridden in `settings`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      A package_set containing candidates for the upgrade action.
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:         A structure to override default goal settings. Only `clean_requirements_on_remove` and `best` values are used.
        :type minimal: boolean, optional
        :param minimal:          Whether to do smallest possible upgrade

        |

        *Overload 9:*
        Add upgrade request to the goal. By default uses `clean_requirements_on_remove` set to `false`,
        which can be overridden in `settings`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      A package_set containing candidates for the upgrade action.
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:         A structure to override default goal settings. Only `clean_requirements_on_remove` and `best` values are used.
        :param minimal:          Whether to do smallest possible upgrade

        |

        *Overload 10:*
        Add upgrade request to the goal. By default uses `clean_requirements_on_remove` set to `false`,
        which can be overridden in `settings`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      A package_set containing candidates for the upgrade action.
        :param settings:         A structure to override default goal settings. Only `clean_requirements_on_remove` and `best` values are used.
        :param minimal:          Whether to do smallest possible upgrade
        """
        ...

    def add_rpm_downgrade(self, *args):
        r"""
        *Overload 1:*
        Add downgrade request to the goal. The `spec` will be resolved to packages in the resolve() call. By default uses
        `clean_requirements_on_remove` set to `false`, which can be overridden in `settings`.

        :type spec: string
        :param spec:      A string describing the Goal downgrade request.
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:  A structure to override default goal settings. The value `from_repo_ids` is not used.

        |

        *Overload 2:*
        Add downgrade request to the goal. By default uses `clean_requirements_on_remove` set to `false`,
        which can be overridden in `settings`.
        Ignores obsoletes. Only installed packages with the same name, architecture and higher version can be downgraded.
        Skips package if the same or lower version is installed.

        :type rpm_package: :py:class:`Package`
        :param rpm_package:      A package that will be used as candidate for the downgrade action.
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:         A structure to override default goal settings. Only `strict`, `best`, and `clean_requirements_on_remove` are used.

        |

        *Overload 3:*
        Add downgrade request to the goal. By default uses `clean_requirements_on_remove` set to `false`,
        which can be overridden in `settings`.
        Ignores obsoletes. Only installed packages with the same name, architecture and higher version can be downgraded.
        Skips package if the same or lower version is installed.

        :type rpm_package: :py:class:`Package`
        :param rpm_package:      A package that will be used as candidate for the downgrade action.
        :param settings:         A structure to override default goal settings. Only `strict`, `best`, and `clean_requirements_on_remove` are used.
        """
        ...

    def add_rpm_distro_sync(self, *args):
        r"""
        *Overload 1:*
        Add distrosync request to the goal. The `spec` will be resolved to packages in the resolve() call. By default uses
        `clean_requirements_on_remove` set to `false`, which can be overridden in `settings`.

        :type spec: string
        :param spec:      A string describing the Goal distrosync request.
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:  A structure to override default goal settings. The value `from_repo_ids` is not used.

        |

        *Overload 2:*
        Add distrosync job of all installed packages to the goal if not limited in `settings`. By default uses
        `clean_requirements_on_remove` set to `false`, which can be overridden in `settings`.

        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:  A structure to override default goal settings. Values `from_repo_ids` is not used.

        |

        *Overload 3:*
        Add distrosync job of all installed packages to the goal if not limited in `settings`. By default uses
        `clean_requirements_on_remove` set to `false`, which can be overridden in `settings`.

        :param settings:  A structure to override default goal settings. Values `from_repo_ids` is not used.

        |

        *Overload 4:*
        Add distrosync request to the goal. By default uses `clean_requirements_on_remove` set to `false`,
        which can be overridden in `settings`.

        :type rpm_package: :py:class:`Package`
        :param rpm_package:      A package hat will be used as candidate for the distrosync action.
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:         A structure to override default goal settings. Only `strict`, `best`, and `clean_requirements_on_remove` values are used.

        |

        *Overload 5:*
        Add distrosync request to the goal. By default uses `clean_requirements_on_remove` set to `false`,
        which can be overridden in `settings`.

        :type rpm_package: :py:class:`Package`
        :param rpm_package:      A package hat will be used as candidate for the distrosync action.
        :param settings:         A structure to override default goal settings. Only `strict`, `best`, and `clean_requirements_on_remove` values are used.

        |

        *Overload 6:*
        Add distrosync request to the goal. By default uses `clean_requirements_on_remove` set to `false`,
        which can be overridden in `settings`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      A package_set containing candidates for the distrosync action.
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:         A structure to override default goal settings. Only `strict`, `best`, and `clean_requirements_on_remove` values are used.

        |

        *Overload 7:*
        Add distrosync request to the goal. By default uses `clean_requirements_on_remove` set to `false`,
        which can be overridden in `settings`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      A package_set containing candidates for the distrosync action.
        :param settings:         A structure to override default goal settings. Only `strict`, `best`, and `clean_requirements_on_remove` values are used.
        """
        ...

    def add_rpm_reason_change(self, *args):
        r"""
        Add reason change request to the goal.

        :type spec: string
        :param spec:      A string describing the requested package
        :type reason: int
        :param reason:    New reason for the package
        :type group_id: string, optional
        :param group_id:  Id of group the package belongs to (only relevant in case the reason is GROUP)
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:  A structure to override default goal settings. Only ResolveSpecSettings values are used
        """
        ...

    def add_group_install(self, *args):
        r"""
        Add group install request to the goal. The `spec` will be resolved to groups in the resolve() call.
        Also packages of the types specified in setting.group_package_types be installed.

        :type spec: string
        :param spec:      A string describing the Goal group install request.
        :type reason: int
        :param reason:    Reason why the group is installed (USER/DEPENDENCY)
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:  A structure to override default goal settings.
        """
        ...

    def add_group_remove(self, *args):
        r"""
        Add group remove request to the goal. The `spec` will be resolved to groups in the resolve() call.
        Also packages not belonging to another group and not explicitly user-installed will get removed.

        :type spec: string
        :param spec:      A string describing the Goal group remove request.
        :type reason: int
        :param reason:    Reason why the group is removed.
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:  A structure to override default goal settings.
        """
        ...

    def add_group_upgrade(self, *args):
        r"""
        Add group upgrade request to the goal.
        Upgrades the packages from the group and upgrades the group itself. The
        latter  comprises of installing packages that were added to the group by
        the distribution and removing packages that got removed from  the  group
        as far as they were not installed explicitly by the user and are not required
        by any other installed package.

        :type spec: string
        :param spec:         A string with group specification
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:     A structure to override default goal settings.
        """
        ...

    def add_provide_install(self, *args):
        r"""
        Request to install providers of the `spec`. Useful to install package
        using rich dependencies.  The `spec` (e.g. "(depA and depB)") is not
        parsed but directly passed to the solver to install package(s) which
        provide the `spec`. Solver then creates a job like:
        "job install provides depA and depB".

        :type spec: string
        :param spec:      A string with libsolv relational dependency.
        :type settings: :py:class:`GoalJobSettings`, optional
        :param settings:  A structure to override default goal settings. The value `from_repo_ids` is not used.
        """
        ...

    def add_serialized_transaction(self, serialized_transaction, settings):
        r"""
        Warning: This method is experimental/unstable and should not be relied on. It may be removed without warning
        Add serialized transaction request to the goal. Only one serialized transaction can be added per goal.

        :param json_serialized_transaction:      A string of JSON serialized transaction
        :type settings: :py:class:`GoalJobSettings`
        :param settings:                         A structure to override default goal settings.
        """
        ...

    def set_allow_erasing(self, value):
        r"""When true it allows to remove installed packages to resolve dependency problems"""
        ...

    def get_allow_erasing(self):
        r"""Return the currets setting of allow_erasing"""
        ...

    def resolve(self):
        r"""
        Resolve all jobs and return a transaction object. Every time it resolves specs (strings) to packages

        :rtype: :py:class:`Transaction`
        :return: transaction object
        """
        ...

    def reset(self):
        r"""Clean all request from the Goal instance"""
        ...

    def get_base(self):
        r"""
        :rtype: :py:class:`BaseWeakPtr`
        :return: The `Base` object to which this object belongs.
        Since: 5.0
        """
        ...

ProblemRules_RULE_DISTUPGRADE = ...
ProblemRules_RULE_INFARCH = ...
ProblemRules_RULE_UPDATE = ...
ProblemRules_RULE_JOB = ...
ProblemRules_RULE_JOB_UNSUPPORTED = ...
ProblemRules_RULE_JOB_NOTHING_PROVIDES_DEP = ...
ProblemRules_RULE_JOB_UNKNOWN_PACKAGE = ...
ProblemRules_RULE_JOB_PROVIDED_BY_SYSTEM = ...
ProblemRules_RULE_PKG = ...
ProblemRules_RULE_BEST_1 = ...
ProblemRules_RULE_BEST_2 = ...
ProblemRules_RULE_PKG_NOT_INSTALLABLE_1 = ...
ProblemRules_RULE_PKG_NOT_INSTALLABLE_2 = ...
ProblemRules_RULE_PKG_NOT_INSTALLABLE_3 = ...
ProblemRules_RULE_PKG_NOT_INSTALLABLE_4 = ...
ProblemRules_RULE_PKG_NOTHING_PROVIDES_DEP = ...
ProblemRules_RULE_PKG_SAME_NAME = ...
ProblemRules_RULE_PKG_CONFLICTS = ...
ProblemRules_RULE_PKG_OBSOLETES = ...
ProblemRules_RULE_PKG_INSTALLED_OBSOLETES = ...
ProblemRules_RULE_PKG_IMPLICIT_OBSOLETES = ...
ProblemRules_RULE_PKG_REQUIRES = ...
ProblemRules_RULE_PKG_SELF_CONFLICT = ...
ProblemRules_RULE_YUMOBS = ...
ProblemRules_RULE_UNKNOWN = ...
ProblemRules_RULE_PKG_REMOVAL_OF_PROTECTED = ...
ProblemRules_RULE_PKG_REMOVAL_OF_RUNNING_KERNEL = ...
GoalProblem_NO_PROBLEM = ...
GoalProblem_SOLVER_ERROR = ...
GoalProblem_NOT_FOUND = ...
GoalProblem_EXCLUDED = ...
GoalProblem_ONLY_SRC = ...
GoalProblem_NOT_FOUND_IN_REPOSITORIES = ...
GoalProblem_NOT_INSTALLED = ...
GoalProblem_NOT_INSTALLED_FOR_ARCHITECTURE = ...
GoalProblem_HINT_ICASE = ...
GoalProblem_HINT_ALTERNATIVES = ...
GoalProblem_INSTALLED_LOWEST_VERSION = ...
GoalProblem_INSTALLED_IN_DIFFERENT_VERSION = ...
GoalProblem_NOT_AVAILABLE = ...
GoalProblem_ALREADY_INSTALLED = ...
GoalProblem_SOLVER_PROBLEM_STRICT_RESOLVEMENT = ...
GoalProblem_WRITE_DEBUG = ...
GoalProblem_UNSUPPORTED_ACTION = ...
GoalProblem_MULTIPLE_STREAMS = ...
GoalProblem_EXCLUDED_VERSIONLOCK = ...
GoalAction_INSTALL = ...
GoalAction_INSTALL_OR_REINSTALL = ...
GoalAction_INSTALL_VIA_PROVIDE = ...
GoalAction_INSTALL_BY_COMPS = ...
GoalAction_REINSTALL = ...
GoalAction_UPGRADE = ...
GoalAction_UPGRADE_MINIMAL = ...
GoalAction_UPGRADE_ALL = ...
GoalAction_UPGRADE_ALL_MINIMAL = ...
GoalAction_DISTRO_SYNC = ...
GoalAction_DISTRO_SYNC_ALL = ...
GoalAction_DOWNGRADE = ...
GoalAction_REMOVE = ...
GoalAction_RESOLVE = ...
GoalAction_REASON_CHANGE = ...
GoalAction_ENABLE = ...
GoalAction_DISABLE = ...
GoalAction_RESET = ...

def goal_action_to_string(action):
    r"""Convert GoalAction enum to user-readable string"""
    ...

GoalSetting_AUTO = ...
GoalSetting_SET_TRUE = ...
GoalSetting_SET_FALSE = ...
GoalUsedSetting_UNUSED = ...
GoalUsedSetting_USED_TRUE = ...
GoalUsedSetting_USED_FALSE = ...

class ResolveSpecSettings:
    thisown = ...
    __repr__ = ...
    ignore_case = ...
    with_nevra = ...
    with_provides = ...
    with_filenames = ...
    with_binaries = ...
    nevra_forms = ...
    group_with_id = ...
    group_with_name = ...
    group_search_groups = ...
    group_search_environments = ...
    def __init__(self) -> None: ...

    __swig_destroy__ = ...

class GoalJobSettings(ResolveSpecSettings):
    thisown = ...
    __repr__ = ...
    def get_used_skip_broken(self):
        r"""Return used value for skip_broken"""
        ...

    def get_used_skip_unavailable(self):
        r"""Return used value for skip_unavailable"""
        ...

    def get_used_best(self):
        r"""Return used value for best"""
        ...

    def get_used_clean_requirements_on_remove(self):
        r"""Return used value for clean_requirements_on_remove"""
        ...

    def set_advisory_filter(self, filter):
        r"""Optionally assign AdvisoryQuery that is used to filter goal target packages (used for upgrade and install)"""
        ...

    def get_advisory_filter(self): ...
    def set_group_package_types(self, type): ...
    def get_group_package_types(self): ...

    group_no_packages = ...
    report_hint = ...
    skip_broken = ...
    skip_unavailable = ...
    best = ...
    clean_requirements_on_remove = ...
    from_repo_ids = ...
    to_repo_ids = ...
    def __init__(self) -> None: ...

    __swig_destroy__ = ...

def __or__(lhs, rhs): ...
def __ior__(lhs, rhs): ...
def __and__(lhs, rhs): ...
