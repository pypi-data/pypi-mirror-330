"""
This type stub file was generated by pyright.
"""

from collections.abc import Iterator

from . import conf

if __package__ or "." in __name__:
    ...
else:
    ...

class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""

    __setattr__ = ...

class SwigPyIterator:
    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    __swig_destroy__ = ...
    def value(self): ...
    def incr(self, n=...): ...
    def decr(self, n=...): ...
    def distance(self, x): ...
    def equal(self, x): ...
    def copy(self): ...
    def next(self): ...
    def __next__(self): ...
    def previous(self): ...
    def advance(self, n): ...
    def __eq__(self, x) -> bool: ...
    def __ne__(self, x) -> bool: ...
    def __iadd__(self, n): ...
    def __isub__(self, n): ...
    def __add__(self, n): ...
    def __sub__(self, *args): ...
    def __iter__(self):  # -> Self:
        ...

class ConfigRepo(conf.Config):
    r"""Holds repo configuration options. Default values of some options are inherited from ConfigMain."""

    thisown = ...
    __repr__ = ...
    __swig_destroy__ = ...
    def __init__(self, *args) -> None: ...
    def get_main_config(self, *args): ...
    def get_id(self): ...
    def get_name_option(self, *args): ...
    def get_enabled_option(self, *args): ...
    def get_basecachedir_option(self, *args): ...
    def get_baseurl_option(self, *args): ...
    def get_mirrorlist_option(self, *args): ...
    def get_metalink_option(self, *args): ...
    def get_type_option(self, *args): ...
    def get_mediaid_option(self, *args): ...
    def get_gpgkey_option(self, *args): ...
    def get_excludepkgs_option(self, *args): ...
    def get_includepkgs_option(self, *args): ...
    def get_fastestmirror_option(self, *args): ...
    def get_proxy_option(self, *args): ...
    def get_proxy_username_option(self, *args): ...
    def get_proxy_password_option(self, *args): ...
    def get_proxy_auth_method_option(self, *args): ...
    def get_username_option(self, *args): ...
    def get_password_option(self, *args): ...
    def get_protected_packages_option(self, *args): ...
    def get_gpgcheck_option(self, *args): ...
    def get_repo_gpgcheck_option(self, *args): ...
    def get_enablegroups_option(self, *args): ...
    def get_retries_option(self, *args): ...
    def get_bandwidth_option(self, *args): ...
    def get_minrate_option(self, *args): ...
    def get_ip_resolve_option(self, *args): ...
    def get_throttle_option(self, *args): ...
    def get_timeout_option(self, *args): ...
    def get_max_parallel_downloads_option(self, *args): ...
    def get_metadata_expire_option(self, *args): ...
    def get_cost_option(self, *args): ...
    def get_priority_option(self, *args): ...
    def get_module_hotfixes_option(self, *args): ...
    def get_sslcacert_option(self, *args): ...
    def get_sslverify_option(self, *args): ...
    def get_sslclientcert_option(self, *args): ...
    def get_sslclientkey_option(self, *args): ...
    def get_proxy_sslcacert_option(self, *args): ...
    def get_proxy_sslverify_option(self, *args): ...
    def get_proxy_sslclientcert_option(self, *args): ...
    def get_proxy_sslclientkey_option(self, *args): ...
    def get_deltarpm_option(self, *args): ...
    def get_deltarpm_percentage_option(self, *args): ...
    def get_skip_if_unavailable_option(self, *args): ...
    def get_build_cache_option(self, *args): ...
    def get_enabled_metadata_option(self, *args): ...
    def get_user_agent_option(self, *args): ...
    def get_countme_option(self, *args): ...
    def get_failovermethod_option(self, *args): ...
    def get_unique_id(self):
        r"""
        :rtype: string
        :return: A unique ID of the repository, consisting of its id and a hash
            computed from its source URLs (metalink, mirrorlist or baseurl, first
            one set is used in the order listed).
        """
        ...

    def get_cachedir(self):
        r"""
        :rtype: string
        :return: The path to the repository's cache directory, where its
            cached metadata are stored.
        """
        ...

    def get_persistdir(self):
        r"""
        :rtype: string
        :return: The path to the repository's persistent directory, where its
            persistent data are stored.
        """
        ...

    def load_from_parser(self, *args): ...

class DownloadCallbacks:
    r"""
    Base class for download callbacks.
    To implement a callback, inherit from this class and override the virtual methods.
    """

    thisown = ...
    __repr__ = ...
    FastestMirrorStage_INIT = ...
    FastestMirrorStage_CACHELOADING = ...
    FastestMirrorStage_CACHELOADINGSTATUS = ...
    FastestMirrorStage_DETECTION = ...
    FastestMirrorStage_FINISHING = ...
    FastestMirrorStage_STATUS = ...
    TransferStatus_SUCCESSFUL = ...
    TransferStatus_ALREADYEXISTS = ...
    TransferStatus_ERROR = ...
    def __init__(self) -> None: ...

    __swig_destroy__ = ...
    def add_new_download(self, user_data, description, total_to_download):
        r"""
        Notify the client that a new download has been created.
        :type user_data: void
        :param user_data: User data entered together with url/package to download.
        :type description: string
        :param description: The message describing new download (url/packagename).
        :type total_to_download: float
        :param total_to_download: Total number of bytes to download.
        :rtype: void
        :return: Associated user data for new download.
        """
        ...

    def progress(self, user_cb_data, total_to_download, downloaded):
        r"""
        Download progress callback.
        :type user_cb_data: void
        :param user_cb_data: Associated user data obtained from add_new_download.
        :type total_to_download: float
        :param total_to_download: Total number of bytes to download.
        :type downloaded: float
        :param downloaded: Number of bytes downloaded.
        :rtype: int
        :return: TODO(lukash) uses the LrCbReturnCode enum from librepo, we should translate that.
        """
        ...

    def end(self, user_cb_data, status, msg):
        r"""
        End of download callback.
        :type user_cb_data: void
        :param user_cb_data: Associated user data obtained from add_new_download.
        :type status: int
        :param status: The transfer status.
        :type msg: string
        :param msg: The error message in case of error.
        :rtype: int
        :return: TODO(lukash) uses the LrCbReturnCode enum from librepo, we should translate that.
        """
        ...

    def mirror_failure(self, user_cb_data, msg, url, metadata):
        r"""
        Mirror failure callback.
        :type user_cb_data: void
        :param user_cb_data: Associated user data obtained from add_new_download.
        :type msg: string
        :param msg: Error message.
        :type url: string
        :param url: Failed mirror URL.
        :type metadata: string
        :param metadata: the type of metadata that is being downloaded TODO(lukash) should this point to LoadFlags in some way?
        :rtype: int
        :return: TODO(lukash) uses the LrCbReturnCode enum from librepo, we should translate that.
        """
        ...

    def fastest_mirror(self, user_cb_data, stage, ptr):
        r"""
        Callback for fastest mirror detection.
        :type user_cb_data: void
        :param user_cb_data: Associated user data obtained from new_download.
        :type stage: int
        :param stage: the stage of the fastest mirror detection, refer to `FastestMirrorStage`
        :type ptr: string
        :param ptr: pointer to additional data depending on the stage, refer to `FastestMirrorStage`
        """
        ...

    def __disown__(self):  # -> Any:
        ...

class DownloadCallbacksUniquePtr:
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...
    def __deref__(self): ...
    def release(self): ...
    def reset(self, __p=...): ...
    def swap(self, __u): ...
    def get(self): ...
    def __nonzero__(self): ...

    __bool__ = ...
    __swig_destroy__ = ...
    def add_new_download(self, user_data, description, total_to_download):
        r"""
        Notify the client that a new download has been created.
        :type user_data: void
        :param user_data: User data entered together with url/package to download.
        :type description: string
        :param description: The message describing new download (url/packagename).
        :type total_to_download: float
        :param total_to_download: Total number of bytes to download.
        :rtype: void
        :return: Associated user data for new download.
        """
        ...

    def progress(self, user_cb_data, total_to_download, downloaded):
        r"""
        Download progress callback.
        :type user_cb_data: void
        :param user_cb_data: Associated user data obtained from add_new_download.
        :type total_to_download: float
        :param total_to_download: Total number of bytes to download.
        :type downloaded: float
        :param downloaded: Number of bytes downloaded.
        :rtype: int
        :return: TODO(lukash) uses the LrCbReturnCode enum from librepo, we should translate that.
        """
        ...

    def end(self, user_cb_data, status, msg):
        r"""
        End of download callback.
        :type user_cb_data: void
        :param user_cb_data: Associated user data obtained from add_new_download.
        :type status: int
        :param status: The transfer status.
        :type msg: string
        :param msg: The error message in case of error.
        :rtype: int
        :return: TODO(lukash) uses the LrCbReturnCode enum from librepo, we should translate that.
        """
        ...

    def mirror_failure(self, user_cb_data, msg, url, metadata):
        r"""
        Mirror failure callback.
        :type user_cb_data: void
        :param user_cb_data: Associated user data obtained from add_new_download.
        :type msg: string
        :param msg: Error message.
        :type url: string
        :param url: Failed mirror URL.
        :type metadata: string
        :param metadata: the type of metadata that is being downloaded TODO(lukash) should this point to LoadFlags in some way?
        :rtype: int
        :return: TODO(lukash) uses the LrCbReturnCode enum from librepo, we should translate that.
        """
        ...

    def fastest_mirror(self, user_cb_data, stage, ptr):
        r"""
        Callback for fastest mirror detection.
        :type user_cb_data: void
        :param user_cb_data: Associated user data obtained from new_download.
        :type stage: int
        :param stage: the stage of the fastest mirror detection, refer to `FastestMirrorStage`
        :type ptr: string
        :param ptr: pointer to additional data depending on the stage, refer to `FastestMirrorStage`
        """
        ...

class FileDownloader:
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def add(self, *args):
        r"""
        *Overload 1:*
        Adds a file (URL) to download.
        :type repo: :py:class:`RepoWeakPtr`
        :param repo: The repository whose settings are to be used.
        :type url: string
        :param url: The file (url) to download.
        :type destination: string
        :param destination: The file path to which to download the file.
        :type user_data: void, optional
        :param user_data: User data.

        |

        *Overload 2:*
        Adds a file (URL) to download. The settings from ConfigMain passed in the FileDownloader constructor are used.
        :type url: string
        :param url: The file (url) to download.
        :type destination: string
        :param destination: The file path to which to download the file.
        :type user_data: void, optional
        :param user_data: User data.

        |

        *Overload 3:*
        Adds a file (URL) to download. The settings from ConfigMain passed in the FileDownloader constructor are used.
        :type url: string
        :param url: The file (url) to download.
        :type destination: string
        :param destination: The file path to which to download the file.
        :param user_data: User data.
        """
        ...

    def download(self):
        r"""Download the previously added files (URLs)."""
        ...

    def set_fail_fast(self, value):
        r"""
        Configure whether to fail the whole download on a first error or keep downloading.
        :type value: boolean
        :param value: If true, download will fail on the first error, otherwise it continues.
            This is set to true by default.
        """
        ...

    def set_resume(self, value):
        r"""
        Configure whether to try resuming the download if a destination package already exists.
        :type value: boolean
        :param value: If true, download is tried to be resumed, otherwise it starts over.
            This is set to true by default.
        """
        ...

class PackageDownloader:
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def add(self, *args):
        r"""
        *Overload 1:*
        Adds a package to download to the standard location of repo cachedir/packages.
        :type package: libdnf5::rpm::Package
        :param package: The package to download.
        :type user_data: void, optional
        :param user_data: User data.

        |

        *Overload 2:*
        Adds a package to download to a specific destination directory.
        :type package: libdnf5::rpm::Package
        :param package: The package to download.
        :type destination: string
        :param destination: The directory to which to download the package.
        :type user_data: void, optional
        :param user_data: User data.

        |

        *Overload 3:*
        Adds a package to download to a specific destination directory.
        :type package: libdnf5::rpm::Package
        :param package: The package to download.
        :type destination: string
        :param destination: The directory to which to download the package.
        :param user_data: User data.
        """
        ...

    def download(self):
        r"""Download the previously added packages."""
        ...

    def set_fail_fast(self, value):
        r"""
        Configure whether to fail the whole download on a first error or keep downloading.
        :type value: boolean
        :param value: If true, download will fail on the first error, otherwise it continues.
            This is set to true by default.
        """
        ...

    def set_resume(self, value):
        r"""
        Configure whether to try resuming the download if a destination package already exists.
        :type value: boolean
        :param value: If true, download is tried to be resumed, otherwise it starts over.
            This is set to true by default.
        """
        ...

    def force_keep_packages(self, value):
        r"""
        Explicitly setup the behavior related to packages caching.
        By default, the `keepcache` configuration option is used to determine whether to keep
        downloaded packages even after following successful transaction.

        :type value: boolean
        :param value: If true, packages will be kept on the disk after downloading
            regardless the `keepcache` option value, if false, it enforces packages removal after
            the next successful transaction.
        """
        ...

class RepoCacheRemoveStatistics:
    thisown = ...
    __repr__ = ...
    files_removed = ...
    dirs_removed = ...
    errors = ...
    def __iadd__(self, rhs): ...
    def __init__(self) -> None: ...

    __swig_destroy__ = ...

class RepoCache:
    r"""Repository cache management class."""

    thisown = ...
    __repr__ = ...
    ATTRIBUTE_EXPIRED = ...
    def __init__(self, *args) -> None:
        r"""
        *Overload 1:*
        Construct a new repository cache management instance.

        :type base: libdnf5::BaseWeakPtr
        :param base:            WeakPtr on the Base instance.
        :type repo_cache_dir: std::filesystem::path
        :param repo_cache_dir:  Path to repository cache directory.

        |

        *Overload 2:*
        Construct a new repository cache management instance.

        :type base: libdnf5::Base
        :param base:            Base instance reference.
        :type repo_cache_dir: string
        :param repo_cache_dir:  Path to repository cache directory.
        """
        ...

    def remove_metadata(self):
        r"""
        Removes metadata from the cache.

        :rtype: :py:class:`RemoveStatistics`
        :return: Number of deleted files and directories. Number of errors.
        """
        ...

    def remove_packages(self):
        r"""
        Removes packages from the cache.

        :rtype: :py:class:`RemoveStatistics`
        :return: Number of deleted files and directories. Number of errors.
        """
        ...

    def remove_solv_files(self):
        r"""
        Removes solvable files from the cache.

        :rtype: :py:class:`RemoveStatistics`
        :return: Number of deleted files and directories. Number of errors.
        """
        ...

    def remove_all(self):
        r"""
        Removes metadata, packages, solvable files, and attributes from the cache.
        If the repository cache directory becomes empty, it will also be deleted.

        :rtype: :py:class:`RemoveStatistics`
        :return: Number of deleted files and directories. Number of errors.
        """
        ...

    def write_attribute(self, *args):
        r"""
        Writes `value` to the` name` attribute.
        If the attribute does not exist, it is created. If it already existed, its value is overwritten.

        :type name: string
        :param name:   Attribute name.
        :type value: string, optional
        :param value:  Attribute value.
        :raises: std::runtime_exception  An error occurred while writing the attribute.
        """
        ...

    def read_attribute(self, name):
        r"""
        Returns the value of the `name` attribute.

        :type name: string
        :param name:  Attribute name.
        :rtype: string
        :return: The value of the `name` attribute.
        :raises: std::runtime_exception  The `name` attribute does not exist or an error occurred while reading it.
        """
        ...

    def is_attribute(self, name):
        r"""
        Tests if the `name` attribute exists.

        :type name: string
        :param name:  Attribute name.
        :rtype: boolean
        :return: If the `name` attribute exists, it returns true otherwise false.
        """
        ...

    def remove_attribute(self, name):
        r"""
        Removes the `name` attribute.

        :type name: string
        :param name:  Attribute name.
        :rtype: boolean
        :return: true if the attribute was deleted, false if the attribute did not exist.
        :raises: std::runtime_exception An error occurred while removing the attribute.
        """
        ...

    def get_repoid(self):
        r"""
        Gets the id of the cached repository.

        :rtype: string
        :return: id of the cached repository.
        :raises: RepoCacheException Throws an exception if the reposiitory id cannot be determined.
        """
        ...
    __swig_destroy__ = ...

class Repo:
    r"""
    RPM repository
    Represents a repository used to download packages.
    Remote metadata is cached locally.
    """

    thisown = ...
    __repr__ = ...
    Type_AVAILABLE = ...
    Type_SYSTEM = ...
    Type_COMMANDLINE = ...
    SyncStrategy_LAZY = ...
    SyncStrategy_ONLY_CACHE = ...
    SyncStrategy_TRY_CACHE = ...
    @staticmethod
    def verify_id(repo_id):
        r"""
        Verify repo ID
        :type repo_id: string
        :param repo_id: repo ID to verify
        :rtype: std::string::size_type
        :return: index of the first invalid character in the repo ID (if present) or std::string::npos
        """
        ...

    def __init__(self, *args) -> None:
        r"""
        *Overload 1:*
        Construct the Repo object
        :type base: libdnf5::BaseWeakPtr
        :param base:   weak pointer to the Base instance
        :type id: string
        :param id:     repo ID to use
        :type type: int, optional
        :param type:   type of repo

        |

        *Overload 2:*
        Construct the Repo object
        :type base: libdnf5::Base
        :param base:   a reference to the Base instance
        :type id: string
        :param id:     repo ID to use
        :type type: int, optional
        :param type:   type of repo

        |

        *Overload 3:*
        Construct the Repo object
        :type base: libdnf5::Base
        :param base:   a reference to the Base instance
        :type id: string
        :param id:     repo ID to use
        :param type:   type of repo
        """
        ...
    __swig_destroy__ = ...
    def get_type(self):
        r"""Returns the repository type"""
        ...

    def set_callbacks(self, callbacks):
        r"""Registers a class that implements callback methods (fastest mirror detection, download state, key import)."""
        ...

    def get_callbacks(self):
        r"""Returns the currently registered callbacks for the repo."""
        ...

    def set_user_data(self, user_data):
        r"""
        Sets the associated user data. These are used in callbacks.
        :type user_data: void
        :param user_data:  Pointer to user data
        """
        ...

    def get_user_data(self):
        r"""
        Gets the associated user data.
        :rtype: void
        :return: Pointer to user data
        """
        ...

    def verify(self):
        r"""
        Verify repo object configuration
        Will throw exception if Repo has no mirror or baseurl set or if Repo type is unsupported.
        """
        ...

    def get_config(self, *args):
        r"""
        *Overload 1:*
        Returns pointer to the repository configuration

        |

        *Overload 2:*
        Returns pointer to the repository configuration
        """
        ...

    def get_id(self):
        r"""Returns repository id"""
        ...

    def enable(self):
        r"""Enable the repository"""
        ...

    def disable(self):
        r"""Disable the repository"""
        ...

    def is_enabled(self):
        r"""
        Return whether the repository is enabled.
        :rtype: boolean
        :return: true if enabled
        """
        ...

    def is_local(self):
        r"""
        Return whether the repository is local.
        :rtype: boolean
        :return: true if local
        """
        ...

    def read_metadata_cache(self):
        r"""Reads metadata from local cache."""
        ...

    def is_in_sync(self):
        r"""
        Checks whether the locally downloaded metadata are in sync with the origin.
        :rtype: boolean
        :return: `true` if metadata are in sync with the origin, `false` otherwise.
        """
        ...

    def download_metadata(self, destdir):
        r"""
        Deprecated: It is going to be removed without a warning
        Downloads repository metadata.
        """
        ...

    def load(self):
        r"""
        Deprecated: It is going to be removed without a warning
        Loads the repository objects into sacks.

        Also writes the libsolv's solv/solvx cache files.
        """
        ...

    def load_extra_system_repo(self, rootdir):
        r"""
        Not API, unsupported
        Append a rpm database into the system repository. The type of the repo must be Type::SYSTEM.
        """
        ...

    def get_use_includes(self):
        r"""
        Returns whether the using of "includes" is enabled
        If enabled, only packages listed in the "includepkgs" will be used from the repository.
        """
        ...

    def set_use_includes(self, enabled):
        r"""
        Enables/disables using of "includes"
        If enabled, only packages listed in the "includepkgs" will be used from the repository.
        """
        ...

    def get_cost(self):
        r"""
        Returns repository cost
        TODO(jrohel): Remove it? It is only shortcut for get_config()->cost()->get_value()
        """
        ...

    def set_cost(self, *args):
        r"""
        Set repo cost in RepoConf and in Libsolv repo if attached. Values are only updated when Option::Priority
        of stored value is equal or lower.

        Version: 1.0.0
        :type value: int
        :param value: Cost value
        :type priority: int, optional
        :param priority: Optional argument
        """
        ...

    def get_priority(self):
        r"""
        Returns repository priority
        TODO(jrohel): Remove it? It is only shortcut for get_config()->cost()->get_value()
        """
        ...

    def set_priority(self, *args):
        r"""
        Set repo priority in RepoConf and in Libsolv repo if attached. Values are only updated when
        Option::Priority of stored value is equal or lower.

        Version: 1.0.0
        :type value: int
        :param value: Priority value
        :type priority: int, optional
        :param priority: Optional argument
        """
        ...

    def get_revision(self): ...
    def get_age(self):
        r"""Gets age of the local cache"""
        ...

    def get_metadata_path(self, metadata_type):
        r"""
        Return path to the particular downloaded repository metadata in cache
        :type metadata_type: string
        :param metadata_type: metadata type (filelists, other, productid...)
        :rtype: string
        :return: file path or empty string in case the requested metadata does not exist
        """
        ...

    def expire(self):
        r"""
        Mark whatever is in the current cache expired.
        This repo instance will always try to fetch a fresh metadata after this
        method is called.
        """
        ...

    def is_expired(self):
        r"""
        Return whether the cached metadata is expired.
        :rtype: boolean
        :return: bool
        """
        ...

    def get_expires_in(self):
        r"""
        Get the number of seconds after which the cached metadata will expire.
        Negative number means the metadata has expired already.
        :rtype: int
        :return: Seconds to expiration
        """
        ...

    def fresh(self):
        r"""Gets repository freshness"""
        ...

    def set_max_mirror_tries(self, max_mirror_tries): ...
    def get_timestamp(self):
        r"""Gets timestamp of metadata "primary" file"""
        ...

    def get_max_timestamp(self):
        r"""
        Gets the highest timestamp from repomd records
        TODO(jrohel): Used in DNF repolist: displayed as "Repo-updated time" base.py: "using metadata from" in debug messages Is it correct?
        """
        ...

    def set_preserve_remote_time(self, preserve_remote_time):
        r"""
        Try to preserve remote side timestamps
        When set to true the underlying librepo is asked to make an attempt to set the timestamps
        of the local downloaded files (repository metadata and packages) to match those from
        the remote files.
        This feature is by default switched off.
        :type preserve_remote_time: boolean
        :param preserve_remote_time: true - use remote file timestamp, false - use the current time
        """
        ...

    def get_preserve_remote_time(self): ...
    def get_content_tags(self):
        r"""TODO(jrohel): Used by DNF repolist. Do we need it?"""
        ...

    def get_distro_tags(self):
        r"""TODO(jrohel): Used by DNF repolist. Do we need it?"""
        ...

    def get_metadata_locations(self):
        r"""
        Get list of relative locations of metadata files inside the repo
        e.g. [('primary', 'repodata/primary.xml.gz'), ('filelists', 'repodata/filelists.xml.gz')...]
        :rtype: std::vector< std::pair< std::string,std::string >,std::allocator< std::pair< std::string,std::string > > >
        :return: vector of (metadata_type, location) string pairs
        """
        ...

    def get_cachedir(self):
        r"""Gets path to the repository cache directory"""
        ...

    def get_persistdir(self):
        r"""Gets path to the repository persistent directory"""
        ...

    def get_name(self):
        r"""
        Gets name of repository
        Alias
        """
        ...

    def set_repo_file_path(self, path):
        r"""Sets repository configuration file path"""
        ...

    def get_repo_file_path(self):
        r"""Gets repository configuration file path"""
        ...

    def set_sync_strategy(self, strategy):
        r"""Sets repository synchronisation strategy"""
        ...

    def get_sync_strategy(self):
        r"""Returns repository synchronisation strategy"""
        ...

    def set_http_headers(self, headers):
        r"""
        Downloads file from URL into given opened file descriptor.
        TODO(lukash) fd seems like an inconvenient API for this function, use target path instead?
                     It also needs defining what it means downloading an URL through a particular repo
        Set http headers.
        :type headers: std::vector< std::string,std::allocator< std::string > >
        :param headers: A vector of full headers ("header: value")
        """
        ...

    def get_http_headers(self):
        r"""
        Get http headers.
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of full headers ("header: value")
        """
        ...

    def get_mirrors(self):
        r"""
        Returns mirrorlist associated with the repository.
        Mirrors on this list are mirrors parsed from mirrorlist/metalink specified by LRO_MIRRORLIST or
        from mirrorlist specified by LRO_MIRROSLISTURL and metalink specified by LRO_METALINKURL.
        No URLs specified by LRO_URLS are included in this list.
        """
        ...

    def set_substitutions(self, substitutions):
        r"""
        Deprecated: It is redundant because repo class has direct access to Base and Vars
        Sets substitutions. Substitutions are used to substitute variables in repository configuration.
        """
        ...

    def add_libsolv_testcase(self, path):
        r"""
        Deprecated: It is going to be removed without a warning
        Not API, unsupported
        """
        ...

    def add_rpm_package(self, path, with_hdrid):
        r"""
        Deprecated: It is going to be removed without a warning
        Not API, unsupported
        Adds an RPM package at `path` to the repository.

        If `with_hdrid` is `true`, the RPM is loaded with the
        `RPM_ADD_WITH_HDRID | RPM_ADD_WITH_SHA256SUM` flags, meaning libsolv will
        calculate the SHA256 checksum of the RPM header and store it. This adds
        overhead but has the advantage of TODO(lukash) describe the advantage.
        :type path: string
        :param path: The path to the RPM file.
        :type with_hdrid: boolean
        :param with_hdrid: If true, libsolv calculates header checksum and stores it.
        :raises: RepoRpmError if the RPM file can't be read or is corrupted.
        :rtype: libdnf5::rpm::Package
        :return: PackageId of the added package.
        """
        ...

    def get_weak_ptr(self): ...
    def get_base(self):
        r"""
        :rtype: libdnf5::BaseWeakPtr
        :return: The `Base` object to which this object belongs.
        Since: 5.0
        """
        ...

    @staticmethod
    def type_to_string(type):
        r"""Return string representation of the Type enum"""
        ...

class RepoWeakPtr:
    r"""
    WeakPtr is a "smart" pointer. It contains a pointer to resource and to guard of resource.
    WeakPtr pointer can be owner of the resource. However, the resource itself may depend on another resource.
    WeakPtr registers/unregisters itself at the guard of resource. And the resource guard invalidates
    the registered WeakPtrs when the resource is unusable (eg. its dependecny was released).
    Note on thread safety:
    It is safe to create, access and destroy WeakPtrs in multiple threads simultaneously.
    """

    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def __deref__(self):
        r"""Provides access to the managed object. Generates exception if object is not valid."""
        ...

    def get(self):
        r"""Returns a pointer to the managed object. Generates exception if object is not valid."""
        ...

    def is_valid(self):
        r"""Checks if managed object is valid."""
        ...

    def has_same_guard(self, other):
        r"""Checks if the other WeakPtr instance has the same WeakPtrGuard."""
        ...

    def __ref__(self): ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def verify_id(self, repo_id):
        r"""
        Verify repo ID
        :type repo_id: string
        :param repo_id: repo ID to verify
        :rtype: std::string::size_type
        :return: index of the first invalid character in the repo ID (if present) or std::string::npos
        """
        ...

    def get_type(self):
        r"""Returns the repository type"""
        ...

    def set_callbacks(self, callbacks):
        r"""Registers a class that implements callback methods (fastest mirror detection, download state, key import)."""
        ...

    def get_callbacks(self):
        r"""Returns the currently registered callbacks for the repo."""
        ...

    def set_user_data(self, user_data):
        r"""
        Sets the associated user data. These are used in callbacks.
        :type user_data: void
        :param user_data:  Pointer to user data
        """
        ...

    def get_user_data(self):
        r"""
        Gets the associated user data.
        :rtype: void
        :return: Pointer to user data
        """
        ...

    def verify(self):
        r"""
        Verify repo object configuration
        Will throw exception if Repo has no mirror or baseurl set or if Repo type is unsupported.
        """
        ...

    def get_config(self, *args):
        r"""
        *Overload 1:*
        Returns pointer to the repository configuration

        |

        *Overload 2:*
        Returns pointer to the repository configuration
        """
        ...

    def get_id(self):
        r"""Returns repository id"""
        ...

    def enable(self):
        r"""Enable the repository"""
        ...

    def disable(self):
        r"""Disable the repository"""
        ...

    def is_enabled(self):
        r"""
        Return whether the repository is enabled.
        :rtype: boolean
        :return: true if enabled
        """
        ...

    def is_local(self):
        r"""
        Return whether the repository is local.
        :rtype: boolean
        :return: true if local
        """
        ...

    def read_metadata_cache(self):
        r"""Reads metadata from local cache."""
        ...

    def is_in_sync(self):
        r"""
        Checks whether the locally downloaded metadata are in sync with the origin.
        :rtype: boolean
        :return: `true` if metadata are in sync with the origin, `false` otherwise.
        """
        ...

    def download_metadata(self, destdir):
        r"""
        Deprecated: It is going to be removed without a warning
        Downloads repository metadata.
        """
        ...

    def load(self):
        r"""
        Deprecated: It is going to be removed without a warning
        Loads the repository objects into sacks.

        Also writes the libsolv's solv/solvx cache files.
        """
        ...

    def load_extra_system_repo(self, rootdir):
        r"""
        Not API, unsupported
        Append a rpm database into the system repository. The type of the repo must be Type::SYSTEM.
        """
        ...

    def get_use_includes(self):
        r"""
        Returns whether the using of "includes" is enabled
        If enabled, only packages listed in the "includepkgs" will be used from the repository.
        """
        ...

    def set_use_includes(self, enabled):
        r"""
        Enables/disables using of "includes"
        If enabled, only packages listed in the "includepkgs" will be used from the repository.
        """
        ...

    def get_cost(self):
        r"""
        Returns repository cost
        TODO(jrohel): Remove it? It is only shortcut for get_config()->cost()->get_value()
        """
        ...

    def set_cost(self, *args):
        r"""
        Set repo cost in RepoConf and in Libsolv repo if attached. Values are only updated when Option::Priority
        of stored value is equal or lower.

        Version: 1.0.0
        :type value: int
        :param value: Cost value
        :type priority: int, optional
        :param priority: Optional argument
        """
        ...

    def get_priority(self):
        r"""
        Returns repository priority
        TODO(jrohel): Remove it? It is only shortcut for get_config()->cost()->get_value()
        """
        ...

    def set_priority(self, *args):
        r"""
        Set repo priority in RepoConf and in Libsolv repo if attached. Values are only updated when
        Option::Priority of stored value is equal or lower.

        Version: 1.0.0
        :type value: int
        :param value: Priority value
        :type priority: int, optional
        :param priority: Optional argument
        """
        ...

    def get_revision(self): ...
    def get_age(self):
        r"""Gets age of the local cache"""
        ...

    def get_metadata_path(self, metadata_type):
        r"""
        Return path to the particular downloaded repository metadata in cache
        :type metadata_type: string
        :param metadata_type: metadata type (filelists, other, productid...)
        :rtype: string
        :return: file path or empty string in case the requested metadata does not exist
        """
        ...

    def expire(self):
        r"""
        Mark whatever is in the current cache expired.
        This repo instance will always try to fetch a fresh metadata after this
        method is called.
        """
        ...

    def is_expired(self):
        r"""
        Return whether the cached metadata is expired.
        :rtype: boolean
        :return: bool
        """
        ...

    def get_expires_in(self):
        r"""
        Get the number of seconds after which the cached metadata will expire.
        Negative number means the metadata has expired already.
        :rtype: int
        :return: Seconds to expiration
        """
        ...

    def fresh(self):
        r"""Gets repository freshness"""
        ...

    def set_max_mirror_tries(self, max_mirror_tries): ...
    def get_timestamp(self):
        r"""Gets timestamp of metadata "primary" file"""
        ...

    def get_max_timestamp(self):
        r"""
        Gets the highest timestamp from repomd records
        TODO(jrohel): Used in DNF repolist: displayed as "Repo-updated time" base.py: "using metadata from" in debug messages Is it correct?
        """
        ...

    def set_preserve_remote_time(self, preserve_remote_time):
        r"""
        Try to preserve remote side timestamps
        When set to true the underlying librepo is asked to make an attempt to set the timestamps
        of the local downloaded files (repository metadata and packages) to match those from
        the remote files.
        This feature is by default switched off.
        :type preserve_remote_time: boolean
        :param preserve_remote_time: true - use remote file timestamp, false - use the current time
        """
        ...

    def get_preserve_remote_time(self): ...
    def get_content_tags(self):
        r"""TODO(jrohel): Used by DNF repolist. Do we need it?"""
        ...

    def get_distro_tags(self):
        r"""TODO(jrohel): Used by DNF repolist. Do we need it?"""
        ...

    def get_metadata_locations(self):
        r"""
        Get list of relative locations of metadata files inside the repo
        e.g. [('primary', 'repodata/primary.xml.gz'), ('filelists', 'repodata/filelists.xml.gz')...]
        :rtype: std::vector< std::pair< std::string,std::string >,std::allocator< std::pair< std::string,std::string > > >
        :return: vector of (metadata_type, location) string pairs
        """
        ...

    def get_cachedir(self):
        r"""Gets path to the repository cache directory"""
        ...

    def get_persistdir(self):
        r"""Gets path to the repository persistent directory"""
        ...

    def get_name(self):
        r"""
        Gets name of repository
        Alias
        """
        ...

    def set_repo_file_path(self, path):
        r"""Sets repository configuration file path"""
        ...

    def get_repo_file_path(self):
        r"""Gets repository configuration file path"""
        ...

    def set_sync_strategy(self, strategy):
        r"""Sets repository synchronisation strategy"""
        ...

    def get_sync_strategy(self):
        r"""Returns repository synchronisation strategy"""
        ...

    def set_http_headers(self, headers):
        r"""
        Downloads file from URL into given opened file descriptor.
        TODO(lukash) fd seems like an inconvenient API for this function, use target path instead?
                     It also needs defining what it means downloading an URL through a particular repo
        Set http headers.
        :type headers: std::vector< std::string,std::allocator< std::string > >
        :param headers: A vector of full headers ("header: value")
        """
        ...

    def get_http_headers(self):
        r"""
        Get http headers.
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A vector of full headers ("header: value")
        """
        ...

    def get_mirrors(self):
        r"""
        Returns mirrorlist associated with the repository.
        Mirrors on this list are mirrors parsed from mirrorlist/metalink specified by LRO_MIRRORLIST or
        from mirrorlist specified by LRO_MIRROSLISTURL and metalink specified by LRO_METALINKURL.
        No URLs specified by LRO_URLS are included in this list.
        """
        ...

    def set_substitutions(self, substitutions):
        r"""
        Deprecated: It is redundant because repo class has direct access to Base and Vars
        Sets substitutions. Substitutions are used to substitute variables in repository configuration.
        """
        ...

    def add_libsolv_testcase(self, path):
        r"""
        Deprecated: It is going to be removed without a warning
        Not API, unsupported
        """
        ...

    def add_rpm_package(self, path, with_hdrid):
        r"""
        Deprecated: It is going to be removed without a warning
        Not API, unsupported
        Adds an RPM package at `path` to the repository.

        If `with_hdrid` is `true`, the RPM is loaded with the
        `RPM_ADD_WITH_HDRID | RPM_ADD_WITH_SHA256SUM` flags, meaning libsolv will
        calculate the SHA256 checksum of the RPM header and store it. This adds
        overhead but has the advantage of TODO(lukash) describe the advantage.
        :type path: string
        :param path: The path to the RPM file.
        :type with_hdrid: boolean
        :param with_hdrid: If true, libsolv calculates header checksum and stores it.
        :raises: RepoRpmError if the RPM file can't be read or is corrupted.
        :rtype: libdnf5::rpm::Package
        :return: PackageId of the added package.
        """
        ...

    def get_weak_ptr(self): ...
    def get_base(self):
        r"""
        :rtype: libdnf5::BaseWeakPtr
        :return: The `Base` object to which this object belongs.
        Since: 5.0
        """
        ...

    def type_to_string(self, type):
        r"""Return string representation of the Type enum"""
        ...

class SetConstIteratorRepoWeakPtr:
    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    def value(self): ...
    def next(self): ...
    def prev(self): ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...

    __swig_destroy__ = ...

class SetRepoWeakPtr:
    r"""
    Set represents set of objects (e.g. repositories, or groups)
    and implements set operations such as unions or differences.
    """

    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    __swig_destroy__ = ...
    def empty(self): ...
    def size(self): ...
    def clear(self): ...
    def add(self, *args): ...
    def remove(self, obj): ...
    def find(self, obj): ...
    def contains(self, obj): ...
    def __ior__(self, other): ...
    def __iand__(self, other): ...
    def __isub__(self, other): ...
    def __ixor__(self, other): ...
    def update(self, other): ...
    def intersection(self, other): ...
    def difference(self, other): ...
    def symmetric_difference(self, other): ...
    def is_subset(self, other): ...
    def is_superset(self, other): ...
    def swap(self, other): ...
    def get_data(self, *args): ...
    def begin(self): ...
    def end(self): ...
    def __len__(self): ...

def __eq__(*args) -> bool: ...

class SackQueryRepoWeakPtr(SetRepoWeakPtr):
    r"""Query is a Set with filtering capabilities."""

    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...
    def filter(self, *args): ...
    def get(self):
        r"""Get a single object. Raise an exception if none or multiple objects match the query."""
        ...

    def list(self):
        r"""List all objects matching the query."""
        ...

    def __iter__(self) -> Iterator[Repo]: ...
    __swig_destroy__ = ...

class RepoCallbacks:
    r"""
    Base class for repository callbacks.
    To implement callbacks, inherit from this class and override virtual methods.
    """

    thisown = ...
    __repr__ = ...
    def __init__(self) -> None: ...

    __swig_destroy__ = ...
    def repokey_import(self, key_info):
        r"""
        GPG key import callback. Allows to confirm or deny the import.
        :type key_info: libdnf5::rpm::KeyInfo
        :param key_info: The key that is about to be imported
        :rtype: boolean
        :return: `true` to import the key, `false` to not import
        """
        ...

    def repokey_imported(self, key_info):
        r"""
        Called on successful repo key import.
        :type key_info: libdnf5::rpm::KeyInfo
        :param key_info: The key that was successfully imported
        """
        ...

    def __disown__(self):  # -> Any:
        ...

class RepoCallbacksUniquePtr:
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...
    def __deref__(self): ...
    def release(self): ...
    def reset(self, __p=...): ...
    def swap(self, __u): ...
    def get(self): ...
    def __nonzero__(self): ...

    __bool__ = ...
    __swig_destroy__ = ...
    def repokey_import(self, key_info):
        r"""
        GPG key import callback. Allows to confirm or deny the import.
        :type key_info: libdnf5::rpm::KeyInfo
        :param key_info: The key that is about to be imported
        :rtype: boolean
        :return: `true` to import the key, `false` to not import
        """
        ...

    def repokey_imported(self, key_info):
        r"""
        Called on successful repo key import.
        :type key_info: libdnf5::rpm::KeyInfo
        :param key_info: The key that was successfully imported
        """
        ...

class RepoQuery(SackQueryRepoWeakPtr):
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        *Overload 1:*
        Create a new RepoQuery instance.

        :type base: libdnf5::BaseWeakPtr
        :param base:     A weak pointer to Base

        |

        *Overload 2:*
        Create a new RepoQuery instance.

        :type base: libdnf5::Base
        :param base:     Reference to Base
        """
        ...

    def get_base(self):
        r"""
        :rtype: libdnf5::BaseWeakPtr
        :return: Weak pointer to the Base object.
        Since: 5.0
        """
        ...

    def filter_enabled(self, enabled):
        r"""
        Filter repos by their `enabled` state.

        :type enabled: boolean
        :param enabled:  A boolean value the filter is matched against.
        Since: 5.0
        """
        ...

    def filter_expired(self, expired):
        r"""
        Filter repos by their `expired` state.

        :type expired: boolean
        :param expired:  A boolean value the filter is matched against.
        Since: 5.0
        """
        ...

    def filter_id(self, *args):
        r"""
        *Overload 1:*
        Filter repos by their `id`.

        :type pattern: string
        :param pattern:  A string the filter is matched against.
        :type cmp: int, optional
        :param cmp:      A comparison (match) operator, defaults to `QueryCmp::EQ`.
        Since: 5.0

        |

        *Overload 2:*
        Filter repos by their `id`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns: A vector of strings the filter is matched against.
        :type cmp: int, optional
        :param cmp:      A comparison (match) operator, defaults to `QueryCmp::EQ`.
        Since: 5.0

        |

        *Overload 3:*
        Filter repos by their `id`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns: A vector of strings the filter is matched against.
        :param cmp:      A comparison (match) operator, defaults to `QueryCmp::EQ`.
        Since: 5.0
        """
        ...

    def filter_local(self, local):
        r"""
        Filter repositories by whether they are local

        :type local: boolean
        :param local:  `true` returns local repos, `false` remote repos.
        Since: 5.0
        """
        ...

    def filter_name(self, *args):
        r"""
        *Overload 1:*
        Filter repos by their `name`.

        :type pattern: string
        :param pattern:  A string the filter is matched against.
        :type cmp: int, optional
        :param cmp:      A comparison (match) operator, defaults to `QueryCmp::EQ`.
        Since: 5.0

        |

        *Overload 2:*
        Filter repos by their `name`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns: A vector of strings the filter is matched against.
        :type cmp: int, optional
        :param cmp:      A comparison (match) operator, defaults to `QueryCmp::EQ`.
        Since: 5.0

        |

        *Overload 3:*
        Filter repos by their `name`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns: A vector of strings the filter is matched against.
        :param cmp:      A comparison (match) operator, defaults to `QueryCmp::EQ`.
        Since: 5.0
        """
        ...

    def filter_type(self, *args):
        r"""
        Filter repos by their `type`.

        :type type: int
        :param type:     A type the filter is matched against.
        :type cmp: int, optional
        :param cmp:      A comparison (match) operator, defaults to `QueryCmp::EQ`.
        Since: 5.0
        """
        ...
    __swig_destroy__ = ...

class SackRepoRepoQuery:
    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    def size(self): ...
    def get_excludes(self): ...
    def add_excludes(self, value): ...
    def remove_excludes(self, value): ...
    def set_excludes(self, value): ...
    def get_includes(self): ...
    def add_includes(self, value): ...
    def remove_includes(self, value): ...
    def set_includes(self, value): ...
    def get_use_includes(self): ...
    def set_use_includes(self, value): ...

    __swig_destroy__ = ...

class RepoSack(SackRepoRepoQuery):
    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    def create_repo(self, id):
        r"""
        Creates a new clear repository with default configuration.
        :type id: string
        :param id: The new repo id
        :rtype: :py:class:`RepoWeakPtr`
        :return: A weak pointer to the new repo
        """
        ...

    def create_repos_from_file(self, path):
        r"""
        Creates new repositories from the configuration file at `path`.
        :type path: string
        :param path: The path to the repository configuration file
        """
        ...

    def create_repos_from_config_file(self):
        r"""
        Creates new repositories from the Base's configuration file (the
        "config_file_path" configuration option).

        Repositories can be configured in dnf's main configuration file in
        sections other than "[main]".
        """
        ...

    def create_repos_from_dir(self, dir_path):
        r"""
        Creates new repositories from all configuration files with the ".repo"
        extension in the `dir_path` directory.

        The files in the directory are read in alphabetical order.
        :type dir_path: string
        :param dir_path: The path to the directory with configuration files
        """
        ...

    def create_repos_from_reposdir(self):
        r"""
        Creates new repositories from all configuration files with ".repo" extension in the directories
        defined by the "reposdir" configuration option.

        The files in the directories are read in alphabetical order.
        """
        ...

    def create_repos_from_paths(self, repos_paths, priority):
        r"""
        Create new repositories from ids and paths.
        :type repos_paths: std::vector< std::pair< std::string,std::string >,std::allocator< std::pair< std::string,std::string > > >
        :param repos_paths: Vector of <ID,PATH> pairs. The "baseurl" parameter of the new repo is set to the PATH, "name" and "id" to the ID. Both values can be enriched by the repository variables which are substituted before creating the repo.
        :type priority: int
        :param priority: Priority with which the name and baseurl attributes of the new repo are set.
        """
        ...

    def create_repos_from_system_configuration(self):
        r"""
        Creates new repositories from the Base's configuration file (the /
        "config_file_path" configuration option) and from directories defined by
        the "reposdir" configuration option. Repository overrides are then applied.

        Calls `create_repos_from_config_file()`, `create_repos_from_reposdir()`,
        and loads repository configuration overrides.
        """
        ...

    def create_repo_from_libsolv_testcase(self, id, path):
        r"""
        Creates a new repository from a libsolv testcase file.
        :type id: string
        :param id: The new repo id
        :type path: string
        :param path: The path to the libsolv testcase file
        :rtype: :py:class:`RepoWeakPtr`
        :return: A weak pointer to the new repo
        """
        ...

    def get_system_repo(self):
        r"""
        If not created yet, creates the system repository and returns it.
        :rtype: :py:class:`RepoWeakPtr`
        :return: The system repository.
        """
        ...

    def add_cmdline_packages(self, paths, calculate_checksum=...):
        r"""
        Add given paths to comdline repository.
        :type paths: std::vector< std::string,std::allocator< std::string > >
        :param paths: Vector of paths to rpm files to be inserted to cmdline repo. Can contain paths to local files or URLs of remote rpm files. Specifications that are neither file paths, nor URLs are ignored.
        :type calculate_checksum: boolean, optional
        :param calculate_checksum: Whether libsolv should calculate and store checksum of added packages. Setting to true significantly reduces performance.
        :rtype: std::map< std::string,libdnf5::rpm::Package,std::less< std::string >,std::allocator< std::pair< std::string const,libdnf5::rpm::Package > > >
        :return: Map path->rpm::Package which maps input path to newly created Package object in cmdline repo
        """
        ...

    def has_system_repo(self):
        r"""
        :rtype: boolean
        :return: `true` if the system repository has been initialized (via `get_system_repo()`).
        """
        ...

    def has_cmdline_repo(self):
        r"""
        :rtype: boolean
        :return: `true` if the command line repository has been initialized (via `get_cmdline_repo()`).
        """
        ...

    def dump_debugdata(self, dir):
        r"""
        Dumps libsolv's rpm debugdata of all loaded repositories.
        :type dir: string
        :param dir: The directory into which to dump the debugdata.
        """
        ...

    def dump_comps_debugdata(self, dir):
        r"""
        Dumps libsolv's comps debugdata of all loaded repositories.
        :type dir: string
        :param dir: The directory into which to dump the debugdata.
        """
        ...

    def update_and_load_enabled_repos(self, load_system):
        r"""
        Downloads (if necessary) all enabled repository metadata and loads them in parallel.

        See `update_and_load_repos()`, which is called on the list of enabled
        repos and, if requested, the system repository.

        :type load_system: boolean
        :param load_system: Whether to load the system repository
        """
        ...

    def update_and_load_repos(self, repos, import_keys=...):
        r"""
        Warning: This method is experimental/unstable and should not be relied on. It may be removed without warning

        Downloads (if necessary) repository metadata and loads them in parallel.

        Launches a thread that picks repos from a queue and loads them into
        memory (calling their `load()` method). Then iterates over `repos`,
        potentially downloads fresh metadata (by calling the
        `download_metadata()` method) and then queues them for loading. This
        speeds up the process by loading repos into memory while others are being
        downloaded.

        :type repos: :py:class:`RepoQuery`
        :param repos: The repositories to update and load
        :type import_keys: boolean, optional
        :param import_keys: If true, attempts to download and import keys for repositories that failed key validation
        """
        ...

    def get_weak_ptr(self): ...
    def get_base(self):
        r"""
        :rtype: libdnf5::BaseWeakPtr
        :return: The `Base` object to which this object belongs.
        Since: 5.0
        """
        ...

    def enable_source_repos(self):
        r"""
        For each enabled repository enable corresponding source repository.
        Since: 5.0
        """
        ...

    def fix_group_missing_xml(self):
        r"""
        Re-create missing xml definitions for installed groups. Since we do not have
        the state of the group in time of installation, current definition from
        available repositories is going to be used.
        In case the repo does not exist in repositories, only the minimal solvables
        are created from info in system state.
        """
        ...
    __swig_destroy__ = ...

class RepoSackWeakPtr:
    r"""
    WeakPtr is a "smart" pointer. It contains a pointer to resource and to guard of resource.
    WeakPtr pointer can be owner of the resource. However, the resource itself may depend on another resource.
    WeakPtr registers/unregisters itself at the guard of resource. And the resource guard invalidates
    the registered WeakPtrs when the resource is unusable (eg. its dependecny was released).
    Note on thread safety:
    It is safe to create, access and destroy WeakPtrs in multiple threads simultaneously.
    """

    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def __deref__(self):
        r"""Provides access to the managed object. Generates exception if object is not valid."""
        ...

    def get(self):
        r"""Returns a pointer to the managed object. Generates exception if object is not valid."""
        ...

    def is_valid(self):
        r"""Checks if managed object is valid."""
        ...

    def has_same_guard(self, other):
        r"""Checks if the other WeakPtr instance has the same WeakPtrGuard."""
        ...

    def __ref__(self): ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def create_repo(self, id):
        r"""
        Creates a new clear repository with default configuration.
        :type id: string
        :param id: The new repo id
        :rtype: :py:class:`RepoWeakPtr`
        :return: A weak pointer to the new repo
        """
        ...

    def create_repos_from_file(self, path):
        r"""
        Creates new repositories from the configuration file at `path`.
        :type path: string
        :param path: The path to the repository configuration file
        """
        ...

    def create_repos_from_config_file(self):
        r"""
        Creates new repositories from the Base's configuration file (the
        "config_file_path" configuration option).

        Repositories can be configured in dnf's main configuration file in
        sections other than "[main]".
        """
        ...

    def create_repos_from_dir(self, dir_path):
        r"""
        Creates new repositories from all configuration files with the ".repo"
        extension in the `dir_path` directory.

        The files in the directory are read in alphabetical order.
        :type dir_path: string
        :param dir_path: The path to the directory with configuration files
        """
        ...

    def create_repos_from_reposdir(self):
        r"""
        Creates new repositories from all configuration files with ".repo" extension in the directories
        defined by the "reposdir" configuration option.

        The files in the directories are read in alphabetical order.
        """
        ...

    def create_repos_from_paths(self, repos_paths, priority):
        r"""
        Create new repositories from ids and paths.
        :type repos_paths: std::vector< std::pair< std::string,std::string >,std::allocator< std::pair< std::string,std::string > > >
        :param repos_paths: Vector of <ID,PATH> pairs. The "baseurl" parameter of the new repo is set to the PATH, "name" and "id" to the ID. Both values can be enriched by the repository variables which are substituted before creating the repo.
        :type priority: int
        :param priority: Priority with which the name and baseurl attributes of the new repo are set.
        """
        ...

    def create_repos_from_system_configuration(self):
        r"""
        Creates new repositories from the Base's configuration file (the /
        "config_file_path" configuration option) and from directories defined by
        the "reposdir" configuration option. Repository overrides are then applied.

        Calls `create_repos_from_config_file()`, `create_repos_from_reposdir()`,
        and loads repository configuration overrides.
        """
        ...

    def create_repo_from_libsolv_testcase(self, id, path):
        r"""
        Creates a new repository from a libsolv testcase file.
        :type id: string
        :param id: The new repo id
        :type path: string
        :param path: The path to the libsolv testcase file
        :rtype: :py:class:`RepoWeakPtr`
        :return: A weak pointer to the new repo
        """
        ...

    def get_system_repo(self):
        r"""
        If not created yet, creates the system repository and returns it.
        :rtype: :py:class:`RepoWeakPtr`
        :return: The system repository.
        """
        ...

    def add_cmdline_packages(self, paths, calculate_checksum=...):
        r"""
        Add given paths to comdline repository.
        :type paths: std::vector< std::string,std::allocator< std::string > >
        :param paths: Vector of paths to rpm files to be inserted to cmdline repo. Can contain paths to local files or URLs of remote rpm files. Specifications that are neither file paths, nor URLs are ignored.
        :type calculate_checksum: boolean, optional
        :param calculate_checksum: Whether libsolv should calculate and store checksum of added packages. Setting to true significantly reduces performance.
        :rtype: std::map< std::string,libdnf5::rpm::Package,std::less< std::string >,std::allocator< std::pair< std::string const,libdnf5::rpm::Package > > >
        :return: Map path->rpm::Package which maps input path to newly created Package object in cmdline repo
        """
        ...

    def has_system_repo(self):
        r"""
        :rtype: boolean
        :return: `true` if the system repository has been initialized (via `get_system_repo()`).
        """
        ...

    def has_cmdline_repo(self):
        r"""
        :rtype: boolean
        :return: `true` if the command line repository has been initialized (via `get_cmdline_repo()`).
        """
        ...

    def dump_debugdata(self, dir):
        r"""
        Dumps libsolv's rpm debugdata of all loaded repositories.
        :type dir: string
        :param dir: The directory into which to dump the debugdata.
        """
        ...

    def dump_comps_debugdata(self, dir):
        r"""
        Dumps libsolv's comps debugdata of all loaded repositories.
        :type dir: string
        :param dir: The directory into which to dump the debugdata.
        """
        ...

    def update_and_load_enabled_repos(self, load_system):
        r"""
        Downloads (if necessary) all enabled repository metadata and loads them in parallel.

        See `update_and_load_repos()`, which is called on the list of enabled
        repos and, if requested, the system repository.

        :type load_system: boolean
        :param load_system: Whether to load the system repository
        """
        ...

    def update_and_load_repos(self, repos, import_keys=...):
        r"""
        Warning: This method is experimental/unstable and should not be relied on. It may be removed without warning

        Downloads (if necessary) repository metadata and loads them in parallel.

        Launches a thread that picks repos from a queue and loads them into
        memory (calling their `load()` method). Then iterates over `repos`,
        potentially downloads fresh metadata (by calling the
        `download_metadata()` method) and then queues them for loading. This
        speeds up the process by loading repos into memory while others are being
        downloaded.

        :type repos: :py:class:`RepoQuery`
        :param repos: The repositories to update and load
        :type import_keys: boolean, optional
        :param import_keys: If true, attempts to download and import keys for repositories that failed key validation
        """
        ...

    def get_weak_ptr(self): ...
    def get_base(self):
        r"""
        :rtype: libdnf5::BaseWeakPtr
        :return: The `Base` object to which this object belongs.
        Since: 5.0
        """
        ...

    def enable_source_repos(self):
        r"""
        For each enabled repository enable corresponding source repository.
        Since: 5.0
        """
        ...

    def fix_group_missing_xml(self):
        r"""
        Re-create missing xml definitions for installed groups. Since we do not have
        the state of the group in time of installation, current definition from
        available repositories is going to be used.
        In case the repo does not exist in repositories, only the minimal solvables
        are created from info in system state.
        """
        ...

    def size(self): ...
    def get_excludes(self): ...
    def add_excludes(self, value): ...
    def remove_excludes(self, value): ...
    def set_excludes(self, value): ...
    def get_includes(self): ...
    def add_includes(self, value): ...
    def remove_includes(self, value): ...
    def set_includes(self, value): ...
    def get_use_includes(self): ...
    def set_use_includes(self, value): ...
