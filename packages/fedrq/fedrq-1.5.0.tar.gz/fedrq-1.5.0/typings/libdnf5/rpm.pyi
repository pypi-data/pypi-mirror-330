"""
This type stub file was generated by pyright.
"""

from __future__ import annotations

from collections.abc import Iterator

if __package__ or "." in __name__:
    ...
else:
    ...

class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""

    __setattr__ = ...

class SwigPyIterator:
    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    __swig_destroy__ = ...
    def value(self): ...
    def incr(self, n=...): ...
    def decr(self, n=...): ...
    def distance(self, x): ...
    def equal(self, x): ...
    def copy(self): ...
    def next(self): ...
    def __next__(self): ...
    def previous(self): ...
    def advance(self, n): ...
    def __eq__(self, x) -> bool: ...
    def __ne__(self, x) -> bool: ...
    def __iadd__(self, n): ...
    def __isub__(self, n): ...
    def __add__(self, n): ...
    def __sub__(self, *args): ...
    def __iter__(self):  # -> Self:
        ...

def get_supported_arches():
    r"""Returns a list of architectures supported by libdnf5."""
    ...

def get_base_arch(arch):
    r"""
    Returns base architecture of the given `arch`. In case the base arch is not
    found the function returns empty string.
    :type arch: string
    :param arch: Architecture.
    """
    ...

class Checksum:
    r"""Class contains checksum and checksum type"""

    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    Type_UNKNOWN = ...
    Type_MD5 = ...
    Type_SHA1 = ...
    Type_SHA224 = ...
    Type_SHA256 = ...
    Type_SHA384 = ...
    Type_SHA512 = ...
    def get_type(self): ...
    def get_type_str(self): ...
    def get_checksum(self):
        r"""Return checksum in hex format"""
        ...
    __swig_destroy__ = ...

class Nevra:
    thisown = ...
    __repr__ = ...
    Form_NEVRA = ...
    Form_NEVR = ...
    Form_NEV = ...
    Form_NA = ...
    Form_NAME = ...
    @staticmethod
    def get_default_pkg_spec_forms():
        r"""The default forms and their order determine pkg_spec matching"""
        ...

    @staticmethod
    def parse(*args):
        r"""
        *Overload 1:*
        Parse string into Nevra struct
        :type nevra_str: string
        :param nevra_str: String to parse
        :rtype: std::vector< libdnf5::rpm::Nevra,std::allocator< libdnf5::rpm::Nevra > >
        :return: Vector with parsed Nevra
        :raises: IncorrectNevraString
        Since: - 1.0.0

        |

        *Overload 2:*
        Parse string into Nevra struct using given forms
        :type nevra_str: string
        :param nevra_str: String to parse
        :type forms: std::vector< libdnf5::rpm::Nevra::Form,std::allocator< libdnf5::rpm::Nevra::Form > >
        :param forms: Allowed forms used for parsing
        :rtype: std::vector< libdnf5::rpm::Nevra,std::allocator< libdnf5::rpm::Nevra > >
        :return: Vector with parsed Nevra
        :raises: IncorrectNevraString
        """
        ...

    def __init__(self, *args) -> None: ...
    def __eq__(self, other) -> bool:
        r"""
        :rtype: boolean
        :return: `true` if all Nevra attributes (`name`, `epoch`, `version`, `release` and `arch`) match.
        """
        ...

    def clear(self):
        r"""Returns false when parsing failed and stored data are in inconsistency state."""
        ...

    def get_name(self): ...
    def get_epoch(self): ...
    def get_version(self): ...
    def get_release(self): ...
    def get_arch(self): ...
    def set_name(self, *args): ...
    def set_epoch(self, *args): ...
    def set_version(self, *args): ...
    def set_release(self, *args): ...
    def set_arch(self, *args): ...
    def has_just_name(self): ...

    __swig_destroy__ = ...

def __lshift__(out, nevra): ...
def rpmvercmp(lhs, rhs):
    r"""
    Compare alpha and numeric segments of two versions.
    :rtype: int
    :return: 1 if `lhs` < `rhs`, -1 if `lhs` > `rhs`, 0 if they are equal
    """
    ...

class VectorNevra:
    thisown = ...
    __repr__ = ...
    def iterator(self): ...
    def __iter__(self): ...
    def __nonzero__(self): ...
    def __bool__(self): ...
    def __len__(self): ...
    def __getslice__(self, i, j): ...
    def __setslice__(self, *args): ...
    def __delslice__(self, i, j): ...
    def __delitem__(self, *args): ...
    def __getitem__(self, *args): ...
    def __setitem__(self, *args): ...
    def pop(self): ...
    def append(self, x): ...
    def empty(self): ...
    def size(self): ...
    def swap(self, v): ...
    def begin(self): ...
    def end(self): ...
    def rbegin(self): ...
    def rend(self): ...
    def clear(self): ...
    def get_allocator(self): ...
    def pop_back(self): ...
    def erase(self, *args): ...
    def __init__(self, *args) -> None: ...
    def push_back(self, x): ...
    def front(self): ...
    def back(self): ...
    def assign(self, n, x): ...
    def insert(self, *args): ...
    def reserve(self, n): ...
    def capacity(self): ...

    __swig_destroy__ = ...

class VectorNevraForm:
    thisown = ...
    __repr__ = ...
    def iterator(self): ...
    def __iter__(self): ...
    def __nonzero__(self): ...
    def __bool__(self): ...
    def __len__(self): ...
    def __getslice__(self, i, j): ...
    def __setslice__(self, *args): ...
    def __delslice__(self, i, j): ...
    def __delitem__(self, *args): ...
    def __getitem__(self, *args): ...
    def __setitem__(self, *args): ...
    def pop(self): ...
    def append(self, x): ...
    def empty(self): ...
    def size(self): ...
    def swap(self, v): ...
    def begin(self): ...
    def end(self): ...
    def rbegin(self): ...
    def rend(self): ...
    def clear(self): ...
    def get_allocator(self): ...
    def pop_back(self): ...
    def erase(self, *args): ...
    def __init__(self, *args) -> None: ...
    def push_back(self, x): ...
    def front(self): ...
    def back(self): ...
    def assign(self, n, x): ...
    def insert(self, *args): ...
    def reserve(self, n): ...
    def capacity(self): ...

    __swig_destroy__ = ...

class PairBoolNevra:
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    first = ...
    second = ...
    def __len__(self):  # -> Literal[2]:
        ...

    def __repr__(self):  # -> str:
        ...

    def __getitem__(self, index):  # -> Any:
        ...

    def __setitem__(self, index, val):  # -> None:
        ...
    __swig_destroy__ = ...

class VersionlockCondition:
    r"""
    A condition for the versionlock package.
    Each condition consist of three parts: key, comparison operator, and value.
    Key can be one of "epoch", "evr", "arch".
    Supported comparison operators are "<", "<=", "=", ">=", ">", "!=".
    Since: 5.1.13
    """

    thisown = ...
    __repr__ = ...
    Keys_EPOCH = ...
    Keys_EVR = ...
    Keys_ARCH = ...
    def __init__(self, key_str, comparator_str, value) -> None: ...
    def is_valid(self):
        r"""
        Returns true if this configuration entry is valid - contains supported values
        in all three parts (key, operator, and value).
        """
        ...

    def get_key(self):
        r"""Get the key (which part of a package is compared)."""
        ...

    def get_comparator(self):
        r"""Get the comparison operator."""
        ...

    def get_value(self):
        r"""Get the value."""
        ...

    def get_key_str(self):
        r"""Get the key as a string."""
        ...

    def get_comparator_str(self):
        r"""Get the comparison operator as a string."""
        ...

    def get_errors(self):
        r"""Get list of errors found during parsing the entry from configuration file."""
        ...

    def to_string(self, with_errors):
        r"""
        Converts the condition to "key operator value" string usable for printing.
        :type with_errors: boolean
        :param with_errors: Include also error messages for invalid entries
        """
        ...
    __swig_destroy__ = ...

class VersionlockPackage:
    r"""
    One versionlock configuration file entry. It consists of the
    package name and a set of conditions. All conditions must be true
    for package version to get locked.
    Since: 5.1.13
    """

    thisown = ...
    __repr__ = ...
    def __init__(self, name, conditions) -> None:
        r"""
        Creates an instance of `VersionlockPackage` class specifying the
        name of package.
        :type name: std::string_view
        :param name: Name of the package to be configured
        """
        ...

    def is_valid(self):
        r"""Returns true if this configuration entry is valid."""
        ...

    def get_name(self):
        r"""Get the package name."""
        ...

    def get_comment(self):
        r"""Get the comment for this entry."""
        ...

    def set_comment(self, comment):
        r"""Set comment for this entry."""
        ...

    def get_conditions(self):
        r"""Get the list of conditions configured for the package."""
        ...

    def add_condition(self, condition):
        r"""Add a new condition for the package"""
        ...

    def get_errors(self):
        r"""Get list of errors found during parsing the entry from configuration file."""
        ...

    def to_string(self, with_errors, with_comment):
        r"""
        Converts the package configuration to string usable for printing.
        :type with_errors: boolean
        :param with_errors: Include also error messages for invalid entries
        """
        ...
    __swig_destroy__ = ...

class VersionlockConfig:
    r"""
    Class contains parsed versionlock configuration file.
    Since: 5.1.13
    """

    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    def get_packages(self):
        r"""Get list of configured versionlock entries."""
        ...

    def save(self):
        r"""Save configuration to the file specified in the constructor."""
        ...
    __swig_destroy__ = ...

class VectorVersionlockCondition:
    thisown = ...
    __repr__ = ...
    def iterator(self): ...
    def __iter__(self): ...
    def __nonzero__(self): ...
    def __bool__(self): ...
    def __len__(self): ...
    def __getslice__(self, i, j): ...
    def __setslice__(self, *args): ...
    def __delslice__(self, i, j): ...
    def __delitem__(self, *args): ...
    def __getitem__(self, *args): ...
    def __setitem__(self, *args): ...
    def pop(self): ...
    def append(self, x): ...
    def empty(self): ...
    def size(self): ...
    def swap(self, v): ...
    def begin(self): ...
    def end(self): ...
    def rbegin(self): ...
    def rend(self): ...
    def clear(self): ...
    def get_allocator(self): ...
    def pop_back(self): ...
    def erase(self, *args): ...
    def __init__(self, *args) -> None: ...
    def push_back(self, x): ...
    def front(self): ...
    def back(self): ...
    def assign(self, n, x): ...
    def insert(self, *args): ...
    def reserve(self, n): ...
    def capacity(self): ...

    __swig_destroy__ = ...

class VectorVersionlockPackage:
    thisown = ...
    __repr__ = ...
    def iterator(self): ...
    def __iter__(self): ...
    def __nonzero__(self): ...
    def __bool__(self): ...
    def __len__(self): ...
    def __getslice__(self, i, j): ...
    def __setslice__(self, *args): ...
    def __delslice__(self, i, j): ...
    def __delitem__(self, *args): ...
    def __getitem__(self, *args): ...
    def __setitem__(self, *args): ...
    def pop(self): ...
    def append(self, x): ...
    def empty(self): ...
    def size(self): ...
    def swap(self, v): ...
    def begin(self): ...
    def end(self): ...
    def rbegin(self): ...
    def rend(self): ...
    def clear(self): ...
    def get_allocator(self): ...
    def pop_back(self): ...
    def erase(self, *args): ...
    def __init__(self, *args) -> None: ...
    def push_back(self, x): ...
    def front(self): ...
    def back(self): ...
    def assign(self, n, x): ...
    def insert(self, *args): ...
    def reserve(self, n): ...
    def capacity(self): ...

    __swig_destroy__ = ...

class PackageSack:
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def get_weak_ptr(self):
        r"""Create WeakPtr to PackageSack"""
        ...

    def get_base(self):
        r"""
        :rtype: libdnf5::BaseWeakPtr
        :return: The `Base` object to which this object belongs.
        Since: 5.0
        """
        ...

    def get_nsolvables(self):
        r"""Returns number of solvables in pool."""
        ...

    def load_config_excludes_includes(self, only_main=...):
        r"""
        Loads excluded and included package sets from the configuration.
        Uses the `disable_excludes`, `excludepkgs`, and `includepkgs` configuration options for calculation.
        :type only_main: boolean, optional
        :param only_main: If `true`, the repository specific configurations are not used.
        Since: 5.0
        """
        ...

    def get_user_excludes(self):
        r"""Returns user excluded package set"""
        ...

    def add_user_excludes(self, excludes):
        r"""
        Add package set to user excluded packages
        :type excludes: :py:class:`PackageSet`
        :param excludes:: packages to add to excludes
        Since: 5.0
        """
        ...

    def remove_user_excludes(self, excludes):
        r"""
        Remove package set from user excluded packages
        :type excludes: :py:class:`PackageSet`
        :param excludes:: packages to remove from excludes
        Since: 5.0
        """
        ...

    def set_user_excludes(self, excludes):
        r"""
        Resets user excluded packages to a new value
        :type excludes: :py:class:`PackageSet`
        :param excludes:: packages to exclude
        Since: 5.0
        """
        ...

    def clear_user_excludes(self):
        r"""
        Clear user excluded packages
        Since: 5.0
        """
        ...

    def get_user_includes(self):
        r"""Returns user included package set"""
        ...

    def add_user_includes(self, includes):
        r"""
        Add package set to user included packages
        :type includes: :py:class:`PackageSet`
        :param includes:: packages to add to includes
        Since: 5.0
        """
        ...

    def remove_user_includes(self, includes):
        r"""
        Remove package set from user included packages
        :type includes: :py:class:`PackageSet`
        :param includes:: packages to remove from includes
        Since: 5.0
        """
        ...

    def set_user_includes(self, includes):
        r"""
        Resets user included packages to a new value
        :type includes: :py:class:`PackageSet`
        :param includes:: packages to include
        Since: 5.0
        """
        ...

    def clear_user_includes(self):
        r"""
        Clear user included packages
        Since: 5.0
        """
        ...

    def get_versionlock_config(self):
        r"""
        Returns versionlock configuration
        Since: 5.1.13
        """
        ...

    def get_versionlock_excludes(self):
        r"""
        Returns versionlock excluded package set
        Since: 5.1.13
        """
        ...

    def add_versionlock_excludes(self, excludes):
        r"""
        Add package set to versionlock excluded packages
        :type excludes: :py:class:`PackageSet`
        :param excludes:: packages to add to excludes
        Since: 5.1.13
        """
        ...

    def remove_versionlock_excludes(self, excludes):
        r"""
        Remove package set from versionlock excluded packages
        :type excludes: :py:class:`PackageSet`
        :param excludes:: packages to remove from excludes
        Since: 5.1.13
        """
        ...

    def set_versionlock_excludes(self, excludes):
        r"""
        Resets versionlock excluded packages to a new value
        :type excludes: :py:class:`PackageSet`
        :param excludes:: packages to exclude
        Since: 5.1.13
        """
        ...

    def clear_versionlock_excludes(self):
        r"""
        Clear versionlock excluded packages
        Since: 5.1.13
        """
        ...

    def get_running_kernel(self): ...

class PackageSackWeakPtr:
    r"""
    WeakPtr is a "smart" pointer. It contains a pointer to resource and to guard of resource.
    WeakPtr pointer can be owner of the resource. However, the resource itself may depend on another resource.
    WeakPtr registers/unregisters itself at the guard of resource. And the resource guard invalidates
    the registered WeakPtrs when the resource is unusable (eg. its dependecny was released).
    Note on thread safety:
    It is safe to create, access and destroy WeakPtrs in multiple threads simultaneously.
    """

    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def __deref__(self):
        r"""Provides access to the managed object. Generates exception if object is not valid."""
        ...

    def get(self):
        r"""Returns a pointer to the managed object. Generates exception if object is not valid."""
        ...

    def is_valid(self):
        r"""Checks if managed object is valid."""
        ...

    def has_same_guard(self, other):
        r"""Checks if the other WeakPtr instance has the same WeakPtrGuard."""
        ...

    def __ref__(self): ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def get_weak_ptr(self):
        r"""Create WeakPtr to PackageSack"""
        ...

    def get_base(self):
        r"""
        :rtype: libdnf5::BaseWeakPtr
        :return: The `Base` object to which this object belongs.
        Since: 5.0
        """
        ...

    def get_nsolvables(self):
        r"""Returns number of solvables in pool."""
        ...

    def load_config_excludes_includes(self, only_main=...):
        r"""
        Loads excluded and included package sets from the configuration.
        Uses the `disable_excludes`, `excludepkgs`, and `includepkgs` configuration options for calculation.
        :type only_main: boolean, optional
        :param only_main: If `true`, the repository specific configurations are not used.
        Since: 5.0
        """
        ...

    def get_user_excludes(self):
        r"""Returns user excluded package set"""
        ...

    def add_user_excludes(self, excludes):
        r"""
        Add package set to user excluded packages
        :type excludes: :py:class:`PackageSet`
        :param excludes:: packages to add to excludes
        Since: 5.0
        """
        ...

    def remove_user_excludes(self, excludes):
        r"""
        Remove package set from user excluded packages
        :type excludes: :py:class:`PackageSet`
        :param excludes:: packages to remove from excludes
        Since: 5.0
        """
        ...

    def set_user_excludes(self, excludes):
        r"""
        Resets user excluded packages to a new value
        :type excludes: :py:class:`PackageSet`
        :param excludes:: packages to exclude
        Since: 5.0
        """
        ...

    def clear_user_excludes(self):
        r"""
        Clear user excluded packages
        Since: 5.0
        """
        ...

    def get_user_includes(self):
        r"""Returns user included package set"""
        ...

    def add_user_includes(self, includes):
        r"""
        Add package set to user included packages
        :type includes: :py:class:`PackageSet`
        :param includes:: packages to add to includes
        Since: 5.0
        """
        ...

    def remove_user_includes(self, includes):
        r"""
        Remove package set from user included packages
        :type includes: :py:class:`PackageSet`
        :param includes:: packages to remove from includes
        Since: 5.0
        """
        ...

    def set_user_includes(self, includes):
        r"""
        Resets user included packages to a new value
        :type includes: :py:class:`PackageSet`
        :param includes:: packages to include
        Since: 5.0
        """
        ...

    def clear_user_includes(self):
        r"""
        Clear user included packages
        Since: 5.0
        """
        ...

    def get_versionlock_config(self):
        r"""
        Returns versionlock configuration
        Since: 5.1.13
        """
        ...

    def get_versionlock_excludes(self):
        r"""
        Returns versionlock excluded package set
        Since: 5.1.13
        """
        ...

    def add_versionlock_excludes(self, excludes):
        r"""
        Add package set to versionlock excluded packages
        :type excludes: :py:class:`PackageSet`
        :param excludes:: packages to add to excludes
        Since: 5.1.13
        """
        ...

    def remove_versionlock_excludes(self, excludes):
        r"""
        Remove package set from versionlock excluded packages
        :type excludes: :py:class:`PackageSet`
        :param excludes:: packages to remove from excludes
        Since: 5.1.13
        """
        ...

    def set_versionlock_excludes(self, excludes):
        r"""
        Resets versionlock excluded packages to a new value
        :type excludes: :py:class:`PackageSet`
        :param excludes:: packages to exclude
        Since: 5.1.13
        """
        ...

    def clear_versionlock_excludes(self):
        r"""
        Clear versionlock excluded packages
        Since: 5.1.13
        """
        ...

    def get_running_kernel(self): ...

class ReldepId:
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...

    id = ...
    __swig_destroy__ = ...

class Reldep:
    r"""Represent a relational dependency from libsolv"""

    thisown = ...
    CmpType_NONE = ...
    CmpType_GT = ...
    CmpType_EQ = ...
    CmpType_GTE = ...
    CmpType_LT = ...
    CmpType_LTE = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def get_name(self): ...
    def get_relation(self): ...
    def get_version(self): ...
    def to_string(self): ...
    def to_string_description(self):
        r"""Provide descriptive information about instance including string value and ID"""
        ...

    def get_id(self): ...
    def get_base(self):
        r"""Return weak pointer to base"""
        ...

    @staticmethod
    def is_rich_dependency(pattern):
        r"""
        Test if pattern is rich dependency
        Return true if pattern start with "("
        """
        ...

    def get_hash(self):
        r"""Return unique ID representing Reldep"""
        ...

    def __str__(self) -> str: ...
    def __repr__(self): ...
    def __hash__(self) -> int: ...

class ReldepListIterator:
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def value(self): ...
    def next(self): ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def begin(self): ...
    def end(self): ...

class ReldepList:
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def begin(self): ...
    def end(self): ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def add(self, *args): ...
    def add_reldep_with_glob(self, reldep_str):
        r"""
        Adds a reldep from Char*. Only globs in name are processed. The process is slow
        therefore if reldepStr is not a glob please use addReldep() instead.

        :type reldep_str: string
        :param reldep_str: p_reldepStr: Char*
        :rtype: boolean
        :return: bool - false if parsing or reldep creation fails
        """
        ...

    def add_reldep(self, reldep_str):
        r"""
        Adds a reldep from Char*. It does not support globs.

        :type reldep_str: string
        :param reldep_str: p_reldepStr: Char*
        :rtype: boolean
        :return: bool false if parsing or reldep creation fails
        """
        ...

    def append(self, source): ...
    def get(self, index): ...
    def get_id(self, index): ...
    def size(self): ...
    def empty(self):
        r"""Return true if container is empty"""
        ...

    def clear(self):
        r"""Remove all RelDeps"""
        ...

    def get_base(self): ...

class PackageId:
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...

    id = ...
    __swig_destroy__ = ...

class Changelog:
    thisown = ...
    __repr__ = ...
    def __init__(self, timestamp, author, text) -> None: ...

    timestamp = ...
    author = ...
    text = ...
    __swig_destroy__ = ...

class Package:
    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def get_id(self): ...
    def get_name(self):
        r"""
        :rtype: string
        :return: RPM package Name (`RPMTAG_NAME`).
        Since: 5.0
        """
        ...

    def get_epoch(self):
        r"""
        :rtype: string
        :return: RPM package Epoch (`RPMTAG_EPOCH`).
        Since: 5.0
        """
        ...

    def get_version(self):
        r"""
        :rtype: string
        :return: RPM package Version (`RPMTAG_VERSION`).
        Since: 5.0
        """
        ...

    def get_release(self):
        r"""
        :rtype: string
        :return: RPM package Release (`RPMTAG_RELEASE`).
        Since: 5.0
        """
        ...

    def get_arch(self):
        r"""
        :rtype: string
        :return: RPM package Arch (`RPMTAG_ARCH`).
        Since: 5.0
        """
        ...

    def get_evr(self):
        r"""
        :rtype: string
        :return: RPM package EVR (Epoch:Version-Release). If the Epoch is 0, it is omitted from the output.
        Since: 5.0
        """
        ...

    def get_nevra(self):
        r"""
        :rtype: string
        :return: RPM package NEVRA (Name-Epoch:Version-Release.Arch). If the Epoch is 0, it is omitted from the output.
        Since: 5.0
        """
        ...

    def get_full_nevra(self):
        r"""
        :rtype: string
        :return: RPM package NEVRA (Name-Epoch:Version-Release.Arch). The Epoch is always present even if it is 0.
        Since: 5.0
        """
        ...

    def get_na(self):
        r"""
        :rtype: string
        :return: RPM package NA (Name.Arch).
        Since: 5.0
        """
        ...

    def get_group(self):
        r"""
        :rtype: string
        :return: RPM package Group (`RPMTAG_GROUP`).
        Since: 5.0
        """
        ...

    def get_download_size(self):
        r"""
        :rtype: int
        :return: File size of the RPM package.
        Since: 5.0
        """
        ...

    def get_install_size(self):
        r"""
        :rtype: int
        :return: Size the RPM package should occupy after installing on disk (`RPMTAG_LONGSIZE`).
                    The information is always present - it is retrieved from rpmdb if the package is installed or from repodata if the package is available.
        Since: 5.0
        Notes: The actual size on disk may vary based on block size and filesystem overhead.
              Libdnf doesn't provide any method to compute the actual size on disk.
        """
        ...

    def get_license(self):
        r"""
        :rtype: string
        :return: RPM package License (`RPMTAG_LICENSE`).
        Since: 5.0
        """
        ...

    def get_source_name(self):
        r"""
        :rtype: string
        :return: RPM package source name.
        Since: 5.0
        """
        ...

    def get_debugsource_name(self):
        r"""
        :rtype: string
        :return: name of the debugsource package for this package
            E.g. krb5-libs -> krb5-debugsource
        Since: 5.0.10
        """
        ...

    def get_debuginfo_name_of_source(self):
        r"""
        :rtype: string
        :return: name of the debuginfo package for source package of this package.
            E.g. krb5-libs -> krb5-debuginfo
        Since: 5.0.10
        """
        ...

    def get_debuginfo_name(self):
        r"""
        :rtype: string
        :return: name of the debuginfo package for this package.
            If this package is a debuginfo package, return its name.
            If this package is a debugsource package, returns the debuginfo package for the base package.
            E.g. kernel-PAE -> kernel-PAE-debuginfo
        Since: 5.0.10
        """
        ...

    def get_sourcerpm(self):
        r"""
        :rtype: string
        :return: RPM package source package filename (`RPMTAG_SOURCERPM`).
        Since: 5.0
        """
        ...

    def get_build_time(self):
        r"""
        :rtype: int
        :return: RPM package build timestamp (`RPMTAG_BUILDTIME`).
        Since: 5.0
        """
        ...

    def get_packager(self):
        r"""
        :rtype: string
        :return: RPM package Packager (`RPMTAG_PACKAGER`).
        Since: 5.0
        """
        ...

    def get_vendor(self):
        r"""
        :rtype: string
        :return: RPM package Vendor (`RPMTAG_VENDOR`).
        Since: 5.0
        """
        ...

    def get_url(self):
        r"""
        :rtype: string
        :return: RPM package URL (project home address) (`RPMTAG_URL`).
        Since: 5.0
        """
        ...

    def get_summary(self):
        r"""
        :rtype: string
        :return: RPM package Summary (`RPMTAG_SUMMARY`).
        Since: 5.0
        """
        ...

    def get_description(self):
        r"""
        :rtype: string
        :return: RPM package Description (`RPMTAG_DESCRIPTION`).
        Since: 5.0
        """
        ...

    def get_provides(self):
        r"""
        :rtype: :py:class:`ReldepList`
        :return: List of RPM package Provides (`RPMTAG_PROVIDENAME`, `RPMTAG_PROVIDEFLAGS`, `RPMTAG_PROVIDEVERSION`).
        Since: 5.0
        """
        ...

    def get_requires(self):
        r"""
        :rtype: :py:class:`ReldepList`
        :return: List of RPM package Requires (`RPMTAG_REQUIRENAME`, `RPMTAG_REQUIREFLAGS`, `RPMTAG_REQUIREVERSION`).
        Since: 5.0
        """
        ...

    def get_requires_pre(self):
        r"""
        :rtype: :py:class:`ReldepList`
        :return: List of RPM package Requires(pre).
        Since: 5.0
        """
        ...

    def get_conflicts(self):
        r"""
        :rtype: :py:class:`ReldepList`
        :return: List of RPM package Conflicts (`RPMTAG_CONFLICTNAME`, `RPMTAG_CONFLICTFLAGS`, `RPMTAG_CONFLICTVERSION`).
        Since: 5.0
        """
        ...

    def get_obsoletes(self):
        r"""
        :rtype: :py:class:`ReldepList`
        :return: List of RPM package Obsoletes (`RPMTAG_OBSOLETENAME`, `RPMTAG_OBSOLETEFLAGS`, `RPMTAG_OBSOLETEVERSION`).
        Since: 5.0
        """
        ...

    def get_prereq_ignoreinst(self): ...
    def get_regular_requires(self): ...
    def get_recommends(self):
        r"""
        :rtype: :py:class:`ReldepList`
        :return: List of RPM package Recommends (`RPMTAG_RECOMMENDNAME`, `RPMTAG_RECOMMENDFLAGS`, `RPMTAG_RECOMMENDVERSION`).
        Since: 5.0
        """
        ...

    def get_suggests(self):
        r"""
        :rtype: :py:class:`ReldepList`
        :return: List of RPM package Suggests (`RPMTAG_SUGGESTNAME`, `RPMTAG_SUGGESTFLAGS`, `RPMTAG_SUGGESTVERSION`).
        Since: 5.0
        """
        ...

    def get_enhances(self):
        r"""
        :rtype: :py:class:`ReldepList`
        :return: List of RPM package Enhances (`RPMTAG_ENHANCENAME`, `RPMTAG_ENHANCEFLAGS`, `RPMTAG_ENHANCEVERSION`).
        Since: 5.0
        """
        ...

    def get_supplements(self):
        r"""
        :rtype: :py:class:`ReldepList`
        :return: List of RPM package Supplements (`RPMTAG_SUPPLEMENTNAME`, `RPMTAG_SUPPLEMENTFLAGS`, `RPMTAG_SUPPLEMENTVERSION`).
        Since: 5.0
        """
        ...

    def get_depends(self):
        r"""
        :rtype: :py:class:`ReldepList`
        :return: List of RPM package dependencies (requires + enhances + suggests + supplements + recommends).
        Since: 5.0.10
        """
        ...

    def get_files(self):
        r"""
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: List of files and directories the RPM package contains (`RPMTAG_FILENAMES`).
                    If file lists are not loaded, empty list is returned.
        Since: 5.0
        Notes: Information whether the returned files are actual files, directories or ghosted files is not available.
        """
        ...

    def get_changelogs(self):
        r"""
        :rtype: std::vector< libdnf5::rpm::Changelog,std::allocator< libdnf5::rpm::Changelog > >
        :return: List of package changelog entries. If `other` repository metadata are
        Since: 5.0
        """
        ...

    def get_baseurl(self):
        r"""
        :rtype: string
        :return: RPM package baseurl from repodata (`<location xml:base="...">`).
        Since: 5.0
        """
        ...

    def get_location(self):
        r"""
        :rtype: string
        :return: RPM package relative path/location from repodata (`<location href="...">`).
        Since: 5.0
        """
        ...

    def get_remote_locations(self, *args):
        r"""
        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: RPM package remote location where the package can be download from.
            Returns empty vector for installed and commandline packages.
        Since: 5.1
        """
        ...

    def get_checksum(self):
        r"""
        :rtype: :py:class:`Checksum`
        :return: Checksum object representing RPM package checksum and its type (`<checksum type="type">checksum<checksum>`).
        Since: 5.0
        """
        ...

    def get_hdr_checksum(self):
        r"""
        :rtype: :py:class:`Checksum`
        :return: Checksum object representing RPM package header checksum and its type.
        Since: 5.0
        """
        ...

    def get_hdr_end(self):
        r"""
        :rtype: int
        :return: RPM package header end (the header is located between file position 0 and the returned offset).
        Since: 5.0
        """
        ...

    def get_media_number(self):
        r"""
        :rtype: int
        :return: Number of media (usually a CD/DVD disc) on which the package is located.
        Since: 5.0
        """
        ...

    def get_package_path(self):
        r"""
        :rtype: string
        :return: Path to the RPM package on the local file system:
           If the package is a local package, return its path
           If the package is a remote package downloaded to cache, return path to the cache
           If the package is a remote package that hasn't been downloaded yet, return path to the cache
        Since: 5.0
        """
        ...

    def is_available_locally(self):
        r"""
        :rtype: boolean
        :return: `true` if the package is available locally, `false` otherwise.
        Since: 5.0.8
        """
        ...

    def is_installed(self):
        r"""
        :rtype: boolean
        :return: `true` if the package is installed on the system, `false` otherwise.
        Since: 5.0
        """
        ...

    def is_excluded(self):
        r"""
        :rtype: boolean
        :return: `true` if the package is excluded, `false` otherwise.
        Since: 5.0
        """
        ...

    def get_from_repo_id(self):
        r"""
        TODO is_local
        For an installed package, return id of repo from the package was installed.
        For an available package, return an empty string.
        """
        ...

    def get_install_time(self):
        r"""
        :rtype: int
        :return: The unix timestamp (seconds since epoch) of when the package was installed.
                    Return 0 if the package is not installed.
        """
        ...

    def get_rpmdbid(self):
        r"""
        :rtype: int
        :return: The rpmdb database id (primary key) of the installed RPM package.
        Since: 5.0
        """
        ...

    def get_repo(self):
        r"""
        :rtype: :py:class:`RepoWeakPtr`
        :return: A `Repo` object that represents the repository the package belongs to.
        Since: 5.0
        Notes: This isn't the repository the package was installed from.
        """
        ...

    def get_repo_id(self):
        r"""
        :rtype: string
        :return: Id of the repository the package belongs to.
        Since: 5.0
        Notes: This isn't the repository the package was installed from.
        """
        ...

    def get_repo_name(self):
        r"""
        :rtype: string
        :return: Name of the repository the package belongs to.
        Since: 5.0.10
        Notes: This isn't the repository the package was installed from.
        """
        ...

    def get_reason(self):
        r"""
        :rtype: int
        :return: Resolved reason why a package was installed.
                    A package can be installed due to multiple reasons, only the most significant is returned.
        Since: 5.0
        """
        ...

    def get_base(self):
        r"""
        :rtype: libdnf5::BaseWeakPtr
        :return: The `Base` object to which this object belongs.
        Since: 5.0.5
        """
        ...

    def to_string(self):
        r"""Return NEVRA -> 0 epoch is not shown in string"""
        ...

    def to_string_description(self):
        r"""Provide descriptive information about instance including NEVRA and ID"""
        ...

    def get_hash(self):
        r"""Return unique ID representing Package"""
        ...

    def __str__(self) -> str: ...
    def __repr__(self): ...
    def __hash__(self) -> int: ...

    __swig_destroy__ = ...

class VectorPackage:
    thisown = ...
    __repr__ = ...
    def iterator(self): ...
    def __iter__(self): ...
    def __nonzero__(self): ...
    def __bool__(self): ...
    def __len__(self): ...
    def __getslice__(self, i, j): ...
    def __setslice__(self, *args): ...
    def __delslice__(self, i, j): ...
    def __delitem__(self, *args): ...
    def __getitem__(self, *args): ...
    def __setitem__(self, *args): ...
    def pop(self): ...
    def append(self, x): ...
    def empty(self): ...
    def size(self): ...
    def swap(self, v): ...
    def begin(self): ...
    def end(self): ...
    def rbegin(self): ...
    def rend(self): ...
    def clear(self): ...
    def get_allocator(self): ...
    def pop_back(self): ...
    def erase(self, *args): ...
    def __init__(self, *args) -> None: ...
    def push_back(self, x): ...
    def front(self): ...
    def back(self): ...
    def assign(self, n, x): ...
    def insert(self, *args): ...
    def reserve(self, n): ...
    def capacity(self): ...

    __swig_destroy__ = ...

class VectorVectorPackage:
    thisown = ...
    __repr__ = ...
    def iterator(self): ...
    def __iter__(self): ...
    def __nonzero__(self): ...
    def __bool__(self): ...
    def __len__(self): ...
    def __getslice__(self, i, j): ...
    def __setslice__(self, *args): ...
    def __delslice__(self, i, j): ...
    def __delitem__(self, *args): ...
    def __getitem__(self, *args): ...
    def __setitem__(self, *args): ...
    def pop(self): ...
    def append(self, x): ...
    def empty(self): ...
    def size(self): ...
    def swap(self, v): ...
    def begin(self): ...
    def end(self): ...
    def rbegin(self): ...
    def rend(self): ...
    def clear(self): ...
    def get_allocator(self): ...
    def pop_back(self): ...
    def erase(self, *args): ...
    def __init__(self, *args) -> None: ...
    def push_back(self, x): ...
    def front(self): ...
    def back(self): ...
    def assign(self, n, x): ...
    def insert(self, *args): ...
    def reserve(self, n): ...
    def capacity(self): ...

    __swig_destroy__ = ...

class VectorChangelog:
    thisown = ...
    __repr__ = ...
    def iterator(self): ...
    def __iter__(self): ...
    def __nonzero__(self): ...
    def __bool__(self): ...
    def __len__(self): ...
    def __getslice__(self, i, j): ...
    def __setslice__(self, *args): ...
    def __delslice__(self, i, j): ...
    def __delitem__(self, *args): ...
    def __getitem__(self, *args): ...
    def __setitem__(self, *args): ...
    def pop(self): ...
    def append(self, x): ...
    def empty(self): ...
    def size(self): ...
    def swap(self, v): ...
    def begin(self): ...
    def end(self): ...
    def rbegin(self): ...
    def rend(self): ...
    def clear(self): ...
    def get_allocator(self): ...
    def pop_back(self): ...
    def erase(self, *args): ...
    def __init__(self, *args) -> None: ...
    def push_back(self, x): ...
    def front(self): ...
    def back(self): ...
    def assign(self, n, x): ...
    def insert(self, *args): ...
    def reserve(self, n): ...
    def capacity(self): ...

    __swig_destroy__ = ...

class PackageSet:
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def begin(self): ...
    def end(self): ...
    def __iter__(self) -> Iterator[Package]: ...
    def __ior__(self, other): ...
    def __isub__(self, other): ...
    def __iand__(self, other): ...
    def update(self, other):
        r"""
        Set union: elements that are in the current set or in the `other` set.

        :type other: :py:class:`PackageSet`
        :param other: The set to unify with.
        :raises: UsedDifferentSack When the sets entering the operation do not share the same PackageSack.
        Since: 5.0
        """
        ...

    def intersection(self, other):
        r"""
        Set intersection: elements in the current set that are also in the `other` set.

        :type other: :py:class:`PackageSet`
        :param other: The set to intersect with.
        :raises: UsedDifferentSack When the sets entering the operation do not share the same PackageSack.
        Since: 5.0
        """
        ...

    def difference(self, other):
        r"""
        Set difference: elements in the current set that are not in the `other` set.

        :type other: :py:class:`PackageSet`
        :param other: The set to check for differences in.
        :raises: UsedDifferentSack When the sets entering the operation do not share the same PackageSack.
        Since: 5.0
        """
        ...

    def clear(self):
        r"""
        Remove all packages from the set.

        Since: 5.0
        """
        ...

    def empty(self):
        r"""
        :rtype: boolean
        :return: `true` if the set is empty, `false` otherwise.
        Since: 5.0
        """
        ...

    def add(self, pkg):
        r"""
        Add `pkg` to the set.

        :type pkg: :py:class:`Package`
        :param pkg: Package to be added to the set.
        Since: 5.0
        """
        ...

    def contains(self, pkg):
        r"""
        :rtype: boolean
        :return: `true` if a package is in the set, `false` otherwise.
        :type pkg: :py:class:`Package`
        :param pkg: Package that is tested for presence.
        Since: 5.0
        """
        ...

    def remove(self, pkg):
        r"""
        Remove `pkg` from the set.

        :type pkg: :py:class:`Package`
        :param pkg: Package to be removed from the set.
        Since: 5.0
        """
        ...

    def get_base(self): ...
    def size(self):
        r"""
        :rtype: int
        :return: Number of elements in the set.
        """
        ...

    def swap(self, other): ...

class PackageQuery(PackageSet):
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def filter_name(self, *args):
        r"""
        *Overload 1:*
        Filter packages by their `name`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`, `IEXACT`, `NOT_IEXACT`, `ICONTAINS`, `NOT_ICONTAINS`, `IGLOB`, `NOT_IGLOB`, `CONTAINS`, `NOT_CONTAINS`.
        Since: 5.0

        |

        *Overload 2:*
        Filter packages by their `name` based on names of the packages in the `package_set`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      PackageSet with Package objects the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0

        |

        *Overload 3:*
        Filter packages by their `name` based on names of the packages in the `package_set`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      PackageSet with Package objects the filter is matched against.
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0
        """
        ...

    def filter_epoch(self, *args):
        r"""
        *Overload 1:*
        Filter packages by their `epoch`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`.
        Since: 5.0

        |

        *Overload 2:*
        Filter packages by their `epoch`.

        :type patterns: std::vector< unsigned long,std::allocator< unsigned long > >
        :param patterns:         A vector of numbers the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GT`, `GTE`, `LT`, `LTE`.
        Since: 5.0

        |

        *Overload 3:*
        Filter packages by their `epoch`.

        :type patterns: std::vector< unsigned long,std::allocator< unsigned long > >
        :param patterns:         A vector of numbers the filter is matched against.
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GT`, `GTE`, `LT`, `LTE`.
        Since: 5.0
        """
        ...

    def filter_version(self, *args):
        r"""
        Filter packages by their `version`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GT`, `GTE`, `LT`, `LTE`, `GLOB`, `NOT_GLOB`.
        Since: 5.0
        """
        ...

    def filter_release(self, *args):
        r"""
        Filter packages by their `release`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GT`, `GTE`, `LT`, `LTE`, `GLOB`, `NOT_GLOB`.
        Since: 5.0
        """
        ...

    def filter_arch(self, *args):
        r"""
        Filter packages by their `arch`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`.
        Since: 5.0
        """
        ...

    def filter_name_arch(self, *args):
        r"""
        Filter packages by their `name` and `arch` based on names and arches of the packages in the `package_set`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      PackageSet with Package objects the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0
        """
        ...

    def filter_evr(self, *args):
        r"""
        Filter packages by their `epoch:version-release`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `GT`, `LT`, `GTE`, `LTE`, `NEQ`.
        Since: 5.0
        """
        ...

    def filter_nevra(self, *args):
        r"""
        *Overload 1:*
        Filter packages by their `name-[epoch:]version-release.arch`. The following matches are tolerant to omitted 0 epoch: `EQ`, `NEQ`, `GT`, `GTE`, `LT`, `LTE`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GT`, `GTE`, `LT`, `LTE`, `GLOB`, `NOT_GLOB`, `IGLOB`, `NOT_IGLOB`, `IEXACT`, `NOT_IEXACT`.
        Since: 5.0

        |

        *Overload 2:*
        Filter packages by the `name`, `epoch`, `version`, `release` and `arch` attributes from the `nevra` object.
        Only the attributes that are not blank are used in the filter.

        :type nevra: :py:class:`Nevra`
        :param nevra:            A Nevra object the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`, `IEXACT`, `NOT_IEXACT`, `IGLOB`, `NOT_IGLOB`.
        Since: 5.0

        |

        *Overload 3:*
        Filter packages by the `name`, `epoch`, `version`, `release` and `arch` attributes from the `nevra` object.
        Only the attributes that are not blank are used in the filter.

        :type nevra: :py:class:`Nevra`
        :param nevra:            A Nevra object the filter is matched against.
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`, `IEXACT`, `NOT_IEXACT`, `IGLOB`, `NOT_IGLOB`.
        Since: 5.0

        |

        *Overload 4:*
        Filter packages by their `name-[epoch:]version-release.arch` attributes of
        the packages in the `package_set`.
        Only packages whose name.arch is present in the `package_set` are taken into
        account. Their epoch:version-release are then compared according to the
        value of `cmp_type` with those in `package_set`.
        Only the matching packages are kept in the query. In case `NOT` is used in
        `cmp_type`, the matching packages are removed from the query.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      PackageSet with Package objects the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GT`, `GTE`, `LT`, `LTE`,
                                    and their combinations with `NOT`.
        Since: 5.0

        |

        *Overload 5:*
        Filter packages by their `name-[epoch:]version-release.arch` attributes of
        the packages in the `package_set`.
        Only packages whose name.arch is present in the `package_set` are taken into
        account. Their epoch:version-release are then compared according to the
        value of `cmp_type` with those in `package_set`.
        Only the matching packages are kept in the query. In case `NOT` is used in
        `cmp_type`, the matching packages are removed from the query.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      PackageSet with Package objects the filter is matched against.
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GT`, `GTE`, `LT`, `LTE`,
                                    and their combinations with `NOT`.
        Since: 5.0
        """
        ...

    def filter_sourcerpm(self, *args):
        r"""
        Filter packages by their `sourcerpm`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`.
        """
        ...

    def filter_url(self, *args):
        r"""
        Filter packages by their `url`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`, `IEXACT`, `NOT_IEXACT`, `ICONTAINS`, `NOT_ICONTAINS`, `IGLOB`, `NOT_IGLOB`, `CONTAINS`, `NOT_CONTAINS`.
        Since: 5.0
        """
        ...

    def filter_summary(self, *args):
        r"""
        Filter packages by their `summary`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`, `IEXACT`, `NOT_IEXACT`, `ICONTAINS`, `NOT_ICONTAINS`, `IGLOB`, `NOT_IGLOB`, `CONTAINS`, `NOT_CONTAINS`.
        Since: 5.0
        """
        ...

    def filter_description(self, *args):
        r"""
        Filter packages by their `summary`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`, `IEXACT`, `NOT_IEXACT`, `ICONTAINS`, `NOT_ICONTAINS`, `IGLOB`, `NOT_IGLOB`, `CONTAINS`, `NOT_CONTAINS`.
        Since: 5.0
        """
        ...

    def filter_provides(self, *args):
        r"""
        *Overload 1:*
        Filter packages by their `provides`.

        :type reldep_list: :py:class:`ReldepList`
        :param reldep_list:      ReldepList with RelDep objects the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0

        |

        *Overload 2:*
        Filter packages by their `provides`.

        :type reldep: :py:class:`Reldep`
        :param reldep:           RelDep object the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0

        |

        *Overload 3:*
        Filter packages by their `provides`.

        :type reldep: :py:class:`Reldep`
        :param reldep:           RelDep object the filter is matched against.
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0

        |

        *Overload 4:*
        Filter packages by their `provides`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`.
        Since: 5.0

        |

        *Overload 5:*
        Filter packages by their `provides`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`.
        Since: 5.0
        """
        ...

    def filter_requires(self, *args):
        r"""
        *Overload 1:*
        Filter packages by their `requires`.

        :type reldep_list: :py:class:`ReldepList`
        :param reldep_list:      ReldepList with RelDep objects the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0

        |

        *Overload 2:*
        Filter packages by their `requires`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`.
        Since: 5.0

        |

        *Overload 3:*
        Filter packages by their `requires`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`.
        Since: 5.0

        |

        *Overload 4:*
        Filter packages by their `requires`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      PackageSet with Package objects the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0

        |

        *Overload 5:*
        Filter packages by their `requires`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      PackageSet with Package objects the filter is matched against.
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0
        """
        ...

    def filter_conflicts(self, *args):
        r"""
        *Overload 1:*
        Filter packages by their `conflicts`.

        :type reldep_list: :py:class:`ReldepList`
        :param reldep_list:      ReldepList with RelDep objects the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0

        |

        *Overload 2:*
        Filter packages by their `conflicts`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`.
        Since: 5.0

        |

        *Overload 3:*
        Filter packages by their `conflicts`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`.
        Since: 5.0

        |

        *Overload 4:*
        Filter packages by their `conflicts`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      PackageSet with Package objects the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0

        |

        *Overload 5:*
        Filter packages by their `conflicts`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      PackageSet with Package objects the filter is matched against.
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0
        """
        ...

    def filter_obsoletes(self, *args):
        r"""
        *Overload 1:*
        Filter packages by their `obsoletes`.

        :type reldep_list: :py:class:`ReldepList`
        :param reldep_list:      ReldepList with RelDep objects the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0

        |

        *Overload 2:*
        Filter packages by their `obsoletes`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`.
        Since: 5.0

        |

        *Overload 3:*
        Filter packages by their `obsoletes`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`.
        Since: 5.0

        |

        *Overload 4:*
        Filter packages by their `obsoletes`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      PackageSet with Package objects the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`.
        Since: 5.0

        |

        *Overload 5:*
        Filter packages by their `obsoletes`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      PackageSet with Package objects the filter is matched against.
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`.
        Since: 5.0
        """
        ...

    def filter_recommends(self, *args):
        r"""
        *Overload 1:*
        Filter packages by their `recommends`.

        :type reldep_list: :py:class:`ReldepList`
        :param reldep_list:      ReldepList with RelDep objects the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0

        |

        *Overload 2:*
        Filter packages by their `recommends`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`.
        Since: 5.0

        |

        *Overload 3:*
        Filter packages by their `recommends`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`.
        Since: 5.0

        |

        *Overload 4:*
        Filter packages by their `recommends`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      PackageSet with Package objects the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0

        |

        *Overload 5:*
        Filter packages by their `recommends`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      PackageSet with Package objects the filter is matched against.
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0
        """
        ...

    def filter_suggests(self, *args):
        r"""
        *Overload 1:*
        Filter packages by their `suggests`.

        :type reldep_list: :py:class:`ReldepList`
        :param reldep_list:      ReldepList with RelDep objects the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0

        |

        *Overload 2:*
        Filter packages by their `suggests`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`.
        Since: 5.0

        |

        *Overload 3:*
        Filter packages by their `suggests`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`.
        Since: 5.0

        |

        *Overload 4:*
        Filter packages by their `suggests`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      PackageSet with Package objects the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0

        |

        *Overload 5:*
        Filter packages by their `suggests`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      PackageSet with Package objects the filter is matched against.
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0
        """
        ...

    def filter_enhances(self, *args):
        r"""
        *Overload 1:*
        Filter packages by their `enhances`.

        :type reldep_list: :py:class:`ReldepList`
        :param reldep_list:      ReldepList with RelDep objects the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0

        |

        *Overload 2:*
        Filter packages by their `enhances`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`.
        Since: 5.0

        |

        *Overload 3:*
        Filter packages by their `enhances`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`.
        Since: 5.0

        |

        *Overload 4:*
        Filter packages by their `enhances`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      PackageSet with Package objects the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0

        |

        *Overload 5:*
        Filter packages by their `enhances`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      PackageSet with Package objects the filter is matched against.
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0
        """
        ...

    def filter_supplements(self, *args):
        r"""
        *Overload 1:*
        Filter packages by their `supplements`.

        :type reldep_list: :py:class:`ReldepList`
        :param reldep_list:      ReldepList with RelDep objects the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0

        |

        *Overload 2:*
        Filter packages by their `supplements`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`.
        Since: 5.0

        |

        *Overload 3:*
        Filter packages by their `supplements`.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`.
        Since: 5.0

        |

        *Overload 4:*
        Filter packages by their `supplements`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      PackageSet with Package objects the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0

        |

        *Overload 5:*
        Filter packages by their `supplements`.

        :type package_set: :py:class:`PackageSet`
        :param package_set:      PackageSet with Package objects the filter is matched against.
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0
        """
        ...

    def filter_file(self, *args):
        r"""
        Filter packages by `files` they contain.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`, `IEXACT`, `NOT_IEXACT`, `ICONTAINS`, `NOT_ICONTAINS`, `IGLOB`, `NOT_IGLOB`, `CONTAINS`, `NOT_CONTAINS`.
        Since: 5.0
        """
        ...

    def filter_location(self, *args):
        r"""
        Filter packages by their `location`.
        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`.
        Since: 5.0
        """
        ...

    def filter_repo_id(self, *args):
        r"""
        Filter packages by `id` of the Repo they belong to.

        :type patterns: std::vector< std::string,std::allocator< std::string > >
        :param patterns:         A vector of strings the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GLOB`, `NOT_GLOB`.
        Since: 5.0
        """
        ...

    def filter_advisories(self, *args):
        r"""
        Filter packages by advisories they are included in.

        :type advisory_query: libdnf5::advisory::AdvisoryQuery
        :param advisory_query:   AdvisoryQuery with Advisories that contain package lists the filter is matched against.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GT`, `GTE`, `LT`, `LTE`.
        Since: 5.0
        """
        ...

    def filter_latest_unresolved_advisories(self, *args):
        r"""
        Filter packages by the advisories they are included in, considering
        only the latest advisories that are not resolved in the currently
        installed package set.

        :type advisory_query: libdnf5::advisory::AdvisoryQuery
        :param advisory_query:   AdvisoryQuery with Advisories that contain package lists the filter is matched against.
        :type installed: :py:class:`PackageQuery`
        :param installed:        PackageQuery with currently installed packages.
        :type cmp_type: int, optional
        :param cmp_type:         A comparison (match) operator, defaults to `QueryCmp::EQ`.
                                    Supported values: `EQ`, `NEQ`, `GT`, `GTE`, `LT`, `LTE`.
        Since: 5.0
        """
        ...

    def filter_installed(self): ...
    def filter_available(self): ...
    def filter_upgrades(self): ...
    def filter_downgrades(self): ...
    def filter_upgradable(self): ...
    def filter_downgradable(self): ...
    def filter_latest_evr(self, limit=...):
        r"""
        Group packages by `name` and `arch`. Then within each group, keep packages that correspond with up to `limit` of (all but) latest `evr`s in the group.

        :type limit: int, optional
        :param limit:            If `limit` > 0, keep `limit` number `evr`s in each group.
                                    If `limit` < 0, keep all **but** `limit` last `evr`s in each group.
        Since: 5.0
        """
        ...

    def filter_latest_evr_any_arch(self, limit=...):
        r"""
        Group packages by `name`. Then within each group, keep packages that correspond with up to `limit` of (all but) latest `evr`s in the group.

        :type limit: int, optional
        :param limit:            If `limit` > 0, keep `limit` number `evr`s in each group.
                                    If `limit` < 0, keep all **but** `limit` last `evr`s in each group.
        Since: 5.2
        """
        ...

    def filter_earliest_evr(self, limit=...):
        r"""
        Group packages by `name` and `arch`. Then within each group, keep packages that correspond with up to `limit` of (all but) earliest `evr`s in the group.

        :type limit: int, optional
        :param limit:            If `limit` > 0, keep `limit` number `evr`s in each group.
                                    If `limit` < 0, keep all **but** `limit` last `evr`s in each group.
        Since: 5.0
        """
        ...

    def filter_earliest_evr_any_arch(self, limit=...):
        r"""
        Group packages by `name`. Then within each group, keep packages that correspond with up to `limit` of (all but) earliest `evr`s in the group.

        :type limit: int, optional
        :param limit:            If `limit` > 0, keep `limit` number `evr`s in each group.
                                    If `limit` < 0, keep all **but** `limit` last `evr`s in each group.
        Since: 5.2
        """
        ...

    def filter_priority(self):
        r"""
        Group packages by `name` and `arch`. Then within each group, keep packages that belong to a repo with the highest priority (the lowest number).
        The filter works only on available packages, installed packages are not affected.

        Since: 5.0
        """
        ...

    def filter_extras(self, exact_evr=...):
        r"""
        Keep in the query only packages that are installed but not available in any
        enabled repository. Even excluded packages (e.g. using excludepkgs config
        option) are considered as available in repositories for the purpose of extras
        calculation.
        Those installed packages that are only part of non-active modules are also
        considered as extras.
        :type exact_evr: boolean, optional
        :param exact_evr: If false (default) extras calculation is based only on
                             `name.arch`. That means package is not in extras if any version
                             of the package exists in any of the enabled repositories.
                             If true, filter_extras is more strict and returns each package
                             which exact NEVRA is not present in any enabled repository.
        """
        ...

    def filter_recent(self, timestamp):
        r"""
        Keep in the query only recent packages - those with build time after given timestamp
        :type timestamp: int
        :param timestamp: Only packages built after this will pass
        """
        ...

    def filter_userinstalled(self):
        r"""Keep in the query only installed packages that are user-installed."""
        ...

    def filter_unneeded(self):
        r"""
        Filter unneeded packages. Unneeded packages are those which are installed as
        dependencies and are not required by any user-installed package any more.
        """
        ...

    def resolve_pkg_spec(self, pkg_spec, settings, with_src):
        r"""
        Resolve spec according to provided settings. It tests whether spec is NEVRA type, provide, file or binary.
        It returns only the first match type. If spec has a match as NEVRA and provide type it only keeps matches with
        the first tested type (NEVRA).
        """
        ...

    def swap(self, other): ...
    def filter_duplicates(self):
        r"""Filter packages to keep only duplicates of installed packages. Packages are duplicate if they have the same `name` and `arch` but different `evr`."""
        ...

    def filter_leaves(self):
        r"""
        Filter the leaf packages.

        Leaf packages are installed packages that are not required as a dependency of another installed package.
        However, two or more installed packages might depend on each other in a dependency cycle. Packages
        in such cycles that are not required by any other installed package are also leaf.
        """
        ...

    def filter_reboot_suggested(self):
        r"""
        Filter packages whose installation or upgrade should cause a system
        reboot to be recommended. These are packages that either (1) belong to
        a hardcoded set of "core packages", including the kernel and systemd,
        or (2) have an associated `reboot_suggested` advisory.
        """
        ...

    def filter_leaves_groups(self):
        r"""
        Filter the leaf packages and return them grouped by their dependencies.

        Leaf packages are installed packages that are not required as a dependency of another installed package.
        However, two or more installed packages might depend on each other in a dependency cycle. Packages
        in such cycles that are not required by any other installed package are also leaf.
        Packages in such cycles form a group of leaf packages.

        :rtype: std::vector< std::vector< libdnf5::rpm::Package,std::allocator< libdnf5::rpm::Package > >,std::allocator< std::vector< libdnf5::rpm::Package,std::allocator< libdnf5::rpm::Package > > > >
        :return: Groups of one or more interdependent leaf packages.
        """
        ...

    def filter_installonly(self):
        r"""
        Filter installonly packages.

        Filter packages that provide a capability that matches with any value in installonlypkgs configuration option.
        """
        ...

    def filter_versionlock(self):
        r"""
        Filter out versionlock excluded packages.

        The packages versions excluded by versionlock are removed from the query.
        Since: 5.1.13
        """
        ...

def PackageSet__iter__(self):  # -> Iterator:
    ...

def ReldepList__iter__(self):  # -> Iterator:
    ...

class TransactionCallbacks:
    r"""
    Base class for Transaction callbacks
    User implements Transaction callbacks by inheriting this class and overriding its methods.
    """

    thisown = ...
    __repr__ = ...
    ScriptType_UNKNOWN = ...
    ScriptType_PRE_INSTALL = ...
    ScriptType_POST_INSTALL = ...
    ScriptType_PRE_UNINSTALL = ...
    ScriptType_POST_UNINSTALL = ...
    ScriptType_PRE_TRANSACTION = ...
    ScriptType_POST_TRANSACTION = ...
    ScriptType_TRIGGER_PRE_INSTALL = ...
    ScriptType_TRIGGER_INSTALL = ...
    ScriptType_TRIGGER_UNINSTALL = ...
    ScriptType_TRIGGER_POST_UNINSTALL = ...
    @staticmethod
    def script_type_to_string(type):
        r"""
        :type type: int
        :param type:  scriptlet type
        :rtype: string
        :return: string representation of the scriptlet type
        """
        ...
    __swig_destroy__ = ...
    def install_progress(self, item, amount, total): ...
    def install_start(self, item, total): ...
    def install_stop(self, item, amount, total): ...
    def transaction_progress(self, amount, total): ...
    def transaction_start(self, total): ...
    def transaction_stop(self, total): ...
    def uninstall_progress(self, item, amount, total): ...
    def uninstall_start(self, item, total): ...
    def uninstall_stop(self, item, amount, total): ...
    def unpack_error(self, item): ...
    def cpio_error(self, item): ...
    def script_error(self, item, nevra, type, return_code): ...
    def script_start(self, item, nevra, type): ...
    def script_stop(self, item, nevra, type, return_code): ...
    def elem_progress(self, item, amount, total): ...
    def verify_progress(self, amount, total): ...
    def verify_start(self, total): ...
    def verify_stop(self, total): ...
    def __init__(self) -> None: ...
    def __disown__(self):  # -> Any:
        ...

class TransactionCallbacksUniquePtr:
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...
    def __deref__(self): ...
    def release(self): ...
    def reset(self, __p=...): ...
    def swap(self, __u): ...
    def get(self): ...
    def __nonzero__(self): ...

    __bool__ = ...
    __swig_destroy__ = ...
    def script_type_to_string(self, type):
        r"""
        :type type: int
        :param type:  scriptlet type
        :rtype: string
        :return: string representation of the scriptlet type
        """
        ...

    def install_progress(self, item, amount, total): ...
    def install_start(self, item, total): ...
    def install_stop(self, item, amount, total): ...
    def transaction_progress(self, amount, total): ...
    def transaction_start(self, total): ...
    def transaction_stop(self, total): ...
    def uninstall_progress(self, item, amount, total): ...
    def uninstall_start(self, item, total): ...
    def uninstall_stop(self, item, amount, total): ...
    def unpack_error(self, item): ...
    def cpio_error(self, item): ...
    def script_error(self, item, nevra, type, return_code): ...
    def script_start(self, item, nevra, type): ...
    def script_stop(self, item, nevra, type, return_code): ...
    def elem_progress(self, item, amount, total): ...
    def verify_progress(self, amount, total): ...
    def verify_start(self, total): ...
    def verify_stop(self, total): ...

class KeyInfo:
    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    def get_key_id(self): ...
    def get_short_key_id(self): ...
    def get_user_ids(self): ...
    def get_fingerprint(self): ...
    def get_url(self): ...
    def get_path(self): ...
    def get_raw_key(self): ...
    def get_timestamp(self): ...

    __swig_destroy__ = ...

class RpmSignature:
    thisown = ...
    __repr__ = ...
    CheckResult_OK = ...
    CheckResult_SKIPPED = ...
    CheckResult_FAILED_KEY_MISSING = ...
    CheckResult_FAILED_NOT_TRUSTED = ...
    CheckResult_FAILED_NOT_SIGNED = ...
    CheckResult_FAILED = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def check_package_signature(self, package):
        r"""
        Check signature of the `package` using public keys stored in rpm database.
        :type package: :py:class:`Package`
        :param package:: package to check.
        :rtype: int
        :return: CheckResult::OK - the check passed
                    CheckResult::SKIPPED - the check was skipped
                    CheckResult::FAILED_KEY_MISSING - no corresponding key found in rpmdb
                    CheckResult::FAILED_NOT_TRUSTED - signature is valid but the key is not trusted
                    CheckResult::FAILED_NOT_SIGNED - package is not signed but signature is required
                    CheckResult::FAILED - check failed for another reason
        """
        ...

    def import_key(self, key):
        r"""
        Import public key into rpm database.
        :type key: :py:class:`KeyInfo`
        :param key:: GPG key to be imported into rpm database.
        """
        ...

    def key_present(self, key):
        r"""Check public key presence in rpm database"""
        ...

    def parse_key_file(self, key_url):
        r"""
        Download the key file if needed and return a vector of keys contained in it
        :type key_url: string
        :param key_url:: URL of the public key to be imported.
        """
        ...

    @staticmethod
    def check_result_to_string(result):
        r"""Return string representation of the CheckResult enum"""
        ...

class VectorKeyInfo:
    thisown = ...
    __repr__ = ...
    def iterator(self): ...
    def __iter__(self): ...
    def __nonzero__(self): ...
    def __bool__(self): ...
    def __len__(self): ...
    def __getslice__(self, i, j): ...
    def __setslice__(self, *args): ...
    def __delslice__(self, i, j): ...
    def __delitem__(self, *args): ...
    def __getitem__(self, *args): ...
    def __setitem__(self, *args): ...
    def pop(self): ...
    def append(self, x): ...
    def empty(self): ...
    def size(self): ...
    def swap(self, v): ...
    def begin(self): ...
    def end(self): ...
    def rbegin(self): ...
    def rend(self): ...
    def clear(self): ...
    def get_allocator(self): ...
    def pop_back(self): ...
    def erase(self, *args): ...
    def __init__(self, *args) -> None: ...
    def push_back(self, x): ...
    def front(self): ...
    def back(self): ...
    def assign(self, n, x): ...
    def insert(self, *args): ...
    def reserve(self, n): ...
    def capacity(self): ...

    __swig_destroy__ = ...
