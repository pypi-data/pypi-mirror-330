"""
This type stub file was generated by pyright.
"""

if __package__ or "." in __name__:
    ...
else:
    ...

class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""

    __setattr__ = ...

class LoggerUniquePtr:
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...
    def __deref__(self): ...
    def release(self): ...
    def reset(self, __p=...): ...
    def swap(self, __u): ...
    def get(self): ...
    def __nonzero__(self): ...

    __bool__ = ...
    __swig_destroy__ = ...
    def level_to_cstr(self, level): ...
    def log_line(self, level, message): ...
    def write(self, time, pid, level, message): ...
    def critical(self, msg): ...
    def error(self, msg): ...
    def warning(self, msg): ...
    def notice(self, msg): ...
    def info(self, msg): ...
    def debug(self, msg): ...
    def trace(self, msg): ...
    def log(self, level, msg): ...

class MemoryBufferLoggerUniquePtr:
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...
    def __deref__(self): ...
    def release(self): ...
    def reset(self, __p=...): ...
    def swap(self, __u): ...
    def get(self): ...
    def __nonzero__(self): ...

    __bool__ = ...
    __swig_destroy__ = ...
    def write(self, time, pid, level, message): ...
    def get_items_count(self): ...
    def get_item(self, item_idx): ...
    def clear(self): ...
    def write_to_logger(self, logger): ...
    def level_to_cstr(self, level): ...
    def log_line(self, level, message): ...
    def critical(self, msg): ...
    def error(self, msg): ...
    def warning(self, msg): ...
    def notice(self, msg): ...
    def info(self, msg): ...
    def debug(self, msg): ...
    def trace(self, msg): ...
    def log(self, level, msg): ...

class LogRouterWeakPtr:
    r"""
    WeakPtr is a "smart" pointer. It contains a pointer to resource and to guard of resource.
    WeakPtr pointer can be owner of the resource. However, the resource itself may depend on another resource.
    WeakPtr registers/unregisters itself at the guard of resource. And the resource guard invalidates
    the registered WeakPtrs when the resource is unusable (eg. its dependecny was released).
    Note on thread safety:
    It is safe to create, access and destroy WeakPtrs in multiple threads simultaneously.
    """

    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def __deref__(self):
        r"""Provides access to the managed object. Generates exception if object is not valid."""
        ...

    def get(self):
        r"""Returns a pointer to the managed object. Generates exception if object is not valid."""
        ...

    def is_valid(self):
        r"""Checks if managed object is valid."""
        ...

    def has_same_guard(self, other):
        r"""Checks if the other WeakPtr instance has the same WeakPtrGuard."""
        ...

    def __ref__(self): ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def add_logger(self, logger):
        r"""Moves (registers) the "logger" into the log router. It gets next free index number."""
        ...

    def get_logger(self, index):
        r"""Returns pointer to the logger at the "index" position."""
        ...

    def release_logger(self, index):
        r"""
        Removes logger at the "index" position from LogRouter.
        The array of the loggers is squeezed. Index of the loggers behind removed logger is decreased by one.
        """
        ...

    def swap_logger(self, logger, index):
        r"""Swaps the logger at the "index" position with another "logger"."""
        ...

    def get_loggers_count(self):
        r"""Returns number of loggers registered in LogRouter."""
        ...

    def log_line(self, level, message): ...
    def write(self, time, pid, level, message): ...
    def level_to_cstr(self, level): ...
    def critical(self, msg): ...
    def error(self, msg): ...
    def warning(self, msg): ...
    def notice(self, msg): ...
    def info(self, msg): ...
    def debug(self, msg): ...
    def trace(self, msg): ...
    def log(self, level, msg): ...

class Logger:
    r"""
    Logger is an abstract interface used for logging.
    An implementation (inherited class) can call callbacks, log the messages to memory, file, or somewhere else.
    """

    thisown = ...
    __repr__ = ...
    def __init__(self) -> None: ...

    __swig_destroy__ = ...
    Level_CRITICAL = ...
    Level_ERROR = ...
    Level_WARNING = ...
    Level_NOTICE = ...
    Level_INFO = ...
    Level_DEBUG = ...
    Level_TRACE = ...
    @staticmethod
    def level_to_cstr(level): ...
    def log_line(self, level, message): ...
    def write(self, time, pid, level, message): ...
    def critical(self, msg): ...
    def error(self, msg): ...
    def warning(self, msg): ...
    def notice(self, msg): ...
    def info(self, msg): ...
    def debug(self, msg): ...
    def trace(self, msg): ...
    def log(self, level, msg): ...
    def __disown__(self):  # -> Any:
        ...

class StringLogger(Logger):
    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    def write(self, *args): ...

    __swig_destroy__ = ...

class LogRouter(Logger):
    r"""
    LogRouter is an implementation of logging class that forwards incoming logging messages to several other loggers.
    Loggers can be addressed via index. Index is serial number of the logger starting from zero.
    """

    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None:
        r"""
        *Overload 1:*
        Constructs a new LogRouter instance with an empty set of destination loggers.

        |

        *Overload 2:*
        Constructs a new LogRouter instance and sets the destination loggers.
        """
        ...

    def add_logger(self, logger):
        r"""Moves (registers) the "logger" into the log router. It gets next free index number."""
        ...

    def get_logger(self, index):
        r"""Returns pointer to the logger at the "index" position."""
        ...

    def release_logger(self, index):
        r"""
        Removes logger at the "index" position from LogRouter.
        The array of the loggers is squeezed. Index of the loggers behind removed logger is decreased by one.
        """
        ...

    def swap_logger(self, logger, index):
        r"""Swaps the logger at the "index" position with another "logger"."""
        ...

    def get_loggers_count(self):
        r"""Returns number of loggers registered in LogRouter."""
        ...

    def log_line(self, level, message): ...
    def write(self, time, pid, level, message): ...

    __swig_destroy__ = ...

class GlobalLogger:
    r"""
    GlobalLogger contains methods for setting the target (logger) for global messages - messages that are
    generated by libraries (eg librepo) without binding to the Base object.
    """

    thisown = ...
    __repr__ = ...
    def __init__(self) -> None: ...

    __swig_destroy__ = ...
    @staticmethod
    def set(destination, verbosity): ...
    @staticmethod
    def unset(): ...

class MemoryBufferLogger(Logger):
    r"""
    MemoryBufferLogger is an implementation of logging class that stores incoming logging messages into memory buffer.
    It is usually used as temporary logger until a final logger is configured.
    """

    thisown = ...
    __repr__ = ...
    def __init__(self, max_items_to_keep, reserve=...) -> None: ...
    def write(self, time, pid, level, message): ...
    def get_items_count(self): ...
    def get_item(self, item_idx): ...
    def clear(self): ...
    def write_to_logger(self, logger): ...

    __swig_destroy__ = ...

def create_file_logger(*args):
    r"""
    *Overload 1:*
    Deprecated: It is going to be removed.
    Helper method for creating a file logger.
    :type base: libdnf5::Base
    :param base: Reference to Base for loading the configured logger path.
    :rtype: std::unique_ptr< libdnf5::Logger >
    :return: Instance of a new file logger.

    |

    *Overload 2:*
    Helper method for creating a file logger in `logdir` location with given file name.
    :type base: libdnf5::Base
    :param base: Reference to Base for loading the configured logger path.
    :type filename: string
    :param filename: Name of the log file.
    :rtype: std::unique_ptr< libdnf5::Logger >
    :return: Instance of a new file logger.
    """
    ...

def create_rotating_file_logger(base, filename):
    r"""
    Helper method for creating a rotating file logger in `logdir` location with given file name.
    :type base: libdnf5::Base
    :param base: Reference to Base for loading the configured parameters.
    :type filename: string
    :param filename: Name of the log file.
    :rtype: std::unique_ptr< libdnf5::Logger >
    :return: Instance of a new rotating file logger.
    """
    ...

cvar = ...
FILE_LOGGER_FILENAME = ...
