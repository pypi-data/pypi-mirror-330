"""
This type stub file was generated by pyright.
"""

if __package__ or "." in __name__:
    ...
else:
    ...

class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""

    __setattr__ = ...

class SwigPyIterator:
    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    __swig_destroy__ = ...
    def value(self): ...
    def incr(self, n=...): ...
    def decr(self, n=...): ...
    def distance(self, x): ...
    def equal(self, x): ...
    def copy(self): ...
    def next(self): ...
    def __next__(self): ...
    def previous(self): ...
    def advance(self, n): ...
    def __eq__(self, x) -> bool: ...
    def __ne__(self, x) -> bool: ...
    def __iadd__(self, n): ...
    def __isub__(self, n): ...
    def __add__(self, n): ...
    def __sub__(self, *args): ...
    def __iter__(self):  # -> Self:
        ...

class AdvisoryId:
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...

    id = ...
    __swig_destroy__ = ...

class Advisory:
    r"""An advisory, represents advisory used to track security updates"""

    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...

    __swig_destroy__ = ...
    def get_name(self):
        r"""
        Get name of this advisory.

        :rtype: string
        :return: Name of this advisory as std::string.
        """
        ...

    def get_severity(self):
        r"""
        Get severity of this advisory.

        :rtype: string
        :return: Severity of this advisory as std::string.
        """
        ...

    def get_type(self):
        r"""
        Get type of this advisory.
        Possible types are: "security", "bugfix", "enhancement", "newpackage".

        :rtype: string
        :return: type of this advisory as std::string.
        """
        ...

    def get_buildtime(self):
        r"""
        Get buildtime of this advisory. Libsolv combines issued and updated dates
        into buildtime by always using the newer one.

        :rtype: int
        :return: buildtime of this advisory.
        """
        ...

    def get_vendor(self):
        r"""
        Get vendor of this advisory.

        :rtype: string
        :return: Vendor of this advisory as std::string.
        """
        ...

    def get_description(self):
        r"""
        Get description of this advisory.

        :rtype: string
        :return: Description of this advisory as std::string.
        """
        ...

    def get_title(self):
        r"""
        Get title of this advisory.

        :rtype: string
        :return: Title of this advisory as std::string.
        """
        ...

    def get_status(self):
        r"""
        Get status of this advisory.

        :rtype: string
        :return: Status of this advisory as std::string.
        """
        ...

    def get_rights(self):
        r"""
        Get rights of this advisory.

        :rtype: string
        :return: Rights of this advisory as std::string.
        """
        ...

    def get_message(self):
        r"""
        Get message of this advisory.

        :rtype: string
        :return: Message of this advisory as std::string.
        """
        ...

    def get_id(self):
        r"""
        Get AdvisoryId.

        :rtype: :py:class:`AdvisoryId`
        :return: AdvisoryId of this advisory.
        """
        ...

    def get_references(self, *args):
        r"""
        Get all references of specified type from this advisory.
        Possible refenrece types are: "bugzilla", "cve", "vendor".

        :type types: std::vector< std::string,std::allocator< std::string > >, optional
        :param types:     What types of references to get. If not specified gets all types.
        :rtype: std::vector< libdnf5::advisory::AdvisoryReference,std::allocator< libdnf5::advisory::AdvisoryReference > >
        :return: Vector of AdvisoryReference objects.
        """
        ...

    def get_collections(self):
        r"""
        Get all collections from this advisory.

        :rtype: std::vector< libdnf5::advisory::AdvisoryCollection,std::allocator< libdnf5::advisory::AdvisoryCollection > >
        :return: Vector of AdvisoryCollection objects.
        """
        ...

    def is_applicable(self):
        r"""
        Check whether at least one collection from this advisory is applicable.

        :rtype: boolean
        :return: True if applicable, False otherwise.
        """
        ...

class AdvisoryPackage:
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def get_name(self):
        r"""
        Get name of this AdvisoryPackage.

        :rtype: string
        :return: Name of this AdvisoryPackage as std::string.
        """
        ...

    def get_epoch(self):
        r"""
        Get epoch of this AdvisoryPackage.

        :rtype: string
        :return: Epoch of this AdvisoryPackage as std::string.
        """
        ...

    def get_version(self):
        r"""
        Get version of this AdvisoryPackage.

        :rtype: string
        :return: Version of this AdvisoryPackage as std::string.
        """
        ...

    def get_release(self):
        r"""
        Get release version of this AdvisoryPackage.

        :rtype: string
        :return: Release of this AdvisoryPackage as std::string.
        """
        ...

    def get_evr(self):
        r"""
        Get evr of this AdvisoryPackage.

        :rtype: string
        :return: Evr of this AdvisoryPackage as std::string.
        """
        ...

    def get_arch(self):
        r"""
        Get arch of this AdvisoryPackage.

        :rtype: string
        :return: Arch of this AdvisoryPackage as std::string.
        """
        ...

    def get_nevra(self):
        r"""
        Get NEVRA of this AdvisoryPackage.

        :rtype: string
        :return: NEVRA of this AdvisoryPackage as std::string.
        """
        ...

    def get_advisory_id(self):
        r"""
        Get AdvisoryId of Advisory this AdvisoryPackage belongs to.

        :rtype: :py:class:`AdvisoryId`
        :return: AdvisoryId of this AdvisoryPackage.
        """
        ...

    def get_reboot_suggested(self):
        r"""
        Get bool value whether reboot is suggested

        :rtype: boolean
        :return: Reboot suggestion of this advisory package as bool
        """
        ...

    def get_restart_suggested(self):
        r"""
        Get bool value whether restart is suggested

        :rtype: boolean
        :return: Restart suggestion of this advisory package as bool
        """
        ...

    def get_relogin_suggested(self):
        r"""
        Get bool value whether relogin is suggested

        :rtype: boolean
        :return: Relogin suggestion of this advisory package as bool
        """
        ...

    def get_advisory(self):
        r"""
        Get Advisory this AdvisoryPackage belongs to.

        :rtype: :py:class:`Advisory`
        :return: newly construted Advisory object of this AdvisoryPackage.
        """
        ...

    def get_advisory_collection(self):
        r"""
        Get AdvisoryCollection this AdvisoryPackage belongs to.

        :rtype: :py:class:`AdvisoryCollection`
        :return: newly construted AdvisoryCollection object of this AdvisoryPackage.
        """
        ...

class AdvisorySet:
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def begin(self): ...
    def end(self): ...
    def __ior__(self, other): ...
    def __isub__(self, other): ...
    def __iand__(self, other): ...
    def update(self, other):
        r"""
        Set union: elements that are in the current set or in the `other` set.

        :type other: :py:class:`AdvisorySet`
        :param other: The set to unify with.
        :raises: UsedDifferentSack When the sets entering the operation do not share the same AdvisorySack.
        Since: 5.0
        """
        ...

    def intersection(self, other):
        r"""
        Set intersection: elements in the current set that are also in the `other` set.

        :type other: :py:class:`AdvisorySet`
        :param other: The set to intersect with.
        :raises: UsedDifferentSack When the sets entering the operation do not share the same AdvisorySack.
        Since: 5.0
        """
        ...

    def difference(self, other):
        r"""
        Set difference: elements in the current set that are not in the `other` set.

        :type other: :py:class:`AdvisorySet`
        :param other: The set to check for differences in.
        :raises: UsedDifferentSack When the sets entering the operation do not share the same AdvisorySack.
        Since: 5.0
        """
        ...

    def clear(self):
        r"""
        Remove all advisories from the set.

        Since: 5.0
        """
        ...

    def empty(self):
        r"""
        :rtype: boolean
        :return: `true` if the set is empty, `false` otherwise.
        Since: 5.0
        """
        ...

    def add(self, adv):
        r"""
        Add `adv` to the set.

        :type adv: :py:class:`Advisory`
        :param adv: Advisory to be added to the set.
        Since: 5.0
        """
        ...

    def contains(self, adv):
        r"""
        :rtype: boolean
        :return: `true` if an advisory is in the set, `false` otherwise.
        :type adv: :py:class:`Advisory`
        :param adv: Advisory that is tested for presence.
        Since: 5.0
        """
        ...

    def remove(self, adv):
        r"""
        Remove `adv` from the set.

        :type adv: :py:class:`Advisory`
        :param adv: Advisory to be removed from the set.
        Since: 5.0
        """
        ...

    def get_base(self): ...
    def size(self):
        r"""
        :rtype: int
        :return: Number of elements in the set.
        """
        ...

    def swap(self, other): ...
    def get_advisory_packages_sorted_by_name_arch_evr(self, only_applicable=...):
        r"""
        Gather AdvisoryPackages for each Advisory in the set.
        The AdvisoryPackages are sorted by libsolv `id`s of name, arch and evr.
        This is a different sorting than sorting by the strings of AdvisoryPackages names, architectures and evrs.

        :type only_applicable: boolean, optional
        :param only_applicable: Whether to return only AdvisoryPackages from applicable AdvisoryCollections.
        Since: 5.0
        """
        ...

class AdvisorySetIterator:
    thisown = ...
    __repr__ = ...
    def __init__(self, other) -> None: ...

    __swig_destroy__ = ...
    def value(self): ...
    def next(self): ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def begin(self, *args): ...
    def end(self, *args): ...

class AdvisoryModule:
    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def get_name(self):
        r"""
        Get name of this AdvisoryModule.

        :rtype: string
        :return: Name of this AdvisoryModule as std::string.
        """
        ...

    def get_stream(self):
        r"""
        Get stream of this AdvisoryModule.

        :rtype: string
        :return: Stream of this AdvisoryModule as std::string.
        """
        ...

    def get_version(self):
        r"""
        Get version of this AdvisoryModule.

        :rtype: string
        :return: Version of this AdvisoryModule as std::string.
        """
        ...

    def get_context(self):
        r"""
        Get context of this AdvisoryModule.

        :rtype: string
        :return: Context of this AdvisoryModule as std::string.
        """
        ...

    def get_arch(self):
        r"""
        Get arch of this AdvisoryModule.

        :rtype: string
        :return: Arch of this AdvisoryModule as std::string.
        """
        ...

    def get_nsvca(self):
        r"""
        Get NSVCA of this AdvisoryModule.

        :rtype: string
        :return: NSVCA of this AdvisoryModule as std::string.
        """
        ...

    def get_advisory_id(self):
        r"""
        Get AdvisoryId of Advisory this AdvisoryModule belongs to.

        :rtype: :py:class:`AdvisoryId`
        :return: AdvisoryId of this AdvisoryModule.
        """
        ...

    def get_advisory(self):
        r"""
        Get Advisory this AdvisoryModule belongs to.

        :rtype: :py:class:`Advisory`
        :return: newly construted Advisory object of this AdvisoryModule.
        """
        ...

    def get_advisory_collection(self):
        r"""
        Get AdvisoryCollection this AdvisoryModule belongs to.

        :rtype: :py:class:`AdvisoryCollection`
        :return: newly construted AdvisoryCollection object of this AdvisoryModule.
        """
        ...

class AdvisoryCollection:
    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    def is_applicable(self):
        r"""
        Whether this AdvisoryCollection is applicable. True when at least one AdvisoryModule in this
        AdvisoryCollection is active on the system, False otherwise.
        """
        ...

    def get_advisory_id(self):
        r"""
        Get AdvisoryId of Advisory this AdvisoryCollection belongs to.

        :rtype: :py:class:`AdvisoryId`
        :return: AdvisoryId of this AdvisoryCollection.
        """
        ...

    def get_packages(self):
        r"""
        Get all AdvisoryPackages stored in this AdvisoryCollection

        :rtype: std::vector< libdnf5::advisory::AdvisoryPackage,std::allocator< libdnf5::advisory::AdvisoryPackage > >
        :return: std::vector of AdvisorPackages used as output.
        """
        ...

    def get_modules(self):
        r"""
        Get all AdvisoryModules stored in this AdvisoryCollection

        :rtype: std::vector< libdnf5::advisory::AdvisoryModule,std::allocator< libdnf5::advisory::AdvisoryModule > >
        :return: std::vector of AdvisorModules.
        """
        ...

    def get_advisory(self):
        r"""
        Get Advisory this AdvisoryCollection belongs to.

        :rtype: :py:class:`Advisory`
        :return: newly construted Advisory object of this AdvisoryCollection.
        """
        ...
    __swig_destroy__ = ...

class AdvisoryQuery(AdvisorySet):
    r"""
    AdvisoryQuery is the only way how to access advisories.
    It is constructed using Base and filled with advisories from enabled repositories in its RepoSack.
    """

    thisown = ...
    __repr__ = ...
    def __init__(self, *args) -> None: ...

    __swig_destroy__ = ...
    def filter_name(self, *args): ...
    def filter_type(self, *args): ...
    def filter_reference(self, *args): ...
    def filter_severity(self, *args): ...
    def filter_packages(self, *args):
        r"""
        Filter out advisories that don't contain at least one AdvisoryPackage that has a counterpart Package in package_set
        such that they have matching name and architecture and also their epoch-version-release complies to cmp_type.

        :type package_set: libdnf5::rpm::PackageSet
        :param package_set:  libdnf5::rpm::PackageSet used when filtering.
        :type cmp_type: int, optional
        :param cmp_type:     Condition to fulfill when comparing epoch-version-release of packages.
        """
        ...

    def get_advisory_packages_sorted(self, *args):
        r"""
        Get std::vector of AdvisoryPackages present in advisories from query.
        Each AdvisoryPackage is returned only if it has a counterpart Package in package_set such that they have matching
        name and architecture and also their epoch-version-release complies to cmp_type.
        AdvisoryPackages are sorted in the std::vector by Name, Arch and EVR.

        :type package_set: libdnf5::rpm::PackageSet
        :param package_set:  libdnf5::rpm::PackageSet used when filtering.
        :type cmp_type: int, optional
        :param cmp_type:     Condition to fulfill when comparing epoch-version-release of packages.
        :rtype: std::vector< libdnf5::advisory::AdvisoryPackage,std::allocator< libdnf5::advisory::AdvisoryPackage > >
        :return: std::vector of AdvisoryPackages
        """
        ...

class AdvisoryReference:
    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    def get_id(self):
        r"""
        Get id of this advisory reference, this id is like a name of this reference
        (it is not libsolv id).

        :rtype: string
        :return: id of this reference as std::string.
        """
        ...

    def get_type(self):
        r"""
        Get type of this reference.
        Possible reference types are: "bugzilla", "cve", "vendor".

        :rtype: string
        :return: type of this reference as std::string.
        """
        ...

    def get_type_cstring(self):
        r"""
        Get type of this reference.

        :rtype: string
        :return: Type of this reference as const char* !! (temporal value)
        """
        ...

    def get_title(self):
        r"""
        Get title of this reference.

        :rtype: string
        :return: Title of this reference.
        """
        ...

    def get_url(self):
        r"""
        Get url of this reference.

        :rtype: string
        :return: Url of this reference.
        """
        ...
    __swig_destroy__ = ...

class VectorAdvisoryModule:
    thisown = ...
    __repr__ = ...
    def iterator(self): ...
    def __iter__(self): ...
    def __nonzero__(self): ...
    def __bool__(self): ...
    def __len__(self): ...
    def __getslice__(self, i, j): ...
    def __setslice__(self, *args): ...
    def __delslice__(self, i, j): ...
    def __delitem__(self, *args): ...
    def __getitem__(self, *args): ...
    def __setitem__(self, *args): ...
    def pop(self): ...
    def append(self, x): ...
    def empty(self): ...
    def size(self): ...
    def swap(self, v): ...
    def begin(self): ...
    def end(self): ...
    def rbegin(self): ...
    def rend(self): ...
    def clear(self): ...
    def get_allocator(self): ...
    def pop_back(self): ...
    def erase(self, *args): ...
    def __init__(self, *args) -> None: ...
    def push_back(self, x): ...
    def front(self): ...
    def back(self): ...
    def assign(self, n, x): ...
    def insert(self, *args): ...
    def reserve(self, n): ...
    def capacity(self): ...

    __swig_destroy__ = ...

class VectorAdvisoryCollection:
    thisown = ...
    __repr__ = ...
    def iterator(self): ...
    def __iter__(self): ...
    def __nonzero__(self): ...
    def __bool__(self): ...
    def __len__(self): ...
    def __getslice__(self, i, j): ...
    def __setslice__(self, *args): ...
    def __delslice__(self, i, j): ...
    def __delitem__(self, *args): ...
    def __getitem__(self, *args): ...
    def __setitem__(self, *args): ...
    def pop(self): ...
    def append(self, x): ...
    def empty(self): ...
    def size(self): ...
    def swap(self, v): ...
    def begin(self): ...
    def end(self): ...
    def rbegin(self): ...
    def rend(self): ...
    def clear(self): ...
    def get_allocator(self): ...
    def pop_back(self): ...
    def erase(self, *args): ...
    def __init__(self, *args) -> None: ...
    def push_back(self, x): ...
    def front(self): ...
    def back(self): ...
    def assign(self, n, x): ...
    def insert(self, *args): ...
    def reserve(self, n): ...
    def capacity(self): ...

    __swig_destroy__ = ...

class VectorAdvisoryPackage:
    thisown = ...
    __repr__ = ...
    def iterator(self): ...
    def __iter__(self): ...
    def __nonzero__(self): ...
    def __bool__(self): ...
    def __len__(self): ...
    def __getslice__(self, i, j): ...
    def __setslice__(self, *args): ...
    def __delslice__(self, i, j): ...
    def __delitem__(self, *args): ...
    def __getitem__(self, *args): ...
    def __setitem__(self, *args): ...
    def pop(self): ...
    def append(self, x): ...
    def empty(self): ...
    def size(self): ...
    def swap(self, v): ...
    def begin(self): ...
    def end(self): ...
    def rbegin(self): ...
    def rend(self): ...
    def clear(self): ...
    def get_allocator(self): ...
    def pop_back(self): ...
    def erase(self, *args): ...
    def __init__(self, *args) -> None: ...
    def push_back(self, x): ...
    def front(self): ...
    def back(self): ...
    def assign(self, n, x): ...
    def insert(self, *args): ...
    def reserve(self, n): ...
    def capacity(self): ...

    __swig_destroy__ = ...

class VectorAdvisoryReference:
    thisown = ...
    __repr__ = ...
    def iterator(self): ...
    def __iter__(self): ...
    def __nonzero__(self): ...
    def __bool__(self): ...
    def __len__(self): ...
    def __getslice__(self, i, j): ...
    def __setslice__(self, *args): ...
    def __delslice__(self, i, j): ...
    def __delitem__(self, *args): ...
    def __getitem__(self, *args): ...
    def __setitem__(self, *args): ...
    def pop(self): ...
    def append(self, x): ...
    def empty(self): ...
    def size(self): ...
    def swap(self, v): ...
    def begin(self): ...
    def end(self): ...
    def rbegin(self): ...
    def rend(self): ...
    def clear(self): ...
    def get_allocator(self): ...
    def pop_back(self): ...
    def erase(self, *args): ...
    def __init__(self, *args) -> None: ...
    def push_back(self, x): ...
    def front(self): ...
    def back(self): ...
    def assign(self, n, x): ...
    def insert(self, *args): ...
    def reserve(self, n): ...
    def capacity(self): ...

    __swig_destroy__ = ...

def AdvisorySet__iter__(self):  # -> Iterator:
    ...
