# Generated by cloudcoil-model-codegen v0.5.6
# DO NOT EDIT

from __future__ import annotations

from typing import (
    Annotated,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class Owner(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Owner"]:
            return Owner

        def build(self) -> "Owner":
            return Owner(**self._attrs)

        def api_version(self, value: str, /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def block_owner_deletion(self, value: Optional[bool], /) -> Self:
            """
            If true, AND if the owner has the "foregroundDeletion" finalizer, then
            the owner cannot be deleted from the key-value store until this
            reference is removed.
            See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion
            for how the garbage collector interacts with this field and enforces the foreground deletion.
            Defaults to false.
            To set this field, a user needs "delete" permission of the owner,
            otherwise 422 (Unprocessable Entity) will be returned.
            """
            return self._set("block_owner_deletion", value)

        def controller(self, value: Optional[bool], /) -> Self:
            """
            If true, this reference points to the managing controller.
            """
            return self._set("controller", value)

        def kind(self, value: str, /) -> Self:
            """
            Kind of the referent.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
            """
            return self._set("name", value)

        def uid(self, value: str, /) -> Self:
            """
            UID of the referent.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
            """
            return self._set("uid", value)

    class BuilderContext(BuilderContextBase["Owner.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Owner.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Owner."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Owner", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Owner.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[str, Field(alias="apiVersion")]
    """
    API version of the referent.
    """
    block_owner_deletion: Annotated[Optional[bool], Field(alias="blockOwnerDeletion")] = None
    """
    If true, AND if the owner has the "foregroundDeletion" finalizer, then
    the owner cannot be deleted from the key-value store until this
    reference is removed.
    See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion
    for how the garbage collector interacts with this field and enforces the foreground deletion.
    Defaults to false.
    To set this field, a user needs "delete" permission of the owner,
    otherwise 422 (Unprocessable Entity) will be returned.
    """
    controller: Optional[bool] = None
    """
    If true, this reference points to the managing controller.
    """
    kind: str
    """
    Kind of the referent.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: str
    """
    Name of the referent.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
    """
    uid: str
    """
    UID of the referent.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
    """


class MatchExpression(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchExpression"]:
            return MatchExpression

        def build(self) -> "MatchExpression":
            return MatchExpression(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key is the label key that the selector applies to.
            """
            return self._set("key", value)

        def operator(self, value: str, /) -> Self:
            """
            operator represents a key's relationship to a set of values.
            Valid operators are In, NotIn, Exists and DoesNotExist.
            """
            return self._set("operator", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            values is an array of string values. If the operator is In or NotIn,
            the values array must be non-empty. If the operator is Exists or DoesNotExist,
            the values array must be empty. This array is replaced during a strategic
            merge patch.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["MatchExpression.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchExpression.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchExpression."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchExpression", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchExpression.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key is the label key that the selector applies to.
    """
    operator: str
    """
    operator represents a key's relationship to a set of values.
    Valid operators are In, NotIn, Exists and DoesNotExist.
    """
    values: Optional[List[str]] = None
    """
    values is an array of string values. If the operator is In or NotIn,
    the values array must be non-empty. If the operator is Exists or DoesNotExist,
    the values array must be empty. This array is replaced during a strategic
    merge patch.
    """


class ResourceSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceSelector"]:
            return ResourceSelector

        def build(self) -> "ResourceSelector":
            return ResourceSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpression], /
        ) -> "ResourceSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpression, MatchExpression.Builder]],
                GenericListBuilder[MatchExpression, MatchExpression.Builder]
                | List[MatchExpression],
            ],
            /,
        ) -> "ResourceSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpression.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpression.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpression.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["ResourceSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpression]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class ResourceModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceModel"]:
            return ResourceModel

        def build(self) -> "ResourceModel":
            return ResourceModel(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def field_path(self, value: Optional[str], /) -> Self:
            """
            If referring to a piece of an object instead of an entire object, this string
            should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
            For example, if the object reference is to a container within a pod, this would take on a value like:
            "spec.containers{name}" (where "name" refers to the name of the container that triggered
            the event) or if no container name is specified "spec.containers[2]" (container with
            index 2 in this pod). This syntax is chosen only to have some well-defined way of
            referencing a part of an object.
            """
            return self._set("field_path", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
            """
            return self._set("namespace", value)

        def resource_version(self, value: Optional[str], /) -> Self:
            """
            Specific resourceVersion to which this reference is made, if any.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
            """
            return self._set("resource_version", value)

        def uid(self, value: Optional[str], /) -> Self:
            """
            UID of the referent.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
            """
            return self._set("uid", value)

    class BuilderContext(BuilderContextBase["ResourceModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    field_path: Annotated[Optional[str], Field(alias="fieldPath")] = None
    """
    If referring to a piece of an object instead of an entire object, this string
    should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
    For example, if the object reference is to a container within a pod, this would take on a value like:
    "spec.containers{name}" (where "name" refers to the name of the container that triggered
    the event) or if no container name is specified "spec.containers[2]" (container with
    index 2 in this pod). This syntax is chosen only to have some well-defined way of
    referencing a part of an object.
    """
    kind: Optional[str] = None
    """
    Kind of the referent.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = None
    """
    Name of the referent.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    """
    resource_version: Annotated[Optional[str], Field(alias="resourceVersion")] = None
    """
    Specific resourceVersion to which this reference is made, if any.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
    """
    uid: Optional[str] = None
    """
    UID of the referent.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
    """


class Timestamp(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Timestamp"]:
            return Timestamp

        def build(self) -> "Timestamp":
            return Timestamp(**self._attrs)

        def nanos(self, value: int, /) -> Self:
            """
            Non-negative fractions of a second at nanosecond resolution. Negative
            second values with fractions must still have non-negative nanos values
            that count forward in time. Must be from 0 to 999,999,999
            inclusive. This field may be limited in precision depending on context.
            """
            return self._set("nanos", value)

        def seconds(self, value: int, /) -> Self:
            """
            Represents seconds of UTC time since Unix epoch
            1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
            9999-12-31T23:59:59Z inclusive.
            """
            return self._set("seconds", value)

    class BuilderContext(BuilderContextBase["Timestamp.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Timestamp.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Timestamp."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Timestamp", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Timestamp.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    nanos: int
    """
    Non-negative fractions of a second at nanosecond resolution. Negative
    second values with fractions must still have non-negative nanos values
    that count forward in time. Must be from 0 to 999,999,999
    inclusive. This field may be limited in precision depending on context.
    """
    seconds: int
    """
    Represents seconds of UTC time since Unix epoch
    1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
    9999-12-31T23:59:59Z inclusive.
    """


class Result(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Result"]:
            return Result

        def build(self) -> "Result":
            return Result(**self._attrs)

        def category(self, value: Optional[str], /) -> Self:
            """
            Category indicates policy category
            """
            return self._set("category", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Description is a short user friendly message for the policy rule
            """
            return self._set("message", value)

        def policy(self, value: str, /) -> Self:
            """
            Policy is the name or identifier of the policy
            """
            return self._set("policy", value)

        def properties(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Properties provides additional information for the policy rule
            """
            return self._set("properties", value)

        @overload
        def resource_selector(
            self, value_or_callback: Optional[ResourceSelector], /
        ) -> "Result.Builder": ...

        @overload
        def resource_selector(
            self,
            value_or_callback: Callable[
                [ResourceSelector.Builder], ResourceSelector.Builder | ResourceSelector
            ],
            /,
        ) -> "Result.Builder": ...

        @overload
        def resource_selector(
            self, value_or_callback: Never = ...
        ) -> "ResourceSelector.BuilderContext": ...

        def resource_selector(self, value_or_callback=None, /):
            """
            SubjectSelector is an optional label selector for checked Kubernetes resources.
            For example, a policy result may apply to all pods that match a label.
            Either a Subject or a SubjectSelector can be specified.
            If neither are provided, the result is assumed to be for the policy report scope.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceSelector.builder())
                if isinstance(output, ResourceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_selector", value)

        @overload
        def resources(self, value_or_callback: List[ResourceModel], /) -> "Result.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ResourceModel, ResourceModel.Builder]],
                GenericListBuilder[ResourceModel, ResourceModel.Builder] | List[ResourceModel],
            ],
            /,
        ) -> "Result.Builder": ...

        @overload
        def resources(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ResourceModel.Builder]: ...

        def resources(self, value_or_callback=None, /):
            """
            Subjects is an optional reference to the checked Kubernetes resources
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ResourceModel.Builder]()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def result(
            self, value: Optional[Literal["pass", "fail", "warn", "error", "skip"]], /
        ) -> Self:
            """
            Result indicates the outcome of the policy rule execution
            """
            return self._set("result", value)

        def rule(self, value: Optional[str], /) -> Self:
            """
            Rule is the name or identifier of the rule within the policy
            """
            return self._set("rule", value)

        def scored(self, value: Optional[bool], /) -> Self:
            """
            Scored indicates if this result is scored
            """
            return self._set("scored", value)

        def severity(
            self,
            value: Optional[Literal["critical", "high", "low", "medium", "info"]],
            /,
        ) -> Self:
            """
            Severity indicates policy check result criticality
            """
            return self._set("severity", value)

        def source(self, value: Optional[str], /) -> Self:
            """
            Source is an identifier for the policy engine that manages this report
            """
            return self._set("source", value)

        @overload
        def timestamp(self, value_or_callback: Optional[Timestamp], /) -> "Result.Builder": ...

        @overload
        def timestamp(
            self,
            value_or_callback: Callable[[Timestamp.Builder], Timestamp.Builder | Timestamp],
            /,
        ) -> "Result.Builder": ...

        @overload
        def timestamp(self, value_or_callback: Never = ...) -> "Timestamp.BuilderContext": ...

        def timestamp(self, value_or_callback=None, /):
            """
            Timestamp indicates the time the result was found
            """
            if self._in_context and value_or_callback is None:
                context = Timestamp.BuilderContext()
                context._parent_builder = self
                context._field_name = "timestamp"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Timestamp.builder())
                if isinstance(output, Timestamp.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("timestamp", value)

    class BuilderContext(BuilderContextBase["Result.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Result.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Result."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Result", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Result.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    category: Optional[str] = None
    """
    Category indicates policy category
    """
    message: Optional[str] = None
    """
    Description is a short user friendly message for the policy rule
    """
    policy: str
    """
    Policy is the name or identifier of the policy
    """
    properties: Optional[Dict[str, str]] = None
    """
    Properties provides additional information for the policy rule
    """
    resource_selector: Annotated[Optional[ResourceSelector], Field(alias="resourceSelector")] = None
    """
    SubjectSelector is an optional label selector for checked Kubernetes resources.
    For example, a policy result may apply to all pods that match a label.
    Either a Subject or a SubjectSelector can be specified.
    If neither are provided, the result is assumed to be for the policy report scope.
    """
    resources: Optional[List[ResourceModel]] = None
    """
    Subjects is an optional reference to the checked Kubernetes resources
    """
    result: Optional[Literal["pass", "fail", "warn", "error", "skip"]] = None
    """
    Result indicates the outcome of the policy rule execution
    """
    rule: Optional[str] = None
    """
    Rule is the name or identifier of the rule within the policy
    """
    scored: Optional[bool] = None
    """
    Scored indicates if this result is scored
    """
    severity: Optional[Literal["critical", "high", "low", "medium", "info"]] = None
    """
    Severity indicates policy check result criticality
    """
    source: Optional[str] = None
    """
    Source is an identifier for the policy engine that manages this report
    """
    timestamp: Optional[Timestamp] = None
    """
    Timestamp indicates the time the result was found
    """


class Summary(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Summary"]:
            return Summary

        def build(self) -> "Summary":
            return Summary(**self._attrs)

        def error(self, value: Optional[int], /) -> Self:
            """
            Error provides the count of policies that could not be evaluated
            """
            return self._set("error", value)

        def fail(self, value: Optional[int], /) -> Self:
            """
            Fail provides the count of policies whose requirements were not met
            """
            return self._set("fail", value)

        def pass_(self, value: Optional[int], /) -> Self:
            """
            Pass provides the count of policies whose requirements were met
            """
            return self._set("pass_", value)

        def skip(self, value: Optional[int], /) -> Self:
            """
            Skip indicates the count of policies that were not selected for evaluation
            """
            return self._set("skip", value)

        def warn(self, value: Optional[int], /) -> Self:
            """
            Warn provides the count of non-scored policies whose requirements were not met
            """
            return self._set("warn", value)

    class BuilderContext(BuilderContextBase["Summary.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Summary.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Summary."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Summary", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Summary.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    error: Optional[int] = None
    """
    Error provides the count of policies that could not be evaluated
    """
    fail: Optional[int] = None
    """
    Fail provides the count of policies whose requirements were not met
    """
    pass_: Annotated[Optional[int], Field(alias="pass")] = None
    """
    Pass provides the count of policies whose requirements were met
    """
    skip: Optional[int] = None
    """
    Skip indicates the count of policies that were not selected for evaluation
    """
    warn: Optional[int] = None
    """
    Warn provides the count of non-scored policies whose requirements were not met
    """


class ClusterEphemeralReportSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterEphemeralReportSpec"]:
            return ClusterEphemeralReportSpec

        def build(self) -> "ClusterEphemeralReportSpec":
            return ClusterEphemeralReportSpec(**self._attrs)

        @overload
        def owner(self, value_or_callback: Owner, /) -> "ClusterEphemeralReportSpec.Builder": ...

        @overload
        def owner(
            self, value_or_callback: Callable[[Owner.Builder], Owner.Builder | Owner], /
        ) -> "ClusterEphemeralReportSpec.Builder": ...

        @overload
        def owner(self, value_or_callback: Never = ...) -> "Owner.BuilderContext": ...

        def owner(self, value_or_callback=None, /):
            """
            Owner is a reference to the report owner (e.g. a Deployment, Namespace, or Node)
            """
            if self._in_context and value_or_callback is None:
                context = Owner.BuilderContext()
                context._parent_builder = self
                context._field_name = "owner"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Owner.builder())
                if isinstance(output, Owner.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("owner", value)

        @overload
        def results(
            self, value_or_callback: List[Result], /
        ) -> "ClusterEphemeralReportSpec.Builder": ...

        @overload
        def results(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Result, Result.Builder]],
                GenericListBuilder[Result, Result.Builder] | List[Result],
            ],
            /,
        ) -> "ClusterEphemeralReportSpec.Builder": ...

        @overload
        def results(self, value_or_callback: Never = ...) -> ListBuilderContext[Result.Builder]: ...

        def results(self, value_or_callback=None, /):
            """
            PolicyReportResult provides result details
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Result.Builder]()
                context._parent_builder = self
                context._field_name = "results"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Result.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("results", value)

        @overload
        def summary(
            self, value_or_callback: Optional[Summary], /
        ) -> "ClusterEphemeralReportSpec.Builder": ...

        @overload
        def summary(
            self,
            value_or_callback: Callable[[Summary.Builder], Summary.Builder | Summary],
            /,
        ) -> "ClusterEphemeralReportSpec.Builder": ...

        @overload
        def summary(self, value_or_callback: Never = ...) -> "Summary.BuilderContext": ...

        def summary(self, value_or_callback=None, /):
            """
            PolicyReportSummary provides a summary of results
            """
            if self._in_context and value_or_callback is None:
                context = Summary.BuilderContext()
                context._parent_builder = self
                context._field_name = "summary"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Summary.builder())
                if isinstance(output, Summary.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("summary", value)

    class BuilderContext(BuilderContextBase["ClusterEphemeralReportSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterEphemeralReportSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterEphemeralReportSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterEphemeralReportSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterEphemeralReportSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    owner: Owner
    """
    Owner is a reference to the report owner (e.g. a Deployment, Namespace, or Node)
    """
    results: Optional[List[Result]] = None
    """
    PolicyReportResult provides result details
    """
    summary: Optional[Summary] = None
    """
    PolicyReportSummary provides a summary of results
    """


class EphemeralReportSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["EphemeralReportSpec"]:
            return EphemeralReportSpec

        def build(self) -> "EphemeralReportSpec":
            return EphemeralReportSpec(**self._attrs)

        @overload
        def owner(self, value_or_callback: Owner, /) -> "EphemeralReportSpec.Builder": ...

        @overload
        def owner(
            self, value_or_callback: Callable[[Owner.Builder], Owner.Builder | Owner], /
        ) -> "EphemeralReportSpec.Builder": ...

        @overload
        def owner(self, value_or_callback: Never = ...) -> "Owner.BuilderContext": ...

        def owner(self, value_or_callback=None, /):
            """
            Owner is a reference to the report owner (e.g. a Deployment, Namespace, or Node)
            """
            if self._in_context and value_or_callback is None:
                context = Owner.BuilderContext()
                context._parent_builder = self
                context._field_name = "owner"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Owner.builder())
                if isinstance(output, Owner.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("owner", value)

        @overload
        def results(self, value_or_callback: List[Result], /) -> "EphemeralReportSpec.Builder": ...

        @overload
        def results(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Result, Result.Builder]],
                GenericListBuilder[Result, Result.Builder] | List[Result],
            ],
            /,
        ) -> "EphemeralReportSpec.Builder": ...

        @overload
        def results(self, value_or_callback: Never = ...) -> ListBuilderContext[Result.Builder]: ...

        def results(self, value_or_callback=None, /):
            """
            PolicyReportResult provides result details
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Result.Builder]()
                context._parent_builder = self
                context._field_name = "results"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Result.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("results", value)

        @overload
        def summary(
            self, value_or_callback: Optional[Summary], /
        ) -> "EphemeralReportSpec.Builder": ...

        @overload
        def summary(
            self,
            value_or_callback: Callable[[Summary.Builder], Summary.Builder | Summary],
            /,
        ) -> "EphemeralReportSpec.Builder": ...

        @overload
        def summary(self, value_or_callback: Never = ...) -> "Summary.BuilderContext": ...

        def summary(self, value_or_callback=None, /):
            """
            PolicyReportSummary provides a summary of results
            """
            if self._in_context and value_or_callback is None:
                context = Summary.BuilderContext()
                context._parent_builder = self
                context._field_name = "summary"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Summary.builder())
                if isinstance(output, Summary.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("summary", value)

    class BuilderContext(BuilderContextBase["EphemeralReportSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = EphemeralReportSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for EphemeralReportSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["EphemeralReportSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use EphemeralReportSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    owner: Owner
    """
    Owner is a reference to the report owner (e.g. a Deployment, Namespace, or Node)
    """
    results: Optional[List[Result]] = None
    """
    PolicyReportResult provides result details
    """
    summary: Optional[Summary] = None
    """
    PolicyReportSummary provides a summary of results
    """


class ClusterEphemeralReport(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterEphemeralReport"]:
            return ClusterEphemeralReport

        def build(self) -> "ClusterEphemeralReport":
            return ClusterEphemeralReport(**self._attrs)

        def api_version(self, value: Optional[Literal["reports.kyverno.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ClusterEphemeralReport"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ClusterEphemeralReport.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ClusterEphemeralReport.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: ClusterEphemeralReportSpec, /
        ) -> "ClusterEphemeralReport.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ClusterEphemeralReportSpec.Builder],
                ClusterEphemeralReportSpec.Builder | ClusterEphemeralReportSpec,
            ],
            /,
        ) -> "ClusterEphemeralReport.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "ClusterEphemeralReportSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterEphemeralReportSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterEphemeralReportSpec.builder())
                if isinstance(output, ClusterEphemeralReportSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["ClusterEphemeralReport.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterEphemeralReport.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterEphemeralReport."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterEphemeralReport", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterEphemeralReport.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["reports.kyverno.io/v1"]], Field(alias="apiVersion")
    ] = "reports.kyverno.io/v1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ClusterEphemeralReport"]] = "ClusterEphemeralReport"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: ClusterEphemeralReportSpec


class EphemeralReport(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["EphemeralReport"]:
            return EphemeralReport

        def build(self) -> "EphemeralReport":
            return EphemeralReport(**self._attrs)

        def api_version(self, value: Optional[Literal["reports.kyverno.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["EphemeralReport"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "EphemeralReport.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "EphemeralReport.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: EphemeralReportSpec, /) -> "EphemeralReport.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [EphemeralReportSpec.Builder],
                EphemeralReportSpec.Builder | EphemeralReportSpec,
            ],
            /,
        ) -> "EphemeralReport.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "EphemeralReportSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = EphemeralReportSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(EphemeralReportSpec.builder())
                if isinstance(output, EphemeralReportSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["EphemeralReport.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = EphemeralReport.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for EphemeralReport."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["EphemeralReport", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use EphemeralReport.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["reports.kyverno.io/v1"]], Field(alias="apiVersion")
    ] = "reports.kyverno.io/v1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["EphemeralReport"]] = "EphemeralReport"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: EphemeralReportSpec
