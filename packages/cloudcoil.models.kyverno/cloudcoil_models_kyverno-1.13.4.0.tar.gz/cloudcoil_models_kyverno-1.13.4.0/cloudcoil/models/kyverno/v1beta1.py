# Generated by cloudcoil-model-codegen v0.5.6
# DO NOT EDIT

from __future__ import annotations

from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class Kind(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Kind"]:
            return Kind

        def build(self) -> "Kind":
            return Kind(**self._attrs)

        def group(self, value: str, /) -> Self:
            return self._set("group", value)

        def kind(self, value: str, /) -> Self:
            return self._set("kind", value)

        def version(self, value: str, /) -> Self:
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["Kind.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Kind.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Kind."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Kind", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Kind.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    group: str
    kind: str
    version: str


class RequestKind(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RequestKind"]:
            return RequestKind

        def build(self) -> "RequestKind":
            return RequestKind(**self._attrs)

        def group(self, value: str, /) -> Self:
            return self._set("group", value)

        def kind(self, value: str, /) -> Self:
            return self._set("kind", value)

        def version(self, value: str, /) -> Self:
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["RequestKind.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestKind.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestKind."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RequestKind", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RequestKind.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    group: str
    kind: str
    version: str


class RequestResource(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RequestResource"]:
            return RequestResource

        def build(self) -> "RequestResource":
            return RequestResource(**self._attrs)

        def group(self, value: str, /) -> Self:
            return self._set("group", value)

        def resource(self, value: str, /) -> Self:
            return self._set("resource", value)

        def version(self, value: str, /) -> Self:
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["RequestResource.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestResource.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestResource."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RequestResource", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RequestResource.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    group: str
    resource: str
    version: str


class ResourceModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceModel"]:
            return ResourceModel

        def build(self) -> "ResourceModel":
            return ResourceModel(**self._attrs)

        def group(self, value: str, /) -> Self:
            return self._set("group", value)

        def resource(self, value: str, /) -> Self:
            return self._set("resource", value)

        def version(self, value: str, /) -> Self:
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["ResourceModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    group: str
    resource: str
    version: str


class UserInfo(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UserInfo"]:
            return UserInfo

        def build(self) -> "UserInfo":
            return UserInfo(**self._attrs)

        def extra(self, value: Optional[Dict[str, List[str]]], /) -> Self:
            """
            Any additional information provided by the authenticator.
            """
            return self._set("extra", value)

        def groups(self, value: Optional[List[str]], /) -> Self:
            """
            The names of groups this user is a part of.
            """
            return self._set("groups", value)

        def uid(self, value: Optional[str], /) -> Self:
            """
            A unique value that identifies this user across time. If this user is
            deleted and another user by the same name is added, they will have
            different UIDs.
            """
            return self._set("uid", value)

        def username(self, value: Optional[str], /) -> Self:
            """
            The name that uniquely identifies this user among all active users.
            """
            return self._set("username", value)

    class BuilderContext(BuilderContextBase["UserInfo.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UserInfo.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UserInfo."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UserInfo", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UserInfo.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    extra: Optional[Dict[str, List[str]]] = None
    """
    Any additional information provided by the authenticator.
    """
    groups: Optional[List[str]] = None
    """
    The names of groups this user is a part of.
    """
    uid: Optional[str] = None
    """
    A unique value that identifies this user across time. If this user is
    deleted and another user by the same name is added, they will have
    different UIDs.
    """
    username: Optional[str] = None
    """
    The name that uniquely identifies this user among all active users.
    """


class AdmissionRequest(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AdmissionRequest"]:
            return AdmissionRequest

        def build(self) -> "AdmissionRequest":
            return AdmissionRequest(**self._attrs)

        def dry_run(self, value: Optional[bool], /) -> Self:
            """
            DryRun indicates that modifications will definitely not be persisted for this request.
            Defaults to false.
            """
            return self._set("dry_run", value)

        @overload
        def kind(self, value_or_callback: Kind, /) -> "AdmissionRequest.Builder": ...

        @overload
        def kind(
            self, value_or_callback: Callable[[Kind.Builder], Kind.Builder | Kind], /
        ) -> "AdmissionRequest.Builder": ...

        @overload
        def kind(self, value_or_callback: Never = ...) -> "Kind.BuilderContext": ...

        def kind(self, value_or_callback=None, /):
            """
            Kind is the fully-qualified type of object being submitted (for example, v1.Pod or autoscaling.v1.Scale)
            """
            if self._in_context and value_or_callback is None:
                context = Kind.BuilderContext()
                context._parent_builder = self
                context._field_name = "kind"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Kind.builder())
                if isinstance(output, Kind.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name is the name of the object as presented in the request.  On a CREATE operation, the client may omit name and
            rely on the server to generate the name.  If that is the case, this field will contain an empty string.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace is the namespace associated with the request (if any).
            """
            return self._set("namespace", value)

        def object(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Object is the object from the incoming request.
            """
            return self._set("object", value)

        def old_object(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            OldObject is the existing object. Only populated for DELETE and UPDATE requests.
            """
            return self._set("old_object", value)

        def operation(self, value: str, /) -> Self:
            """
            Operation is the operation being performed. This may be different than the operation
            requested. e.g. a patch can result in either a CREATE or UPDATE Operation.
            """
            return self._set("operation", value)

        def options(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Options is the operation option structure of the operation being performed.
            e.g. `meta.k8s.io/v1.DeleteOptions` or `meta.k8s.io/v1.CreateOptions`. This may be
            different than the options the caller provided. e.g. for a patch request the performed
            Operation might be a CREATE, in which case the Options will a
            `meta.k8s.io/v1.CreateOptions` even though the caller provided `meta.k8s.io/v1.PatchOptions`.
            """
            return self._set("options", value)

        @overload
        def request_kind(
            self, value_or_callback: Optional[RequestKind], /
        ) -> "AdmissionRequest.Builder": ...

        @overload
        def request_kind(
            self,
            value_or_callback: Callable[[RequestKind.Builder], RequestKind.Builder | RequestKind],
            /,
        ) -> "AdmissionRequest.Builder": ...

        @overload
        def request_kind(self, value_or_callback: Never = ...) -> "RequestKind.BuilderContext": ...

        def request_kind(self, value_or_callback=None, /):
            """
            RequestKind is the fully-qualified type of the original API request (for example, v1.Pod or autoscaling.v1.Scale).
            If this is specified and differs from the value in "kind", an equivalent match and conversion was performed.

            For example, if deployments can be modified via apps/v1 and apps/v1beta1, and a webhook registered a rule of
            `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]` and `matchPolicy: Equivalent`,
            an API request to apps/v1beta1 deployments would be converted and sent to the webhook
            with `kind: {group:"apps", version:"v1", kind:"Deployment"}` (matching the rule the webhook registered for),
            and `requestKind: {group:"apps", version:"v1beta1", kind:"Deployment"}` (indicating the kind of the original API request).

            See documentation for the "matchPolicy" field in the webhook configuration type for more details.
            """
            if self._in_context and value_or_callback is None:
                context = RequestKind.BuilderContext()
                context._parent_builder = self
                context._field_name = "request_kind"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RequestKind.builder())
                if isinstance(output, RequestKind.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("request_kind", value)

        @overload
        def request_resource(
            self, value_or_callback: Optional[RequestResource], /
        ) -> "AdmissionRequest.Builder": ...

        @overload
        def request_resource(
            self,
            value_or_callback: Callable[
                [RequestResource.Builder], RequestResource.Builder | RequestResource
            ],
            /,
        ) -> "AdmissionRequest.Builder": ...

        @overload
        def request_resource(
            self, value_or_callback: Never = ...
        ) -> "RequestResource.BuilderContext": ...

        def request_resource(self, value_or_callback=None, /):
            """
            RequestResource is the fully-qualified resource of the original API request (for example, v1.pods).
            If this is specified and differs from the value in "resource", an equivalent match and conversion was performed.

            For example, if deployments can be modified via apps/v1 and apps/v1beta1, and a webhook registered a rule of
            `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]` and `matchPolicy: Equivalent`,
            an API request to apps/v1beta1 deployments would be converted and sent to the webhook
            with `resource: {group:"apps", version:"v1", resource:"deployments"}` (matching the resource the webhook registered for),
            and `requestResource: {group:"apps", version:"v1beta1", resource:"deployments"}` (indicating the resource of the original API request).

            See documentation for the "matchPolicy" field in the webhook configuration type.
            """
            if self._in_context and value_or_callback is None:
                context = RequestResource.BuilderContext()
                context._parent_builder = self
                context._field_name = "request_resource"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RequestResource.builder())
                if isinstance(output, RequestResource.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("request_resource", value)

        def request_sub_resource(self, value: Optional[str], /) -> Self:
            """
            RequestSubResource is the name of the subresource of the original API request, if any (for example, "status" or "scale")
            If this is specified and differs from the value in "subResource", an equivalent match and conversion was performed.
            See documentation for the "matchPolicy" field in the webhook configuration type.
            """
            return self._set("request_sub_resource", value)

        @overload
        def resource(self, value_or_callback: ResourceModel, /) -> "AdmissionRequest.Builder": ...

        @overload
        def resource(
            self,
            value_or_callback: Callable[
                [ResourceModel.Builder], ResourceModel.Builder | ResourceModel
            ],
            /,
        ) -> "AdmissionRequest.Builder": ...

        @overload
        def resource(self, value_or_callback: Never = ...) -> "ResourceModel.BuilderContext": ...

        def resource(self, value_or_callback=None, /):
            """
            Resource is the fully-qualified resource being requested (for example, v1.pods)
            """
            if self._in_context and value_or_callback is None:
                context = ResourceModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceModel.builder())
                if isinstance(output, ResourceModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource", value)

        def sub_resource(self, value: Optional[str], /) -> Self:
            """
            SubResource is the subresource being requested, if any (for example, "status" or "scale")
            """
            return self._set("sub_resource", value)

        def uid(self, value: str, /) -> Self:
            """
            UID is an identifier for the individual request/response. It allows us to distinguish instances of requests which are
            otherwise identical (parallel requests, requests when earlier requests did not modify etc)
            The UID is meant to track the round trip (request/response) between the KAS and the WebHook, not the user request.
            It is suitable for correlating log entries between the webhook and apiserver, for either auditing or debugging.
            """
            return self._set("uid", value)

        @overload
        def user_info(self, value_or_callback: UserInfo, /) -> "AdmissionRequest.Builder": ...

        @overload
        def user_info(
            self,
            value_or_callback: Callable[[UserInfo.Builder], UserInfo.Builder | UserInfo],
            /,
        ) -> "AdmissionRequest.Builder": ...

        @overload
        def user_info(self, value_or_callback: Never = ...) -> "UserInfo.BuilderContext": ...

        def user_info(self, value_or_callback=None, /):
            """
            UserInfo is information about the requesting user
            """
            if self._in_context and value_or_callback is None:
                context = UserInfo.BuilderContext()
                context._parent_builder = self
                context._field_name = "user_info"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UserInfo.builder())
                if isinstance(output, UserInfo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("user_info", value)

    class BuilderContext(BuilderContextBase["AdmissionRequest.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AdmissionRequest.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AdmissionRequest."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AdmissionRequest", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AdmissionRequest.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    dry_run: Annotated[Optional[bool], Field(alias="dryRun")] = None
    """
    DryRun indicates that modifications will definitely not be persisted for this request.
    Defaults to false.
    """
    kind: Kind
    """
    Kind is the fully-qualified type of object being submitted (for example, v1.Pod or autoscaling.v1.Scale)
    """
    name: Optional[str] = None
    """
    Name is the name of the object as presented in the request.  On a CREATE operation, the client may omit name and
    rely on the server to generate the name.  If that is the case, this field will contain an empty string.
    """
    namespace: Optional[str] = None
    """
    Namespace is the namespace associated with the request (if any).
    """
    object: Optional[Dict[str, Any]] = None
    """
    Object is the object from the incoming request.
    """
    old_object: Annotated[Optional[Dict[str, Any]], Field(alias="oldObject")] = None
    """
    OldObject is the existing object. Only populated for DELETE and UPDATE requests.
    """
    operation: str
    """
    Operation is the operation being performed. This may be different than the operation
    requested. e.g. a patch can result in either a CREATE or UPDATE Operation.
    """
    options: Optional[Dict[str, Any]] = None
    """
    Options is the operation option structure of the operation being performed.
    e.g. `meta.k8s.io/v1.DeleteOptions` or `meta.k8s.io/v1.CreateOptions`. This may be
    different than the options the caller provided. e.g. for a patch request the performed
    Operation might be a CREATE, in which case the Options will a
    `meta.k8s.io/v1.CreateOptions` even though the caller provided `meta.k8s.io/v1.PatchOptions`.
    """
    request_kind: Annotated[Optional[RequestKind], Field(alias="requestKind")] = None
    """
    RequestKind is the fully-qualified type of the original API request (for example, v1.Pod or autoscaling.v1.Scale).
    If this is specified and differs from the value in "kind", an equivalent match and conversion was performed.

    For example, if deployments can be modified via apps/v1 and apps/v1beta1, and a webhook registered a rule of
    `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]` and `matchPolicy: Equivalent`,
    an API request to apps/v1beta1 deployments would be converted and sent to the webhook
    with `kind: {group:"apps", version:"v1", kind:"Deployment"}` (matching the rule the webhook registered for),
    and `requestKind: {group:"apps", version:"v1beta1", kind:"Deployment"}` (indicating the kind of the original API request).

    See documentation for the "matchPolicy" field in the webhook configuration type for more details.
    """
    request_resource: Annotated[Optional[RequestResource], Field(alias="requestResource")] = None
    """
    RequestResource is the fully-qualified resource of the original API request (for example, v1.pods).
    If this is specified and differs from the value in "resource", an equivalent match and conversion was performed.

    For example, if deployments can be modified via apps/v1 and apps/v1beta1, and a webhook registered a rule of
    `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]` and `matchPolicy: Equivalent`,
    an API request to apps/v1beta1 deployments would be converted and sent to the webhook
    with `resource: {group:"apps", version:"v1", resource:"deployments"}` (matching the resource the webhook registered for),
    and `requestResource: {group:"apps", version:"v1beta1", resource:"deployments"}` (indicating the resource of the original API request).

    See documentation for the "matchPolicy" field in the webhook configuration type.
    """
    request_sub_resource: Annotated[Optional[str], Field(alias="requestSubResource")] = None
    """
    RequestSubResource is the name of the subresource of the original API request, if any (for example, "status" or "scale")
    If this is specified and differs from the value in "subResource", an equivalent match and conversion was performed.
    See documentation for the "matchPolicy" field in the webhook configuration type.
    """
    resource: ResourceModel
    """
    Resource is the fully-qualified resource being requested (for example, v1.pods)
    """
    sub_resource: Annotated[Optional[str], Field(alias="subResource")] = None
    """
    SubResource is the subresource being requested, if any (for example, "status" or "scale")
    """
    uid: str
    """
    UID is an identifier for the individual request/response. It allows us to distinguish instances of requests which are
    otherwise identical (parallel requests, requests when earlier requests did not modify etc)
    The UID is meant to track the round trip (request/response) between the KAS and the WebHook, not the user request.
    It is suitable for correlating log entries between the webhook and apiserver, for either auditing or debugging.
    """
    user_info: Annotated[UserInfo, Field(alias="userInfo")]
    """
    UserInfo is information about the requesting user
    """


class AdmissionRequestInfo(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AdmissionRequestInfo"]:
            return AdmissionRequestInfo

        def build(self) -> "AdmissionRequestInfo":
            return AdmissionRequestInfo(**self._attrs)

        @overload
        def admission_request(
            self, value_or_callback: Optional[AdmissionRequest], /
        ) -> "AdmissionRequestInfo.Builder": ...

        @overload
        def admission_request(
            self,
            value_or_callback: Callable[
                [AdmissionRequest.Builder], AdmissionRequest.Builder | AdmissionRequest
            ],
            /,
        ) -> "AdmissionRequestInfo.Builder": ...

        @overload
        def admission_request(
            self, value_or_callback: Never = ...
        ) -> "AdmissionRequest.BuilderContext": ...

        def admission_request(self, value_or_callback=None, /):
            """
            AdmissionRequest describes the admission.Attributes for the admission request.
            """
            if self._in_context and value_or_callback is None:
                context = AdmissionRequest.BuilderContext()
                context._parent_builder = self
                context._field_name = "admission_request"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AdmissionRequest.builder())
                if isinstance(output, AdmissionRequest.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("admission_request", value)

        def operation(self, value: Optional[str], /) -> Self:
            """
            Operation is the type of resource operation being checked for admission control
            """
            return self._set("operation", value)

    class BuilderContext(BuilderContextBase["AdmissionRequestInfo.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AdmissionRequestInfo.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AdmissionRequestInfo."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AdmissionRequestInfo", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AdmissionRequestInfo.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    admission_request: Annotated[Optional[AdmissionRequest], Field(alias="admissionRequest")] = None
    """
    AdmissionRequest describes the admission.Attributes for the admission request.
    """
    operation: Optional[str] = None
    """
    Operation is the type of resource operation being checked for admission control
    """


class UserInfoModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UserInfoModel"]:
            return UserInfoModel

        def build(self) -> "UserInfoModel":
            return UserInfoModel(**self._attrs)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is a list of possible clusterRoles send the request.
            """
            return self._set("cluster_roles", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is a list of possible role send the request.
            """
            return self._set("roles", value)

        @overload
        def user_info(
            self, value_or_callback: Optional[UserInfo], /
        ) -> "UserInfoModel.Builder": ...

        @overload
        def user_info(
            self,
            value_or_callback: Callable[[UserInfo.Builder], UserInfo.Builder | UserInfo],
            /,
        ) -> "UserInfoModel.Builder": ...

        @overload
        def user_info(self, value_or_callback: Never = ...) -> "UserInfo.BuilderContext": ...

        def user_info(self, value_or_callback=None, /):
            """
            UserInfo is the userInfo carried in the admission request.
            """
            if self._in_context and value_or_callback is None:
                context = UserInfo.BuilderContext()
                context._parent_builder = self
                context._field_name = "user_info"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UserInfo.builder())
                if isinstance(output, UserInfo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("user_info", value)

    class BuilderContext(BuilderContextBase["UserInfoModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UserInfoModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UserInfoModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UserInfoModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UserInfoModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is a list of possible clusterRoles send the request.
    """
    roles: Optional[List[str]] = None
    """
    Roles is a list of possible role send the request.
    """
    user_info: Annotated[Optional[UserInfo], Field(alias="userInfo")] = None
    """
    UserInfo is the userInfo carried in the admission request.
    """


class Context(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Context"]:
            return Context

        def build(self) -> "Context":
            return Context(**self._attrs)

        @overload
        def admission_request_info(
            self, value_or_callback: Optional[AdmissionRequestInfo], /
        ) -> "Context.Builder": ...

        @overload
        def admission_request_info(
            self,
            value_or_callback: Callable[
                [AdmissionRequestInfo.Builder],
                AdmissionRequestInfo.Builder | AdmissionRequestInfo,
            ],
            /,
        ) -> "Context.Builder": ...

        @overload
        def admission_request_info(
            self, value_or_callback: Never = ...
        ) -> "AdmissionRequestInfo.BuilderContext": ...

        def admission_request_info(self, value_or_callback=None, /):
            """
            AdmissionRequestInfoObject stores the admission request and operation details
            """
            if self._in_context and value_or_callback is None:
                context = AdmissionRequestInfo.BuilderContext()
                context._parent_builder = self
                context._field_name = "admission_request_info"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AdmissionRequestInfo.builder())
                if isinstance(output, AdmissionRequestInfo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("admission_request_info", value)

        @overload
        def user_info(self, value_or_callback: Optional[UserInfoModel], /) -> "Context.Builder": ...

        @overload
        def user_info(
            self,
            value_or_callback: Callable[
                [UserInfoModel.Builder], UserInfoModel.Builder | UserInfoModel
            ],
            /,
        ) -> "Context.Builder": ...

        @overload
        def user_info(self, value_or_callback: Never = ...) -> "UserInfoModel.BuilderContext": ...

        def user_info(self, value_or_callback=None, /):
            """
            RequestInfo contains permission info carried in an admission request.
            """
            if self._in_context and value_or_callback is None:
                context = UserInfoModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "user_info"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UserInfoModel.builder())
                if isinstance(output, UserInfoModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("user_info", value)

    class BuilderContext(BuilderContextBase["Context.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Context.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Context."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Context", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Context.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    admission_request_info: Annotated[
        Optional[AdmissionRequestInfo], Field(alias="admissionRequestInfo")
    ] = None
    """
    AdmissionRequestInfoObject stores the admission request and operation details
    """
    user_info: Annotated[Optional[UserInfoModel], Field(alias="userInfo")] = None
    """
    RequestInfo contains permission info carried in an admission request.
    """


class ResourceModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceModel1"]:
            return ResourceModel1

        def build(self) -> "ResourceModel1":
            return ResourceModel1(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion specifies resource apiVersion.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind specifies resource kind.
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name specifies the resource name.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace specifies resource namespace.
            """
            return self._set("namespace", value)

        def uid(self, value: Optional[str], /) -> Self:
            """
            UID specifies the resource uid.
            """
            return self._set("uid", value)

    class BuilderContext(BuilderContextBase["ResourceModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion specifies resource apiVersion.
    """
    kind: Optional[str] = None
    """
    Kind specifies resource kind.
    """
    name: Optional[str] = None
    """
    Name specifies the resource name.
    """
    namespace: Optional[str] = None
    """
    Namespace specifies resource namespace.
    """
    uid: Optional[str] = None
    """
    UID specifies the resource uid.
    """


class UpdateRequestSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UpdateRequestSpec"]:
            return UpdateRequestSpec

        def build(self) -> "UpdateRequestSpec":
            return UpdateRequestSpec(**self._attrs)

        @overload
        def context(self, value_or_callback: Context, /) -> "UpdateRequestSpec.Builder": ...

        @overload
        def context(
            self,
            value_or_callback: Callable[[Context.Builder], Context.Builder | Context],
            /,
        ) -> "UpdateRequestSpec.Builder": ...

        @overload
        def context(self, value_or_callback: Never = ...) -> "Context.BuilderContext": ...

        def context(self, value_or_callback=None, /):
            """
            Context ...
            """
            if self._in_context and value_or_callback is None:
                context = Context.BuilderContext()
                context._parent_builder = self
                context._field_name = "context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Context.builder())
                if isinstance(output, Context.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("context", value)

        def delete_downstream(self, value: bool, /) -> Self:
            """
            DeleteDownstream represents whether the downstream needs to be deleted.
            """
            return self._set("delete_downstream", value)

        def policy(self, value: str, /) -> Self:
            """
            Specifies the name of the policy.
            """
            return self._set("policy", value)

        def request_type(self, value: Optional[Literal["mutate", "generate"]], /) -> Self:
            """
            Type represents request type for background processing
            """
            return self._set("request_type", value)

        @overload
        def resource(self, value_or_callback: ResourceModel1, /) -> "UpdateRequestSpec.Builder": ...

        @overload
        def resource(
            self,
            value_or_callback: Callable[
                [ResourceModel1.Builder], ResourceModel1.Builder | ResourceModel1
            ],
            /,
        ) -> "UpdateRequestSpec.Builder": ...

        @overload
        def resource(self, value_or_callback: Never = ...) -> "ResourceModel1.BuilderContext": ...

        def resource(self, value_or_callback=None, /):
            """
            ResourceSpec is the information to identify the trigger resource.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceModel1.builder())
                if isinstance(output, ResourceModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource", value)

        def rule(self, value: str, /) -> Self:
            """
            Rule is the associate rule name of the current UR.
            """
            return self._set("rule", value)

        def synchronize(self, value: Optional[bool], /) -> Self:
            """
            Synchronize represents the sync behavior of the corresponding rule
            Optional. Defaults to "false" if not specified.
            """
            return self._set("synchronize", value)

    class BuilderContext(BuilderContextBase["UpdateRequestSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UpdateRequestSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UpdateRequestSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UpdateRequestSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UpdateRequestSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    context: Context
    """
    Context ...
    """
    delete_downstream: Annotated[bool, Field(alias="deleteDownstream")]
    """
    DeleteDownstream represents whether the downstream needs to be deleted.
    """
    policy: str
    """
    Specifies the name of the policy.
    """
    request_type: Annotated[Optional[Literal["mutate", "generate"]], Field(alias="requestType")] = (
        None
    )
    """
    Type represents request type for background processing
    """
    resource: ResourceModel1
    """
    ResourceSpec is the information to identify the trigger resource.
    """
    rule: str
    """
    Rule is the associate rule name of the current UR.
    """
    synchronize: Optional[bool] = None
    """
    Synchronize represents the sync behavior of the corresponding rule
    Optional. Defaults to "false" if not specified.
    """


class GeneratedResource(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GeneratedResource"]:
            return GeneratedResource

        def build(self) -> "GeneratedResource":
            return GeneratedResource(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion specifies resource apiVersion.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind specifies resource kind.
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name specifies the resource name.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace specifies resource namespace.
            """
            return self._set("namespace", value)

        def uid(self, value: Optional[str], /) -> Self:
            """
            UID specifies the resource uid.
            """
            return self._set("uid", value)

    class BuilderContext(BuilderContextBase["GeneratedResource.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GeneratedResource.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GeneratedResource."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GeneratedResource", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GeneratedResource.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion specifies resource apiVersion.
    """
    kind: Optional[str] = None
    """
    Kind specifies resource kind.
    """
    name: Optional[str] = None
    """
    Name specifies the resource name.
    """
    namespace: Optional[str] = None
    """
    Namespace specifies resource namespace.
    """
    uid: Optional[str] = None
    """
    UID specifies the resource uid.
    """


class UpdateRequestStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UpdateRequestStatus"]:
            return UpdateRequestStatus

        def build(self) -> "UpdateRequestStatus":
            return UpdateRequestStatus(**self._attrs)

        @overload
        def generated_resources(
            self, value_or_callback: List[GeneratedResource], /
        ) -> "UpdateRequestStatus.Builder": ...

        @overload
        def generated_resources(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[GeneratedResource, GeneratedResource.Builder]],
                GenericListBuilder[GeneratedResource, GeneratedResource.Builder]
                | List[GeneratedResource],
            ],
            /,
        ) -> "UpdateRequestStatus.Builder": ...

        @overload
        def generated_resources(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[GeneratedResource.Builder]: ...

        def generated_resources(self, value_or_callback=None, /):
            """
            This will track the resources that are updated by the generate Policy.
            Will be used during clean up resources.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[GeneratedResource.Builder]()
                context._parent_builder = self
                context._field_name = "generated_resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GeneratedResource.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("generated_resources", value)

        def handler(self, value: Optional[str], /) -> Self:
            """
            Deprecated
            """
            return self._set("handler", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Specifies request status message.
            """
            return self._set("message", value)

        def retry_count(self, value: Optional[int], /) -> Self:
            return self._set("retry_count", value)

        def state(self, value: str, /) -> Self:
            """
            State represents state of the update request.
            """
            return self._set("state", value)

    class BuilderContext(BuilderContextBase["UpdateRequestStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UpdateRequestStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UpdateRequestStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UpdateRequestStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UpdateRequestStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    generated_resources: Annotated[
        Optional[List[GeneratedResource]], Field(alias="generatedResources")
    ] = None
    """
    This will track the resources that are updated by the generate Policy.
    Will be used during clean up resources.
    """
    handler: Optional[str] = None
    """
    Deprecated
    """
    message: Optional[str] = None
    """
    Specifies request status message.
    """
    retry_count: Annotated[Optional[int], Field(alias="retryCount")] = None
    state: str
    """
    State represents state of the update request.
    """


class UpdateRequest(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UpdateRequest"]:
            return UpdateRequest

        def build(self) -> "UpdateRequest":
            return UpdateRequest(**self._attrs)

        def api_version(self, value: Optional[Literal["kyverno.io/v1beta1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["UpdateRequest"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "UpdateRequest.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "UpdateRequest.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[UpdateRequestSpec], /
        ) -> "UpdateRequest.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [UpdateRequestSpec.Builder],
                UpdateRequestSpec.Builder | UpdateRequestSpec,
            ],
            /,
        ) -> "UpdateRequest.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "UpdateRequestSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = UpdateRequestSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UpdateRequestSpec.builder())
                if isinstance(output, UpdateRequestSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[UpdateRequestStatus], /
        ) -> "UpdateRequest.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [UpdateRequestStatus.Builder],
                UpdateRequestStatus.Builder | UpdateRequestStatus,
            ],
            /,
        ) -> "UpdateRequest.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "UpdateRequestStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = UpdateRequestStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UpdateRequestStatus.builder())
                if isinstance(output, UpdateRequestStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["UpdateRequest.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UpdateRequest.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UpdateRequest."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UpdateRequest", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UpdateRequest.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kyverno.io/v1beta1"]], Field(alias="apiVersion")] = (
        "kyverno.io/v1beta1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["UpdateRequest"]] = "UpdateRequest"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[UpdateRequestSpec] = None
    status: Optional[UpdateRequestStatus] = None
