# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from ._enums import *

__all__ = [
    'AuthorizationArgs',
    'BareMetalAdminApiServerArgumentArgs',
    'BareMetalAdminClusterOperationsConfigArgs',
    'BareMetalAdminControlPlaneConfigArgs',
    'BareMetalAdminControlPlaneNodePoolConfigArgs',
    'BareMetalAdminIslandModeCidrConfigArgs',
    'BareMetalAdminLoadBalancerConfigArgs',
    'BareMetalAdminMaintenanceConfigArgs',
    'BareMetalAdminManualLbConfigArgs',
    'BareMetalAdminNetworkConfigArgs',
    'BareMetalAdminNodeAccessConfigArgs',
    'BareMetalAdminOsEnvironmentConfigArgs',
    'BareMetalAdminPortConfigArgs',
    'BareMetalAdminProxyConfigArgs',
    'BareMetalAdminSecurityConfigArgs',
    'BareMetalAdminStorageConfigArgs',
    'BareMetalAdminVipConfigArgs',
    'BareMetalAdminWorkloadNodeConfigArgs',
    'BareMetalApiServerArgumentArgs',
    'BareMetalBgpLbConfigArgs',
    'BareMetalBgpPeerConfigArgs',
    'BareMetalClusterOperationsConfigArgs',
    'BareMetalClusterUpgradePolicyArgs',
    'BareMetalControlPlaneConfigArgs',
    'BareMetalControlPlaneNodePoolConfigArgs',
    'BareMetalIslandModeCidrConfigArgs',
    'BareMetalKubeletConfigArgs',
    'BareMetalLoadBalancerAddressPoolArgs',
    'BareMetalLoadBalancerConfigArgs',
    'BareMetalLoadBalancerNodePoolConfigArgs',
    'BareMetalLvpConfigArgs',
    'BareMetalLvpShareConfigArgs',
    'BareMetalMaintenanceConfigArgs',
    'BareMetalManualLbConfigArgs',
    'BareMetalMetalLbConfigArgs',
    'BareMetalMultipleNetworkInterfacesConfigArgs',
    'BareMetalNetworkConfigArgs',
    'BareMetalNodeAccessConfigArgs',
    'BareMetalNodeConfigArgs',
    'BareMetalNodePoolConfigArgs',
    'BareMetalNodePoolUpgradePolicyArgs',
    'BareMetalOsEnvironmentConfigArgs',
    'BareMetalParallelUpgradeConfigArgs',
    'BareMetalPortConfigArgs',
    'BareMetalProxyConfigArgs',
    'BareMetalSecurityConfigArgs',
    'BareMetalSrIovConfigArgs',
    'BareMetalStorageConfigArgs',
    'BareMetalVipConfigArgs',
    'BareMetalWorkloadNodeConfigArgs',
    'BinaryAuthorizationArgs',
    'BindingArgs',
    'ClusterUserArgs',
    'ExprArgs',
    'NodeTaintArgs',
    'VmwareAAGConfigArgs',
    'VmwareAddressPoolArgs',
    'VmwareAutoRepairConfigArgs',
    'VmwareAutoResizeConfigArgs',
    'VmwareClusterUpgradePolicyArgs',
    'VmwareControlPlaneNodeConfigArgs',
    'VmwareControlPlaneV2ConfigArgs',
    'VmwareControlPlaneVsphereConfigArgs',
    'VmwareDataplaneV2ConfigArgs',
    'VmwareDhcpIpConfigArgs',
    'VmwareF5BigIpConfigArgs',
    'VmwareHostConfigArgs',
    'VmwareHostIpArgs',
    'VmwareIpBlockArgs',
    'VmwareLoadBalancerConfigArgs',
    'VmwareManualLbConfigArgs',
    'VmwareMetalLbConfigArgs',
    'VmwareNetworkConfigArgs',
    'VmwareNodeConfigArgs',
    'VmwareNodePoolAutoscalingConfigArgs',
    'VmwareStaticIpConfigArgs',
    'VmwareStorageConfigArgs',
    'VmwareVCenterConfigArgs',
    'VmwareVipConfigArgs',
    'VmwareVsphereConfigArgs',
    'VmwareVsphereTagArgs',
]

@pulumi.input_type
class AuthorizationArgs:
    def __init__(__self__, *,
                 admin_users: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterUserArgs']]]] = None):
        """
        Authorization defines the On-Prem cluster authorization configuration to bootstrap onto the admin cluster.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterUserArgs']]] admin_users: For VMware and bare metal user clusters, users will be granted the cluster-admin role on the cluster, which provides full administrative access to the cluster. For bare metal admin clusters, users will be granted the cluster-view role, which limits users to read-only access.
        """
        if admin_users is not None:
            pulumi.set(__self__, "admin_users", admin_users)

    @property
    @pulumi.getter(name="adminUsers")
    def admin_users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterUserArgs']]]]:
        """
        For VMware and bare metal user clusters, users will be granted the cluster-admin role on the cluster, which provides full administrative access to the cluster. For bare metal admin clusters, users will be granted the cluster-view role, which limits users to read-only access.
        """
        return pulumi.get(self, "admin_users")

    @admin_users.setter
    def admin_users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterUserArgs']]]]):
        pulumi.set(self, "admin_users", value)


@pulumi.input_type
class BareMetalAdminApiServerArgumentArgs:
    def __init__(__self__, *,
                 argument: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        BareMetalAdminApiServerArgument represents an arg name->value pair. Only a subset of customized flags are supported. Please refer to the API server documentation below to know the exact format: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
        :param pulumi.Input[str] argument: The argument name as it appears on the API Server command line please make sure to remove the leading dashes.
        :param pulumi.Input[str] value: The value of the arg as it will be passed to the API Server command line.
        """
        pulumi.set(__self__, "argument", argument)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def argument(self) -> pulumi.Input[str]:
        """
        The argument name as it appears on the API Server command line please make sure to remove the leading dashes.
        """
        return pulumi.get(self, "argument")

    @argument.setter
    def argument(self, value: pulumi.Input[str]):
        pulumi.set(self, "argument", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the arg as it will be passed to the API Server command line.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class BareMetalAdminClusterOperationsConfigArgs:
    def __init__(__self__, *,
                 enable_application_logs: Optional[pulumi.Input[bool]] = None):
        """
        BareMetalAdminClusterOperationsConfig specifies the admin cluster's observability infrastructure.
        :param pulumi.Input[bool] enable_application_logs: Whether collection of application logs/metrics should be enabled (in addition to system logs/metrics).
        """
        if enable_application_logs is not None:
            pulumi.set(__self__, "enable_application_logs", enable_application_logs)

    @property
    @pulumi.getter(name="enableApplicationLogs")
    def enable_application_logs(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether collection of application logs/metrics should be enabled (in addition to system logs/metrics).
        """
        return pulumi.get(self, "enable_application_logs")

    @enable_application_logs.setter
    def enable_application_logs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_application_logs", value)


@pulumi.input_type
class BareMetalAdminControlPlaneConfigArgs:
    def __init__(__self__, *,
                 control_plane_node_pool_config: pulumi.Input['BareMetalAdminControlPlaneNodePoolConfigArgs'],
                 api_server_args: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalAdminApiServerArgumentArgs']]]] = None):
        """
        BareMetalAdminControlPlaneConfig specifies the control plane configuration.
        :param pulumi.Input['BareMetalAdminControlPlaneNodePoolConfigArgs'] control_plane_node_pool_config: Configures the node pool running the control plane. If specified the corresponding NodePool will be created for the cluster's control plane. The NodePool will have the same name and namespace as the cluster.
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalAdminApiServerArgumentArgs']]] api_server_args: Customizes the default API server args. Only a subset of customized flags are supported. Please refer to the API server documentation below to know the exact format: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
        """
        pulumi.set(__self__, "control_plane_node_pool_config", control_plane_node_pool_config)
        if api_server_args is not None:
            pulumi.set(__self__, "api_server_args", api_server_args)

    @property
    @pulumi.getter(name="controlPlaneNodePoolConfig")
    def control_plane_node_pool_config(self) -> pulumi.Input['BareMetalAdminControlPlaneNodePoolConfigArgs']:
        """
        Configures the node pool running the control plane. If specified the corresponding NodePool will be created for the cluster's control plane. The NodePool will have the same name and namespace as the cluster.
        """
        return pulumi.get(self, "control_plane_node_pool_config")

    @control_plane_node_pool_config.setter
    def control_plane_node_pool_config(self, value: pulumi.Input['BareMetalAdminControlPlaneNodePoolConfigArgs']):
        pulumi.set(self, "control_plane_node_pool_config", value)

    @property
    @pulumi.getter(name="apiServerArgs")
    def api_server_args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalAdminApiServerArgumentArgs']]]]:
        """
        Customizes the default API server args. Only a subset of customized flags are supported. Please refer to the API server documentation below to know the exact format: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
        """
        return pulumi.get(self, "api_server_args")

    @api_server_args.setter
    def api_server_args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalAdminApiServerArgumentArgs']]]]):
        pulumi.set(self, "api_server_args", value)


@pulumi.input_type
class BareMetalAdminControlPlaneNodePoolConfigArgs:
    def __init__(__self__, *,
                 node_pool_config: pulumi.Input['BareMetalNodePoolConfigArgs']):
        """
        BareMetalAdminControlPlaneNodePoolConfig specifies the control plane node pool configuration. We have a control plane specific node pool config so that we can flexible about supporting control plane specific fields in the future.
        :param pulumi.Input['BareMetalNodePoolConfigArgs'] node_pool_config: The generic configuration for a node pool running the control plane.
        """
        pulumi.set(__self__, "node_pool_config", node_pool_config)

    @property
    @pulumi.getter(name="nodePoolConfig")
    def node_pool_config(self) -> pulumi.Input['BareMetalNodePoolConfigArgs']:
        """
        The generic configuration for a node pool running the control plane.
        """
        return pulumi.get(self, "node_pool_config")

    @node_pool_config.setter
    def node_pool_config(self, value: pulumi.Input['BareMetalNodePoolConfigArgs']):
        pulumi.set(self, "node_pool_config", value)


@pulumi.input_type
class BareMetalAdminIslandModeCidrConfigArgs:
    def __init__(__self__, *,
                 pod_address_cidr_blocks: pulumi.Input[Sequence[pulumi.Input[str]]],
                 service_address_cidr_blocks: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        BareMetalAdminIslandModeCidrConfig specifies the cluster CIDR configuration while running in island mode.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pod_address_cidr_blocks: All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_address_cidr_blocks: All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        pulumi.set(__self__, "pod_address_cidr_blocks", pod_address_cidr_blocks)
        pulumi.set(__self__, "service_address_cidr_blocks", service_address_cidr_blocks)

    @property
    @pulumi.getter(name="podAddressCidrBlocks")
    def pod_address_cidr_blocks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        return pulumi.get(self, "pod_address_cidr_blocks")

    @pod_address_cidr_blocks.setter
    def pod_address_cidr_blocks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "pod_address_cidr_blocks", value)

    @property
    @pulumi.getter(name="serviceAddressCidrBlocks")
    def service_address_cidr_blocks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        return pulumi.get(self, "service_address_cidr_blocks")

    @service_address_cidr_blocks.setter
    def service_address_cidr_blocks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "service_address_cidr_blocks", value)


@pulumi.input_type
class BareMetalAdminLoadBalancerConfigArgs:
    def __init__(__self__, *,
                 manual_lb_config: Optional[pulumi.Input['BareMetalAdminManualLbConfigArgs']] = None,
                 port_config: Optional[pulumi.Input['BareMetalAdminPortConfigArgs']] = None,
                 vip_config: Optional[pulumi.Input['BareMetalAdminVipConfigArgs']] = None):
        """
        BareMetalAdminLoadBalancerConfig specifies the load balancer configuration.
        :param pulumi.Input['BareMetalAdminManualLbConfigArgs'] manual_lb_config: Manually configured load balancers.
        :param pulumi.Input['BareMetalAdminPortConfigArgs'] port_config: Configures the ports that the load balancer will listen on.
        :param pulumi.Input['BareMetalAdminVipConfigArgs'] vip_config: The VIPs used by the load balancer.
        """
        if manual_lb_config is not None:
            pulumi.set(__self__, "manual_lb_config", manual_lb_config)
        if port_config is not None:
            pulumi.set(__self__, "port_config", port_config)
        if vip_config is not None:
            pulumi.set(__self__, "vip_config", vip_config)

    @property
    @pulumi.getter(name="manualLbConfig")
    def manual_lb_config(self) -> Optional[pulumi.Input['BareMetalAdminManualLbConfigArgs']]:
        """
        Manually configured load balancers.
        """
        return pulumi.get(self, "manual_lb_config")

    @manual_lb_config.setter
    def manual_lb_config(self, value: Optional[pulumi.Input['BareMetalAdminManualLbConfigArgs']]):
        pulumi.set(self, "manual_lb_config", value)

    @property
    @pulumi.getter(name="portConfig")
    def port_config(self) -> Optional[pulumi.Input['BareMetalAdminPortConfigArgs']]:
        """
        Configures the ports that the load balancer will listen on.
        """
        return pulumi.get(self, "port_config")

    @port_config.setter
    def port_config(self, value: Optional[pulumi.Input['BareMetalAdminPortConfigArgs']]):
        pulumi.set(self, "port_config", value)

    @property
    @pulumi.getter(name="vipConfig")
    def vip_config(self) -> Optional[pulumi.Input['BareMetalAdminVipConfigArgs']]:
        """
        The VIPs used by the load balancer.
        """
        return pulumi.get(self, "vip_config")

    @vip_config.setter
    def vip_config(self, value: Optional[pulumi.Input['BareMetalAdminVipConfigArgs']]):
        pulumi.set(self, "vip_config", value)


@pulumi.input_type
class BareMetalAdminMaintenanceConfigArgs:
    def __init__(__self__, *,
                 maintenance_address_cidr_blocks: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        BareMetalAdminMaintenanceConfig specifies configurations to put bare metal Admin cluster CRs nodes in and out of maintenance.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] maintenance_address_cidr_blocks: All IPv4 address from these ranges will be placed into maintenance mode. Nodes in maintenance mode will be cordoned and drained. When both of these are true, the "baremetal.cluster.gke.io/maintenance" annotation will be set on the node resource.
        """
        pulumi.set(__self__, "maintenance_address_cidr_blocks", maintenance_address_cidr_blocks)

    @property
    @pulumi.getter(name="maintenanceAddressCidrBlocks")
    def maintenance_address_cidr_blocks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        All IPv4 address from these ranges will be placed into maintenance mode. Nodes in maintenance mode will be cordoned and drained. When both of these are true, the "baremetal.cluster.gke.io/maintenance" annotation will be set on the node resource.
        """
        return pulumi.get(self, "maintenance_address_cidr_blocks")

    @maintenance_address_cidr_blocks.setter
    def maintenance_address_cidr_blocks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "maintenance_address_cidr_blocks", value)


@pulumi.input_type
class BareMetalAdminManualLbConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        BareMetalAdminManualLbConfig represents configuration parameters for a manual load balancer.
        :param pulumi.Input[bool] enabled: Whether manual load balancing is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether manual load balancing is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class BareMetalAdminNetworkConfigArgs:
    def __init__(__self__, *,
                 island_mode_cidr: Optional[pulumi.Input['BareMetalAdminIslandModeCidrConfigArgs']] = None):
        """
        BareMetalAdminNetworkConfig specifies the cluster network configuration.
        :param pulumi.Input['BareMetalAdminIslandModeCidrConfigArgs'] island_mode_cidr: Configuration for Island mode CIDR.
        """
        if island_mode_cidr is not None:
            pulumi.set(__self__, "island_mode_cidr", island_mode_cidr)

    @property
    @pulumi.getter(name="islandModeCidr")
    def island_mode_cidr(self) -> Optional[pulumi.Input['BareMetalAdminIslandModeCidrConfigArgs']]:
        """
        Configuration for Island mode CIDR.
        """
        return pulumi.get(self, "island_mode_cidr")

    @island_mode_cidr.setter
    def island_mode_cidr(self, value: Optional[pulumi.Input['BareMetalAdminIslandModeCidrConfigArgs']]):
        pulumi.set(self, "island_mode_cidr", value)


@pulumi.input_type
class BareMetalAdminNodeAccessConfigArgs:
    def __init__(__self__, *,
                 login_user: pulumi.Input[str]):
        """
        Specifies the node access related settings for the bare metal admin cluster.
        :param pulumi.Input[str] login_user: LoginUser is the user name used to access node machines. It defaults to "root" if not set.
        """
        pulumi.set(__self__, "login_user", login_user)

    @property
    @pulumi.getter(name="loginUser")
    def login_user(self) -> pulumi.Input[str]:
        """
        LoginUser is the user name used to access node machines. It defaults to "root" if not set.
        """
        return pulumi.get(self, "login_user")

    @login_user.setter
    def login_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "login_user", value)


@pulumi.input_type
class BareMetalAdminOsEnvironmentConfigArgs:
    def __init__(__self__, *,
                 package_repo_excluded: Optional[pulumi.Input[bool]] = None):
        """
        Specifies operating system operation settings for cluster provisioning.
        :param pulumi.Input[bool] package_repo_excluded: Whether the package repo should be added when initializing bare metal machines.
        """
        if package_repo_excluded is not None:
            pulumi.set(__self__, "package_repo_excluded", package_repo_excluded)

    @property
    @pulumi.getter(name="packageRepoExcluded")
    def package_repo_excluded(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the package repo should be added when initializing bare metal machines.
        """
        return pulumi.get(self, "package_repo_excluded")

    @package_repo_excluded.setter
    def package_repo_excluded(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "package_repo_excluded", value)


@pulumi.input_type
class BareMetalAdminPortConfigArgs:
    def __init__(__self__, *,
                 control_plane_load_balancer_port: Optional[pulumi.Input[int]] = None):
        """
        BareMetalAdminPortConfig is the specification of load balancer ports.
        :param pulumi.Input[int] control_plane_load_balancer_port: The port that control plane hosted load balancers will listen on.
        """
        if control_plane_load_balancer_port is not None:
            pulumi.set(__self__, "control_plane_load_balancer_port", control_plane_load_balancer_port)

    @property
    @pulumi.getter(name="controlPlaneLoadBalancerPort")
    def control_plane_load_balancer_port(self) -> Optional[pulumi.Input[int]]:
        """
        The port that control plane hosted load balancers will listen on.
        """
        return pulumi.get(self, "control_plane_load_balancer_port")

    @control_plane_load_balancer_port.setter
    def control_plane_load_balancer_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "control_plane_load_balancer_port", value)


@pulumi.input_type
class BareMetalAdminProxyConfigArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str],
                 no_proxy: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        BareMetalAdminProxyConfig specifies the cluster proxy configuration.
        :param pulumi.Input[str] uri: Specifies the address of your proxy server. Examples: `http://domain` WARNING: Do not provide credentials in the format `http://(username:password@)domain` these will be rejected by the server.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] no_proxy: A list of IPs, hostnames, and domains that should skip the proxy. Examples: ["127.0.0.1", "example.com", ".corp", "localhost"].
        """
        pulumi.set(__self__, "uri", uri)
        if no_proxy is not None:
            pulumi.set(__self__, "no_proxy", no_proxy)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        Specifies the address of your proxy server. Examples: `http://domain` WARNING: Do not provide credentials in the format `http://(username:password@)domain` these will be rejected by the server.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="noProxy")
    def no_proxy(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of IPs, hostnames, and domains that should skip the proxy. Examples: ["127.0.0.1", "example.com", ".corp", "localhost"].
        """
        return pulumi.get(self, "no_proxy")

    @no_proxy.setter
    def no_proxy(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "no_proxy", value)


@pulumi.input_type
class BareMetalAdminSecurityConfigArgs:
    def __init__(__self__, *,
                 authorization: Optional[pulumi.Input['AuthorizationArgs']] = None):
        """
        Specifies the security related settings for the bare metal admin cluster.
        :param pulumi.Input['AuthorizationArgs'] authorization: Configures user access to the admin cluster.
        """
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input['AuthorizationArgs']]:
        """
        Configures user access to the admin cluster.
        """
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input['AuthorizationArgs']]):
        pulumi.set(self, "authorization", value)


@pulumi.input_type
class BareMetalAdminStorageConfigArgs:
    def __init__(__self__, *,
                 lvp_node_mounts_config: pulumi.Input['BareMetalLvpConfigArgs'],
                 lvp_share_config: pulumi.Input['BareMetalLvpShareConfigArgs']):
        """
        BareMetalAdminStorageConfig specifies the cluster storage configuration.
        :param pulumi.Input['BareMetalLvpConfigArgs'] lvp_node_mounts_config: Specifies the config for local PersistentVolumes backed by mounted node disks. These disks need to be formatted and mounted by the user, which can be done before or after cluster creation.
        :param pulumi.Input['BareMetalLvpShareConfigArgs'] lvp_share_config: Specifies the config for local PersistentVolumes backed by subdirectories in a shared filesystem. These subdirectores are automatically created during cluster creation.
        """
        pulumi.set(__self__, "lvp_node_mounts_config", lvp_node_mounts_config)
        pulumi.set(__self__, "lvp_share_config", lvp_share_config)

    @property
    @pulumi.getter(name="lvpNodeMountsConfig")
    def lvp_node_mounts_config(self) -> pulumi.Input['BareMetalLvpConfigArgs']:
        """
        Specifies the config for local PersistentVolumes backed by mounted node disks. These disks need to be formatted and mounted by the user, which can be done before or after cluster creation.
        """
        return pulumi.get(self, "lvp_node_mounts_config")

    @lvp_node_mounts_config.setter
    def lvp_node_mounts_config(self, value: pulumi.Input['BareMetalLvpConfigArgs']):
        pulumi.set(self, "lvp_node_mounts_config", value)

    @property
    @pulumi.getter(name="lvpShareConfig")
    def lvp_share_config(self) -> pulumi.Input['BareMetalLvpShareConfigArgs']:
        """
        Specifies the config for local PersistentVolumes backed by subdirectories in a shared filesystem. These subdirectores are automatically created during cluster creation.
        """
        return pulumi.get(self, "lvp_share_config")

    @lvp_share_config.setter
    def lvp_share_config(self, value: pulumi.Input['BareMetalLvpShareConfigArgs']):
        pulumi.set(self, "lvp_share_config", value)


@pulumi.input_type
class BareMetalAdminVipConfigArgs:
    def __init__(__self__, *,
                 control_plane_vip: Optional[pulumi.Input[str]] = None):
        """
        BareMetalAdminVipConfig for bare metal load balancer configurations.
        :param pulumi.Input[str] control_plane_vip: The VIP which you previously set aside for the Kubernetes API of this bare metal admin cluster.
        """
        if control_plane_vip is not None:
            pulumi.set(__self__, "control_plane_vip", control_plane_vip)

    @property
    @pulumi.getter(name="controlPlaneVip")
    def control_plane_vip(self) -> Optional[pulumi.Input[str]]:
        """
        The VIP which you previously set aside for the Kubernetes API of this bare metal admin cluster.
        """
        return pulumi.get(self, "control_plane_vip")

    @control_plane_vip.setter
    def control_plane_vip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "control_plane_vip", value)


@pulumi.input_type
class BareMetalAdminWorkloadNodeConfigArgs:
    def __init__(__self__, *,
                 max_pods_per_node: Optional[pulumi.Input[str]] = None):
        """
        BareMetalAdminWorkloadNodeConfig specifies the workload node configurations.
        :param pulumi.Input[str] max_pods_per_node: The maximum number of pods a node can run. The size of the CIDR range assigned to the node will be derived from this parameter. By default 110 Pods are created per Node. Upper bound is 250 for both HA and non-HA admin cluster. Lower bound is 64 for non-HA admin cluster and 32 for HA admin cluster.
        """
        if max_pods_per_node is not None:
            pulumi.set(__self__, "max_pods_per_node", max_pods_per_node)

    @property
    @pulumi.getter(name="maxPodsPerNode")
    def max_pods_per_node(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum number of pods a node can run. The size of the CIDR range assigned to the node will be derived from this parameter. By default 110 Pods are created per Node. Upper bound is 250 for both HA and non-HA admin cluster. Lower bound is 64 for non-HA admin cluster and 32 for HA admin cluster.
        """
        return pulumi.get(self, "max_pods_per_node")

    @max_pods_per_node.setter
    def max_pods_per_node(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_pods_per_node", value)


@pulumi.input_type
class BareMetalApiServerArgumentArgs:
    def __init__(__self__, *,
                 argument: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        Represents an arg name->value pair. Only a subset of customized flags are supported. For the exact format, refer to the [API server documentation](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/).
        :param pulumi.Input[str] argument: The argument name as it appears on the API Server command line, make sure to remove the leading dashes.
        :param pulumi.Input[str] value: The value of the arg as it will be passed to the API Server command line.
        """
        pulumi.set(__self__, "argument", argument)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def argument(self) -> pulumi.Input[str]:
        """
        The argument name as it appears on the API Server command line, make sure to remove the leading dashes.
        """
        return pulumi.get(self, "argument")

    @argument.setter
    def argument(self, value: pulumi.Input[str]):
        pulumi.set(self, "argument", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the arg as it will be passed to the API Server command line.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class BareMetalBgpLbConfigArgs:
    def __init__(__self__, *,
                 address_pools: pulumi.Input[Sequence[pulumi.Input['BareMetalLoadBalancerAddressPoolArgs']]],
                 asn: pulumi.Input[str],
                 bgp_peer_configs: pulumi.Input[Sequence[pulumi.Input['BareMetalBgpPeerConfigArgs']]],
                 load_balancer_node_pool_config: Optional[pulumi.Input['BareMetalLoadBalancerNodePoolConfigArgs']] = None):
        """
        BareMetalBgpLbConfig represents configuration parameters for a Border Gateway Protocol (BGP) load balancer.
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalLoadBalancerAddressPoolArgs']]] address_pools: AddressPools is a list of non-overlapping IP pools used by load balancer typed services. All addresses must be routable to load balancer nodes. IngressVIP must be included in the pools.
        :param pulumi.Input[str] asn: BGP autonomous system number (ASN) of the cluster. This field can be updated after cluster creation.
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalBgpPeerConfigArgs']]] bgp_peer_configs: The list of BGP peers that the cluster will connect to. At least one peer must be configured for each control plane node. Control plane nodes will connect to these peers to advertise the control plane VIP. The Services load balancer also uses these peers by default. This field can be updated after cluster creation.
        :param pulumi.Input['BareMetalLoadBalancerNodePoolConfigArgs'] load_balancer_node_pool_config: Specifies the node pool running data plane load balancing. L2 connectivity is required among nodes in this pool. If missing, the control plane node pool is used for data plane load balancing.
        """
        pulumi.set(__self__, "address_pools", address_pools)
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "bgp_peer_configs", bgp_peer_configs)
        if load_balancer_node_pool_config is not None:
            pulumi.set(__self__, "load_balancer_node_pool_config", load_balancer_node_pool_config)

    @property
    @pulumi.getter(name="addressPools")
    def address_pools(self) -> pulumi.Input[Sequence[pulumi.Input['BareMetalLoadBalancerAddressPoolArgs']]]:
        """
        AddressPools is a list of non-overlapping IP pools used by load balancer typed services. All addresses must be routable to load balancer nodes. IngressVIP must be included in the pools.
        """
        return pulumi.get(self, "address_pools")

    @address_pools.setter
    def address_pools(self, value: pulumi.Input[Sequence[pulumi.Input['BareMetalLoadBalancerAddressPoolArgs']]]):
        pulumi.set(self, "address_pools", value)

    @property
    @pulumi.getter
    def asn(self) -> pulumi.Input[str]:
        """
        BGP autonomous system number (ASN) of the cluster. This field can be updated after cluster creation.
        """
        return pulumi.get(self, "asn")

    @asn.setter
    def asn(self, value: pulumi.Input[str]):
        pulumi.set(self, "asn", value)

    @property
    @pulumi.getter(name="bgpPeerConfigs")
    def bgp_peer_configs(self) -> pulumi.Input[Sequence[pulumi.Input['BareMetalBgpPeerConfigArgs']]]:
        """
        The list of BGP peers that the cluster will connect to. At least one peer must be configured for each control plane node. Control plane nodes will connect to these peers to advertise the control plane VIP. The Services load balancer also uses these peers by default. This field can be updated after cluster creation.
        """
        return pulumi.get(self, "bgp_peer_configs")

    @bgp_peer_configs.setter
    def bgp_peer_configs(self, value: pulumi.Input[Sequence[pulumi.Input['BareMetalBgpPeerConfigArgs']]]):
        pulumi.set(self, "bgp_peer_configs", value)

    @property
    @pulumi.getter(name="loadBalancerNodePoolConfig")
    def load_balancer_node_pool_config(self) -> Optional[pulumi.Input['BareMetalLoadBalancerNodePoolConfigArgs']]:
        """
        Specifies the node pool running data plane load balancing. L2 connectivity is required among nodes in this pool. If missing, the control plane node pool is used for data plane load balancing.
        """
        return pulumi.get(self, "load_balancer_node_pool_config")

    @load_balancer_node_pool_config.setter
    def load_balancer_node_pool_config(self, value: Optional[pulumi.Input['BareMetalLoadBalancerNodePoolConfigArgs']]):
        pulumi.set(self, "load_balancer_node_pool_config", value)


@pulumi.input_type
class BareMetalBgpPeerConfigArgs:
    def __init__(__self__, *,
                 asn: pulumi.Input[str],
                 ip_address: pulumi.Input[str],
                 control_plane_nodes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        BareMetalBgpPeerConfig represents configuration parameters for a Border Gateway Protocol (BGP) peer.
        :param pulumi.Input[str] asn: BGP autonomous system number (ASN) for the network that contains the external peer device.
        :param pulumi.Input[str] ip_address: The IP address of the external peer device.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] control_plane_nodes: The IP address of the control plane node that connects to the external peer. If you don't specify any control plane nodes, all control plane nodes can connect to the external peer. If you specify one or more IP addresses, only the nodes specified participate in peering sessions.
        """
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "ip_address", ip_address)
        if control_plane_nodes is not None:
            pulumi.set(__self__, "control_plane_nodes", control_plane_nodes)

    @property
    @pulumi.getter
    def asn(self) -> pulumi.Input[str]:
        """
        BGP autonomous system number (ASN) for the network that contains the external peer device.
        """
        return pulumi.get(self, "asn")

    @asn.setter
    def asn(self, value: pulumi.Input[str]):
        pulumi.set(self, "asn", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> pulumi.Input[str]:
        """
        The IP address of the external peer device.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="controlPlaneNodes")
    def control_plane_nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The IP address of the control plane node that connects to the external peer. If you don't specify any control plane nodes, all control plane nodes can connect to the external peer. If you specify one or more IP addresses, only the nodes specified participate in peering sessions.
        """
        return pulumi.get(self, "control_plane_nodes")

    @control_plane_nodes.setter
    def control_plane_nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "control_plane_nodes", value)


@pulumi.input_type
class BareMetalClusterOperationsConfigArgs:
    def __init__(__self__, *,
                 enable_application_logs: Optional[pulumi.Input[bool]] = None):
        """
        Specifies the bare metal user cluster's observability infrastructure.
        :param pulumi.Input[bool] enable_application_logs: Whether collection of application logs/metrics should be enabled (in addition to system logs/metrics).
        """
        if enable_application_logs is not None:
            pulumi.set(__self__, "enable_application_logs", enable_application_logs)

    @property
    @pulumi.getter(name="enableApplicationLogs")
    def enable_application_logs(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether collection of application logs/metrics should be enabled (in addition to system logs/metrics).
        """
        return pulumi.get(self, "enable_application_logs")

    @enable_application_logs.setter
    def enable_application_logs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_application_logs", value)


@pulumi.input_type
class BareMetalClusterUpgradePolicyArgs:
    def __init__(__self__, *,
                 policy: Optional[pulumi.Input['BareMetalClusterUpgradePolicyPolicy']] = None):
        """
        BareMetalClusterUpgradePolicy defines the cluster upgrade policy.
        :param pulumi.Input['BareMetalClusterUpgradePolicyPolicy'] policy: Specifies which upgrade policy to use.
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['BareMetalClusterUpgradePolicyPolicy']]:
        """
        Specifies which upgrade policy to use.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['BareMetalClusterUpgradePolicyPolicy']]):
        pulumi.set(self, "policy", value)


@pulumi.input_type
class BareMetalControlPlaneConfigArgs:
    def __init__(__self__, *,
                 control_plane_node_pool_config: pulumi.Input['BareMetalControlPlaneNodePoolConfigArgs'],
                 api_server_args: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalApiServerArgumentArgs']]]] = None):
        """
        Specifies the control plane configuration.
        :param pulumi.Input['BareMetalControlPlaneNodePoolConfigArgs'] control_plane_node_pool_config: Configures the node pool running the control plane.
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalApiServerArgumentArgs']]] api_server_args: Customizes the default API server args. Only a subset of customized flags are supported. For the exact format, refer to the [API server documentation](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/).
        """
        pulumi.set(__self__, "control_plane_node_pool_config", control_plane_node_pool_config)
        if api_server_args is not None:
            pulumi.set(__self__, "api_server_args", api_server_args)

    @property
    @pulumi.getter(name="controlPlaneNodePoolConfig")
    def control_plane_node_pool_config(self) -> pulumi.Input['BareMetalControlPlaneNodePoolConfigArgs']:
        """
        Configures the node pool running the control plane.
        """
        return pulumi.get(self, "control_plane_node_pool_config")

    @control_plane_node_pool_config.setter
    def control_plane_node_pool_config(self, value: pulumi.Input['BareMetalControlPlaneNodePoolConfigArgs']):
        pulumi.set(self, "control_plane_node_pool_config", value)

    @property
    @pulumi.getter(name="apiServerArgs")
    def api_server_args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalApiServerArgumentArgs']]]]:
        """
        Customizes the default API server args. Only a subset of customized flags are supported. For the exact format, refer to the [API server documentation](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/).
        """
        return pulumi.get(self, "api_server_args")

    @api_server_args.setter
    def api_server_args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalApiServerArgumentArgs']]]]):
        pulumi.set(self, "api_server_args", value)


@pulumi.input_type
class BareMetalControlPlaneNodePoolConfigArgs:
    def __init__(__self__, *,
                 node_pool_config: pulumi.Input['BareMetalNodePoolConfigArgs']):
        """
        Specifies the control plane node pool configuration.
        :param pulumi.Input['BareMetalNodePoolConfigArgs'] node_pool_config: The generic configuration for a node pool running the control plane.
        """
        pulumi.set(__self__, "node_pool_config", node_pool_config)

    @property
    @pulumi.getter(name="nodePoolConfig")
    def node_pool_config(self) -> pulumi.Input['BareMetalNodePoolConfigArgs']:
        """
        The generic configuration for a node pool running the control plane.
        """
        return pulumi.get(self, "node_pool_config")

    @node_pool_config.setter
    def node_pool_config(self, value: pulumi.Input['BareMetalNodePoolConfigArgs']):
        pulumi.set(self, "node_pool_config", value)


@pulumi.input_type
class BareMetalIslandModeCidrConfigArgs:
    def __init__(__self__, *,
                 pod_address_cidr_blocks: pulumi.Input[Sequence[pulumi.Input[str]]],
                 service_address_cidr_blocks: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Specifies the cluster CIDR configuration while running in island mode.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pod_address_cidr_blocks: All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_address_cidr_blocks: All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field is mutable after creation starting with version 1.15.
        """
        pulumi.set(__self__, "pod_address_cidr_blocks", pod_address_cidr_blocks)
        pulumi.set(__self__, "service_address_cidr_blocks", service_address_cidr_blocks)

    @property
    @pulumi.getter(name="podAddressCidrBlocks")
    def pod_address_cidr_blocks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        return pulumi.get(self, "pod_address_cidr_blocks")

    @pod_address_cidr_blocks.setter
    def pod_address_cidr_blocks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "pod_address_cidr_blocks", value)

    @property
    @pulumi.getter(name="serviceAddressCidrBlocks")
    def service_address_cidr_blocks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field is mutable after creation starting with version 1.15.
        """
        return pulumi.get(self, "service_address_cidr_blocks")

    @service_address_cidr_blocks.setter
    def service_address_cidr_blocks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "service_address_cidr_blocks", value)


@pulumi.input_type
class BareMetalKubeletConfigArgs:
    def __init__(__self__, *,
                 registry_burst: Optional[pulumi.Input[int]] = None,
                 registry_pull_qps: Optional[pulumi.Input[int]] = None,
                 serialize_image_pulls_disabled: Optional[pulumi.Input[bool]] = None):
        """
        KubeletConfig defines the modifiable kubelet configurations for bare metal machines. Note: this list includes fields supported in GKE (see https://cloud.google.com/kubernetes-engine/docs/how-to/node-system-config#kubelet-options).
        :param pulumi.Input[int] registry_burst: The maximum size of bursty pulls, temporarily allows pulls to burst to this number, while still not exceeding registry_pull_qps. The value must not be a negative number. Updating this field may impact scalability by changing the amount of traffic produced by image pulls. Defaults to 10.
        :param pulumi.Input[int] registry_pull_qps: The limit of registry pulls per second. Setting this value to 0 means no limit. Updating this field may impact scalability by changing the amount of traffic produced by image pulls. Defaults to 5.
        :param pulumi.Input[bool] serialize_image_pulls_disabled: Prevents the Kubelet from pulling multiple images at a time. We recommend *not* changing the default value on nodes that run docker daemon with version < 1.9 or an Another Union File System (Aufs) storage backend. Issue https://github.com/kubernetes/kubernetes/issues/10959 has more details.
        """
        if registry_burst is not None:
            pulumi.set(__self__, "registry_burst", registry_burst)
        if registry_pull_qps is not None:
            pulumi.set(__self__, "registry_pull_qps", registry_pull_qps)
        if serialize_image_pulls_disabled is not None:
            pulumi.set(__self__, "serialize_image_pulls_disabled", serialize_image_pulls_disabled)

    @property
    @pulumi.getter(name="registryBurst")
    def registry_burst(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum size of bursty pulls, temporarily allows pulls to burst to this number, while still not exceeding registry_pull_qps. The value must not be a negative number. Updating this field may impact scalability by changing the amount of traffic produced by image pulls. Defaults to 10.
        """
        return pulumi.get(self, "registry_burst")

    @registry_burst.setter
    def registry_burst(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "registry_burst", value)

    @property
    @pulumi.getter(name="registryPullQps")
    def registry_pull_qps(self) -> Optional[pulumi.Input[int]]:
        """
        The limit of registry pulls per second. Setting this value to 0 means no limit. Updating this field may impact scalability by changing the amount of traffic produced by image pulls. Defaults to 5.
        """
        return pulumi.get(self, "registry_pull_qps")

    @registry_pull_qps.setter
    def registry_pull_qps(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "registry_pull_qps", value)

    @property
    @pulumi.getter(name="serializeImagePullsDisabled")
    def serialize_image_pulls_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Prevents the Kubelet from pulling multiple images at a time. We recommend *not* changing the default value on nodes that run docker daemon with version < 1.9 or an Another Union File System (Aufs) storage backend. Issue https://github.com/kubernetes/kubernetes/issues/10959 has more details.
        """
        return pulumi.get(self, "serialize_image_pulls_disabled")

    @serialize_image_pulls_disabled.setter
    def serialize_image_pulls_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "serialize_image_pulls_disabled", value)


@pulumi.input_type
class BareMetalLoadBalancerAddressPoolArgs:
    def __init__(__self__, *,
                 addresses: pulumi.Input[Sequence[pulumi.Input[str]]],
                 pool: pulumi.Input[str],
                 avoid_buggy_ips: Optional[pulumi.Input[bool]] = None,
                 manual_assign: Optional[pulumi.Input[bool]] = None):
        """
        Represents an IP pool used by the load balancer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] addresses: The addresses that are part of this pool. Each address must be either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
        :param pulumi.Input[str] pool: The name of the address pool.
        :param pulumi.Input[bool] avoid_buggy_ips: If true, avoid using IPs ending in .0 or .255. This avoids buggy consumer devices mistakenly dropping IPv4 traffic for those special IP addresses.
        :param pulumi.Input[bool] manual_assign: If true, prevent IP addresses from being automatically assigned.
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "pool", pool)
        if avoid_buggy_ips is not None:
            pulumi.set(__self__, "avoid_buggy_ips", avoid_buggy_ips)
        if manual_assign is not None:
            pulumi.set(__self__, "manual_assign", manual_assign)

    @property
    @pulumi.getter
    def addresses(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The addresses that are part of this pool. Each address must be either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter
    def pool(self) -> pulumi.Input[str]:
        """
        The name of the address pool.
        """
        return pulumi.get(self, "pool")

    @pool.setter
    def pool(self, value: pulumi.Input[str]):
        pulumi.set(self, "pool", value)

    @property
    @pulumi.getter(name="avoidBuggyIps")
    def avoid_buggy_ips(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, avoid using IPs ending in .0 or .255. This avoids buggy consumer devices mistakenly dropping IPv4 traffic for those special IP addresses.
        """
        return pulumi.get(self, "avoid_buggy_ips")

    @avoid_buggy_ips.setter
    def avoid_buggy_ips(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "avoid_buggy_ips", value)

    @property
    @pulumi.getter(name="manualAssign")
    def manual_assign(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, prevent IP addresses from being automatically assigned.
        """
        return pulumi.get(self, "manual_assign")

    @manual_assign.setter
    def manual_assign(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "manual_assign", value)


@pulumi.input_type
class BareMetalLoadBalancerConfigArgs:
    def __init__(__self__, *,
                 bgp_lb_config: Optional[pulumi.Input['BareMetalBgpLbConfigArgs']] = None,
                 manual_lb_config: Optional[pulumi.Input['BareMetalManualLbConfigArgs']] = None,
                 metal_lb_config: Optional[pulumi.Input['BareMetalMetalLbConfigArgs']] = None,
                 port_config: Optional[pulumi.Input['BareMetalPortConfigArgs']] = None,
                 vip_config: Optional[pulumi.Input['BareMetalVipConfigArgs']] = None):
        """
        Specifies the load balancer configuration.
        :param pulumi.Input['BareMetalBgpLbConfigArgs'] bgp_lb_config: Configuration for BGP typed load balancers. When set network_config.advanced_networking is automatically set to true.
        :param pulumi.Input['BareMetalManualLbConfigArgs'] manual_lb_config: Manually configured load balancers.
        :param pulumi.Input['BareMetalMetalLbConfigArgs'] metal_lb_config: Configuration for MetalLB load balancers.
        :param pulumi.Input['BareMetalPortConfigArgs'] port_config: Configures the ports that the load balancer will listen on.
        :param pulumi.Input['BareMetalVipConfigArgs'] vip_config: The VIPs used by the load balancer.
        """
        if bgp_lb_config is not None:
            pulumi.set(__self__, "bgp_lb_config", bgp_lb_config)
        if manual_lb_config is not None:
            pulumi.set(__self__, "manual_lb_config", manual_lb_config)
        if metal_lb_config is not None:
            pulumi.set(__self__, "metal_lb_config", metal_lb_config)
        if port_config is not None:
            pulumi.set(__self__, "port_config", port_config)
        if vip_config is not None:
            pulumi.set(__self__, "vip_config", vip_config)

    @property
    @pulumi.getter(name="bgpLbConfig")
    def bgp_lb_config(self) -> Optional[pulumi.Input['BareMetalBgpLbConfigArgs']]:
        """
        Configuration for BGP typed load balancers. When set network_config.advanced_networking is automatically set to true.
        """
        return pulumi.get(self, "bgp_lb_config")

    @bgp_lb_config.setter
    def bgp_lb_config(self, value: Optional[pulumi.Input['BareMetalBgpLbConfigArgs']]):
        pulumi.set(self, "bgp_lb_config", value)

    @property
    @pulumi.getter(name="manualLbConfig")
    def manual_lb_config(self) -> Optional[pulumi.Input['BareMetalManualLbConfigArgs']]:
        """
        Manually configured load balancers.
        """
        return pulumi.get(self, "manual_lb_config")

    @manual_lb_config.setter
    def manual_lb_config(self, value: Optional[pulumi.Input['BareMetalManualLbConfigArgs']]):
        pulumi.set(self, "manual_lb_config", value)

    @property
    @pulumi.getter(name="metalLbConfig")
    def metal_lb_config(self) -> Optional[pulumi.Input['BareMetalMetalLbConfigArgs']]:
        """
        Configuration for MetalLB load balancers.
        """
        return pulumi.get(self, "metal_lb_config")

    @metal_lb_config.setter
    def metal_lb_config(self, value: Optional[pulumi.Input['BareMetalMetalLbConfigArgs']]):
        pulumi.set(self, "metal_lb_config", value)

    @property
    @pulumi.getter(name="portConfig")
    def port_config(self) -> Optional[pulumi.Input['BareMetalPortConfigArgs']]:
        """
        Configures the ports that the load balancer will listen on.
        """
        return pulumi.get(self, "port_config")

    @port_config.setter
    def port_config(self, value: Optional[pulumi.Input['BareMetalPortConfigArgs']]):
        pulumi.set(self, "port_config", value)

    @property
    @pulumi.getter(name="vipConfig")
    def vip_config(self) -> Optional[pulumi.Input['BareMetalVipConfigArgs']]:
        """
        The VIPs used by the load balancer.
        """
        return pulumi.get(self, "vip_config")

    @vip_config.setter
    def vip_config(self, value: Optional[pulumi.Input['BareMetalVipConfigArgs']]):
        pulumi.set(self, "vip_config", value)


@pulumi.input_type
class BareMetalLoadBalancerNodePoolConfigArgs:
    def __init__(__self__, *,
                 node_pool_config: Optional[pulumi.Input['BareMetalNodePoolConfigArgs']] = None):
        """
        Specifies the load balancer's node pool configuration.
        :param pulumi.Input['BareMetalNodePoolConfigArgs'] node_pool_config: The generic configuration for a node pool running a load balancer.
        """
        if node_pool_config is not None:
            pulumi.set(__self__, "node_pool_config", node_pool_config)

    @property
    @pulumi.getter(name="nodePoolConfig")
    def node_pool_config(self) -> Optional[pulumi.Input['BareMetalNodePoolConfigArgs']]:
        """
        The generic configuration for a node pool running a load balancer.
        """
        return pulumi.get(self, "node_pool_config")

    @node_pool_config.setter
    def node_pool_config(self, value: Optional[pulumi.Input['BareMetalNodePoolConfigArgs']]):
        pulumi.set(self, "node_pool_config", value)


@pulumi.input_type
class BareMetalLvpConfigArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 storage_class: pulumi.Input[str]):
        """
        Specifies the configs for local persistent volumes (PVs).
        :param pulumi.Input[str] path: The host machine path.
        :param pulumi.Input[str] storage_class: The StorageClass name that PVs will be created with.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The host machine path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[str]:
        """
        The StorageClass name that PVs will be created with.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_class", value)


@pulumi.input_type
class BareMetalLvpShareConfigArgs:
    def __init__(__self__, *,
                 lvp_config: pulumi.Input['BareMetalLvpConfigArgs'],
                 shared_path_pv_count: Optional[pulumi.Input[int]] = None):
        """
        Specifies the configs for local persistent volumes under a shared file system.
        :param pulumi.Input['BareMetalLvpConfigArgs'] lvp_config: Defines the machine path and storage class for the LVP Share.
        :param pulumi.Input[int] shared_path_pv_count: The number of subdirectories to create under path.
        """
        pulumi.set(__self__, "lvp_config", lvp_config)
        if shared_path_pv_count is not None:
            pulumi.set(__self__, "shared_path_pv_count", shared_path_pv_count)

    @property
    @pulumi.getter(name="lvpConfig")
    def lvp_config(self) -> pulumi.Input['BareMetalLvpConfigArgs']:
        """
        Defines the machine path and storage class for the LVP Share.
        """
        return pulumi.get(self, "lvp_config")

    @lvp_config.setter
    def lvp_config(self, value: pulumi.Input['BareMetalLvpConfigArgs']):
        pulumi.set(self, "lvp_config", value)

    @property
    @pulumi.getter(name="sharedPathPvCount")
    def shared_path_pv_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of subdirectories to create under path.
        """
        return pulumi.get(self, "shared_path_pv_count")

    @shared_path_pv_count.setter
    def shared_path_pv_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "shared_path_pv_count", value)


@pulumi.input_type
class BareMetalMaintenanceConfigArgs:
    def __init__(__self__, *,
                 maintenance_address_cidr_blocks: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Specifies configurations to put bare metal nodes in and out of maintenance.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] maintenance_address_cidr_blocks: All IPv4 address from these ranges will be placed into maintenance mode. Nodes in maintenance mode will be cordoned and drained. When both of these are true, the "baremetal.cluster.gke.io/maintenance" annotation will be set on the node resource.
        """
        pulumi.set(__self__, "maintenance_address_cidr_blocks", maintenance_address_cidr_blocks)

    @property
    @pulumi.getter(name="maintenanceAddressCidrBlocks")
    def maintenance_address_cidr_blocks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        All IPv4 address from these ranges will be placed into maintenance mode. Nodes in maintenance mode will be cordoned and drained. When both of these are true, the "baremetal.cluster.gke.io/maintenance" annotation will be set on the node resource.
        """
        return pulumi.get(self, "maintenance_address_cidr_blocks")

    @maintenance_address_cidr_blocks.setter
    def maintenance_address_cidr_blocks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "maintenance_address_cidr_blocks", value)


@pulumi.input_type
class BareMetalManualLbConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        Represents configuration parameters for a manual load balancer.
        :param pulumi.Input[bool] enabled: Whether manual load balancing is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether manual load balancing is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class BareMetalMetalLbConfigArgs:
    def __init__(__self__, *,
                 address_pools: pulumi.Input[Sequence[pulumi.Input['BareMetalLoadBalancerAddressPoolArgs']]],
                 load_balancer_node_pool_config: Optional[pulumi.Input['BareMetalLoadBalancerNodePoolConfigArgs']] = None):
        """
        Represents configuration parameters for a MetalLB load balancer.
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalLoadBalancerAddressPoolArgs']]] address_pools: AddressPools is a list of non-overlapping IP pools used by load balancer typed services. All addresses must be routable to load balancer nodes. IngressVIP must be included in the pools.
        :param pulumi.Input['BareMetalLoadBalancerNodePoolConfigArgs'] load_balancer_node_pool_config: Specifies the node pool running the load balancer. L2 connectivity is required among nodes in this pool. If missing, the control plane node pool is used as the load balancer pool.
        """
        pulumi.set(__self__, "address_pools", address_pools)
        if load_balancer_node_pool_config is not None:
            pulumi.set(__self__, "load_balancer_node_pool_config", load_balancer_node_pool_config)

    @property
    @pulumi.getter(name="addressPools")
    def address_pools(self) -> pulumi.Input[Sequence[pulumi.Input['BareMetalLoadBalancerAddressPoolArgs']]]:
        """
        AddressPools is a list of non-overlapping IP pools used by load balancer typed services. All addresses must be routable to load balancer nodes. IngressVIP must be included in the pools.
        """
        return pulumi.get(self, "address_pools")

    @address_pools.setter
    def address_pools(self, value: pulumi.Input[Sequence[pulumi.Input['BareMetalLoadBalancerAddressPoolArgs']]]):
        pulumi.set(self, "address_pools", value)

    @property
    @pulumi.getter(name="loadBalancerNodePoolConfig")
    def load_balancer_node_pool_config(self) -> Optional[pulumi.Input['BareMetalLoadBalancerNodePoolConfigArgs']]:
        """
        Specifies the node pool running the load balancer. L2 connectivity is required among nodes in this pool. If missing, the control plane node pool is used as the load balancer pool.
        """
        return pulumi.get(self, "load_balancer_node_pool_config")

    @load_balancer_node_pool_config.setter
    def load_balancer_node_pool_config(self, value: Optional[pulumi.Input['BareMetalLoadBalancerNodePoolConfigArgs']]):
        pulumi.set(self, "load_balancer_node_pool_config", value)


@pulumi.input_type
class BareMetalMultipleNetworkInterfacesConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        Specifies the multiple networking interfaces cluster configuration.
        :param pulumi.Input[bool] enabled: Whether to enable multiple network interfaces for your pods. When set network_config.advanced_networking is automatically set to true.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable multiple network interfaces for your pods. When set network_config.advanced_networking is automatically set to true.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class BareMetalNetworkConfigArgs:
    def __init__(__self__, *,
                 advanced_networking: Optional[pulumi.Input[bool]] = None,
                 island_mode_cidr: Optional[pulumi.Input['BareMetalIslandModeCidrConfigArgs']] = None,
                 multiple_network_interfaces_config: Optional[pulumi.Input['BareMetalMultipleNetworkInterfacesConfigArgs']] = None,
                 sr_iov_config: Optional[pulumi.Input['BareMetalSrIovConfigArgs']] = None):
        """
        Specifies the cluster network configuration.
        :param pulumi.Input[bool] advanced_networking: Enables the use of advanced Anthos networking features, such as Bundled Load Balancing with BGP or the egress NAT gateway. Setting configuration for advanced networking features will automatically set this flag.
        :param pulumi.Input['BareMetalIslandModeCidrConfigArgs'] island_mode_cidr: Configuration for island mode CIDR. In an island-mode network, nodes have unique IP addresses, but pods don't have unique addresses across clusters. This doesn't cause problems because pods in one cluster never directly communicate with pods in another cluster. Instead, there are gateways that mediate between a pod in one cluster and a pod in another cluster.
        :param pulumi.Input['BareMetalMultipleNetworkInterfacesConfigArgs'] multiple_network_interfaces_config: Configuration for multiple network interfaces.
        :param pulumi.Input['BareMetalSrIovConfigArgs'] sr_iov_config: Configuration for SR-IOV.
        """
        if advanced_networking is not None:
            pulumi.set(__self__, "advanced_networking", advanced_networking)
        if island_mode_cidr is not None:
            pulumi.set(__self__, "island_mode_cidr", island_mode_cidr)
        if multiple_network_interfaces_config is not None:
            pulumi.set(__self__, "multiple_network_interfaces_config", multiple_network_interfaces_config)
        if sr_iov_config is not None:
            pulumi.set(__self__, "sr_iov_config", sr_iov_config)

    @property
    @pulumi.getter(name="advancedNetworking")
    def advanced_networking(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables the use of advanced Anthos networking features, such as Bundled Load Balancing with BGP or the egress NAT gateway. Setting configuration for advanced networking features will automatically set this flag.
        """
        return pulumi.get(self, "advanced_networking")

    @advanced_networking.setter
    def advanced_networking(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "advanced_networking", value)

    @property
    @pulumi.getter(name="islandModeCidr")
    def island_mode_cidr(self) -> Optional[pulumi.Input['BareMetalIslandModeCidrConfigArgs']]:
        """
        Configuration for island mode CIDR. In an island-mode network, nodes have unique IP addresses, but pods don't have unique addresses across clusters. This doesn't cause problems because pods in one cluster never directly communicate with pods in another cluster. Instead, there are gateways that mediate between a pod in one cluster and a pod in another cluster.
        """
        return pulumi.get(self, "island_mode_cidr")

    @island_mode_cidr.setter
    def island_mode_cidr(self, value: Optional[pulumi.Input['BareMetalIslandModeCidrConfigArgs']]):
        pulumi.set(self, "island_mode_cidr", value)

    @property
    @pulumi.getter(name="multipleNetworkInterfacesConfig")
    def multiple_network_interfaces_config(self) -> Optional[pulumi.Input['BareMetalMultipleNetworkInterfacesConfigArgs']]:
        """
        Configuration for multiple network interfaces.
        """
        return pulumi.get(self, "multiple_network_interfaces_config")

    @multiple_network_interfaces_config.setter
    def multiple_network_interfaces_config(self, value: Optional[pulumi.Input['BareMetalMultipleNetworkInterfacesConfigArgs']]):
        pulumi.set(self, "multiple_network_interfaces_config", value)

    @property
    @pulumi.getter(name="srIovConfig")
    def sr_iov_config(self) -> Optional[pulumi.Input['BareMetalSrIovConfigArgs']]:
        """
        Configuration for SR-IOV.
        """
        return pulumi.get(self, "sr_iov_config")

    @sr_iov_config.setter
    def sr_iov_config(self, value: Optional[pulumi.Input['BareMetalSrIovConfigArgs']]):
        pulumi.set(self, "sr_iov_config", value)


@pulumi.input_type
class BareMetalNodeAccessConfigArgs:
    def __init__(__self__, *,
                 login_user: Optional[pulumi.Input[str]] = None):
        """
        Specifies the node access related settings for the bare metal user cluster.
        :param pulumi.Input[str] login_user: LoginUser is the user name used to access node machines. It defaults to "root" if not set.
        """
        if login_user is not None:
            pulumi.set(__self__, "login_user", login_user)

    @property
    @pulumi.getter(name="loginUser")
    def login_user(self) -> Optional[pulumi.Input[str]]:
        """
        LoginUser is the user name used to access node machines. It defaults to "root" if not set.
        """
        return pulumi.get(self, "login_user")

    @login_user.setter
    def login_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "login_user", value)


@pulumi.input_type
class BareMetalNodeConfigArgs:
    def __init__(__self__, *,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 node_ip: Optional[pulumi.Input[str]] = None):
        """
        BareMetalNodeConfig lists machine addresses to access Nodes.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: The labels assigned to this node. An object containing a list of key/value pairs. The labels here, unioned with the labels set on BareMetalNodePoolConfig are the set of labels that will be applied to the node. If there are any conflicts, the BareMetalNodeConfig labels take precedence. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param pulumi.Input[str] node_ip: The default IPv4 address for SSH access and Kubernetes node. Example: 192.168.0.1
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_ip is not None:
            pulumi.set(__self__, "node_ip", node_ip)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The labels assigned to this node. An object containing a list of key/value pairs. The labels here, unioned with the labels set on BareMetalNodePoolConfig are the set of labels that will be applied to the node. If there are any conflicts, the BareMetalNodeConfig labels take precedence. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The default IPv4 address for SSH access and Kubernetes node. Example: 192.168.0.1
        """
        return pulumi.get(self, "node_ip")

    @node_ip.setter
    def node_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_ip", value)


@pulumi.input_type
class BareMetalNodePoolConfigArgs:
    def __init__(__self__, *,
                 node_configs: pulumi.Input[Sequence[pulumi.Input['BareMetalNodeConfigArgs']]],
                 kubelet_config: Optional[pulumi.Input['BareMetalKubeletConfigArgs']] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 operating_system: Optional[pulumi.Input['BareMetalNodePoolConfigOperatingSystem']] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['NodeTaintArgs']]]] = None):
        """
        BareMetalNodePoolConfig describes the configuration of all nodes within a given bare metal node pool.
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalNodeConfigArgs']]] node_configs: The list of machine addresses in the bare metal node pool.
        :param pulumi.Input['BareMetalKubeletConfigArgs'] kubelet_config: The modifiable kubelet configurations for the bare metal machines.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: The labels assigned to nodes of this node pool. An object containing a list of key/value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param pulumi.Input['BareMetalNodePoolConfigOperatingSystem'] operating_system: Specifies the nodes operating system (default: LINUX).
        :param pulumi.Input[Sequence[pulumi.Input['NodeTaintArgs']]] taints: The initial taints assigned to nodes of this node pool.
        """
        pulumi.set(__self__, "node_configs", node_configs)
        if kubelet_config is not None:
            pulumi.set(__self__, "kubelet_config", kubelet_config)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if operating_system is not None:
            pulumi.set(__self__, "operating_system", operating_system)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter(name="nodeConfigs")
    def node_configs(self) -> pulumi.Input[Sequence[pulumi.Input['BareMetalNodeConfigArgs']]]:
        """
        The list of machine addresses in the bare metal node pool.
        """
        return pulumi.get(self, "node_configs")

    @node_configs.setter
    def node_configs(self, value: pulumi.Input[Sequence[pulumi.Input['BareMetalNodeConfigArgs']]]):
        pulumi.set(self, "node_configs", value)

    @property
    @pulumi.getter(name="kubeletConfig")
    def kubelet_config(self) -> Optional[pulumi.Input['BareMetalKubeletConfigArgs']]:
        """
        The modifiable kubelet configurations for the bare metal machines.
        """
        return pulumi.get(self, "kubelet_config")

    @kubelet_config.setter
    def kubelet_config(self, value: Optional[pulumi.Input['BareMetalKubeletConfigArgs']]):
        pulumi.set(self, "kubelet_config", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The labels assigned to nodes of this node pool. An object containing a list of key/value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[pulumi.Input['BareMetalNodePoolConfigOperatingSystem']]:
        """
        Specifies the nodes operating system (default: LINUX).
        """
        return pulumi.get(self, "operating_system")

    @operating_system.setter
    def operating_system(self, value: Optional[pulumi.Input['BareMetalNodePoolConfigOperatingSystem']]):
        pulumi.set(self, "operating_system", value)

    @property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NodeTaintArgs']]]]:
        """
        The initial taints assigned to nodes of this node pool.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NodeTaintArgs']]]]):
        pulumi.set(self, "taints", value)


@pulumi.input_type
class BareMetalNodePoolUpgradePolicyArgs:
    def __init__(__self__, *,
                 parallel_upgrade_config: Optional[pulumi.Input['BareMetalParallelUpgradeConfigArgs']] = None):
        """
        BareMetalNodePoolUpgradePolicy defines the node pool upgrade policy.
        :param pulumi.Input['BareMetalParallelUpgradeConfigArgs'] parallel_upgrade_config: The parallel upgrade settings for worker node pools.
        """
        if parallel_upgrade_config is not None:
            pulumi.set(__self__, "parallel_upgrade_config", parallel_upgrade_config)

    @property
    @pulumi.getter(name="parallelUpgradeConfig")
    def parallel_upgrade_config(self) -> Optional[pulumi.Input['BareMetalParallelUpgradeConfigArgs']]:
        """
        The parallel upgrade settings for worker node pools.
        """
        return pulumi.get(self, "parallel_upgrade_config")

    @parallel_upgrade_config.setter
    def parallel_upgrade_config(self, value: Optional[pulumi.Input['BareMetalParallelUpgradeConfigArgs']]):
        pulumi.set(self, "parallel_upgrade_config", value)


@pulumi.input_type
class BareMetalOsEnvironmentConfigArgs:
    def __init__(__self__, *,
                 package_repo_excluded: Optional[pulumi.Input[bool]] = None):
        """
        Specifies operating system settings for cluster provisioning.
        :param pulumi.Input[bool] package_repo_excluded: Whether the package repo should not be included when initializing bare metal machines.
        """
        if package_repo_excluded is not None:
            pulumi.set(__self__, "package_repo_excluded", package_repo_excluded)

    @property
    @pulumi.getter(name="packageRepoExcluded")
    def package_repo_excluded(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the package repo should not be included when initializing bare metal machines.
        """
        return pulumi.get(self, "package_repo_excluded")

    @package_repo_excluded.setter
    def package_repo_excluded(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "package_repo_excluded", value)


@pulumi.input_type
class BareMetalParallelUpgradeConfigArgs:
    def __init__(__self__, *,
                 concurrent_nodes: Optional[pulumi.Input[int]] = None,
                 minimum_available_nodes: Optional[pulumi.Input[int]] = None):
        """
        BareMetalParallelUpgradeConfig defines the parallel upgrade settings for worker node pools.
        :param pulumi.Input[int] concurrent_nodes: The maximum number of nodes that can be upgraded at once.
        :param pulumi.Input[int] minimum_available_nodes: The minimum number of nodes that should be healthy and available during an upgrade. If set to the default value of 0, it is possible that none of the nodes will be available during an upgrade.
        """
        if concurrent_nodes is not None:
            pulumi.set(__self__, "concurrent_nodes", concurrent_nodes)
        if minimum_available_nodes is not None:
            pulumi.set(__self__, "minimum_available_nodes", minimum_available_nodes)

    @property
    @pulumi.getter(name="concurrentNodes")
    def concurrent_nodes(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of nodes that can be upgraded at once.
        """
        return pulumi.get(self, "concurrent_nodes")

    @concurrent_nodes.setter
    def concurrent_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "concurrent_nodes", value)

    @property
    @pulumi.getter(name="minimumAvailableNodes")
    def minimum_available_nodes(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum number of nodes that should be healthy and available during an upgrade. If set to the default value of 0, it is possible that none of the nodes will be available during an upgrade.
        """
        return pulumi.get(self, "minimum_available_nodes")

    @minimum_available_nodes.setter
    def minimum_available_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minimum_available_nodes", value)


@pulumi.input_type
class BareMetalPortConfigArgs:
    def __init__(__self__, *,
                 control_plane_load_balancer_port: Optional[pulumi.Input[int]] = None):
        """
        Specifies load balancer ports for the bare metal user cluster.
        :param pulumi.Input[int] control_plane_load_balancer_port: The port that control plane hosted load balancers will listen on.
        """
        if control_plane_load_balancer_port is not None:
            pulumi.set(__self__, "control_plane_load_balancer_port", control_plane_load_balancer_port)

    @property
    @pulumi.getter(name="controlPlaneLoadBalancerPort")
    def control_plane_load_balancer_port(self) -> Optional[pulumi.Input[int]]:
        """
        The port that control plane hosted load balancers will listen on.
        """
        return pulumi.get(self, "control_plane_load_balancer_port")

    @control_plane_load_balancer_port.setter
    def control_plane_load_balancer_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "control_plane_load_balancer_port", value)


@pulumi.input_type
class BareMetalProxyConfigArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str],
                 no_proxy: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Specifies the cluster proxy configuration.
        :param pulumi.Input[str] uri: Specifies the address of your proxy server. Examples: `http://domain` Do not provide credentials in the format `http://(username:password@)domain` these will be rejected by the server.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] no_proxy: A list of IPs, hostnames, and domains that should skip the proxy. Examples: ["127.0.0.1", "example.com", ".corp", "localhost"].
        """
        pulumi.set(__self__, "uri", uri)
        if no_proxy is not None:
            pulumi.set(__self__, "no_proxy", no_proxy)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        Specifies the address of your proxy server. Examples: `http://domain` Do not provide credentials in the format `http://(username:password@)domain` these will be rejected by the server.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="noProxy")
    def no_proxy(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of IPs, hostnames, and domains that should skip the proxy. Examples: ["127.0.0.1", "example.com", ".corp", "localhost"].
        """
        return pulumi.get(self, "no_proxy")

    @no_proxy.setter
    def no_proxy(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "no_proxy", value)


@pulumi.input_type
class BareMetalSecurityConfigArgs:
    def __init__(__self__, *,
                 authorization: Optional[pulumi.Input['AuthorizationArgs']] = None):
        """
        Specifies the security related settings for the bare metal user cluster.
        :param pulumi.Input['AuthorizationArgs'] authorization: Configures user access to the user cluster.
        """
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input['AuthorizationArgs']]:
        """
        Configures user access to the user cluster.
        """
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input['AuthorizationArgs']]):
        pulumi.set(self, "authorization", value)


@pulumi.input_type
class BareMetalSrIovConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        Specifies the SR-IOV networking operator config.
        :param pulumi.Input[bool] enabled: Whether to install the SR-IOV operator.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to install the SR-IOV operator.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class BareMetalStorageConfigArgs:
    def __init__(__self__, *,
                 lvp_node_mounts_config: pulumi.Input['BareMetalLvpConfigArgs'],
                 lvp_share_config: pulumi.Input['BareMetalLvpShareConfigArgs']):
        """
        BareMetalStorageConfig specifies the cluster storage configuration.
        :param pulumi.Input['BareMetalLvpConfigArgs'] lvp_node_mounts_config: Specifies the config for local PersistentVolumes backed by mounted node disks. These disks need to be formatted and mounted by the user, which can be done before or after cluster creation.
        :param pulumi.Input['BareMetalLvpShareConfigArgs'] lvp_share_config: Specifies the config for local PersistentVolumes backed by subdirectories in a shared filesystem. These subdirectores are automatically created during cluster creation.
        """
        pulumi.set(__self__, "lvp_node_mounts_config", lvp_node_mounts_config)
        pulumi.set(__self__, "lvp_share_config", lvp_share_config)

    @property
    @pulumi.getter(name="lvpNodeMountsConfig")
    def lvp_node_mounts_config(self) -> pulumi.Input['BareMetalLvpConfigArgs']:
        """
        Specifies the config for local PersistentVolumes backed by mounted node disks. These disks need to be formatted and mounted by the user, which can be done before or after cluster creation.
        """
        return pulumi.get(self, "lvp_node_mounts_config")

    @lvp_node_mounts_config.setter
    def lvp_node_mounts_config(self, value: pulumi.Input['BareMetalLvpConfigArgs']):
        pulumi.set(self, "lvp_node_mounts_config", value)

    @property
    @pulumi.getter(name="lvpShareConfig")
    def lvp_share_config(self) -> pulumi.Input['BareMetalLvpShareConfigArgs']:
        """
        Specifies the config for local PersistentVolumes backed by subdirectories in a shared filesystem. These subdirectores are automatically created during cluster creation.
        """
        return pulumi.get(self, "lvp_share_config")

    @lvp_share_config.setter
    def lvp_share_config(self, value: pulumi.Input['BareMetalLvpShareConfigArgs']):
        pulumi.set(self, "lvp_share_config", value)


@pulumi.input_type
class BareMetalVipConfigArgs:
    def __init__(__self__, *,
                 control_plane_vip: Optional[pulumi.Input[str]] = None,
                 ingress_vip: Optional[pulumi.Input[str]] = None):
        """
        Specifies the VIP config for the bare metal load balancer.
        :param pulumi.Input[str] control_plane_vip: The VIP which you previously set aside for the Kubernetes API of this bare metal user cluster.
        :param pulumi.Input[str] ingress_vip: The VIP which you previously set aside for ingress traffic into this bare metal user cluster.
        """
        if control_plane_vip is not None:
            pulumi.set(__self__, "control_plane_vip", control_plane_vip)
        if ingress_vip is not None:
            pulumi.set(__self__, "ingress_vip", ingress_vip)

    @property
    @pulumi.getter(name="controlPlaneVip")
    def control_plane_vip(self) -> Optional[pulumi.Input[str]]:
        """
        The VIP which you previously set aside for the Kubernetes API of this bare metal user cluster.
        """
        return pulumi.get(self, "control_plane_vip")

    @control_plane_vip.setter
    def control_plane_vip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "control_plane_vip", value)

    @property
    @pulumi.getter(name="ingressVip")
    def ingress_vip(self) -> Optional[pulumi.Input[str]]:
        """
        The VIP which you previously set aside for ingress traffic into this bare metal user cluster.
        """
        return pulumi.get(self, "ingress_vip")

    @ingress_vip.setter
    def ingress_vip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ingress_vip", value)


@pulumi.input_type
class BareMetalWorkloadNodeConfigArgs:
    def __init__(__self__, *,
                 container_runtime: Optional[pulumi.Input['BareMetalWorkloadNodeConfigContainerRuntime']] = None,
                 max_pods_per_node: Optional[pulumi.Input[str]] = None):
        """
        Specifies the workload node configurations.
        :param pulumi.Input['BareMetalWorkloadNodeConfigContainerRuntime'] container_runtime: Specifies which container runtime will be used.
        :param pulumi.Input[str] max_pods_per_node: The maximum number of pods a node can run. The size of the CIDR range assigned to the node will be derived from this parameter.
        """
        if container_runtime is not None:
            pulumi.set(__self__, "container_runtime", container_runtime)
        if max_pods_per_node is not None:
            pulumi.set(__self__, "max_pods_per_node", max_pods_per_node)

    @property
    @pulumi.getter(name="containerRuntime")
    def container_runtime(self) -> Optional[pulumi.Input['BareMetalWorkloadNodeConfigContainerRuntime']]:
        """
        Specifies which container runtime will be used.
        """
        return pulumi.get(self, "container_runtime")

    @container_runtime.setter
    def container_runtime(self, value: Optional[pulumi.Input['BareMetalWorkloadNodeConfigContainerRuntime']]):
        pulumi.set(self, "container_runtime", value)

    @property
    @pulumi.getter(name="maxPodsPerNode")
    def max_pods_per_node(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum number of pods a node can run. The size of the CIDR range assigned to the node will be derived from this parameter.
        """
        return pulumi.get(self, "max_pods_per_node")

    @max_pods_per_node.setter
    def max_pods_per_node(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_pods_per_node", value)


@pulumi.input_type
class BinaryAuthorizationArgs:
    def __init__(__self__, *,
                 evaluation_mode: Optional[pulumi.Input['BinaryAuthorizationEvaluationMode']] = None):
        """
        Configuration for Binary Authorization.
        :param pulumi.Input['BinaryAuthorizationEvaluationMode'] evaluation_mode: Mode of operation for binauthz policy evaluation. If unspecified, defaults to DISABLED.
        """
        if evaluation_mode is not None:
            pulumi.set(__self__, "evaluation_mode", evaluation_mode)

    @property
    @pulumi.getter(name="evaluationMode")
    def evaluation_mode(self) -> Optional[pulumi.Input['BinaryAuthorizationEvaluationMode']]:
        """
        Mode of operation for binauthz policy evaluation. If unspecified, defaults to DISABLED.
        """
        return pulumi.get(self, "evaluation_mode")

    @evaluation_mode.setter
    def evaluation_mode(self, value: Optional[pulumi.Input['BinaryAuthorizationEvaluationMode']]):
        pulumi.set(self, "evaluation_mode", value)


@pulumi.input_type
class BindingArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input['ExprArgs']] = None,
                 members: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 role: Optional[pulumi.Input[str]] = None):
        """
        Associates `members`, or principals, with a `role`.
        :param pulumi.Input['ExprArgs'] condition: The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] members: Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
        :param pulumi.Input[str] role: Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if members is not None:
            pulumi.set(__self__, "members", members)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['ExprArgs']]:
        """
        The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['ExprArgs']]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def members(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
        """
        return pulumi.get(self, "members")

    @members.setter
    def members(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "members", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)


@pulumi.input_type
class ClusterUserArgs:
    def __init__(__self__, *,
                 username: pulumi.Input[str]):
        """
        ClusterUser configures user principals for an RBAC policy.
        :param pulumi.Input[str] username: The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ExprArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
        :param pulumi.Input[str] description: Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        :param pulumi.Input[str] expression: Textual representation of an expression in Common Expression Language syntax.
        :param pulumi.Input[str] location: Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
        :param pulumi.Input[str] title: Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class NodeTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input['NodeTaintEffect']] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        NodeTaint applied to every Kubernetes node in a node pool. Kubernetes taints can be used together with tolerations to control how workloads are scheduled to your nodes. Node taints are permanent.
        :param pulumi.Input['NodeTaintEffect'] effect: The taint effect.
        :param pulumi.Input[str] key: Key associated with the effect.
        :param pulumi.Input[str] value: Value associated with the effect.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input['NodeTaintEffect']]:
        """
        The taint effect.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input['NodeTaintEffect']]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key associated with the effect.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value associated with the effect.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class VmwareAAGConfigArgs:
    def __init__(__self__, *,
                 aag_config_disabled: Optional[pulumi.Input[bool]] = None):
        """
        Specifies anti affinity group config for the VMware user cluster.
        :param pulumi.Input[bool] aag_config_disabled: Spread nodes across at least three physical hosts (requires at least three hosts). Enabled by default.
        """
        if aag_config_disabled is not None:
            pulumi.set(__self__, "aag_config_disabled", aag_config_disabled)

    @property
    @pulumi.getter(name="aagConfigDisabled")
    def aag_config_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Spread nodes across at least three physical hosts (requires at least three hosts). Enabled by default.
        """
        return pulumi.get(self, "aag_config_disabled")

    @aag_config_disabled.setter
    def aag_config_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "aag_config_disabled", value)


@pulumi.input_type
class VmwareAddressPoolArgs:
    def __init__(__self__, *,
                 addresses: pulumi.Input[Sequence[pulumi.Input[str]]],
                 pool: pulumi.Input[str],
                 avoid_buggy_ips: Optional[pulumi.Input[bool]] = None,
                 manual_assign: Optional[pulumi.Input[bool]] = None):
        """
        Represents an IP pool used by the load balancer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] addresses: The addresses that are part of this pool. Each address must be either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
        :param pulumi.Input[str] pool: The name of the address pool.
        :param pulumi.Input[bool] avoid_buggy_ips: If true, avoid using IPs ending in .0 or .255. This avoids buggy consumer devices mistakenly dropping IPv4 traffic for those special IP addresses.
        :param pulumi.Input[bool] manual_assign: If true, prevent IP addresses from being automatically assigned.
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "pool", pool)
        if avoid_buggy_ips is not None:
            pulumi.set(__self__, "avoid_buggy_ips", avoid_buggy_ips)
        if manual_assign is not None:
            pulumi.set(__self__, "manual_assign", manual_assign)

    @property
    @pulumi.getter
    def addresses(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The addresses that are part of this pool. Each address must be either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter
    def pool(self) -> pulumi.Input[str]:
        """
        The name of the address pool.
        """
        return pulumi.get(self, "pool")

    @pool.setter
    def pool(self, value: pulumi.Input[str]):
        pulumi.set(self, "pool", value)

    @property
    @pulumi.getter(name="avoidBuggyIps")
    def avoid_buggy_ips(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, avoid using IPs ending in .0 or .255. This avoids buggy consumer devices mistakenly dropping IPv4 traffic for those special IP addresses.
        """
        return pulumi.get(self, "avoid_buggy_ips")

    @avoid_buggy_ips.setter
    def avoid_buggy_ips(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "avoid_buggy_ips", value)

    @property
    @pulumi.getter(name="manualAssign")
    def manual_assign(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, prevent IP addresses from being automatically assigned.
        """
        return pulumi.get(self, "manual_assign")

    @manual_assign.setter
    def manual_assign(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "manual_assign", value)


@pulumi.input_type
class VmwareAutoRepairConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        Specifies config to enable/disable auto repair. The cluster-health-controller is deployed only if Enabled is true.
        :param pulumi.Input[bool] enabled: Whether auto repair is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether auto repair is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class VmwareAutoResizeConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        Represents auto resizing configurations for the VMware user cluster.
        :param pulumi.Input[bool] enabled: Whether to enable controle plane node auto resizing.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable controle plane node auto resizing.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class VmwareClusterUpgradePolicyArgs:
    def __init__(__self__, *,
                 control_plane_only: Optional[pulumi.Input[bool]] = None):
        """
        VmwareClusterUpgradePolicy defines the cluster upgrade policy.
        :param pulumi.Input[bool] control_plane_only: Controls whether the upgrade applies to the control plane only.
        """
        if control_plane_only is not None:
            pulumi.set(__self__, "control_plane_only", control_plane_only)

    @property
    @pulumi.getter(name="controlPlaneOnly")
    def control_plane_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Controls whether the upgrade applies to the control plane only.
        """
        return pulumi.get(self, "control_plane_only")

    @control_plane_only.setter
    def control_plane_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "control_plane_only", value)


@pulumi.input_type
class VmwareControlPlaneNodeConfigArgs:
    def __init__(__self__, *,
                 auto_resize_config: Optional[pulumi.Input['VmwareAutoResizeConfigArgs']] = None,
                 cpus: Optional[pulumi.Input[str]] = None,
                 memory: Optional[pulumi.Input[str]] = None,
                 replicas: Optional[pulumi.Input[str]] = None,
                 vsphere_config: Optional[pulumi.Input['VmwareControlPlaneVsphereConfigArgs']] = None):
        """
        Specifies control plane node config for the VMware user cluster.
        :param pulumi.Input['VmwareAutoResizeConfigArgs'] auto_resize_config: AutoResizeConfig provides auto resizing configurations.
        :param pulumi.Input[str] cpus: The number of CPUs for each admin cluster node that serve as control planes for this VMware user cluster. (default: 4 CPUs)
        :param pulumi.Input[str] memory: The megabytes of memory for each admin cluster node that serves as a control plane for this VMware user cluster (default: 8192 MB memory).
        :param pulumi.Input[str] replicas: The number of control plane nodes for this VMware user cluster. (default: 1 replica).
        :param pulumi.Input['VmwareControlPlaneVsphereConfigArgs'] vsphere_config: Vsphere-specific config.
        """
        if auto_resize_config is not None:
            pulumi.set(__self__, "auto_resize_config", auto_resize_config)
        if cpus is not None:
            pulumi.set(__self__, "cpus", cpus)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if vsphere_config is not None:
            pulumi.set(__self__, "vsphere_config", vsphere_config)

    @property
    @pulumi.getter(name="autoResizeConfig")
    def auto_resize_config(self) -> Optional[pulumi.Input['VmwareAutoResizeConfigArgs']]:
        """
        AutoResizeConfig provides auto resizing configurations.
        """
        return pulumi.get(self, "auto_resize_config")

    @auto_resize_config.setter
    def auto_resize_config(self, value: Optional[pulumi.Input['VmwareAutoResizeConfigArgs']]):
        pulumi.set(self, "auto_resize_config", value)

    @property
    @pulumi.getter
    def cpus(self) -> Optional[pulumi.Input[str]]:
        """
        The number of CPUs for each admin cluster node that serve as control planes for this VMware user cluster. (default: 4 CPUs)
        """
        return pulumi.get(self, "cpus")

    @cpus.setter
    def cpus(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpus", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[str]]:
        """
        The megabytes of memory for each admin cluster node that serves as a control plane for this VMware user cluster (default: 8192 MB memory).
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[str]]:
        """
        The number of control plane nodes for this VMware user cluster. (default: 1 replica).
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter(name="vsphereConfig")
    def vsphere_config(self) -> Optional[pulumi.Input['VmwareControlPlaneVsphereConfigArgs']]:
        """
        Vsphere-specific config.
        """
        return pulumi.get(self, "vsphere_config")

    @vsphere_config.setter
    def vsphere_config(self, value: Optional[pulumi.Input['VmwareControlPlaneVsphereConfigArgs']]):
        pulumi.set(self, "vsphere_config", value)


@pulumi.input_type
class VmwareControlPlaneV2ConfigArgs:
    def __init__(__self__, *,
                 control_plane_ip_block: Optional[pulumi.Input['VmwareIpBlockArgs']] = None):
        """
        Specifies control plane V2 config.
        :param pulumi.Input['VmwareIpBlockArgs'] control_plane_ip_block: Static IP addresses for the control plane nodes.
        """
        if control_plane_ip_block is not None:
            pulumi.set(__self__, "control_plane_ip_block", control_plane_ip_block)

    @property
    @pulumi.getter(name="controlPlaneIpBlock")
    def control_plane_ip_block(self) -> Optional[pulumi.Input['VmwareIpBlockArgs']]:
        """
        Static IP addresses for the control plane nodes.
        """
        return pulumi.get(self, "control_plane_ip_block")

    @control_plane_ip_block.setter
    def control_plane_ip_block(self, value: Optional[pulumi.Input['VmwareIpBlockArgs']]):
        pulumi.set(self, "control_plane_ip_block", value)


@pulumi.input_type
class VmwareControlPlaneVsphereConfigArgs:
    def __init__(__self__, *,
                 datastore: Optional[pulumi.Input[str]] = None,
                 storage_policy_name: Optional[pulumi.Input[str]] = None):
        """
        Specifies control plane node config.
        :param pulumi.Input[str] datastore: The Vsphere datastore used by the control plane Node.
        :param pulumi.Input[str] storage_policy_name: The Vsphere storage policy used by the control plane Node.
        """
        if datastore is not None:
            pulumi.set(__self__, "datastore", datastore)
        if storage_policy_name is not None:
            pulumi.set(__self__, "storage_policy_name", storage_policy_name)

    @property
    @pulumi.getter
    def datastore(self) -> Optional[pulumi.Input[str]]:
        """
        The Vsphere datastore used by the control plane Node.
        """
        return pulumi.get(self, "datastore")

    @datastore.setter
    def datastore(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore", value)

    @property
    @pulumi.getter(name="storagePolicyName")
    def storage_policy_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Vsphere storage policy used by the control plane Node.
        """
        return pulumi.get(self, "storage_policy_name")

    @storage_policy_name.setter
    def storage_policy_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_policy_name", value)


@pulumi.input_type
class VmwareDataplaneV2ConfigArgs:
    def __init__(__self__, *,
                 advanced_networking: Optional[pulumi.Input[bool]] = None,
                 dataplane_v2_enabled: Optional[pulumi.Input[bool]] = None,
                 windows_dataplane_v2_enabled: Optional[pulumi.Input[bool]] = None):
        """
        Contains configurations for Dataplane V2, which is optimized dataplane for Kubernetes networking. For more information, see: https://cloud.google.com/kubernetes-engine/docs/concepts/dataplane-v2
        :param pulumi.Input[bool] advanced_networking: Enable advanced networking which requires dataplane_v2_enabled to be set true.
        :param pulumi.Input[bool] dataplane_v2_enabled: Enables Dataplane V2.
        :param pulumi.Input[bool] windows_dataplane_v2_enabled: Enable Dataplane V2 for clusters with Windows nodes.
        """
        if advanced_networking is not None:
            pulumi.set(__self__, "advanced_networking", advanced_networking)
        if dataplane_v2_enabled is not None:
            pulumi.set(__self__, "dataplane_v2_enabled", dataplane_v2_enabled)
        if windows_dataplane_v2_enabled is not None:
            pulumi.set(__self__, "windows_dataplane_v2_enabled", windows_dataplane_v2_enabled)

    @property
    @pulumi.getter(name="advancedNetworking")
    def advanced_networking(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable advanced networking which requires dataplane_v2_enabled to be set true.
        """
        return pulumi.get(self, "advanced_networking")

    @advanced_networking.setter
    def advanced_networking(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "advanced_networking", value)

    @property
    @pulumi.getter(name="dataplaneV2Enabled")
    def dataplane_v2_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables Dataplane V2.
        """
        return pulumi.get(self, "dataplane_v2_enabled")

    @dataplane_v2_enabled.setter
    def dataplane_v2_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dataplane_v2_enabled", value)

    @property
    @pulumi.getter(name="windowsDataplaneV2Enabled")
    def windows_dataplane_v2_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable Dataplane V2 for clusters with Windows nodes.
        """
        return pulumi.get(self, "windows_dataplane_v2_enabled")

    @windows_dataplane_v2_enabled.setter
    def windows_dataplane_v2_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "windows_dataplane_v2_enabled", value)


@pulumi.input_type
class VmwareDhcpIpConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        Represents the network configuration required for the VMware user clusters with DHCP IP configurations.
        :param pulumi.Input[bool] enabled: enabled is a flag to mark if DHCP IP allocation is used for VMware user clusters.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        enabled is a flag to mark if DHCP IP allocation is used for VMware user clusters.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class VmwareF5BigIpConfigArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 partition: Optional[pulumi.Input[str]] = None,
                 snat_pool: Optional[pulumi.Input[str]] = None):
        """
        Represents configuration parameters for an F5 BIG-IP load balancer.
        :param pulumi.Input[str] address: The load balancer's IP address.
        :param pulumi.Input[str] partition: The preexisting partition to be used by the load balancer. This partition is usually created for the admin cluster for example: 'my-f5-admin-partition'.
        :param pulumi.Input[str] snat_pool: The pool name. Only necessary, if using SNAT.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if snat_pool is not None:
            pulumi.set(__self__, "snat_pool", snat_pool)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The load balancer's IP address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def partition(self) -> Optional[pulumi.Input[str]]:
        """
        The preexisting partition to be used by the load balancer. This partition is usually created for the admin cluster for example: 'my-f5-admin-partition'.
        """
        return pulumi.get(self, "partition")

    @partition.setter
    def partition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "partition", value)

    @property
    @pulumi.getter(name="snatPool")
    def snat_pool(self) -> Optional[pulumi.Input[str]]:
        """
        The pool name. Only necessary, if using SNAT.
        """
        return pulumi.get(self, "snat_pool")

    @snat_pool.setter
    def snat_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snat_pool", value)


@pulumi.input_type
class VmwareHostConfigArgs:
    def __init__(__self__, *,
                 dns_search_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ntp_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Represents the common parameters for all the hosts irrespective of their IP address.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_search_domains: DNS search domains.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: DNS servers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ntp_servers: NTP servers.
        """
        if dns_search_domains is not None:
            pulumi.set(__self__, "dns_search_domains", dns_search_domains)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if ntp_servers is not None:
            pulumi.set(__self__, "ntp_servers", ntp_servers)

    @property
    @pulumi.getter(name="dnsSearchDomains")
    def dns_search_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        DNS search domains.
        """
        return pulumi.get(self, "dns_search_domains")

    @dns_search_domains.setter
    def dns_search_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_search_domains", value)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        DNS servers.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_servers", value)

    @property
    @pulumi.getter(name="ntpServers")
    def ntp_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        NTP servers.
        """
        return pulumi.get(self, "ntp_servers")

    @ntp_servers.setter
    def ntp_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ntp_servers", value)


@pulumi.input_type
class VmwareHostIpArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None):
        """
        Represents VMware user cluster node's network configuration.
        :param pulumi.Input[str] hostname: Hostname of the machine. VM's name will be used if this field is empty.
        :param pulumi.Input[str] ip: IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname of the machine. VM's name will be used if this field is empty.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)


@pulumi.input_type
class VmwareIpBlockArgs:
    def __init__(__self__, *,
                 gateway: Optional[pulumi.Input[str]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['VmwareHostIpArgs']]]] = None,
                 netmask: Optional[pulumi.Input[str]] = None):
        """
        Represents a collection of IP addresses to assign to nodes.
        :param pulumi.Input[str] gateway: The network gateway used by the VMware user cluster.
        :param pulumi.Input[Sequence[pulumi.Input['VmwareHostIpArgs']]] ips: The node's network configurations used by the VMware user cluster.
        :param pulumi.Input[str] netmask: The netmask used by the VMware user cluster.
        """
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[str]]:
        """
        The network gateway used by the VMware user cluster.
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmwareHostIpArgs']]]]:
        """
        The node's network configurations used by the VMware user cluster.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmwareHostIpArgs']]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter
    def netmask(self) -> Optional[pulumi.Input[str]]:
        """
        The netmask used by the VMware user cluster.
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "netmask", value)


@pulumi.input_type
class VmwareLoadBalancerConfigArgs:
    def __init__(__self__, *,
                 f5_config: Optional[pulumi.Input['VmwareF5BigIpConfigArgs']] = None,
                 manual_lb_config: Optional[pulumi.Input['VmwareManualLbConfigArgs']] = None,
                 metal_lb_config: Optional[pulumi.Input['VmwareMetalLbConfigArgs']] = None,
                 vip_config: Optional[pulumi.Input['VmwareVipConfigArgs']] = None):
        """
        Specifies the locad balancer config for the VMware user cluster.
        :param pulumi.Input['VmwareF5BigIpConfigArgs'] f5_config: Configuration for F5 Big IP typed load balancers.
        :param pulumi.Input['VmwareManualLbConfigArgs'] manual_lb_config: Manually configured load balancers.
        :param pulumi.Input['VmwareMetalLbConfigArgs'] metal_lb_config: Configuration for MetalLB typed load balancers.
        :param pulumi.Input['VmwareVipConfigArgs'] vip_config: The VIPs used by the load balancer.
        """
        if f5_config is not None:
            pulumi.set(__self__, "f5_config", f5_config)
        if manual_lb_config is not None:
            pulumi.set(__self__, "manual_lb_config", manual_lb_config)
        if metal_lb_config is not None:
            pulumi.set(__self__, "metal_lb_config", metal_lb_config)
        if vip_config is not None:
            pulumi.set(__self__, "vip_config", vip_config)

    @property
    @pulumi.getter(name="f5Config")
    def f5_config(self) -> Optional[pulumi.Input['VmwareF5BigIpConfigArgs']]:
        """
        Configuration for F5 Big IP typed load balancers.
        """
        return pulumi.get(self, "f5_config")

    @f5_config.setter
    def f5_config(self, value: Optional[pulumi.Input['VmwareF5BigIpConfigArgs']]):
        pulumi.set(self, "f5_config", value)

    @property
    @pulumi.getter(name="manualLbConfig")
    def manual_lb_config(self) -> Optional[pulumi.Input['VmwareManualLbConfigArgs']]:
        """
        Manually configured load balancers.
        """
        return pulumi.get(self, "manual_lb_config")

    @manual_lb_config.setter
    def manual_lb_config(self, value: Optional[pulumi.Input['VmwareManualLbConfigArgs']]):
        pulumi.set(self, "manual_lb_config", value)

    @property
    @pulumi.getter(name="metalLbConfig")
    def metal_lb_config(self) -> Optional[pulumi.Input['VmwareMetalLbConfigArgs']]:
        """
        Configuration for MetalLB typed load balancers.
        """
        return pulumi.get(self, "metal_lb_config")

    @metal_lb_config.setter
    def metal_lb_config(self, value: Optional[pulumi.Input['VmwareMetalLbConfigArgs']]):
        pulumi.set(self, "metal_lb_config", value)

    @property
    @pulumi.getter(name="vipConfig")
    def vip_config(self) -> Optional[pulumi.Input['VmwareVipConfigArgs']]:
        """
        The VIPs used by the load balancer.
        """
        return pulumi.get(self, "vip_config")

    @vip_config.setter
    def vip_config(self, value: Optional[pulumi.Input['VmwareVipConfigArgs']]):
        pulumi.set(self, "vip_config", value)


@pulumi.input_type
class VmwareManualLbConfigArgs:
    def __init__(__self__, *,
                 control_plane_node_port: Optional[pulumi.Input[int]] = None,
                 ingress_http_node_port: Optional[pulumi.Input[int]] = None,
                 ingress_https_node_port: Optional[pulumi.Input[int]] = None,
                 konnectivity_server_node_port: Optional[pulumi.Input[int]] = None):
        """
        Represents configuration parameters for an already existing manual load balancer. Given the nature of manual load balancers it is expected that said load balancer will be fully managed by users. IMPORTANT: Please note that the Anthos On-Prem API will not generate or update ManualLB configurations it can only bind a pre-existing configuration to a new VMware user cluster.
        :param pulumi.Input[int] control_plane_node_port: NodePort for control plane service. The Kubernetes API server in the admin cluster is implemented as a Service of type NodePort (ex. 30968).
        :param pulumi.Input[int] ingress_http_node_port: NodePort for ingress service's http. The ingress service in the admin cluster is implemented as a Service of type NodePort (ex. 32527).
        :param pulumi.Input[int] ingress_https_node_port: NodePort for ingress service's https. The ingress service in the admin cluster is implemented as a Service of type NodePort (ex. 30139).
        :param pulumi.Input[int] konnectivity_server_node_port: NodePort for konnectivity server service running as a sidecar in each kube-apiserver pod (ex. 30564).
        """
        if control_plane_node_port is not None:
            pulumi.set(__self__, "control_plane_node_port", control_plane_node_port)
        if ingress_http_node_port is not None:
            pulumi.set(__self__, "ingress_http_node_port", ingress_http_node_port)
        if ingress_https_node_port is not None:
            pulumi.set(__self__, "ingress_https_node_port", ingress_https_node_port)
        if konnectivity_server_node_port is not None:
            pulumi.set(__self__, "konnectivity_server_node_port", konnectivity_server_node_port)

    @property
    @pulumi.getter(name="controlPlaneNodePort")
    def control_plane_node_port(self) -> Optional[pulumi.Input[int]]:
        """
        NodePort for control plane service. The Kubernetes API server in the admin cluster is implemented as a Service of type NodePort (ex. 30968).
        """
        return pulumi.get(self, "control_plane_node_port")

    @control_plane_node_port.setter
    def control_plane_node_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "control_plane_node_port", value)

    @property
    @pulumi.getter(name="ingressHttpNodePort")
    def ingress_http_node_port(self) -> Optional[pulumi.Input[int]]:
        """
        NodePort for ingress service's http. The ingress service in the admin cluster is implemented as a Service of type NodePort (ex. 32527).
        """
        return pulumi.get(self, "ingress_http_node_port")

    @ingress_http_node_port.setter
    def ingress_http_node_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ingress_http_node_port", value)

    @property
    @pulumi.getter(name="ingressHttpsNodePort")
    def ingress_https_node_port(self) -> Optional[pulumi.Input[int]]:
        """
        NodePort for ingress service's https. The ingress service in the admin cluster is implemented as a Service of type NodePort (ex. 30139).
        """
        return pulumi.get(self, "ingress_https_node_port")

    @ingress_https_node_port.setter
    def ingress_https_node_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ingress_https_node_port", value)

    @property
    @pulumi.getter(name="konnectivityServerNodePort")
    def konnectivity_server_node_port(self) -> Optional[pulumi.Input[int]]:
        """
        NodePort for konnectivity server service running as a sidecar in each kube-apiserver pod (ex. 30564).
        """
        return pulumi.get(self, "konnectivity_server_node_port")

    @konnectivity_server_node_port.setter
    def konnectivity_server_node_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "konnectivity_server_node_port", value)


@pulumi.input_type
class VmwareMetalLbConfigArgs:
    def __init__(__self__, *,
                 address_pools: pulumi.Input[Sequence[pulumi.Input['VmwareAddressPoolArgs']]]):
        """
        Represents configuration parameters for the MetalLB load balancer.
        :param pulumi.Input[Sequence[pulumi.Input['VmwareAddressPoolArgs']]] address_pools: AddressPools is a list of non-overlapping IP pools used by load balancer typed services. All addresses must be routable to load balancer nodes. IngressVIP must be included in the pools.
        """
        pulumi.set(__self__, "address_pools", address_pools)

    @property
    @pulumi.getter(name="addressPools")
    def address_pools(self) -> pulumi.Input[Sequence[pulumi.Input['VmwareAddressPoolArgs']]]:
        """
        AddressPools is a list of non-overlapping IP pools used by load balancer typed services. All addresses must be routable to load balancer nodes. IngressVIP must be included in the pools.
        """
        return pulumi.get(self, "address_pools")

    @address_pools.setter
    def address_pools(self, value: pulumi.Input[Sequence[pulumi.Input['VmwareAddressPoolArgs']]]):
        pulumi.set(self, "address_pools", value)


@pulumi.input_type
class VmwareNetworkConfigArgs:
    def __init__(__self__, *,
                 pod_address_cidr_blocks: pulumi.Input[Sequence[pulumi.Input[str]]],
                 service_address_cidr_blocks: pulumi.Input[Sequence[pulumi.Input[str]]],
                 control_plane_v2_config: Optional[pulumi.Input['VmwareControlPlaneV2ConfigArgs']] = None,
                 dhcp_ip_config: Optional[pulumi.Input['VmwareDhcpIpConfigArgs']] = None,
                 host_config: Optional[pulumi.Input['VmwareHostConfigArgs']] = None,
                 static_ip_config: Optional[pulumi.Input['VmwareStaticIpConfigArgs']] = None,
                 vcenter_network: Optional[pulumi.Input[str]] = None):
        """
        Specifies network config for the VMware user cluster.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pod_address_cidr_blocks: All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. Only a single range is supported. This field cannot be changed after creation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_address_cidr_blocks: All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. Only a single range is supported. This field cannot be changed after creation.
        :param pulumi.Input['VmwareControlPlaneV2ConfigArgs'] control_plane_v2_config: Configuration for control plane V2 mode.
        :param pulumi.Input['VmwareDhcpIpConfigArgs'] dhcp_ip_config: Configuration settings for a DHCP IP configuration.
        :param pulumi.Input['VmwareHostConfigArgs'] host_config: Represents common network settings irrespective of the host's IP address.
        :param pulumi.Input['VmwareStaticIpConfigArgs'] static_ip_config: Configuration settings for a static IP configuration.
        :param pulumi.Input[str] vcenter_network: vcenter_network specifies vCenter network name. Inherited from the admin cluster.
        """
        pulumi.set(__self__, "pod_address_cidr_blocks", pod_address_cidr_blocks)
        pulumi.set(__self__, "service_address_cidr_blocks", service_address_cidr_blocks)
        if control_plane_v2_config is not None:
            pulumi.set(__self__, "control_plane_v2_config", control_plane_v2_config)
        if dhcp_ip_config is not None:
            pulumi.set(__self__, "dhcp_ip_config", dhcp_ip_config)
        if host_config is not None:
            pulumi.set(__self__, "host_config", host_config)
        if static_ip_config is not None:
            pulumi.set(__self__, "static_ip_config", static_ip_config)
        if vcenter_network is not None:
            pulumi.set(__self__, "vcenter_network", vcenter_network)

    @property
    @pulumi.getter(name="podAddressCidrBlocks")
    def pod_address_cidr_blocks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. Only a single range is supported. This field cannot be changed after creation.
        """
        return pulumi.get(self, "pod_address_cidr_blocks")

    @pod_address_cidr_blocks.setter
    def pod_address_cidr_blocks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "pod_address_cidr_blocks", value)

    @property
    @pulumi.getter(name="serviceAddressCidrBlocks")
    def service_address_cidr_blocks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. Only a single range is supported. This field cannot be changed after creation.
        """
        return pulumi.get(self, "service_address_cidr_blocks")

    @service_address_cidr_blocks.setter
    def service_address_cidr_blocks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "service_address_cidr_blocks", value)

    @property
    @pulumi.getter(name="controlPlaneV2Config")
    def control_plane_v2_config(self) -> Optional[pulumi.Input['VmwareControlPlaneV2ConfigArgs']]:
        """
        Configuration for control plane V2 mode.
        """
        return pulumi.get(self, "control_plane_v2_config")

    @control_plane_v2_config.setter
    def control_plane_v2_config(self, value: Optional[pulumi.Input['VmwareControlPlaneV2ConfigArgs']]):
        pulumi.set(self, "control_plane_v2_config", value)

    @property
    @pulumi.getter(name="dhcpIpConfig")
    def dhcp_ip_config(self) -> Optional[pulumi.Input['VmwareDhcpIpConfigArgs']]:
        """
        Configuration settings for a DHCP IP configuration.
        """
        return pulumi.get(self, "dhcp_ip_config")

    @dhcp_ip_config.setter
    def dhcp_ip_config(self, value: Optional[pulumi.Input['VmwareDhcpIpConfigArgs']]):
        pulumi.set(self, "dhcp_ip_config", value)

    @property
    @pulumi.getter(name="hostConfig")
    def host_config(self) -> Optional[pulumi.Input['VmwareHostConfigArgs']]:
        """
        Represents common network settings irrespective of the host's IP address.
        """
        return pulumi.get(self, "host_config")

    @host_config.setter
    def host_config(self, value: Optional[pulumi.Input['VmwareHostConfigArgs']]):
        pulumi.set(self, "host_config", value)

    @property
    @pulumi.getter(name="staticIpConfig")
    def static_ip_config(self) -> Optional[pulumi.Input['VmwareStaticIpConfigArgs']]:
        """
        Configuration settings for a static IP configuration.
        """
        return pulumi.get(self, "static_ip_config")

    @static_ip_config.setter
    def static_ip_config(self, value: Optional[pulumi.Input['VmwareStaticIpConfigArgs']]):
        pulumi.set(self, "static_ip_config", value)

    @property
    @pulumi.getter(name="vcenterNetwork")
    def vcenter_network(self) -> Optional[pulumi.Input[str]]:
        """
        vcenter_network specifies vCenter network name. Inherited from the admin cluster.
        """
        return pulumi.get(self, "vcenter_network")

    @vcenter_network.setter
    def vcenter_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vcenter_network", value)


@pulumi.input_type
class VmwareNodeConfigArgs:
    def __init__(__self__, *,
                 image_type: pulumi.Input[str],
                 boot_disk_size_gb: Optional[pulumi.Input[str]] = None,
                 cpus: Optional[pulumi.Input[str]] = None,
                 enable_load_balancer: Optional[pulumi.Input[bool]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 memory_mb: Optional[pulumi.Input[str]] = None,
                 replicas: Optional[pulumi.Input[str]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['NodeTaintArgs']]]] = None,
                 vsphere_config: Optional[pulumi.Input['VmwareVsphereConfigArgs']] = None):
        """
        Parameters that describe the configuration of all nodes within a given node pool.
        :param pulumi.Input[str] image_type: The OS image to be used for each node in a node pool. Currently `cos`, `ubuntu`, `ubuntu_containerd` and `windows` are supported.
        :param pulumi.Input[str] boot_disk_size_gb: VMware disk size to be used during creation.
        :param pulumi.Input[str] cpus: The number of CPUs for each node in the node pool.
        :param pulumi.Input[bool] enable_load_balancer: Allow node pool traffic to be load balanced. Only works for clusters with MetalLB load balancers.
        :param pulumi.Input[str] image: The OS image name in vCenter, only valid when using Windows.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: The map of Kubernetes labels (key/value pairs) to be applied to each node. These will added in addition to any default label(s) that Kubernetes may apply to the node. In case of conflict in label keys, the applied set may differ depending on the Kubernetes version -- it's best to assume the behavior is undefined and conflicts should be avoided. For more information, including usage and the valid values, see: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        :param pulumi.Input[str] memory_mb: The megabytes of memory for each node in the node pool.
        :param pulumi.Input[str] replicas: The number of nodes in the node pool.
        :param pulumi.Input[Sequence[pulumi.Input['NodeTaintArgs']]] taints: The initial taints assigned to nodes of this node pool.
        :param pulumi.Input['VmwareVsphereConfigArgs'] vsphere_config: Specifies the vSphere config for node pool.
        """
        pulumi.set(__self__, "image_type", image_type)
        if boot_disk_size_gb is not None:
            pulumi.set(__self__, "boot_disk_size_gb", boot_disk_size_gb)
        if cpus is not None:
            pulumi.set(__self__, "cpus", cpus)
        if enable_load_balancer is not None:
            pulumi.set(__self__, "enable_load_balancer", enable_load_balancer)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if memory_mb is not None:
            pulumi.set(__self__, "memory_mb", memory_mb)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if vsphere_config is not None:
            pulumi.set(__self__, "vsphere_config", vsphere_config)

    @property
    @pulumi.getter(name="imageType")
    def image_type(self) -> pulumi.Input[str]:
        """
        The OS image to be used for each node in a node pool. Currently `cos`, `ubuntu`, `ubuntu_containerd` and `windows` are supported.
        """
        return pulumi.get(self, "image_type")

    @image_type.setter
    def image_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_type", value)

    @property
    @pulumi.getter(name="bootDiskSizeGb")
    def boot_disk_size_gb(self) -> Optional[pulumi.Input[str]]:
        """
        VMware disk size to be used during creation.
        """
        return pulumi.get(self, "boot_disk_size_gb")

    @boot_disk_size_gb.setter
    def boot_disk_size_gb(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_disk_size_gb", value)

    @property
    @pulumi.getter
    def cpus(self) -> Optional[pulumi.Input[str]]:
        """
        The number of CPUs for each node in the node pool.
        """
        return pulumi.get(self, "cpus")

    @cpus.setter
    def cpus(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpus", value)

    @property
    @pulumi.getter(name="enableLoadBalancer")
    def enable_load_balancer(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow node pool traffic to be load balanced. Only works for clusters with MetalLB load balancers.
        """
        return pulumi.get(self, "enable_load_balancer")

    @enable_load_balancer.setter
    def enable_load_balancer(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_load_balancer", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        The OS image name in vCenter, only valid when using Windows.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to each node. These will added in addition to any default label(s) that Kubernetes may apply to the node. In case of conflict in label keys, the applied set may differ depending on the Kubernetes version -- it's best to assume the behavior is undefined and conflicts should be avoided. For more information, including usage and the valid values, see: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="memoryMb")
    def memory_mb(self) -> Optional[pulumi.Input[str]]:
        """
        The megabytes of memory for each node in the node pool.
        """
        return pulumi.get(self, "memory_mb")

    @memory_mb.setter
    def memory_mb(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory_mb", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[str]]:
        """
        The number of nodes in the node pool.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NodeTaintArgs']]]]:
        """
        The initial taints assigned to nodes of this node pool.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NodeTaintArgs']]]]):
        pulumi.set(self, "taints", value)

    @property
    @pulumi.getter(name="vsphereConfig")
    def vsphere_config(self) -> Optional[pulumi.Input['VmwareVsphereConfigArgs']]:
        """
        Specifies the vSphere config for node pool.
        """
        return pulumi.get(self, "vsphere_config")

    @vsphere_config.setter
    def vsphere_config(self, value: Optional[pulumi.Input['VmwareVsphereConfigArgs']]):
        pulumi.set(self, "vsphere_config", value)


@pulumi.input_type
class VmwareNodePoolAutoscalingConfigArgs:
    def __init__(__self__, *,
                 max_replicas: Optional[pulumi.Input[int]] = None,
                 min_replicas: Optional[pulumi.Input[int]] = None):
        """
        NodePoolAutoscaling config for the NodePool to allow for the kubernetes to scale NodePool.
        :param pulumi.Input[int] max_replicas: Maximum number of replicas in the NodePool.
        :param pulumi.Input[int] min_replicas: Minimum number of replicas in the NodePool.
        """
        if max_replicas is not None:
            pulumi.set(__self__, "max_replicas", max_replicas)
        if min_replicas is not None:
            pulumi.set(__self__, "min_replicas", min_replicas)

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of replicas in the NodePool.
        """
        return pulumi.get(self, "max_replicas")

    @max_replicas.setter
    def max_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_replicas", value)

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of replicas in the NodePool.
        """
        return pulumi.get(self, "min_replicas")

    @min_replicas.setter
    def min_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_replicas", value)


@pulumi.input_type
class VmwareStaticIpConfigArgs:
    def __init__(__self__, *,
                 ip_blocks: Optional[pulumi.Input[Sequence[pulumi.Input['VmwareIpBlockArgs']]]] = None):
        """
        Represents the network configuration required for the VMware user clusters with Static IP configurations.
        :param pulumi.Input[Sequence[pulumi.Input['VmwareIpBlockArgs']]] ip_blocks: Represents the configuration values for static IP allocation to nodes.
        """
        if ip_blocks is not None:
            pulumi.set(__self__, "ip_blocks", ip_blocks)

    @property
    @pulumi.getter(name="ipBlocks")
    def ip_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmwareIpBlockArgs']]]]:
        """
        Represents the configuration values for static IP allocation to nodes.
        """
        return pulumi.get(self, "ip_blocks")

    @ip_blocks.setter
    def ip_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmwareIpBlockArgs']]]]):
        pulumi.set(self, "ip_blocks", value)


@pulumi.input_type
class VmwareStorageConfigArgs:
    def __init__(__self__, *,
                 vsphere_csi_disabled: Optional[pulumi.Input[bool]] = None):
        """
        Specifies vSphere CSI components deployment config in the VMware user cluster.
        :param pulumi.Input[bool] vsphere_csi_disabled: Whether or not to deploy vSphere CSI components in the VMware user cluster. Enabled by default.
        """
        if vsphere_csi_disabled is not None:
            pulumi.set(__self__, "vsphere_csi_disabled", vsphere_csi_disabled)

    @property
    @pulumi.getter(name="vsphereCsiDisabled")
    def vsphere_csi_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to deploy vSphere CSI components in the VMware user cluster. Enabled by default.
        """
        return pulumi.get(self, "vsphere_csi_disabled")

    @vsphere_csi_disabled.setter
    def vsphere_csi_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "vsphere_csi_disabled", value)


@pulumi.input_type
class VmwareVCenterConfigArgs:
    def __init__(__self__, *,
                 ca_cert_data: Optional[pulumi.Input[str]] = None,
                 cluster: Optional[pulumi.Input[str]] = None,
                 datacenter: Optional[pulumi.Input[str]] = None,
                 datastore: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input[str]] = None,
                 resource_pool: Optional[pulumi.Input[str]] = None,
                 storage_policy_name: Optional[pulumi.Input[str]] = None):
        """
        Represents configuration for the VMware VCenter for the user cluster.
        :param pulumi.Input[str] ca_cert_data: Contains the vCenter CA certificate public key for SSL verification.
        :param pulumi.Input[str] cluster: The name of the vCenter cluster for the user cluster.
        :param pulumi.Input[str] datacenter: The name of the vCenter datacenter for the user cluster.
        :param pulumi.Input[str] datastore: The name of the vCenter datastore for the user cluster.
        :param pulumi.Input[str] folder: The name of the vCenter folder for the user cluster.
        :param pulumi.Input[str] resource_pool: The name of the vCenter resource pool for the user cluster.
        :param pulumi.Input[str] storage_policy_name: The name of the vCenter storage policy for the user cluster.
        """
        if ca_cert_data is not None:
            pulumi.set(__self__, "ca_cert_data", ca_cert_data)
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if datastore is not None:
            pulumi.set(__self__, "datastore", datastore)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if resource_pool is not None:
            pulumi.set(__self__, "resource_pool", resource_pool)
        if storage_policy_name is not None:
            pulumi.set(__self__, "storage_policy_name", storage_policy_name)

    @property
    @pulumi.getter(name="caCertData")
    def ca_cert_data(self) -> Optional[pulumi.Input[str]]:
        """
        Contains the vCenter CA certificate public key for SSL verification.
        """
        return pulumi.get(self, "ca_cert_data")

    @ca_cert_data.setter
    def ca_cert_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_cert_data", value)

    @property
    @pulumi.getter
    def cluster(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the vCenter cluster for the user cluster.
        """
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster", value)

    @property
    @pulumi.getter
    def datacenter(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the vCenter datacenter for the user cluster.
        """
        return pulumi.get(self, "datacenter")

    @datacenter.setter
    def datacenter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datacenter", value)

    @property
    @pulumi.getter
    def datastore(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the vCenter datastore for the user cluster.
        """
        return pulumi.get(self, "datastore")

    @datastore.setter
    def datastore(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the vCenter folder for the user cluster.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter(name="resourcePool")
    def resource_pool(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the vCenter resource pool for the user cluster.
        """
        return pulumi.get(self, "resource_pool")

    @resource_pool.setter
    def resource_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_pool", value)

    @property
    @pulumi.getter(name="storagePolicyName")
    def storage_policy_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the vCenter storage policy for the user cluster.
        """
        return pulumi.get(self, "storage_policy_name")

    @storage_policy_name.setter
    def storage_policy_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_policy_name", value)


@pulumi.input_type
class VmwareVipConfigArgs:
    def __init__(__self__, *,
                 control_plane_vip: Optional[pulumi.Input[str]] = None,
                 ingress_vip: Optional[pulumi.Input[str]] = None):
        """
        Specifies the VIP config for the VMware user cluster load balancer.
        :param pulumi.Input[str] control_plane_vip: The VIP which you previously set aside for the Kubernetes API of this cluster.
        :param pulumi.Input[str] ingress_vip: The VIP which you previously set aside for ingress traffic into this cluster.
        """
        if control_plane_vip is not None:
            pulumi.set(__self__, "control_plane_vip", control_plane_vip)
        if ingress_vip is not None:
            pulumi.set(__self__, "ingress_vip", ingress_vip)

    @property
    @pulumi.getter(name="controlPlaneVip")
    def control_plane_vip(self) -> Optional[pulumi.Input[str]]:
        """
        The VIP which you previously set aside for the Kubernetes API of this cluster.
        """
        return pulumi.get(self, "control_plane_vip")

    @control_plane_vip.setter
    def control_plane_vip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "control_plane_vip", value)

    @property
    @pulumi.getter(name="ingressVip")
    def ingress_vip(self) -> Optional[pulumi.Input[str]]:
        """
        The VIP which you previously set aside for ingress traffic into this cluster.
        """
        return pulumi.get(self, "ingress_vip")

    @ingress_vip.setter
    def ingress_vip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ingress_vip", value)


@pulumi.input_type
class VmwareVsphereConfigArgs:
    def __init__(__self__, *,
                 datastore: Optional[pulumi.Input[str]] = None,
                 host_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['VmwareVsphereTagArgs']]]] = None):
        """
        VmwareVsphereConfig represents configuration for the VMware VCenter for node pool.
        :param pulumi.Input[str] datastore: The name of the vCenter datastore. Inherited from the user cluster.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] host_groups: Vsphere host groups to apply to all VMs in the node pool
        :param pulumi.Input[Sequence[pulumi.Input['VmwareVsphereTagArgs']]] tags: Tags to apply to VMs.
        """
        if datastore is not None:
            pulumi.set(__self__, "datastore", datastore)
        if host_groups is not None:
            pulumi.set(__self__, "host_groups", host_groups)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def datastore(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the vCenter datastore. Inherited from the user cluster.
        """
        return pulumi.get(self, "datastore")

    @datastore.setter
    def datastore(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore", value)

    @property
    @pulumi.getter(name="hostGroups")
    def host_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Vsphere host groups to apply to all VMs in the node pool
        """
        return pulumi.get(self, "host_groups")

    @host_groups.setter
    def host_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "host_groups", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmwareVsphereTagArgs']]]]:
        """
        Tags to apply to VMs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmwareVsphereTagArgs']]]]):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class VmwareVsphereTagArgs:
    def __init__(__self__, *,
                 category: Optional[pulumi.Input[str]] = None,
                 tag: Optional[pulumi.Input[str]] = None):
        """
        VmwareVsphereTag describes a vSphere tag to be placed on VMs in the node pool. For more information, see https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.vcenterhost.doc/GUID-E8E854DD-AA97-4E0C-8419-CE84F93C4058.html
        :param pulumi.Input[str] category: The Vsphere tag category.
        :param pulumi.Input[str] tag: The Vsphere tag name.
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[str]]:
        """
        The Vsphere tag category.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Vsphere tag name.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)


