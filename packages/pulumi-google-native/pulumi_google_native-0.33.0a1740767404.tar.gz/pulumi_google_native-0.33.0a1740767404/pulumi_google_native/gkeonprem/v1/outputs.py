# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AuthorizationResponse',
    'BareMetalAdminApiServerArgumentResponse',
    'BareMetalAdminClusterOperationsConfigResponse',
    'BareMetalAdminControlPlaneConfigResponse',
    'BareMetalAdminControlPlaneNodePoolConfigResponse',
    'BareMetalAdminDrainedMachineResponse',
    'BareMetalAdminDrainingMachineResponse',
    'BareMetalAdminIslandModeCidrConfigResponse',
    'BareMetalAdminLoadBalancerConfigResponse',
    'BareMetalAdminMachineDrainStatusResponse',
    'BareMetalAdminMaintenanceConfigResponse',
    'BareMetalAdminMaintenanceStatusResponse',
    'BareMetalAdminManualLbConfigResponse',
    'BareMetalAdminNetworkConfigResponse',
    'BareMetalAdminNodeAccessConfigResponse',
    'BareMetalAdminOsEnvironmentConfigResponse',
    'BareMetalAdminPortConfigResponse',
    'BareMetalAdminProxyConfigResponse',
    'BareMetalAdminSecurityConfigResponse',
    'BareMetalAdminStorageConfigResponse',
    'BareMetalAdminVipConfigResponse',
    'BareMetalAdminWorkloadNodeConfigResponse',
    'BareMetalApiServerArgumentResponse',
    'BareMetalBgpLbConfigResponse',
    'BareMetalBgpPeerConfigResponse',
    'BareMetalClusterOperationsConfigResponse',
    'BareMetalClusterUpgradePolicyResponse',
    'BareMetalControlPlaneConfigResponse',
    'BareMetalControlPlaneNodePoolConfigResponse',
    'BareMetalDrainedMachineResponse',
    'BareMetalDrainingMachineResponse',
    'BareMetalIslandModeCidrConfigResponse',
    'BareMetalKubeletConfigResponse',
    'BareMetalLoadBalancerAddressPoolResponse',
    'BareMetalLoadBalancerConfigResponse',
    'BareMetalLoadBalancerNodePoolConfigResponse',
    'BareMetalLvpConfigResponse',
    'BareMetalLvpShareConfigResponse',
    'BareMetalMachineDrainStatusResponse',
    'BareMetalMaintenanceConfigResponse',
    'BareMetalMaintenanceStatusResponse',
    'BareMetalManualLbConfigResponse',
    'BareMetalMetalLbConfigResponse',
    'BareMetalMultipleNetworkInterfacesConfigResponse',
    'BareMetalNetworkConfigResponse',
    'BareMetalNodeAccessConfigResponse',
    'BareMetalNodeConfigResponse',
    'BareMetalNodePoolConfigResponse',
    'BareMetalNodePoolUpgradePolicyResponse',
    'BareMetalOsEnvironmentConfigResponse',
    'BareMetalParallelUpgradeConfigResponse',
    'BareMetalPortConfigResponse',
    'BareMetalProxyConfigResponse',
    'BareMetalSecurityConfigResponse',
    'BareMetalSrIovConfigResponse',
    'BareMetalStorageConfigResponse',
    'BareMetalVipConfigResponse',
    'BareMetalWorkloadNodeConfigResponse',
    'BinaryAuthorizationResponse',
    'BindingResponse',
    'ClusterUserResponse',
    'ExprResponse',
    'FleetResponse',
    'NodeTaintResponse',
    'ResourceConditionResponse',
    'ResourceStatusResponse',
    'ValidationCheckResponse',
    'ValidationCheckResultResponse',
    'ValidationCheckStatusResponse',
    'VmwareAAGConfigResponse',
    'VmwareAddressPoolResponse',
    'VmwareAutoRepairConfigResponse',
    'VmwareAutoResizeConfigResponse',
    'VmwareClusterUpgradePolicyResponse',
    'VmwareControlPlaneNodeConfigResponse',
    'VmwareControlPlaneV2ConfigResponse',
    'VmwareControlPlaneVsphereConfigResponse',
    'VmwareDataplaneV2ConfigResponse',
    'VmwareDhcpIpConfigResponse',
    'VmwareF5BigIpConfigResponse',
    'VmwareHostConfigResponse',
    'VmwareHostIpResponse',
    'VmwareIpBlockResponse',
    'VmwareLoadBalancerConfigResponse',
    'VmwareManualLbConfigResponse',
    'VmwareMetalLbConfigResponse',
    'VmwareNetworkConfigResponse',
    'VmwareNodeConfigResponse',
    'VmwareNodePoolAutoscalingConfigResponse',
    'VmwareSeesawConfigResponse',
    'VmwareStaticIpConfigResponse',
    'VmwareStorageConfigResponse',
    'VmwareVCenterConfigResponse',
    'VmwareVipConfigResponse',
    'VmwareVsphereConfigResponse',
    'VmwareVsphereTagResponse',
]

@pulumi.output_type
class AuthorizationResponse(dict):
    """
    Authorization defines the On-Prem cluster authorization configuration to bootstrap onto the admin cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUsers":
            suggest = "admin_users"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthorizationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthorizationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthorizationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_users: Sequence['outputs.ClusterUserResponse']):
        """
        Authorization defines the On-Prem cluster authorization configuration to bootstrap onto the admin cluster.
        :param Sequence['ClusterUserResponse'] admin_users: For VMware and bare metal user clusters, users will be granted the cluster-admin role on the cluster, which provides full administrative access to the cluster. For bare metal admin clusters, users will be granted the cluster-view role, which limits users to read-only access.
        """
        pulumi.set(__self__, "admin_users", admin_users)

    @property
    @pulumi.getter(name="adminUsers")
    def admin_users(self) -> Sequence['outputs.ClusterUserResponse']:
        """
        For VMware and bare metal user clusters, users will be granted the cluster-admin role on the cluster, which provides full administrative access to the cluster. For bare metal admin clusters, users will be granted the cluster-view role, which limits users to read-only access.
        """
        return pulumi.get(self, "admin_users")


@pulumi.output_type
class BareMetalAdminApiServerArgumentResponse(dict):
    """
    BareMetalAdminApiServerArgument represents an arg name->value pair. Only a subset of customized flags are supported. Please refer to the API server documentation below to know the exact format: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
    """
    def __init__(__self__, *,
                 argument: str,
                 value: str):
        """
        BareMetalAdminApiServerArgument represents an arg name->value pair. Only a subset of customized flags are supported. Please refer to the API server documentation below to know the exact format: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
        :param str argument: The argument name as it appears on the API Server command line please make sure to remove the leading dashes.
        :param str value: The value of the arg as it will be passed to the API Server command line.
        """
        pulumi.set(__self__, "argument", argument)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def argument(self) -> str:
        """
        The argument name as it appears on the API Server command line please make sure to remove the leading dashes.
        """
        return pulumi.get(self, "argument")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the arg as it will be passed to the API Server command line.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BareMetalAdminClusterOperationsConfigResponse(dict):
    """
    BareMetalAdminClusterOperationsConfig specifies the admin cluster's observability infrastructure.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableApplicationLogs":
            suggest = "enable_application_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterOperationsConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterOperationsConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterOperationsConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_application_logs: bool):
        """
        BareMetalAdminClusterOperationsConfig specifies the admin cluster's observability infrastructure.
        :param bool enable_application_logs: Whether collection of application logs/metrics should be enabled (in addition to system logs/metrics).
        """
        pulumi.set(__self__, "enable_application_logs", enable_application_logs)

    @property
    @pulumi.getter(name="enableApplicationLogs")
    def enable_application_logs(self) -> bool:
        """
        Whether collection of application logs/metrics should be enabled (in addition to system logs/metrics).
        """
        return pulumi.get(self, "enable_application_logs")


@pulumi.output_type
class BareMetalAdminControlPlaneConfigResponse(dict):
    """
    BareMetalAdminControlPlaneConfig specifies the control plane configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiServerArgs":
            suggest = "api_server_args"
        elif key == "controlPlaneNodePoolConfig":
            suggest = "control_plane_node_pool_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminControlPlaneConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminControlPlaneConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminControlPlaneConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_server_args: Sequence['outputs.BareMetalAdminApiServerArgumentResponse'],
                 control_plane_node_pool_config: 'outputs.BareMetalAdminControlPlaneNodePoolConfigResponse'):
        """
        BareMetalAdminControlPlaneConfig specifies the control plane configuration.
        :param Sequence['BareMetalAdminApiServerArgumentResponse'] api_server_args: Customizes the default API server args. Only a subset of customized flags are supported. Please refer to the API server documentation below to know the exact format: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
        :param 'BareMetalAdminControlPlaneNodePoolConfigResponse' control_plane_node_pool_config: Configures the node pool running the control plane. If specified the corresponding NodePool will be created for the cluster's control plane. The NodePool will have the same name and namespace as the cluster.
        """
        pulumi.set(__self__, "api_server_args", api_server_args)
        pulumi.set(__self__, "control_plane_node_pool_config", control_plane_node_pool_config)

    @property
    @pulumi.getter(name="apiServerArgs")
    def api_server_args(self) -> Sequence['outputs.BareMetalAdminApiServerArgumentResponse']:
        """
        Customizes the default API server args. Only a subset of customized flags are supported. Please refer to the API server documentation below to know the exact format: https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
        """
        return pulumi.get(self, "api_server_args")

    @property
    @pulumi.getter(name="controlPlaneNodePoolConfig")
    def control_plane_node_pool_config(self) -> 'outputs.BareMetalAdminControlPlaneNodePoolConfigResponse':
        """
        Configures the node pool running the control plane. If specified the corresponding NodePool will be created for the cluster's control plane. The NodePool will have the same name and namespace as the cluster.
        """
        return pulumi.get(self, "control_plane_node_pool_config")


@pulumi.output_type
class BareMetalAdminControlPlaneNodePoolConfigResponse(dict):
    """
    BareMetalAdminControlPlaneNodePoolConfig specifies the control plane node pool configuration. We have a control plane specific node pool config so that we can flexible about supporting control plane specific fields in the future.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodePoolConfig":
            suggest = "node_pool_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminControlPlaneNodePoolConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminControlPlaneNodePoolConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminControlPlaneNodePoolConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_pool_config: 'outputs.BareMetalNodePoolConfigResponse'):
        """
        BareMetalAdminControlPlaneNodePoolConfig specifies the control plane node pool configuration. We have a control plane specific node pool config so that we can flexible about supporting control plane specific fields in the future.
        :param 'BareMetalNodePoolConfigResponse' node_pool_config: The generic configuration for a node pool running the control plane.
        """
        pulumi.set(__self__, "node_pool_config", node_pool_config)

    @property
    @pulumi.getter(name="nodePoolConfig")
    def node_pool_config(self) -> 'outputs.BareMetalNodePoolConfigResponse':
        """
        The generic configuration for a node pool running the control plane.
        """
        return pulumi.get(self, "node_pool_config")


@pulumi.output_type
class BareMetalAdminDrainedMachineResponse(dict):
    """
    BareMetalAdminDrainedMachine represents the machines that are drained.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeIp":
            suggest = "node_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminDrainedMachineResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminDrainedMachineResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminDrainedMachineResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_ip: str):
        """
        BareMetalAdminDrainedMachine represents the machines that are drained.
        :param str node_ip: Drained machine IP address.
        """
        pulumi.set(__self__, "node_ip", node_ip)

    @property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> str:
        """
        Drained machine IP address.
        """
        return pulumi.get(self, "node_ip")


@pulumi.output_type
class BareMetalAdminDrainingMachineResponse(dict):
    """
    BareMetalAdminDrainingMachine represents the machines that are currently draining.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeIp":
            suggest = "node_ip"
        elif key == "podCount":
            suggest = "pod_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminDrainingMachineResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminDrainingMachineResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminDrainingMachineResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_ip: str,
                 pod_count: int):
        """
        BareMetalAdminDrainingMachine represents the machines that are currently draining.
        :param str node_ip: Draining machine IP address.
        :param int pod_count: The count of pods yet to drain.
        """
        pulumi.set(__self__, "node_ip", node_ip)
        pulumi.set(__self__, "pod_count", pod_count)

    @property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> str:
        """
        Draining machine IP address.
        """
        return pulumi.get(self, "node_ip")

    @property
    @pulumi.getter(name="podCount")
    def pod_count(self) -> int:
        """
        The count of pods yet to drain.
        """
        return pulumi.get(self, "pod_count")


@pulumi.output_type
class BareMetalAdminIslandModeCidrConfigResponse(dict):
    """
    BareMetalAdminIslandModeCidrConfig specifies the cluster CIDR configuration while running in island mode.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podAddressCidrBlocks":
            suggest = "pod_address_cidr_blocks"
        elif key == "serviceAddressCidrBlocks":
            suggest = "service_address_cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminIslandModeCidrConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminIslandModeCidrConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminIslandModeCidrConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_address_cidr_blocks: Sequence[str],
                 service_address_cidr_blocks: Sequence[str]):
        """
        BareMetalAdminIslandModeCidrConfig specifies the cluster CIDR configuration while running in island mode.
        :param Sequence[str] pod_address_cidr_blocks: All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        :param Sequence[str] service_address_cidr_blocks: All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        pulumi.set(__self__, "pod_address_cidr_blocks", pod_address_cidr_blocks)
        pulumi.set(__self__, "service_address_cidr_blocks", service_address_cidr_blocks)

    @property
    @pulumi.getter(name="podAddressCidrBlocks")
    def pod_address_cidr_blocks(self) -> Sequence[str]:
        """
        All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        return pulumi.get(self, "pod_address_cidr_blocks")

    @property
    @pulumi.getter(name="serviceAddressCidrBlocks")
    def service_address_cidr_blocks(self) -> Sequence[str]:
        """
        All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        return pulumi.get(self, "service_address_cidr_blocks")


@pulumi.output_type
class BareMetalAdminLoadBalancerConfigResponse(dict):
    """
    BareMetalAdminLoadBalancerConfig specifies the load balancer configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "manualLbConfig":
            suggest = "manual_lb_config"
        elif key == "portConfig":
            suggest = "port_config"
        elif key == "vipConfig":
            suggest = "vip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminLoadBalancerConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminLoadBalancerConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminLoadBalancerConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 manual_lb_config: 'outputs.BareMetalAdminManualLbConfigResponse',
                 port_config: 'outputs.BareMetalAdminPortConfigResponse',
                 vip_config: 'outputs.BareMetalAdminVipConfigResponse'):
        """
        BareMetalAdminLoadBalancerConfig specifies the load balancer configuration.
        :param 'BareMetalAdminManualLbConfigResponse' manual_lb_config: Manually configured load balancers.
        :param 'BareMetalAdminPortConfigResponse' port_config: Configures the ports that the load balancer will listen on.
        :param 'BareMetalAdminVipConfigResponse' vip_config: The VIPs used by the load balancer.
        """
        pulumi.set(__self__, "manual_lb_config", manual_lb_config)
        pulumi.set(__self__, "port_config", port_config)
        pulumi.set(__self__, "vip_config", vip_config)

    @property
    @pulumi.getter(name="manualLbConfig")
    def manual_lb_config(self) -> 'outputs.BareMetalAdminManualLbConfigResponse':
        """
        Manually configured load balancers.
        """
        return pulumi.get(self, "manual_lb_config")

    @property
    @pulumi.getter(name="portConfig")
    def port_config(self) -> 'outputs.BareMetalAdminPortConfigResponse':
        """
        Configures the ports that the load balancer will listen on.
        """
        return pulumi.get(self, "port_config")

    @property
    @pulumi.getter(name="vipConfig")
    def vip_config(self) -> 'outputs.BareMetalAdminVipConfigResponse':
        """
        The VIPs used by the load balancer.
        """
        return pulumi.get(self, "vip_config")


@pulumi.output_type
class BareMetalAdminMachineDrainStatusResponse(dict):
    """
    BareMetalAdminMachineDrainStatus represents the status of bare metal node machines that are undergoing drain operations.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainedMachines":
            suggest = "drained_machines"
        elif key == "drainingMachines":
            suggest = "draining_machines"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminMachineDrainStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminMachineDrainStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminMachineDrainStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drained_machines: Sequence['outputs.BareMetalAdminDrainedMachineResponse'],
                 draining_machines: Sequence['outputs.BareMetalAdminDrainingMachineResponse']):
        """
        BareMetalAdminMachineDrainStatus represents the status of bare metal node machines that are undergoing drain operations.
        :param Sequence['BareMetalAdminDrainedMachineResponse'] drained_machines: The list of drained machines.
        :param Sequence['BareMetalAdminDrainingMachineResponse'] draining_machines: The list of draning machines.
        """
        pulumi.set(__self__, "drained_machines", drained_machines)
        pulumi.set(__self__, "draining_machines", draining_machines)

    @property
    @pulumi.getter(name="drainedMachines")
    def drained_machines(self) -> Sequence['outputs.BareMetalAdminDrainedMachineResponse']:
        """
        The list of drained machines.
        """
        return pulumi.get(self, "drained_machines")

    @property
    @pulumi.getter(name="drainingMachines")
    def draining_machines(self) -> Sequence['outputs.BareMetalAdminDrainingMachineResponse']:
        """
        The list of draning machines.
        """
        return pulumi.get(self, "draining_machines")


@pulumi.output_type
class BareMetalAdminMaintenanceConfigResponse(dict):
    """
    BareMetalAdminMaintenanceConfig specifies configurations to put bare metal Admin cluster CRs nodes in and out of maintenance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maintenanceAddressCidrBlocks":
            suggest = "maintenance_address_cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminMaintenanceConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminMaintenanceConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminMaintenanceConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maintenance_address_cidr_blocks: Sequence[str]):
        """
        BareMetalAdminMaintenanceConfig specifies configurations to put bare metal Admin cluster CRs nodes in and out of maintenance.
        :param Sequence[str] maintenance_address_cidr_blocks: All IPv4 address from these ranges will be placed into maintenance mode. Nodes in maintenance mode will be cordoned and drained. When both of these are true, the "baremetal.cluster.gke.io/maintenance" annotation will be set on the node resource.
        """
        pulumi.set(__self__, "maintenance_address_cidr_blocks", maintenance_address_cidr_blocks)

    @property
    @pulumi.getter(name="maintenanceAddressCidrBlocks")
    def maintenance_address_cidr_blocks(self) -> Sequence[str]:
        """
        All IPv4 address from these ranges will be placed into maintenance mode. Nodes in maintenance mode will be cordoned and drained. When both of these are true, the "baremetal.cluster.gke.io/maintenance" annotation will be set on the node resource.
        """
        return pulumi.get(self, "maintenance_address_cidr_blocks")


@pulumi.output_type
class BareMetalAdminMaintenanceStatusResponse(dict):
    """
    BareMetalAdminMaintenanceStatus represents the maintenance status for bare metal Admin cluster CR's nodes.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "machineDrainStatus":
            suggest = "machine_drain_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminMaintenanceStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminMaintenanceStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminMaintenanceStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 machine_drain_status: 'outputs.BareMetalAdminMachineDrainStatusResponse'):
        """
        BareMetalAdminMaintenanceStatus represents the maintenance status for bare metal Admin cluster CR's nodes.
        :param 'BareMetalAdminMachineDrainStatusResponse' machine_drain_status: Represents the status of draining and drained machine nodes. This is used to show the progress of cluster upgrade.
        """
        pulumi.set(__self__, "machine_drain_status", machine_drain_status)

    @property
    @pulumi.getter(name="machineDrainStatus")
    def machine_drain_status(self) -> 'outputs.BareMetalAdminMachineDrainStatusResponse':
        """
        Represents the status of draining and drained machine nodes. This is used to show the progress of cluster upgrade.
        """
        return pulumi.get(self, "machine_drain_status")


@pulumi.output_type
class BareMetalAdminManualLbConfigResponse(dict):
    """
    BareMetalAdminManualLbConfig represents configuration parameters for a manual load balancer.
    """
    def __init__(__self__, *,
                 enabled: bool):
        """
        BareMetalAdminManualLbConfig represents configuration parameters for a manual load balancer.
        :param bool enabled: Whether manual load balancing is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether manual load balancing is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class BareMetalAdminNetworkConfigResponse(dict):
    """
    BareMetalAdminNetworkConfig specifies the cluster network configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "islandModeCidr":
            suggest = "island_mode_cidr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminNetworkConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminNetworkConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminNetworkConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 island_mode_cidr: 'outputs.BareMetalAdminIslandModeCidrConfigResponse'):
        """
        BareMetalAdminNetworkConfig specifies the cluster network configuration.
        :param 'BareMetalAdminIslandModeCidrConfigResponse' island_mode_cidr: Configuration for Island mode CIDR.
        """
        pulumi.set(__self__, "island_mode_cidr", island_mode_cidr)

    @property
    @pulumi.getter(name="islandModeCidr")
    def island_mode_cidr(self) -> 'outputs.BareMetalAdminIslandModeCidrConfigResponse':
        """
        Configuration for Island mode CIDR.
        """
        return pulumi.get(self, "island_mode_cidr")


@pulumi.output_type
class BareMetalAdminNodeAccessConfigResponse(dict):
    """
    Specifies the node access related settings for the bare metal admin cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loginUser":
            suggest = "login_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminNodeAccessConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminNodeAccessConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminNodeAccessConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login_user: str):
        """
        Specifies the node access related settings for the bare metal admin cluster.
        :param str login_user: LoginUser is the user name used to access node machines. It defaults to "root" if not set.
        """
        pulumi.set(__self__, "login_user", login_user)

    @property
    @pulumi.getter(name="loginUser")
    def login_user(self) -> str:
        """
        LoginUser is the user name used to access node machines. It defaults to "root" if not set.
        """
        return pulumi.get(self, "login_user")


@pulumi.output_type
class BareMetalAdminOsEnvironmentConfigResponse(dict):
    """
    Specifies operating system operation settings for cluster provisioning.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "packageRepoExcluded":
            suggest = "package_repo_excluded"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminOsEnvironmentConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminOsEnvironmentConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminOsEnvironmentConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 package_repo_excluded: bool):
        """
        Specifies operating system operation settings for cluster provisioning.
        :param bool package_repo_excluded: Whether the package repo should be added when initializing bare metal machines.
        """
        pulumi.set(__self__, "package_repo_excluded", package_repo_excluded)

    @property
    @pulumi.getter(name="packageRepoExcluded")
    def package_repo_excluded(self) -> bool:
        """
        Whether the package repo should be added when initializing bare metal machines.
        """
        return pulumi.get(self, "package_repo_excluded")


@pulumi.output_type
class BareMetalAdminPortConfigResponse(dict):
    """
    BareMetalAdminPortConfig is the specification of load balancer ports.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneLoadBalancerPort":
            suggest = "control_plane_load_balancer_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminPortConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminPortConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminPortConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_load_balancer_port: int):
        """
        BareMetalAdminPortConfig is the specification of load balancer ports.
        :param int control_plane_load_balancer_port: The port that control plane hosted load balancers will listen on.
        """
        pulumi.set(__self__, "control_plane_load_balancer_port", control_plane_load_balancer_port)

    @property
    @pulumi.getter(name="controlPlaneLoadBalancerPort")
    def control_plane_load_balancer_port(self) -> int:
        """
        The port that control plane hosted load balancers will listen on.
        """
        return pulumi.get(self, "control_plane_load_balancer_port")


@pulumi.output_type
class BareMetalAdminProxyConfigResponse(dict):
    """
    BareMetalAdminProxyConfig specifies the cluster proxy configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noProxy":
            suggest = "no_proxy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminProxyConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminProxyConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminProxyConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_proxy: Sequence[str],
                 uri: str):
        """
        BareMetalAdminProxyConfig specifies the cluster proxy configuration.
        :param Sequence[str] no_proxy: A list of IPs, hostnames, and domains that should skip the proxy. Examples: ["127.0.0.1", "example.com", ".corp", "localhost"].
        :param str uri: Specifies the address of your proxy server. Examples: `http://domain` WARNING: Do not provide credentials in the format `http://(username:password@)domain` these will be rejected by the server.
        """
        pulumi.set(__self__, "no_proxy", no_proxy)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter(name="noProxy")
    def no_proxy(self) -> Sequence[str]:
        """
        A list of IPs, hostnames, and domains that should skip the proxy. Examples: ["127.0.0.1", "example.com", ".corp", "localhost"].
        """
        return pulumi.get(self, "no_proxy")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        Specifies the address of your proxy server. Examples: `http://domain` WARNING: Do not provide credentials in the format `http://(username:password@)domain` these will be rejected by the server.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class BareMetalAdminSecurityConfigResponse(dict):
    """
    Specifies the security related settings for the bare metal admin cluster.
    """
    def __init__(__self__, *,
                 authorization: 'outputs.AuthorizationResponse'):
        """
        Specifies the security related settings for the bare metal admin cluster.
        :param 'AuthorizationResponse' authorization: Configures user access to the admin cluster.
        """
        pulumi.set(__self__, "authorization", authorization)

    @property
    @pulumi.getter
    def authorization(self) -> 'outputs.AuthorizationResponse':
        """
        Configures user access to the admin cluster.
        """
        return pulumi.get(self, "authorization")


@pulumi.output_type
class BareMetalAdminStorageConfigResponse(dict):
    """
    BareMetalAdminStorageConfig specifies the cluster storage configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lvpNodeMountsConfig":
            suggest = "lvp_node_mounts_config"
        elif key == "lvpShareConfig":
            suggest = "lvp_share_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminStorageConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminStorageConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminStorageConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lvp_node_mounts_config: 'outputs.BareMetalLvpConfigResponse',
                 lvp_share_config: 'outputs.BareMetalLvpShareConfigResponse'):
        """
        BareMetalAdminStorageConfig specifies the cluster storage configuration.
        :param 'BareMetalLvpConfigResponse' lvp_node_mounts_config: Specifies the config for local PersistentVolumes backed by mounted node disks. These disks need to be formatted and mounted by the user, which can be done before or after cluster creation.
        :param 'BareMetalLvpShareConfigResponse' lvp_share_config: Specifies the config for local PersistentVolumes backed by subdirectories in a shared filesystem. These subdirectores are automatically created during cluster creation.
        """
        pulumi.set(__self__, "lvp_node_mounts_config", lvp_node_mounts_config)
        pulumi.set(__self__, "lvp_share_config", lvp_share_config)

    @property
    @pulumi.getter(name="lvpNodeMountsConfig")
    def lvp_node_mounts_config(self) -> 'outputs.BareMetalLvpConfigResponse':
        """
        Specifies the config for local PersistentVolumes backed by mounted node disks. These disks need to be formatted and mounted by the user, which can be done before or after cluster creation.
        """
        return pulumi.get(self, "lvp_node_mounts_config")

    @property
    @pulumi.getter(name="lvpShareConfig")
    def lvp_share_config(self) -> 'outputs.BareMetalLvpShareConfigResponse':
        """
        Specifies the config for local PersistentVolumes backed by subdirectories in a shared filesystem. These subdirectores are automatically created during cluster creation.
        """
        return pulumi.get(self, "lvp_share_config")


@pulumi.output_type
class BareMetalAdminVipConfigResponse(dict):
    """
    BareMetalAdminVipConfig for bare metal load balancer configurations.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneVip":
            suggest = "control_plane_vip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminVipConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminVipConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminVipConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_vip: str):
        """
        BareMetalAdminVipConfig for bare metal load balancer configurations.
        :param str control_plane_vip: The VIP which you previously set aside for the Kubernetes API of this bare metal admin cluster.
        """
        pulumi.set(__self__, "control_plane_vip", control_plane_vip)

    @property
    @pulumi.getter(name="controlPlaneVip")
    def control_plane_vip(self) -> str:
        """
        The VIP which you previously set aside for the Kubernetes API of this bare metal admin cluster.
        """
        return pulumi.get(self, "control_plane_vip")


@pulumi.output_type
class BareMetalAdminWorkloadNodeConfigResponse(dict):
    """
    BareMetalAdminWorkloadNodeConfig specifies the workload node configurations.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxPodsPerNode":
            suggest = "max_pods_per_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminWorkloadNodeConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminWorkloadNodeConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminWorkloadNodeConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_pods_per_node: str):
        """
        BareMetalAdminWorkloadNodeConfig specifies the workload node configurations.
        :param str max_pods_per_node: The maximum number of pods a node can run. The size of the CIDR range assigned to the node will be derived from this parameter. By default 110 Pods are created per Node. Upper bound is 250 for both HA and non-HA admin cluster. Lower bound is 64 for non-HA admin cluster and 32 for HA admin cluster.
        """
        pulumi.set(__self__, "max_pods_per_node", max_pods_per_node)

    @property
    @pulumi.getter(name="maxPodsPerNode")
    def max_pods_per_node(self) -> str:
        """
        The maximum number of pods a node can run. The size of the CIDR range assigned to the node will be derived from this parameter. By default 110 Pods are created per Node. Upper bound is 250 for both HA and non-HA admin cluster. Lower bound is 64 for non-HA admin cluster and 32 for HA admin cluster.
        """
        return pulumi.get(self, "max_pods_per_node")


@pulumi.output_type
class BareMetalApiServerArgumentResponse(dict):
    """
    Represents an arg name->value pair. Only a subset of customized flags are supported. For the exact format, refer to the [API server documentation](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/).
    """
    def __init__(__self__, *,
                 argument: str,
                 value: str):
        """
        Represents an arg name->value pair. Only a subset of customized flags are supported. For the exact format, refer to the [API server documentation](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/).
        :param str argument: The argument name as it appears on the API Server command line, make sure to remove the leading dashes.
        :param str value: The value of the arg as it will be passed to the API Server command line.
        """
        pulumi.set(__self__, "argument", argument)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def argument(self) -> str:
        """
        The argument name as it appears on the API Server command line, make sure to remove the leading dashes.
        """
        return pulumi.get(self, "argument")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the arg as it will be passed to the API Server command line.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BareMetalBgpLbConfigResponse(dict):
    """
    BareMetalBgpLbConfig represents configuration parameters for a Border Gateway Protocol (BGP) load balancer.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPools":
            suggest = "address_pools"
        elif key == "bgpPeerConfigs":
            suggest = "bgp_peer_configs"
        elif key == "loadBalancerNodePoolConfig":
            suggest = "load_balancer_node_pool_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalBgpLbConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalBgpLbConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalBgpLbConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_pools: Sequence['outputs.BareMetalLoadBalancerAddressPoolResponse'],
                 asn: str,
                 bgp_peer_configs: Sequence['outputs.BareMetalBgpPeerConfigResponse'],
                 load_balancer_node_pool_config: 'outputs.BareMetalLoadBalancerNodePoolConfigResponse'):
        """
        BareMetalBgpLbConfig represents configuration parameters for a Border Gateway Protocol (BGP) load balancer.
        :param Sequence['BareMetalLoadBalancerAddressPoolResponse'] address_pools: AddressPools is a list of non-overlapping IP pools used by load balancer typed services. All addresses must be routable to load balancer nodes. IngressVIP must be included in the pools.
        :param str asn: BGP autonomous system number (ASN) of the cluster. This field can be updated after cluster creation.
        :param Sequence['BareMetalBgpPeerConfigResponse'] bgp_peer_configs: The list of BGP peers that the cluster will connect to. At least one peer must be configured for each control plane node. Control plane nodes will connect to these peers to advertise the control plane VIP. The Services load balancer also uses these peers by default. This field can be updated after cluster creation.
        :param 'BareMetalLoadBalancerNodePoolConfigResponse' load_balancer_node_pool_config: Specifies the node pool running data plane load balancing. L2 connectivity is required among nodes in this pool. If missing, the control plane node pool is used for data plane load balancing.
        """
        pulumi.set(__self__, "address_pools", address_pools)
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "bgp_peer_configs", bgp_peer_configs)
        pulumi.set(__self__, "load_balancer_node_pool_config", load_balancer_node_pool_config)

    @property
    @pulumi.getter(name="addressPools")
    def address_pools(self) -> Sequence['outputs.BareMetalLoadBalancerAddressPoolResponse']:
        """
        AddressPools is a list of non-overlapping IP pools used by load balancer typed services. All addresses must be routable to load balancer nodes. IngressVIP must be included in the pools.
        """
        return pulumi.get(self, "address_pools")

    @property
    @pulumi.getter
    def asn(self) -> str:
        """
        BGP autonomous system number (ASN) of the cluster. This field can be updated after cluster creation.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="bgpPeerConfigs")
    def bgp_peer_configs(self) -> Sequence['outputs.BareMetalBgpPeerConfigResponse']:
        """
        The list of BGP peers that the cluster will connect to. At least one peer must be configured for each control plane node. Control plane nodes will connect to these peers to advertise the control plane VIP. The Services load balancer also uses these peers by default. This field can be updated after cluster creation.
        """
        return pulumi.get(self, "bgp_peer_configs")

    @property
    @pulumi.getter(name="loadBalancerNodePoolConfig")
    def load_balancer_node_pool_config(self) -> 'outputs.BareMetalLoadBalancerNodePoolConfigResponse':
        """
        Specifies the node pool running data plane load balancing. L2 connectivity is required among nodes in this pool. If missing, the control plane node pool is used for data plane load balancing.
        """
        return pulumi.get(self, "load_balancer_node_pool_config")


@pulumi.output_type
class BareMetalBgpPeerConfigResponse(dict):
    """
    BareMetalBgpPeerConfig represents configuration parameters for a Border Gateway Protocol (BGP) peer.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneNodes":
            suggest = "control_plane_nodes"
        elif key == "ipAddress":
            suggest = "ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalBgpPeerConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalBgpPeerConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalBgpPeerConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asn: str,
                 control_plane_nodes: Sequence[str],
                 ip_address: str):
        """
        BareMetalBgpPeerConfig represents configuration parameters for a Border Gateway Protocol (BGP) peer.
        :param str asn: BGP autonomous system number (ASN) for the network that contains the external peer device.
        :param Sequence[str] control_plane_nodes: The IP address of the control plane node that connects to the external peer. If you don't specify any control plane nodes, all control plane nodes can connect to the external peer. If you specify one or more IP addresses, only the nodes specified participate in peering sessions.
        :param str ip_address: The IP address of the external peer device.
        """
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "control_plane_nodes", control_plane_nodes)
        pulumi.set(__self__, "ip_address", ip_address)

    @property
    @pulumi.getter
    def asn(self) -> str:
        """
        BGP autonomous system number (ASN) for the network that contains the external peer device.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="controlPlaneNodes")
    def control_plane_nodes(self) -> Sequence[str]:
        """
        The IP address of the control plane node that connects to the external peer. If you don't specify any control plane nodes, all control plane nodes can connect to the external peer. If you specify one or more IP addresses, only the nodes specified participate in peering sessions.
        """
        return pulumi.get(self, "control_plane_nodes")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address of the external peer device.
        """
        return pulumi.get(self, "ip_address")


@pulumi.output_type
class BareMetalClusterOperationsConfigResponse(dict):
    """
    Specifies the bare metal user cluster's observability infrastructure.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableApplicationLogs":
            suggest = "enable_application_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterOperationsConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterOperationsConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterOperationsConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_application_logs: bool):
        """
        Specifies the bare metal user cluster's observability infrastructure.
        :param bool enable_application_logs: Whether collection of application logs/metrics should be enabled (in addition to system logs/metrics).
        """
        pulumi.set(__self__, "enable_application_logs", enable_application_logs)

    @property
    @pulumi.getter(name="enableApplicationLogs")
    def enable_application_logs(self) -> bool:
        """
        Whether collection of application logs/metrics should be enabled (in addition to system logs/metrics).
        """
        return pulumi.get(self, "enable_application_logs")


@pulumi.output_type
class BareMetalClusterUpgradePolicyResponse(dict):
    """
    BareMetalClusterUpgradePolicy defines the cluster upgrade policy.
    """
    def __init__(__self__, *,
                 policy: str):
        """
        BareMetalClusterUpgradePolicy defines the cluster upgrade policy.
        :param str policy: Specifies which upgrade policy to use.
        """
        pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter
    def policy(self) -> str:
        """
        Specifies which upgrade policy to use.
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class BareMetalControlPlaneConfigResponse(dict):
    """
    Specifies the control plane configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiServerArgs":
            suggest = "api_server_args"
        elif key == "controlPlaneNodePoolConfig":
            suggest = "control_plane_node_pool_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalControlPlaneConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalControlPlaneConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalControlPlaneConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_server_args: Sequence['outputs.BareMetalApiServerArgumentResponse'],
                 control_plane_node_pool_config: 'outputs.BareMetalControlPlaneNodePoolConfigResponse'):
        """
        Specifies the control plane configuration.
        :param Sequence['BareMetalApiServerArgumentResponse'] api_server_args: Customizes the default API server args. Only a subset of customized flags are supported. For the exact format, refer to the [API server documentation](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/).
        :param 'BareMetalControlPlaneNodePoolConfigResponse' control_plane_node_pool_config: Configures the node pool running the control plane.
        """
        pulumi.set(__self__, "api_server_args", api_server_args)
        pulumi.set(__self__, "control_plane_node_pool_config", control_plane_node_pool_config)

    @property
    @pulumi.getter(name="apiServerArgs")
    def api_server_args(self) -> Sequence['outputs.BareMetalApiServerArgumentResponse']:
        """
        Customizes the default API server args. Only a subset of customized flags are supported. For the exact format, refer to the [API server documentation](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/).
        """
        return pulumi.get(self, "api_server_args")

    @property
    @pulumi.getter(name="controlPlaneNodePoolConfig")
    def control_plane_node_pool_config(self) -> 'outputs.BareMetalControlPlaneNodePoolConfigResponse':
        """
        Configures the node pool running the control plane.
        """
        return pulumi.get(self, "control_plane_node_pool_config")


@pulumi.output_type
class BareMetalControlPlaneNodePoolConfigResponse(dict):
    """
    Specifies the control plane node pool configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodePoolConfig":
            suggest = "node_pool_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalControlPlaneNodePoolConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalControlPlaneNodePoolConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalControlPlaneNodePoolConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_pool_config: 'outputs.BareMetalNodePoolConfigResponse'):
        """
        Specifies the control plane node pool configuration.
        :param 'BareMetalNodePoolConfigResponse' node_pool_config: The generic configuration for a node pool running the control plane.
        """
        pulumi.set(__self__, "node_pool_config", node_pool_config)

    @property
    @pulumi.getter(name="nodePoolConfig")
    def node_pool_config(self) -> 'outputs.BareMetalNodePoolConfigResponse':
        """
        The generic configuration for a node pool running the control plane.
        """
        return pulumi.get(self, "node_pool_config")


@pulumi.output_type
class BareMetalDrainedMachineResponse(dict):
    """
    Represents a machine that is currently drained.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeIp":
            suggest = "node_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalDrainedMachineResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalDrainedMachineResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalDrainedMachineResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_ip: str):
        """
        Represents a machine that is currently drained.
        :param str node_ip: Drained machine IP address.
        """
        pulumi.set(__self__, "node_ip", node_ip)

    @property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> str:
        """
        Drained machine IP address.
        """
        return pulumi.get(self, "node_ip")


@pulumi.output_type
class BareMetalDrainingMachineResponse(dict):
    """
    Represents a machine that is currently draining.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeIp":
            suggest = "node_ip"
        elif key == "podCount":
            suggest = "pod_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalDrainingMachineResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalDrainingMachineResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalDrainingMachineResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_ip: str,
                 pod_count: int):
        """
        Represents a machine that is currently draining.
        :param str node_ip: Draining machine IP address.
        :param int pod_count: The count of pods yet to drain.
        """
        pulumi.set(__self__, "node_ip", node_ip)
        pulumi.set(__self__, "pod_count", pod_count)

    @property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> str:
        """
        Draining machine IP address.
        """
        return pulumi.get(self, "node_ip")

    @property
    @pulumi.getter(name="podCount")
    def pod_count(self) -> int:
        """
        The count of pods yet to drain.
        """
        return pulumi.get(self, "pod_count")


@pulumi.output_type
class BareMetalIslandModeCidrConfigResponse(dict):
    """
    Specifies the cluster CIDR configuration while running in island mode.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podAddressCidrBlocks":
            suggest = "pod_address_cidr_blocks"
        elif key == "serviceAddressCidrBlocks":
            suggest = "service_address_cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalIslandModeCidrConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalIslandModeCidrConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalIslandModeCidrConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_address_cidr_blocks: Sequence[str],
                 service_address_cidr_blocks: Sequence[str]):
        """
        Specifies the cluster CIDR configuration while running in island mode.
        :param Sequence[str] pod_address_cidr_blocks: All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        :param Sequence[str] service_address_cidr_blocks: All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field is mutable after creation starting with version 1.15.
        """
        pulumi.set(__self__, "pod_address_cidr_blocks", pod_address_cidr_blocks)
        pulumi.set(__self__, "service_address_cidr_blocks", service_address_cidr_blocks)

    @property
    @pulumi.getter(name="podAddressCidrBlocks")
    def pod_address_cidr_blocks(self) -> Sequence[str]:
        """
        All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        return pulumi.get(self, "pod_address_cidr_blocks")

    @property
    @pulumi.getter(name="serviceAddressCidrBlocks")
    def service_address_cidr_blocks(self) -> Sequence[str]:
        """
        All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field is mutable after creation starting with version 1.15.
        """
        return pulumi.get(self, "service_address_cidr_blocks")


@pulumi.output_type
class BareMetalKubeletConfigResponse(dict):
    """
    KubeletConfig defines the modifiable kubelet configurations for bare metal machines. Note: this list includes fields supported in GKE (see https://cloud.google.com/kubernetes-engine/docs/how-to/node-system-config#kubelet-options).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "registryBurst":
            suggest = "registry_burst"
        elif key == "registryPullQps":
            suggest = "registry_pull_qps"
        elif key == "serializeImagePullsDisabled":
            suggest = "serialize_image_pulls_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalKubeletConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalKubeletConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalKubeletConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 registry_burst: int,
                 registry_pull_qps: int,
                 serialize_image_pulls_disabled: bool):
        """
        KubeletConfig defines the modifiable kubelet configurations for bare metal machines. Note: this list includes fields supported in GKE (see https://cloud.google.com/kubernetes-engine/docs/how-to/node-system-config#kubelet-options).
        :param int registry_burst: The maximum size of bursty pulls, temporarily allows pulls to burst to this number, while still not exceeding registry_pull_qps. The value must not be a negative number. Updating this field may impact scalability by changing the amount of traffic produced by image pulls. Defaults to 10.
        :param int registry_pull_qps: The limit of registry pulls per second. Setting this value to 0 means no limit. Updating this field may impact scalability by changing the amount of traffic produced by image pulls. Defaults to 5.
        :param bool serialize_image_pulls_disabled: Prevents the Kubelet from pulling multiple images at a time. We recommend *not* changing the default value on nodes that run docker daemon with version < 1.9 or an Another Union File System (Aufs) storage backend. Issue https://github.com/kubernetes/kubernetes/issues/10959 has more details.
        """
        pulumi.set(__self__, "registry_burst", registry_burst)
        pulumi.set(__self__, "registry_pull_qps", registry_pull_qps)
        pulumi.set(__self__, "serialize_image_pulls_disabled", serialize_image_pulls_disabled)

    @property
    @pulumi.getter(name="registryBurst")
    def registry_burst(self) -> int:
        """
        The maximum size of bursty pulls, temporarily allows pulls to burst to this number, while still not exceeding registry_pull_qps. The value must not be a negative number. Updating this field may impact scalability by changing the amount of traffic produced by image pulls. Defaults to 10.
        """
        return pulumi.get(self, "registry_burst")

    @property
    @pulumi.getter(name="registryPullQps")
    def registry_pull_qps(self) -> int:
        """
        The limit of registry pulls per second. Setting this value to 0 means no limit. Updating this field may impact scalability by changing the amount of traffic produced by image pulls. Defaults to 5.
        """
        return pulumi.get(self, "registry_pull_qps")

    @property
    @pulumi.getter(name="serializeImagePullsDisabled")
    def serialize_image_pulls_disabled(self) -> bool:
        """
        Prevents the Kubelet from pulling multiple images at a time. We recommend *not* changing the default value on nodes that run docker daemon with version < 1.9 or an Another Union File System (Aufs) storage backend. Issue https://github.com/kubernetes/kubernetes/issues/10959 has more details.
        """
        return pulumi.get(self, "serialize_image_pulls_disabled")


@pulumi.output_type
class BareMetalLoadBalancerAddressPoolResponse(dict):
    """
    Represents an IP pool used by the load balancer.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avoidBuggyIps":
            suggest = "avoid_buggy_ips"
        elif key == "manualAssign":
            suggest = "manual_assign"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalLoadBalancerAddressPoolResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalLoadBalancerAddressPoolResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalLoadBalancerAddressPoolResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Sequence[str],
                 avoid_buggy_ips: bool,
                 manual_assign: bool,
                 pool: str):
        """
        Represents an IP pool used by the load balancer.
        :param Sequence[str] addresses: The addresses that are part of this pool. Each address must be either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
        :param bool avoid_buggy_ips: If true, avoid using IPs ending in .0 or .255. This avoids buggy consumer devices mistakenly dropping IPv4 traffic for those special IP addresses.
        :param bool manual_assign: If true, prevent IP addresses from being automatically assigned.
        :param str pool: The name of the address pool.
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "avoid_buggy_ips", avoid_buggy_ips)
        pulumi.set(__self__, "manual_assign", manual_assign)
        pulumi.set(__self__, "pool", pool)

    @property
    @pulumi.getter
    def addresses(self) -> Sequence[str]:
        """
        The addresses that are part of this pool. Each address must be either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter(name="avoidBuggyIps")
    def avoid_buggy_ips(self) -> bool:
        """
        If true, avoid using IPs ending in .0 or .255. This avoids buggy consumer devices mistakenly dropping IPv4 traffic for those special IP addresses.
        """
        return pulumi.get(self, "avoid_buggy_ips")

    @property
    @pulumi.getter(name="manualAssign")
    def manual_assign(self) -> bool:
        """
        If true, prevent IP addresses from being automatically assigned.
        """
        return pulumi.get(self, "manual_assign")

    @property
    @pulumi.getter
    def pool(self) -> str:
        """
        The name of the address pool.
        """
        return pulumi.get(self, "pool")


@pulumi.output_type
class BareMetalLoadBalancerConfigResponse(dict):
    """
    Specifies the load balancer configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bgpLbConfig":
            suggest = "bgp_lb_config"
        elif key == "manualLbConfig":
            suggest = "manual_lb_config"
        elif key == "metalLbConfig":
            suggest = "metal_lb_config"
        elif key == "portConfig":
            suggest = "port_config"
        elif key == "vipConfig":
            suggest = "vip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalLoadBalancerConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalLoadBalancerConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalLoadBalancerConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bgp_lb_config: 'outputs.BareMetalBgpLbConfigResponse',
                 manual_lb_config: 'outputs.BareMetalManualLbConfigResponse',
                 metal_lb_config: 'outputs.BareMetalMetalLbConfigResponse',
                 port_config: 'outputs.BareMetalPortConfigResponse',
                 vip_config: 'outputs.BareMetalVipConfigResponse'):
        """
        Specifies the load balancer configuration.
        :param 'BareMetalBgpLbConfigResponse' bgp_lb_config: Configuration for BGP typed load balancers. When set network_config.advanced_networking is automatically set to true.
        :param 'BareMetalManualLbConfigResponse' manual_lb_config: Manually configured load balancers.
        :param 'BareMetalMetalLbConfigResponse' metal_lb_config: Configuration for MetalLB load balancers.
        :param 'BareMetalPortConfigResponse' port_config: Configures the ports that the load balancer will listen on.
        :param 'BareMetalVipConfigResponse' vip_config: The VIPs used by the load balancer.
        """
        pulumi.set(__self__, "bgp_lb_config", bgp_lb_config)
        pulumi.set(__self__, "manual_lb_config", manual_lb_config)
        pulumi.set(__self__, "metal_lb_config", metal_lb_config)
        pulumi.set(__self__, "port_config", port_config)
        pulumi.set(__self__, "vip_config", vip_config)

    @property
    @pulumi.getter(name="bgpLbConfig")
    def bgp_lb_config(self) -> 'outputs.BareMetalBgpLbConfigResponse':
        """
        Configuration for BGP typed load balancers. When set network_config.advanced_networking is automatically set to true.
        """
        return pulumi.get(self, "bgp_lb_config")

    @property
    @pulumi.getter(name="manualLbConfig")
    def manual_lb_config(self) -> 'outputs.BareMetalManualLbConfigResponse':
        """
        Manually configured load balancers.
        """
        return pulumi.get(self, "manual_lb_config")

    @property
    @pulumi.getter(name="metalLbConfig")
    def metal_lb_config(self) -> 'outputs.BareMetalMetalLbConfigResponse':
        """
        Configuration for MetalLB load balancers.
        """
        return pulumi.get(self, "metal_lb_config")

    @property
    @pulumi.getter(name="portConfig")
    def port_config(self) -> 'outputs.BareMetalPortConfigResponse':
        """
        Configures the ports that the load balancer will listen on.
        """
        return pulumi.get(self, "port_config")

    @property
    @pulumi.getter(name="vipConfig")
    def vip_config(self) -> 'outputs.BareMetalVipConfigResponse':
        """
        The VIPs used by the load balancer.
        """
        return pulumi.get(self, "vip_config")


@pulumi.output_type
class BareMetalLoadBalancerNodePoolConfigResponse(dict):
    """
    Specifies the load balancer's node pool configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodePoolConfig":
            suggest = "node_pool_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalLoadBalancerNodePoolConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalLoadBalancerNodePoolConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalLoadBalancerNodePoolConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_pool_config: 'outputs.BareMetalNodePoolConfigResponse'):
        """
        Specifies the load balancer's node pool configuration.
        :param 'BareMetalNodePoolConfigResponse' node_pool_config: The generic configuration for a node pool running a load balancer.
        """
        pulumi.set(__self__, "node_pool_config", node_pool_config)

    @property
    @pulumi.getter(name="nodePoolConfig")
    def node_pool_config(self) -> 'outputs.BareMetalNodePoolConfigResponse':
        """
        The generic configuration for a node pool running a load balancer.
        """
        return pulumi.get(self, "node_pool_config")


@pulumi.output_type
class BareMetalLvpConfigResponse(dict):
    """
    Specifies the configs for local persistent volumes (PVs).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalLvpConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalLvpConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalLvpConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 storage_class: str):
        """
        Specifies the configs for local persistent volumes (PVs).
        :param str path: The host machine path.
        :param str storage_class: The StorageClass name that PVs will be created with.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The host machine path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> str:
        """
        The StorageClass name that PVs will be created with.
        """
        return pulumi.get(self, "storage_class")


@pulumi.output_type
class BareMetalLvpShareConfigResponse(dict):
    """
    Specifies the configs for local persistent volumes under a shared file system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lvpConfig":
            suggest = "lvp_config"
        elif key == "sharedPathPvCount":
            suggest = "shared_path_pv_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalLvpShareConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalLvpShareConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalLvpShareConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lvp_config: 'outputs.BareMetalLvpConfigResponse',
                 shared_path_pv_count: int):
        """
        Specifies the configs for local persistent volumes under a shared file system.
        :param 'BareMetalLvpConfigResponse' lvp_config: Defines the machine path and storage class for the LVP Share.
        :param int shared_path_pv_count: The number of subdirectories to create under path.
        """
        pulumi.set(__self__, "lvp_config", lvp_config)
        pulumi.set(__self__, "shared_path_pv_count", shared_path_pv_count)

    @property
    @pulumi.getter(name="lvpConfig")
    def lvp_config(self) -> 'outputs.BareMetalLvpConfigResponse':
        """
        Defines the machine path and storage class for the LVP Share.
        """
        return pulumi.get(self, "lvp_config")

    @property
    @pulumi.getter(name="sharedPathPvCount")
    def shared_path_pv_count(self) -> int:
        """
        The number of subdirectories to create under path.
        """
        return pulumi.get(self, "shared_path_pv_count")


@pulumi.output_type
class BareMetalMachineDrainStatusResponse(dict):
    """
    Represents the status of node machines that are undergoing drain operations.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainedMachines":
            suggest = "drained_machines"
        elif key == "drainingMachines":
            suggest = "draining_machines"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalMachineDrainStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalMachineDrainStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalMachineDrainStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drained_machines: Sequence['outputs.BareMetalDrainedMachineResponse'],
                 draining_machines: Sequence['outputs.BareMetalDrainingMachineResponse']):
        """
        Represents the status of node machines that are undergoing drain operations.
        :param Sequence['BareMetalDrainedMachineResponse'] drained_machines: The list of drained machines.
        :param Sequence['BareMetalDrainingMachineResponse'] draining_machines: The list of draning machines.
        """
        pulumi.set(__self__, "drained_machines", drained_machines)
        pulumi.set(__self__, "draining_machines", draining_machines)

    @property
    @pulumi.getter(name="drainedMachines")
    def drained_machines(self) -> Sequence['outputs.BareMetalDrainedMachineResponse']:
        """
        The list of drained machines.
        """
        return pulumi.get(self, "drained_machines")

    @property
    @pulumi.getter(name="drainingMachines")
    def draining_machines(self) -> Sequence['outputs.BareMetalDrainingMachineResponse']:
        """
        The list of draning machines.
        """
        return pulumi.get(self, "draining_machines")


@pulumi.output_type
class BareMetalMaintenanceConfigResponse(dict):
    """
    Specifies configurations to put bare metal nodes in and out of maintenance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maintenanceAddressCidrBlocks":
            suggest = "maintenance_address_cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalMaintenanceConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalMaintenanceConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalMaintenanceConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maintenance_address_cidr_blocks: Sequence[str]):
        """
        Specifies configurations to put bare metal nodes in and out of maintenance.
        :param Sequence[str] maintenance_address_cidr_blocks: All IPv4 address from these ranges will be placed into maintenance mode. Nodes in maintenance mode will be cordoned and drained. When both of these are true, the "baremetal.cluster.gke.io/maintenance" annotation will be set on the node resource.
        """
        pulumi.set(__self__, "maintenance_address_cidr_blocks", maintenance_address_cidr_blocks)

    @property
    @pulumi.getter(name="maintenanceAddressCidrBlocks")
    def maintenance_address_cidr_blocks(self) -> Sequence[str]:
        """
        All IPv4 address from these ranges will be placed into maintenance mode. Nodes in maintenance mode will be cordoned and drained. When both of these are true, the "baremetal.cluster.gke.io/maintenance" annotation will be set on the node resource.
        """
        return pulumi.get(self, "maintenance_address_cidr_blocks")


@pulumi.output_type
class BareMetalMaintenanceStatusResponse(dict):
    """
    Represents the maintenance status of the bare metal user cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "machineDrainStatus":
            suggest = "machine_drain_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalMaintenanceStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalMaintenanceStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalMaintenanceStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 machine_drain_status: 'outputs.BareMetalMachineDrainStatusResponse'):
        """
        Represents the maintenance status of the bare metal user cluster.
        :param 'BareMetalMachineDrainStatusResponse' machine_drain_status: The maintenance status of node machines.
        """
        pulumi.set(__self__, "machine_drain_status", machine_drain_status)

    @property
    @pulumi.getter(name="machineDrainStatus")
    def machine_drain_status(self) -> 'outputs.BareMetalMachineDrainStatusResponse':
        """
        The maintenance status of node machines.
        """
        return pulumi.get(self, "machine_drain_status")


@pulumi.output_type
class BareMetalManualLbConfigResponse(dict):
    """
    Represents configuration parameters for a manual load balancer.
    """
    def __init__(__self__, *,
                 enabled: bool):
        """
        Represents configuration parameters for a manual load balancer.
        :param bool enabled: Whether manual load balancing is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether manual load balancing is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class BareMetalMetalLbConfigResponse(dict):
    """
    Represents configuration parameters for a MetalLB load balancer.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPools":
            suggest = "address_pools"
        elif key == "loadBalancerNodePoolConfig":
            suggest = "load_balancer_node_pool_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalMetalLbConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalMetalLbConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalMetalLbConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_pools: Sequence['outputs.BareMetalLoadBalancerAddressPoolResponse'],
                 load_balancer_node_pool_config: 'outputs.BareMetalLoadBalancerNodePoolConfigResponse'):
        """
        Represents configuration parameters for a MetalLB load balancer.
        :param Sequence['BareMetalLoadBalancerAddressPoolResponse'] address_pools: AddressPools is a list of non-overlapping IP pools used by load balancer typed services. All addresses must be routable to load balancer nodes. IngressVIP must be included in the pools.
        :param 'BareMetalLoadBalancerNodePoolConfigResponse' load_balancer_node_pool_config: Specifies the node pool running the load balancer. L2 connectivity is required among nodes in this pool. If missing, the control plane node pool is used as the load balancer pool.
        """
        pulumi.set(__self__, "address_pools", address_pools)
        pulumi.set(__self__, "load_balancer_node_pool_config", load_balancer_node_pool_config)

    @property
    @pulumi.getter(name="addressPools")
    def address_pools(self) -> Sequence['outputs.BareMetalLoadBalancerAddressPoolResponse']:
        """
        AddressPools is a list of non-overlapping IP pools used by load balancer typed services. All addresses must be routable to load balancer nodes. IngressVIP must be included in the pools.
        """
        return pulumi.get(self, "address_pools")

    @property
    @pulumi.getter(name="loadBalancerNodePoolConfig")
    def load_balancer_node_pool_config(self) -> 'outputs.BareMetalLoadBalancerNodePoolConfigResponse':
        """
        Specifies the node pool running the load balancer. L2 connectivity is required among nodes in this pool. If missing, the control plane node pool is used as the load balancer pool.
        """
        return pulumi.get(self, "load_balancer_node_pool_config")


@pulumi.output_type
class BareMetalMultipleNetworkInterfacesConfigResponse(dict):
    """
    Specifies the multiple networking interfaces cluster configuration.
    """
    def __init__(__self__, *,
                 enabled: bool):
        """
        Specifies the multiple networking interfaces cluster configuration.
        :param bool enabled: Whether to enable multiple network interfaces for your pods. When set network_config.advanced_networking is automatically set to true.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether to enable multiple network interfaces for your pods. When set network_config.advanced_networking is automatically set to true.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class BareMetalNetworkConfigResponse(dict):
    """
    Specifies the cluster network configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advancedNetworking":
            suggest = "advanced_networking"
        elif key == "islandModeCidr":
            suggest = "island_mode_cidr"
        elif key == "multipleNetworkInterfacesConfig":
            suggest = "multiple_network_interfaces_config"
        elif key == "srIovConfig":
            suggest = "sr_iov_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalNetworkConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalNetworkConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalNetworkConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advanced_networking: bool,
                 island_mode_cidr: 'outputs.BareMetalIslandModeCidrConfigResponse',
                 multiple_network_interfaces_config: 'outputs.BareMetalMultipleNetworkInterfacesConfigResponse',
                 sr_iov_config: 'outputs.BareMetalSrIovConfigResponse'):
        """
        Specifies the cluster network configuration.
        :param bool advanced_networking: Enables the use of advanced Anthos networking features, such as Bundled Load Balancing with BGP or the egress NAT gateway. Setting configuration for advanced networking features will automatically set this flag.
        :param 'BareMetalIslandModeCidrConfigResponse' island_mode_cidr: Configuration for island mode CIDR. In an island-mode network, nodes have unique IP addresses, but pods don't have unique addresses across clusters. This doesn't cause problems because pods in one cluster never directly communicate with pods in another cluster. Instead, there are gateways that mediate between a pod in one cluster and a pod in another cluster.
        :param 'BareMetalMultipleNetworkInterfacesConfigResponse' multiple_network_interfaces_config: Configuration for multiple network interfaces.
        :param 'BareMetalSrIovConfigResponse' sr_iov_config: Configuration for SR-IOV.
        """
        pulumi.set(__self__, "advanced_networking", advanced_networking)
        pulumi.set(__self__, "island_mode_cidr", island_mode_cidr)
        pulumi.set(__self__, "multiple_network_interfaces_config", multiple_network_interfaces_config)
        pulumi.set(__self__, "sr_iov_config", sr_iov_config)

    @property
    @pulumi.getter(name="advancedNetworking")
    def advanced_networking(self) -> bool:
        """
        Enables the use of advanced Anthos networking features, such as Bundled Load Balancing with BGP or the egress NAT gateway. Setting configuration for advanced networking features will automatically set this flag.
        """
        return pulumi.get(self, "advanced_networking")

    @property
    @pulumi.getter(name="islandModeCidr")
    def island_mode_cidr(self) -> 'outputs.BareMetalIslandModeCidrConfigResponse':
        """
        Configuration for island mode CIDR. In an island-mode network, nodes have unique IP addresses, but pods don't have unique addresses across clusters. This doesn't cause problems because pods in one cluster never directly communicate with pods in another cluster. Instead, there are gateways that mediate between a pod in one cluster and a pod in another cluster.
        """
        return pulumi.get(self, "island_mode_cidr")

    @property
    @pulumi.getter(name="multipleNetworkInterfacesConfig")
    def multiple_network_interfaces_config(self) -> 'outputs.BareMetalMultipleNetworkInterfacesConfigResponse':
        """
        Configuration for multiple network interfaces.
        """
        return pulumi.get(self, "multiple_network_interfaces_config")

    @property
    @pulumi.getter(name="srIovConfig")
    def sr_iov_config(self) -> 'outputs.BareMetalSrIovConfigResponse':
        """
        Configuration for SR-IOV.
        """
        return pulumi.get(self, "sr_iov_config")


@pulumi.output_type
class BareMetalNodeAccessConfigResponse(dict):
    """
    Specifies the node access related settings for the bare metal user cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loginUser":
            suggest = "login_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalNodeAccessConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalNodeAccessConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalNodeAccessConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login_user: str):
        """
        Specifies the node access related settings for the bare metal user cluster.
        :param str login_user: LoginUser is the user name used to access node machines. It defaults to "root" if not set.
        """
        pulumi.set(__self__, "login_user", login_user)

    @property
    @pulumi.getter(name="loginUser")
    def login_user(self) -> str:
        """
        LoginUser is the user name used to access node machines. It defaults to "root" if not set.
        """
        return pulumi.get(self, "login_user")


@pulumi.output_type
class BareMetalNodeConfigResponse(dict):
    """
    BareMetalNodeConfig lists machine addresses to access Nodes.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeIp":
            suggest = "node_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalNodeConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalNodeConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalNodeConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 labels: Mapping[str, str],
                 node_ip: str):
        """
        BareMetalNodeConfig lists machine addresses to access Nodes.
        :param Mapping[str, str] labels: The labels assigned to this node. An object containing a list of key/value pairs. The labels here, unioned with the labels set on BareMetalNodePoolConfig are the set of labels that will be applied to the node. If there are any conflicts, the BareMetalNodeConfig labels take precedence. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param str node_ip: The default IPv4 address for SSH access and Kubernetes node. Example: 192.168.0.1
        """
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "node_ip", node_ip)

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        The labels assigned to this node. An object containing a list of key/value pairs. The labels here, unioned with the labels set on BareMetalNodePoolConfig are the set of labels that will be applied to the node. If there are any conflicts, the BareMetalNodeConfig labels take precedence. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> str:
        """
        The default IPv4 address for SSH access and Kubernetes node. Example: 192.168.0.1
        """
        return pulumi.get(self, "node_ip")


@pulumi.output_type
class BareMetalNodePoolConfigResponse(dict):
    """
    BareMetalNodePoolConfig describes the configuration of all nodes within a given bare metal node pool.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kubeletConfig":
            suggest = "kubelet_config"
        elif key == "nodeConfigs":
            suggest = "node_configs"
        elif key == "operatingSystem":
            suggest = "operating_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalNodePoolConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalNodePoolConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalNodePoolConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kubelet_config: 'outputs.BareMetalKubeletConfigResponse',
                 labels: Mapping[str, str],
                 node_configs: Sequence['outputs.BareMetalNodeConfigResponse'],
                 operating_system: str,
                 taints: Sequence['outputs.NodeTaintResponse']):
        """
        BareMetalNodePoolConfig describes the configuration of all nodes within a given bare metal node pool.
        :param 'BareMetalKubeletConfigResponse' kubelet_config: The modifiable kubelet configurations for the bare metal machines.
        :param Mapping[str, str] labels: The labels assigned to nodes of this node pool. An object containing a list of key/value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param Sequence['BareMetalNodeConfigResponse'] node_configs: The list of machine addresses in the bare metal node pool.
        :param str operating_system: Specifies the nodes operating system (default: LINUX).
        :param Sequence['NodeTaintResponse'] taints: The initial taints assigned to nodes of this node pool.
        """
        pulumi.set(__self__, "kubelet_config", kubelet_config)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "node_configs", node_configs)
        pulumi.set(__self__, "operating_system", operating_system)
        pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter(name="kubeletConfig")
    def kubelet_config(self) -> 'outputs.BareMetalKubeletConfigResponse':
        """
        The modifiable kubelet configurations for the bare metal machines.
        """
        return pulumi.get(self, "kubelet_config")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        The labels assigned to nodes of this node pool. An object containing a list of key/value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="nodeConfigs")
    def node_configs(self) -> Sequence['outputs.BareMetalNodeConfigResponse']:
        """
        The list of machine addresses in the bare metal node pool.
        """
        return pulumi.get(self, "node_configs")

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> str:
        """
        Specifies the nodes operating system (default: LINUX).
        """
        return pulumi.get(self, "operating_system")

    @property
    @pulumi.getter
    def taints(self) -> Sequence['outputs.NodeTaintResponse']:
        """
        The initial taints assigned to nodes of this node pool.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class BareMetalNodePoolUpgradePolicyResponse(dict):
    """
    BareMetalNodePoolUpgradePolicy defines the node pool upgrade policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parallelUpgradeConfig":
            suggest = "parallel_upgrade_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalNodePoolUpgradePolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalNodePoolUpgradePolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalNodePoolUpgradePolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parallel_upgrade_config: 'outputs.BareMetalParallelUpgradeConfigResponse'):
        """
        BareMetalNodePoolUpgradePolicy defines the node pool upgrade policy.
        :param 'BareMetalParallelUpgradeConfigResponse' parallel_upgrade_config: The parallel upgrade settings for worker node pools.
        """
        pulumi.set(__self__, "parallel_upgrade_config", parallel_upgrade_config)

    @property
    @pulumi.getter(name="parallelUpgradeConfig")
    def parallel_upgrade_config(self) -> 'outputs.BareMetalParallelUpgradeConfigResponse':
        """
        The parallel upgrade settings for worker node pools.
        """
        return pulumi.get(self, "parallel_upgrade_config")


@pulumi.output_type
class BareMetalOsEnvironmentConfigResponse(dict):
    """
    Specifies operating system settings for cluster provisioning.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "packageRepoExcluded":
            suggest = "package_repo_excluded"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalOsEnvironmentConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalOsEnvironmentConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalOsEnvironmentConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 package_repo_excluded: bool):
        """
        Specifies operating system settings for cluster provisioning.
        :param bool package_repo_excluded: Whether the package repo should not be included when initializing bare metal machines.
        """
        pulumi.set(__self__, "package_repo_excluded", package_repo_excluded)

    @property
    @pulumi.getter(name="packageRepoExcluded")
    def package_repo_excluded(self) -> bool:
        """
        Whether the package repo should not be included when initializing bare metal machines.
        """
        return pulumi.get(self, "package_repo_excluded")


@pulumi.output_type
class BareMetalParallelUpgradeConfigResponse(dict):
    """
    BareMetalParallelUpgradeConfig defines the parallel upgrade settings for worker node pools.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "concurrentNodes":
            suggest = "concurrent_nodes"
        elif key == "minimumAvailableNodes":
            suggest = "minimum_available_nodes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalParallelUpgradeConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalParallelUpgradeConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalParallelUpgradeConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 concurrent_nodes: int,
                 minimum_available_nodes: int):
        """
        BareMetalParallelUpgradeConfig defines the parallel upgrade settings for worker node pools.
        :param int concurrent_nodes: The maximum number of nodes that can be upgraded at once.
        :param int minimum_available_nodes: The minimum number of nodes that should be healthy and available during an upgrade. If set to the default value of 0, it is possible that none of the nodes will be available during an upgrade.
        """
        pulumi.set(__self__, "concurrent_nodes", concurrent_nodes)
        pulumi.set(__self__, "minimum_available_nodes", minimum_available_nodes)

    @property
    @pulumi.getter(name="concurrentNodes")
    def concurrent_nodes(self) -> int:
        """
        The maximum number of nodes that can be upgraded at once.
        """
        return pulumi.get(self, "concurrent_nodes")

    @property
    @pulumi.getter(name="minimumAvailableNodes")
    def minimum_available_nodes(self) -> int:
        """
        The minimum number of nodes that should be healthy and available during an upgrade. If set to the default value of 0, it is possible that none of the nodes will be available during an upgrade.
        """
        return pulumi.get(self, "minimum_available_nodes")


@pulumi.output_type
class BareMetalPortConfigResponse(dict):
    """
    Specifies load balancer ports for the bare metal user cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneLoadBalancerPort":
            suggest = "control_plane_load_balancer_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalPortConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalPortConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalPortConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_load_balancer_port: int):
        """
        Specifies load balancer ports for the bare metal user cluster.
        :param int control_plane_load_balancer_port: The port that control plane hosted load balancers will listen on.
        """
        pulumi.set(__self__, "control_plane_load_balancer_port", control_plane_load_balancer_port)

    @property
    @pulumi.getter(name="controlPlaneLoadBalancerPort")
    def control_plane_load_balancer_port(self) -> int:
        """
        The port that control plane hosted load balancers will listen on.
        """
        return pulumi.get(self, "control_plane_load_balancer_port")


@pulumi.output_type
class BareMetalProxyConfigResponse(dict):
    """
    Specifies the cluster proxy configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noProxy":
            suggest = "no_proxy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalProxyConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalProxyConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalProxyConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_proxy: Sequence[str],
                 uri: str):
        """
        Specifies the cluster proxy configuration.
        :param Sequence[str] no_proxy: A list of IPs, hostnames, and domains that should skip the proxy. Examples: ["127.0.0.1", "example.com", ".corp", "localhost"].
        :param str uri: Specifies the address of your proxy server. Examples: `http://domain` Do not provide credentials in the format `http://(username:password@)domain` these will be rejected by the server.
        """
        pulumi.set(__self__, "no_proxy", no_proxy)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter(name="noProxy")
    def no_proxy(self) -> Sequence[str]:
        """
        A list of IPs, hostnames, and domains that should skip the proxy. Examples: ["127.0.0.1", "example.com", ".corp", "localhost"].
        """
        return pulumi.get(self, "no_proxy")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        Specifies the address of your proxy server. Examples: `http://domain` Do not provide credentials in the format `http://(username:password@)domain` these will be rejected by the server.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class BareMetalSecurityConfigResponse(dict):
    """
    Specifies the security related settings for the bare metal user cluster.
    """
    def __init__(__self__, *,
                 authorization: 'outputs.AuthorizationResponse'):
        """
        Specifies the security related settings for the bare metal user cluster.
        :param 'AuthorizationResponse' authorization: Configures user access to the user cluster.
        """
        pulumi.set(__self__, "authorization", authorization)

    @property
    @pulumi.getter
    def authorization(self) -> 'outputs.AuthorizationResponse':
        """
        Configures user access to the user cluster.
        """
        return pulumi.get(self, "authorization")


@pulumi.output_type
class BareMetalSrIovConfigResponse(dict):
    """
    Specifies the SR-IOV networking operator config.
    """
    def __init__(__self__, *,
                 enabled: bool):
        """
        Specifies the SR-IOV networking operator config.
        :param bool enabled: Whether to install the SR-IOV operator.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether to install the SR-IOV operator.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class BareMetalStorageConfigResponse(dict):
    """
    BareMetalStorageConfig specifies the cluster storage configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lvpNodeMountsConfig":
            suggest = "lvp_node_mounts_config"
        elif key == "lvpShareConfig":
            suggest = "lvp_share_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalStorageConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalStorageConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalStorageConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lvp_node_mounts_config: 'outputs.BareMetalLvpConfigResponse',
                 lvp_share_config: 'outputs.BareMetalLvpShareConfigResponse'):
        """
        BareMetalStorageConfig specifies the cluster storage configuration.
        :param 'BareMetalLvpConfigResponse' lvp_node_mounts_config: Specifies the config for local PersistentVolumes backed by mounted node disks. These disks need to be formatted and mounted by the user, which can be done before or after cluster creation.
        :param 'BareMetalLvpShareConfigResponse' lvp_share_config: Specifies the config for local PersistentVolumes backed by subdirectories in a shared filesystem. These subdirectores are automatically created during cluster creation.
        """
        pulumi.set(__self__, "lvp_node_mounts_config", lvp_node_mounts_config)
        pulumi.set(__self__, "lvp_share_config", lvp_share_config)

    @property
    @pulumi.getter(name="lvpNodeMountsConfig")
    def lvp_node_mounts_config(self) -> 'outputs.BareMetalLvpConfigResponse':
        """
        Specifies the config for local PersistentVolumes backed by mounted node disks. These disks need to be formatted and mounted by the user, which can be done before or after cluster creation.
        """
        return pulumi.get(self, "lvp_node_mounts_config")

    @property
    @pulumi.getter(name="lvpShareConfig")
    def lvp_share_config(self) -> 'outputs.BareMetalLvpShareConfigResponse':
        """
        Specifies the config for local PersistentVolumes backed by subdirectories in a shared filesystem. These subdirectores are automatically created during cluster creation.
        """
        return pulumi.get(self, "lvp_share_config")


@pulumi.output_type
class BareMetalVipConfigResponse(dict):
    """
    Specifies the VIP config for the bare metal load balancer.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneVip":
            suggest = "control_plane_vip"
        elif key == "ingressVip":
            suggest = "ingress_vip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalVipConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalVipConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalVipConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_vip: str,
                 ingress_vip: str):
        """
        Specifies the VIP config for the bare metal load balancer.
        :param str control_plane_vip: The VIP which you previously set aside for the Kubernetes API of this bare metal user cluster.
        :param str ingress_vip: The VIP which you previously set aside for ingress traffic into this bare metal user cluster.
        """
        pulumi.set(__self__, "control_plane_vip", control_plane_vip)
        pulumi.set(__self__, "ingress_vip", ingress_vip)

    @property
    @pulumi.getter(name="controlPlaneVip")
    def control_plane_vip(self) -> str:
        """
        The VIP which you previously set aside for the Kubernetes API of this bare metal user cluster.
        """
        return pulumi.get(self, "control_plane_vip")

    @property
    @pulumi.getter(name="ingressVip")
    def ingress_vip(self) -> str:
        """
        The VIP which you previously set aside for ingress traffic into this bare metal user cluster.
        """
        return pulumi.get(self, "ingress_vip")


@pulumi.output_type
class BareMetalWorkloadNodeConfigResponse(dict):
    """
    Specifies the workload node configurations.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerRuntime":
            suggest = "container_runtime"
        elif key == "maxPodsPerNode":
            suggest = "max_pods_per_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalWorkloadNodeConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalWorkloadNodeConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalWorkloadNodeConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_runtime: str,
                 max_pods_per_node: str):
        """
        Specifies the workload node configurations.
        :param str container_runtime: Specifies which container runtime will be used.
        :param str max_pods_per_node: The maximum number of pods a node can run. The size of the CIDR range assigned to the node will be derived from this parameter.
        """
        pulumi.set(__self__, "container_runtime", container_runtime)
        pulumi.set(__self__, "max_pods_per_node", max_pods_per_node)

    @property
    @pulumi.getter(name="containerRuntime")
    def container_runtime(self) -> str:
        """
        Specifies which container runtime will be used.
        """
        return pulumi.get(self, "container_runtime")

    @property
    @pulumi.getter(name="maxPodsPerNode")
    def max_pods_per_node(self) -> str:
        """
        The maximum number of pods a node can run. The size of the CIDR range assigned to the node will be derived from this parameter.
        """
        return pulumi.get(self, "max_pods_per_node")


@pulumi.output_type
class BinaryAuthorizationResponse(dict):
    """
    Configuration for Binary Authorization.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluationMode":
            suggest = "evaluation_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BinaryAuthorizationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BinaryAuthorizationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BinaryAuthorizationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluation_mode: str):
        """
        Configuration for Binary Authorization.
        :param str evaluation_mode: Mode of operation for binauthz policy evaluation. If unspecified, defaults to DISABLED.
        """
        pulumi.set(__self__, "evaluation_mode", evaluation_mode)

    @property
    @pulumi.getter(name="evaluationMode")
    def evaluation_mode(self) -> str:
        """
        Mode of operation for binauthz policy evaluation. If unspecified, defaults to DISABLED.
        """
        return pulumi.get(self, "evaluation_mode")


@pulumi.output_type
class BindingResponse(dict):
    """
    Associates `members`, or principals, with a `role`.
    """
    def __init__(__self__, *,
                 condition: 'outputs.ExprResponse',
                 members: Sequence[str],
                 role: str):
        """
        Associates `members`, or principals, with a `role`.
        :param 'ExprResponse' condition: The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        :param Sequence[str] members: Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
        :param str role: Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "members", members)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.ExprResponse':
        """
        The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def members(self) -> Sequence[str]:
        """
        Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
        """
        return pulumi.get(self, "members")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class ClusterUserResponse(dict):
    """
    ClusterUser configures user principals for an RBAC policy.
    """
    def __init__(__self__, *,
                 username: str):
        """
        ClusterUser configures user principals for an RBAC policy.
        :param str username: The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ExprResponse(dict):
    """
    Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
    """
    def __init__(__self__, *,
                 description: str,
                 expression: str,
                 location: str,
                 title: str):
        """
        Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
        :param str description: Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        :param str expression: Textual representation of an expression in Common Expression Language syntax.
        :param str location: Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
        :param str title: Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class FleetResponse(dict):
    """
    Fleet related configuration. Fleets are a Google Cloud concept for logically organizing clusters, letting you use and manage multi-cluster capabilities and apply consistent policies across your systems. See [Anthos Fleets](`https://cloud.google.com/anthos/multicluster-management/fleets`) for more details on Anthos multi-cluster capabilities using Fleets. ##
    """
    def __init__(__self__, *,
                 membership: str):
        """
        Fleet related configuration. Fleets are a Google Cloud concept for logically organizing clusters, letting you use and manage multi-cluster capabilities and apply consistent policies across your systems. See [Anthos Fleets](`https://cloud.google.com/anthos/multicluster-management/fleets`) for more details on Anthos multi-cluster capabilities using Fleets. ##
        :param str membership: The name of the managed fleet Membership resource associated to this cluster. Membership names are formatted as `projects//locations//memberships/`.
        """
        pulumi.set(__self__, "membership", membership)

    @property
    @pulumi.getter
    def membership(self) -> str:
        """
        The name of the managed fleet Membership resource associated to this cluster. Membership names are formatted as `projects//locations//memberships/`.
        """
        return pulumi.get(self, "membership")


@pulumi.output_type
class NodeTaintResponse(dict):
    """
    NodeTaint applied to every Kubernetes node in a node pool. Kubernetes taints can be used together with tolerations to control how workloads are scheduled to your nodes. Node taints are permanent.
    """
    def __init__(__self__, *,
                 effect: str,
                 key: str,
                 value: str):
        """
        NodeTaint applied to every Kubernetes node in a node pool. Kubernetes taints can be used together with tolerations to control how workloads are scheduled to your nodes. Node taints are permanent.
        :param str effect: The taint effect.
        :param str key: Key associated with the effect.
        :param str value: Value associated with the effect.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> str:
        """
        The taint effect.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key associated with the effect.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value associated with the effect.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ResourceConditionResponse(dict):
    """
    ResourceCondition provides a standard mechanism for higher-level status reporting from controller.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: str,
                 message: str,
                 reason: str,
                 state: str,
                 type: str):
        """
        ResourceCondition provides a standard mechanism for higher-level status reporting from controller.
        :param str last_transition_time: Last time the condition transit from one status to another.
        :param str message: Human-readable message indicating details about last transition.
        :param str reason: Machine-readable message indicating details about last transition.
        :param str state: state of the condition.
        :param str type: Type of the condition. (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        pulumi.set(__self__, "last_transition_time", last_transition_time)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "reason", reason)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> str:
        """
        Last time the condition transit from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Human-readable message indicating details about last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> str:
        """
        Machine-readable message indicating details about last transition.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        state of the condition.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the condition. (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ResourceStatusResponse(dict):
    """
    ResourceStatus describes why a cluster or node pool has a certain status. (e.g., ERROR or DEGRADED).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Sequence['outputs.ResourceConditionResponse'],
                 error_message: str):
        """
        ResourceStatus describes why a cluster or node pool has a certain status. (e.g., ERROR or DEGRADED).
        :param Sequence['ResourceConditionResponse'] conditions: ResourceCondition provide a standard mechanism for higher-level status reporting from controller.
        :param str error_message: Human-friendly representation of the error message from controller. The error message can be temporary as the controller controller creates a cluster or node pool. If the error message persists for a longer period of time, it can be used to surface error message to indicate real problems requiring user intervention.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "error_message", error_message)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.ResourceConditionResponse']:
        """
        ResourceCondition provide a standard mechanism for higher-level status reporting from controller.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        """
        Human-friendly representation of the error message from controller. The error message can be temporary as the controller controller creates a cluster or node pool. If the error message persists for a longer period of time, it can be used to surface error message to indicate real problems requiring user intervention.
        """
        return pulumi.get(self, "error_message")


@pulumi.output_type
class ValidationCheckResponse(dict):
    """
    ValidationCheck represents the result of preflight check.
    """
    def __init__(__self__, *,
                 option: str,
                 scenario: str,
                 status: 'outputs.ValidationCheckStatusResponse'):
        """
        ValidationCheck represents the result of preflight check.
        :param str option: Options used for the validation check
        :param str scenario: The scenario when the preflight checks were run.
        :param 'ValidationCheckStatusResponse' status: The detailed validation check status.
        """
        pulumi.set(__self__, "option", option)
        pulumi.set(__self__, "scenario", scenario)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def option(self) -> str:
        """
        Options used for the validation check
        """
        return pulumi.get(self, "option")

    @property
    @pulumi.getter
    def scenario(self) -> str:
        """
        The scenario when the preflight checks were run.
        """
        return pulumi.get(self, "scenario")

    @property
    @pulumi.getter
    def status(self) -> 'outputs.ValidationCheckStatusResponse':
        """
        The detailed validation check status.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ValidationCheckResultResponse(dict):
    """
    ValidationCheckResult defines the details about the validation check.
    """
    def __init__(__self__, *,
                 category: str,
                 description: str,
                 details: str,
                 reason: str,
                 state: str):
        """
        ValidationCheckResult defines the details about the validation check.
        :param str category: The category of the validation.
        :param str description: The description of the validation check.
        :param str details: Detailed failure information, which might be unformatted.
        :param str reason: A human-readable message of the check failure.
        :param str state: The validation check state.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "reason", reason)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        The category of the validation.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the validation check.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> str:
        """
        Detailed failure information, which might be unformatted.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def reason(self) -> str:
        """
        A human-readable message of the check failure.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The validation check state.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class ValidationCheckStatusResponse(dict):
    """
    ValidationCheckStatus defines the detailed validation check status.
    """
    def __init__(__self__, *,
                 result: Sequence['outputs.ValidationCheckResultResponse']):
        """
        ValidationCheckStatus defines the detailed validation check status.
        :param Sequence['ValidationCheckResultResponse'] result: Individual checks which failed as part of the Preflight check execution.
        """
        pulumi.set(__self__, "result", result)

    @property
    @pulumi.getter
    def result(self) -> Sequence['outputs.ValidationCheckResultResponse']:
        """
        Individual checks which failed as part of the Preflight check execution.
        """
        return pulumi.get(self, "result")


@pulumi.output_type
class VmwareAAGConfigResponse(dict):
    """
    Specifies anti affinity group config for the VMware user cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aagConfigDisabled":
            suggest = "aag_config_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAAGConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAAGConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAAGConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aag_config_disabled: bool):
        """
        Specifies anti affinity group config for the VMware user cluster.
        :param bool aag_config_disabled: Spread nodes across at least three physical hosts (requires at least three hosts). Enabled by default.
        """
        pulumi.set(__self__, "aag_config_disabled", aag_config_disabled)

    @property
    @pulumi.getter(name="aagConfigDisabled")
    def aag_config_disabled(self) -> bool:
        """
        Spread nodes across at least three physical hosts (requires at least three hosts). Enabled by default.
        """
        return pulumi.get(self, "aag_config_disabled")


@pulumi.output_type
class VmwareAddressPoolResponse(dict):
    """
    Represents an IP pool used by the load balancer.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avoidBuggyIps":
            suggest = "avoid_buggy_ips"
        elif key == "manualAssign":
            suggest = "manual_assign"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAddressPoolResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAddressPoolResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAddressPoolResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Sequence[str],
                 avoid_buggy_ips: bool,
                 manual_assign: bool,
                 pool: str):
        """
        Represents an IP pool used by the load balancer.
        :param Sequence[str] addresses: The addresses that are part of this pool. Each address must be either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
        :param bool avoid_buggy_ips: If true, avoid using IPs ending in .0 or .255. This avoids buggy consumer devices mistakenly dropping IPv4 traffic for those special IP addresses.
        :param bool manual_assign: If true, prevent IP addresses from being automatically assigned.
        :param str pool: The name of the address pool.
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "avoid_buggy_ips", avoid_buggy_ips)
        pulumi.set(__self__, "manual_assign", manual_assign)
        pulumi.set(__self__, "pool", pool)

    @property
    @pulumi.getter
    def addresses(self) -> Sequence[str]:
        """
        The addresses that are part of this pool. Each address must be either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter(name="avoidBuggyIps")
    def avoid_buggy_ips(self) -> bool:
        """
        If true, avoid using IPs ending in .0 or .255. This avoids buggy consumer devices mistakenly dropping IPv4 traffic for those special IP addresses.
        """
        return pulumi.get(self, "avoid_buggy_ips")

    @property
    @pulumi.getter(name="manualAssign")
    def manual_assign(self) -> bool:
        """
        If true, prevent IP addresses from being automatically assigned.
        """
        return pulumi.get(self, "manual_assign")

    @property
    @pulumi.getter
    def pool(self) -> str:
        """
        The name of the address pool.
        """
        return pulumi.get(self, "pool")


@pulumi.output_type
class VmwareAutoRepairConfigResponse(dict):
    """
    Specifies config to enable/disable auto repair. The cluster-health-controller is deployed only if Enabled is true.
    """
    def __init__(__self__, *,
                 enabled: bool):
        """
        Specifies config to enable/disable auto repair. The cluster-health-controller is deployed only if Enabled is true.
        :param bool enabled: Whether auto repair is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether auto repair is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class VmwareAutoResizeConfigResponse(dict):
    """
    Represents auto resizing configurations for the VMware user cluster.
    """
    def __init__(__self__, *,
                 enabled: bool):
        """
        Represents auto resizing configurations for the VMware user cluster.
        :param bool enabled: Whether to enable controle plane node auto resizing.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether to enable controle plane node auto resizing.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class VmwareClusterUpgradePolicyResponse(dict):
    """
    VmwareClusterUpgradePolicy defines the cluster upgrade policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneOnly":
            suggest = "control_plane_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareClusterUpgradePolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareClusterUpgradePolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareClusterUpgradePolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_only: bool):
        """
        VmwareClusterUpgradePolicy defines the cluster upgrade policy.
        :param bool control_plane_only: Controls whether the upgrade applies to the control plane only.
        """
        pulumi.set(__self__, "control_plane_only", control_plane_only)

    @property
    @pulumi.getter(name="controlPlaneOnly")
    def control_plane_only(self) -> bool:
        """
        Controls whether the upgrade applies to the control plane only.
        """
        return pulumi.get(self, "control_plane_only")


@pulumi.output_type
class VmwareControlPlaneNodeConfigResponse(dict):
    """
    Specifies control plane node config for the VMware user cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoResizeConfig":
            suggest = "auto_resize_config"
        elif key == "vsphereConfig":
            suggest = "vsphere_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareControlPlaneNodeConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareControlPlaneNodeConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareControlPlaneNodeConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_resize_config: 'outputs.VmwareAutoResizeConfigResponse',
                 cpus: str,
                 memory: str,
                 replicas: str,
                 vsphere_config: 'outputs.VmwareControlPlaneVsphereConfigResponse'):
        """
        Specifies control plane node config for the VMware user cluster.
        :param 'VmwareAutoResizeConfigResponse' auto_resize_config: AutoResizeConfig provides auto resizing configurations.
        :param str cpus: The number of CPUs for each admin cluster node that serve as control planes for this VMware user cluster. (default: 4 CPUs)
        :param str memory: The megabytes of memory for each admin cluster node that serves as a control plane for this VMware user cluster (default: 8192 MB memory).
        :param str replicas: The number of control plane nodes for this VMware user cluster. (default: 1 replica).
        :param 'VmwareControlPlaneVsphereConfigResponse' vsphere_config: Vsphere-specific config.
        """
        pulumi.set(__self__, "auto_resize_config", auto_resize_config)
        pulumi.set(__self__, "cpus", cpus)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "replicas", replicas)
        pulumi.set(__self__, "vsphere_config", vsphere_config)

    @property
    @pulumi.getter(name="autoResizeConfig")
    def auto_resize_config(self) -> 'outputs.VmwareAutoResizeConfigResponse':
        """
        AutoResizeConfig provides auto resizing configurations.
        """
        return pulumi.get(self, "auto_resize_config")

    @property
    @pulumi.getter
    def cpus(self) -> str:
        """
        The number of CPUs for each admin cluster node that serve as control planes for this VMware user cluster. (default: 4 CPUs)
        """
        return pulumi.get(self, "cpus")

    @property
    @pulumi.getter
    def memory(self) -> str:
        """
        The megabytes of memory for each admin cluster node that serves as a control plane for this VMware user cluster (default: 8192 MB memory).
        """
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter
    def replicas(self) -> str:
        """
        The number of control plane nodes for this VMware user cluster. (default: 1 replica).
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter(name="vsphereConfig")
    def vsphere_config(self) -> 'outputs.VmwareControlPlaneVsphereConfigResponse':
        """
        Vsphere-specific config.
        """
        return pulumi.get(self, "vsphere_config")


@pulumi.output_type
class VmwareControlPlaneV2ConfigResponse(dict):
    """
    Specifies control plane V2 config.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneIpBlock":
            suggest = "control_plane_ip_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareControlPlaneV2ConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareControlPlaneV2ConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareControlPlaneV2ConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_ip_block: 'outputs.VmwareIpBlockResponse'):
        """
        Specifies control plane V2 config.
        :param 'VmwareIpBlockResponse' control_plane_ip_block: Static IP addresses for the control plane nodes.
        """
        pulumi.set(__self__, "control_plane_ip_block", control_plane_ip_block)

    @property
    @pulumi.getter(name="controlPlaneIpBlock")
    def control_plane_ip_block(self) -> 'outputs.VmwareIpBlockResponse':
        """
        Static IP addresses for the control plane nodes.
        """
        return pulumi.get(self, "control_plane_ip_block")


@pulumi.output_type
class VmwareControlPlaneVsphereConfigResponse(dict):
    """
    Specifies control plane node config.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storagePolicyName":
            suggest = "storage_policy_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareControlPlaneVsphereConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareControlPlaneVsphereConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareControlPlaneVsphereConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datastore: str,
                 storage_policy_name: str):
        """
        Specifies control plane node config.
        :param str datastore: The Vsphere datastore used by the control plane Node.
        :param str storage_policy_name: The Vsphere storage policy used by the control plane Node.
        """
        pulumi.set(__self__, "datastore", datastore)
        pulumi.set(__self__, "storage_policy_name", storage_policy_name)

    @property
    @pulumi.getter
    def datastore(self) -> str:
        """
        The Vsphere datastore used by the control plane Node.
        """
        return pulumi.get(self, "datastore")

    @property
    @pulumi.getter(name="storagePolicyName")
    def storage_policy_name(self) -> str:
        """
        The Vsphere storage policy used by the control plane Node.
        """
        return pulumi.get(self, "storage_policy_name")


@pulumi.output_type
class VmwareDataplaneV2ConfigResponse(dict):
    """
    Contains configurations for Dataplane V2, which is optimized dataplane for Kubernetes networking. For more information, see: https://cloud.google.com/kubernetes-engine/docs/concepts/dataplane-v2
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advancedNetworking":
            suggest = "advanced_networking"
        elif key == "dataplaneV2Enabled":
            suggest = "dataplane_v2_enabled"
        elif key == "windowsDataplaneV2Enabled":
            suggest = "windows_dataplane_v2_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareDataplaneV2ConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareDataplaneV2ConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareDataplaneV2ConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advanced_networking: bool,
                 dataplane_v2_enabled: bool,
                 windows_dataplane_v2_enabled: bool):
        """
        Contains configurations for Dataplane V2, which is optimized dataplane for Kubernetes networking. For more information, see: https://cloud.google.com/kubernetes-engine/docs/concepts/dataplane-v2
        :param bool advanced_networking: Enable advanced networking which requires dataplane_v2_enabled to be set true.
        :param bool dataplane_v2_enabled: Enables Dataplane V2.
        :param bool windows_dataplane_v2_enabled: Enable Dataplane V2 for clusters with Windows nodes.
        """
        pulumi.set(__self__, "advanced_networking", advanced_networking)
        pulumi.set(__self__, "dataplane_v2_enabled", dataplane_v2_enabled)
        pulumi.set(__self__, "windows_dataplane_v2_enabled", windows_dataplane_v2_enabled)

    @property
    @pulumi.getter(name="advancedNetworking")
    def advanced_networking(self) -> bool:
        """
        Enable advanced networking which requires dataplane_v2_enabled to be set true.
        """
        return pulumi.get(self, "advanced_networking")

    @property
    @pulumi.getter(name="dataplaneV2Enabled")
    def dataplane_v2_enabled(self) -> bool:
        """
        Enables Dataplane V2.
        """
        return pulumi.get(self, "dataplane_v2_enabled")

    @property
    @pulumi.getter(name="windowsDataplaneV2Enabled")
    def windows_dataplane_v2_enabled(self) -> bool:
        """
        Enable Dataplane V2 for clusters with Windows nodes.
        """
        return pulumi.get(self, "windows_dataplane_v2_enabled")


@pulumi.output_type
class VmwareDhcpIpConfigResponse(dict):
    """
    Represents the network configuration required for the VMware user clusters with DHCP IP configurations.
    """
    def __init__(__self__, *,
                 enabled: bool):
        """
        Represents the network configuration required for the VMware user clusters with DHCP IP configurations.
        :param bool enabled: enabled is a flag to mark if DHCP IP allocation is used for VMware user clusters.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        enabled is a flag to mark if DHCP IP allocation is used for VMware user clusters.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class VmwareF5BigIpConfigResponse(dict):
    """
    Represents configuration parameters for an F5 BIG-IP load balancer.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snatPool":
            suggest = "snat_pool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareF5BigIpConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareF5BigIpConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareF5BigIpConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 partition: str,
                 snat_pool: str):
        """
        Represents configuration parameters for an F5 BIG-IP load balancer.
        :param str address: The load balancer's IP address.
        :param str partition: The preexisting partition to be used by the load balancer. This partition is usually created for the admin cluster for example: 'my-f5-admin-partition'.
        :param str snat_pool: The pool name. Only necessary, if using SNAT.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "partition", partition)
        pulumi.set(__self__, "snat_pool", snat_pool)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The load balancer's IP address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def partition(self) -> str:
        """
        The preexisting partition to be used by the load balancer. This partition is usually created for the admin cluster for example: 'my-f5-admin-partition'.
        """
        return pulumi.get(self, "partition")

    @property
    @pulumi.getter(name="snatPool")
    def snat_pool(self) -> str:
        """
        The pool name. Only necessary, if using SNAT.
        """
        return pulumi.get(self, "snat_pool")


@pulumi.output_type
class VmwareHostConfigResponse(dict):
    """
    Represents the common parameters for all the hosts irrespective of their IP address.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsSearchDomains":
            suggest = "dns_search_domains"
        elif key == "dnsServers":
            suggest = "dns_servers"
        elif key == "ntpServers":
            suggest = "ntp_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareHostConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareHostConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareHostConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_search_domains: Sequence[str],
                 dns_servers: Sequence[str],
                 ntp_servers: Sequence[str]):
        """
        Represents the common parameters for all the hosts irrespective of their IP address.
        :param Sequence[str] dns_search_domains: DNS search domains.
        :param Sequence[str] dns_servers: DNS servers.
        :param Sequence[str] ntp_servers: NTP servers.
        """
        pulumi.set(__self__, "dns_search_domains", dns_search_domains)
        pulumi.set(__self__, "dns_servers", dns_servers)
        pulumi.set(__self__, "ntp_servers", ntp_servers)

    @property
    @pulumi.getter(name="dnsSearchDomains")
    def dns_search_domains(self) -> Sequence[str]:
        """
        DNS search domains.
        """
        return pulumi.get(self, "dns_search_domains")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Sequence[str]:
        """
        DNS servers.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter(name="ntpServers")
    def ntp_servers(self) -> Sequence[str]:
        """
        NTP servers.
        """
        return pulumi.get(self, "ntp_servers")


@pulumi.output_type
class VmwareHostIpResponse(dict):
    """
    Represents VMware user cluster node's network configuration.
    """
    def __init__(__self__, *,
                 hostname: str,
                 ip: str):
        """
        Represents VMware user cluster node's network configuration.
        :param str hostname: Hostname of the machine. VM's name will be used if this field is empty.
        :param str ip: IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        Hostname of the machine. VM's name will be used if this field is empty.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class VmwareIpBlockResponse(dict):
    """
    Represents a collection of IP addresses to assign to nodes.
    """
    def __init__(__self__, *,
                 gateway: str,
                 ips: Sequence['outputs.VmwareHostIpResponse'],
                 netmask: str):
        """
        Represents a collection of IP addresses to assign to nodes.
        :param str gateway: The network gateway used by the VMware user cluster.
        :param Sequence['VmwareHostIpResponse'] ips: The node's network configurations used by the VMware user cluster.
        :param str netmask: The netmask used by the VMware user cluster.
        """
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "netmask", netmask)

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        The network gateway used by the VMware user cluster.
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def ips(self) -> Sequence['outputs.VmwareHostIpResponse']:
        """
        The node's network configurations used by the VMware user cluster.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def netmask(self) -> str:
        """
        The netmask used by the VMware user cluster.
        """
        return pulumi.get(self, "netmask")


@pulumi.output_type
class VmwareLoadBalancerConfigResponse(dict):
    """
    Specifies the locad balancer config for the VMware user cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "f5Config":
            suggest = "f5_config"
        elif key == "manualLbConfig":
            suggest = "manual_lb_config"
        elif key == "metalLbConfig":
            suggest = "metal_lb_config"
        elif key == "seesawConfig":
            suggest = "seesaw_config"
        elif key == "vipConfig":
            suggest = "vip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareLoadBalancerConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareLoadBalancerConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareLoadBalancerConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 f5_config: 'outputs.VmwareF5BigIpConfigResponse',
                 manual_lb_config: 'outputs.VmwareManualLbConfigResponse',
                 metal_lb_config: 'outputs.VmwareMetalLbConfigResponse',
                 seesaw_config: 'outputs.VmwareSeesawConfigResponse',
                 vip_config: 'outputs.VmwareVipConfigResponse'):
        """
        Specifies the locad balancer config for the VMware user cluster.
        :param 'VmwareF5BigIpConfigResponse' f5_config: Configuration for F5 Big IP typed load balancers.
        :param 'VmwareManualLbConfigResponse' manual_lb_config: Manually configured load balancers.
        :param 'VmwareMetalLbConfigResponse' metal_lb_config: Configuration for MetalLB typed load balancers.
        :param 'VmwareSeesawConfigResponse' seesaw_config: Configuration for Seesaw typed load balancers.
        :param 'VmwareVipConfigResponse' vip_config: The VIPs used by the load balancer.
        """
        pulumi.set(__self__, "f5_config", f5_config)
        pulumi.set(__self__, "manual_lb_config", manual_lb_config)
        pulumi.set(__self__, "metal_lb_config", metal_lb_config)
        pulumi.set(__self__, "seesaw_config", seesaw_config)
        pulumi.set(__self__, "vip_config", vip_config)

    @property
    @pulumi.getter(name="f5Config")
    def f5_config(self) -> 'outputs.VmwareF5BigIpConfigResponse':
        """
        Configuration for F5 Big IP typed load balancers.
        """
        return pulumi.get(self, "f5_config")

    @property
    @pulumi.getter(name="manualLbConfig")
    def manual_lb_config(self) -> 'outputs.VmwareManualLbConfigResponse':
        """
        Manually configured load balancers.
        """
        return pulumi.get(self, "manual_lb_config")

    @property
    @pulumi.getter(name="metalLbConfig")
    def metal_lb_config(self) -> 'outputs.VmwareMetalLbConfigResponse':
        """
        Configuration for MetalLB typed load balancers.
        """
        return pulumi.get(self, "metal_lb_config")

    @property
    @pulumi.getter(name="seesawConfig")
    def seesaw_config(self) -> 'outputs.VmwareSeesawConfigResponse':
        """
        Configuration for Seesaw typed load balancers.
        """
        return pulumi.get(self, "seesaw_config")

    @property
    @pulumi.getter(name="vipConfig")
    def vip_config(self) -> 'outputs.VmwareVipConfigResponse':
        """
        The VIPs used by the load balancer.
        """
        return pulumi.get(self, "vip_config")


@pulumi.output_type
class VmwareManualLbConfigResponse(dict):
    """
    Represents configuration parameters for an already existing manual load balancer. Given the nature of manual load balancers it is expected that said load balancer will be fully managed by users. IMPORTANT: Please note that the Anthos On-Prem API will not generate or update ManualLB configurations it can only bind a pre-existing configuration to a new VMware user cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneNodePort":
            suggest = "control_plane_node_port"
        elif key == "ingressHttpNodePort":
            suggest = "ingress_http_node_port"
        elif key == "ingressHttpsNodePort":
            suggest = "ingress_https_node_port"
        elif key == "konnectivityServerNodePort":
            suggest = "konnectivity_server_node_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareManualLbConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareManualLbConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareManualLbConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_node_port: int,
                 ingress_http_node_port: int,
                 ingress_https_node_port: int,
                 konnectivity_server_node_port: int):
        """
        Represents configuration parameters for an already existing manual load balancer. Given the nature of manual load balancers it is expected that said load balancer will be fully managed by users. IMPORTANT: Please note that the Anthos On-Prem API will not generate or update ManualLB configurations it can only bind a pre-existing configuration to a new VMware user cluster.
        :param int control_plane_node_port: NodePort for control plane service. The Kubernetes API server in the admin cluster is implemented as a Service of type NodePort (ex. 30968).
        :param int ingress_http_node_port: NodePort for ingress service's http. The ingress service in the admin cluster is implemented as a Service of type NodePort (ex. 32527).
        :param int ingress_https_node_port: NodePort for ingress service's https. The ingress service in the admin cluster is implemented as a Service of type NodePort (ex. 30139).
        :param int konnectivity_server_node_port: NodePort for konnectivity server service running as a sidecar in each kube-apiserver pod (ex. 30564).
        """
        pulumi.set(__self__, "control_plane_node_port", control_plane_node_port)
        pulumi.set(__self__, "ingress_http_node_port", ingress_http_node_port)
        pulumi.set(__self__, "ingress_https_node_port", ingress_https_node_port)
        pulumi.set(__self__, "konnectivity_server_node_port", konnectivity_server_node_port)

    @property
    @pulumi.getter(name="controlPlaneNodePort")
    def control_plane_node_port(self) -> int:
        """
        NodePort for control plane service. The Kubernetes API server in the admin cluster is implemented as a Service of type NodePort (ex. 30968).
        """
        return pulumi.get(self, "control_plane_node_port")

    @property
    @pulumi.getter(name="ingressHttpNodePort")
    def ingress_http_node_port(self) -> int:
        """
        NodePort for ingress service's http. The ingress service in the admin cluster is implemented as a Service of type NodePort (ex. 32527).
        """
        return pulumi.get(self, "ingress_http_node_port")

    @property
    @pulumi.getter(name="ingressHttpsNodePort")
    def ingress_https_node_port(self) -> int:
        """
        NodePort for ingress service's https. The ingress service in the admin cluster is implemented as a Service of type NodePort (ex. 30139).
        """
        return pulumi.get(self, "ingress_https_node_port")

    @property
    @pulumi.getter(name="konnectivityServerNodePort")
    def konnectivity_server_node_port(self) -> int:
        """
        NodePort for konnectivity server service running as a sidecar in each kube-apiserver pod (ex. 30564).
        """
        return pulumi.get(self, "konnectivity_server_node_port")


@pulumi.output_type
class VmwareMetalLbConfigResponse(dict):
    """
    Represents configuration parameters for the MetalLB load balancer.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPools":
            suggest = "address_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareMetalLbConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareMetalLbConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareMetalLbConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_pools: Sequence['outputs.VmwareAddressPoolResponse']):
        """
        Represents configuration parameters for the MetalLB load balancer.
        :param Sequence['VmwareAddressPoolResponse'] address_pools: AddressPools is a list of non-overlapping IP pools used by load balancer typed services. All addresses must be routable to load balancer nodes. IngressVIP must be included in the pools.
        """
        pulumi.set(__self__, "address_pools", address_pools)

    @property
    @pulumi.getter(name="addressPools")
    def address_pools(self) -> Sequence['outputs.VmwareAddressPoolResponse']:
        """
        AddressPools is a list of non-overlapping IP pools used by load balancer typed services. All addresses must be routable to load balancer nodes. IngressVIP must be included in the pools.
        """
        return pulumi.get(self, "address_pools")


@pulumi.output_type
class VmwareNetworkConfigResponse(dict):
    """
    Specifies network config for the VMware user cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneV2Config":
            suggest = "control_plane_v2_config"
        elif key == "dhcpIpConfig":
            suggest = "dhcp_ip_config"
        elif key == "hostConfig":
            suggest = "host_config"
        elif key == "podAddressCidrBlocks":
            suggest = "pod_address_cidr_blocks"
        elif key == "serviceAddressCidrBlocks":
            suggest = "service_address_cidr_blocks"
        elif key == "staticIpConfig":
            suggest = "static_ip_config"
        elif key == "vcenterNetwork":
            suggest = "vcenter_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareNetworkConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareNetworkConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareNetworkConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_v2_config: 'outputs.VmwareControlPlaneV2ConfigResponse',
                 dhcp_ip_config: 'outputs.VmwareDhcpIpConfigResponse',
                 host_config: 'outputs.VmwareHostConfigResponse',
                 pod_address_cidr_blocks: Sequence[str],
                 service_address_cidr_blocks: Sequence[str],
                 static_ip_config: 'outputs.VmwareStaticIpConfigResponse',
                 vcenter_network: str):
        """
        Specifies network config for the VMware user cluster.
        :param 'VmwareControlPlaneV2ConfigResponse' control_plane_v2_config: Configuration for control plane V2 mode.
        :param 'VmwareDhcpIpConfigResponse' dhcp_ip_config: Configuration settings for a DHCP IP configuration.
        :param 'VmwareHostConfigResponse' host_config: Represents common network settings irrespective of the host's IP address.
        :param Sequence[str] pod_address_cidr_blocks: All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. Only a single range is supported. This field cannot be changed after creation.
        :param Sequence[str] service_address_cidr_blocks: All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. Only a single range is supported. This field cannot be changed after creation.
        :param 'VmwareStaticIpConfigResponse' static_ip_config: Configuration settings for a static IP configuration.
        :param str vcenter_network: vcenter_network specifies vCenter network name. Inherited from the admin cluster.
        """
        pulumi.set(__self__, "control_plane_v2_config", control_plane_v2_config)
        pulumi.set(__self__, "dhcp_ip_config", dhcp_ip_config)
        pulumi.set(__self__, "host_config", host_config)
        pulumi.set(__self__, "pod_address_cidr_blocks", pod_address_cidr_blocks)
        pulumi.set(__self__, "service_address_cidr_blocks", service_address_cidr_blocks)
        pulumi.set(__self__, "static_ip_config", static_ip_config)
        pulumi.set(__self__, "vcenter_network", vcenter_network)

    @property
    @pulumi.getter(name="controlPlaneV2Config")
    def control_plane_v2_config(self) -> 'outputs.VmwareControlPlaneV2ConfigResponse':
        """
        Configuration for control plane V2 mode.
        """
        return pulumi.get(self, "control_plane_v2_config")

    @property
    @pulumi.getter(name="dhcpIpConfig")
    def dhcp_ip_config(self) -> 'outputs.VmwareDhcpIpConfigResponse':
        """
        Configuration settings for a DHCP IP configuration.
        """
        return pulumi.get(self, "dhcp_ip_config")

    @property
    @pulumi.getter(name="hostConfig")
    def host_config(self) -> 'outputs.VmwareHostConfigResponse':
        """
        Represents common network settings irrespective of the host's IP address.
        """
        return pulumi.get(self, "host_config")

    @property
    @pulumi.getter(name="podAddressCidrBlocks")
    def pod_address_cidr_blocks(self) -> Sequence[str]:
        """
        All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. Only a single range is supported. This field cannot be changed after creation.
        """
        return pulumi.get(self, "pod_address_cidr_blocks")

    @property
    @pulumi.getter(name="serviceAddressCidrBlocks")
    def service_address_cidr_blocks(self) -> Sequence[str]:
        """
        All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. Only a single range is supported. This field cannot be changed after creation.
        """
        return pulumi.get(self, "service_address_cidr_blocks")

    @property
    @pulumi.getter(name="staticIpConfig")
    def static_ip_config(self) -> 'outputs.VmwareStaticIpConfigResponse':
        """
        Configuration settings for a static IP configuration.
        """
        return pulumi.get(self, "static_ip_config")

    @property
    @pulumi.getter(name="vcenterNetwork")
    def vcenter_network(self) -> str:
        """
        vcenter_network specifies vCenter network name. Inherited from the admin cluster.
        """
        return pulumi.get(self, "vcenter_network")


@pulumi.output_type
class VmwareNodeConfigResponse(dict):
    """
    Parameters that describe the configuration of all nodes within a given node pool.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDiskSizeGb":
            suggest = "boot_disk_size_gb"
        elif key == "enableLoadBalancer":
            suggest = "enable_load_balancer"
        elif key == "imageType":
            suggest = "image_type"
        elif key == "memoryMb":
            suggest = "memory_mb"
        elif key == "vsphereConfig":
            suggest = "vsphere_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareNodeConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareNodeConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareNodeConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boot_disk_size_gb: str,
                 cpus: str,
                 enable_load_balancer: bool,
                 image: str,
                 image_type: str,
                 labels: Mapping[str, str],
                 memory_mb: str,
                 replicas: str,
                 taints: Sequence['outputs.NodeTaintResponse'],
                 vsphere_config: 'outputs.VmwareVsphereConfigResponse'):
        """
        Parameters that describe the configuration of all nodes within a given node pool.
        :param str boot_disk_size_gb: VMware disk size to be used during creation.
        :param str cpus: The number of CPUs for each node in the node pool.
        :param bool enable_load_balancer: Allow node pool traffic to be load balanced. Only works for clusters with MetalLB load balancers.
        :param str image: The OS image name in vCenter, only valid when using Windows.
        :param str image_type: The OS image to be used for each node in a node pool. Currently `cos`, `ubuntu`, `ubuntu_containerd` and `windows` are supported.
        :param Mapping[str, str] labels: The map of Kubernetes labels (key/value pairs) to be applied to each node. These will added in addition to any default label(s) that Kubernetes may apply to the node. In case of conflict in label keys, the applied set may differ depending on the Kubernetes version -- it's best to assume the behavior is undefined and conflicts should be avoided. For more information, including usage and the valid values, see: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        :param str memory_mb: The megabytes of memory for each node in the node pool.
        :param str replicas: The number of nodes in the node pool.
        :param Sequence['NodeTaintResponse'] taints: The initial taints assigned to nodes of this node pool.
        :param 'VmwareVsphereConfigResponse' vsphere_config: Specifies the vSphere config for node pool.
        """
        pulumi.set(__self__, "boot_disk_size_gb", boot_disk_size_gb)
        pulumi.set(__self__, "cpus", cpus)
        pulumi.set(__self__, "enable_load_balancer", enable_load_balancer)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "image_type", image_type)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "memory_mb", memory_mb)
        pulumi.set(__self__, "replicas", replicas)
        pulumi.set(__self__, "taints", taints)
        pulumi.set(__self__, "vsphere_config", vsphere_config)

    @property
    @pulumi.getter(name="bootDiskSizeGb")
    def boot_disk_size_gb(self) -> str:
        """
        VMware disk size to be used during creation.
        """
        return pulumi.get(self, "boot_disk_size_gb")

    @property
    @pulumi.getter
    def cpus(self) -> str:
        """
        The number of CPUs for each node in the node pool.
        """
        return pulumi.get(self, "cpus")

    @property
    @pulumi.getter(name="enableLoadBalancer")
    def enable_load_balancer(self) -> bool:
        """
        Allow node pool traffic to be load balanced. Only works for clusters with MetalLB load balancers.
        """
        return pulumi.get(self, "enable_load_balancer")

    @property
    @pulumi.getter
    def image(self) -> str:
        """
        The OS image name in vCenter, only valid when using Windows.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="imageType")
    def image_type(self) -> str:
        """
        The OS image to be used for each node in a node pool. Currently `cos`, `ubuntu`, `ubuntu_containerd` and `windows` are supported.
        """
        return pulumi.get(self, "image_type")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to each node. These will added in addition to any default label(s) that Kubernetes may apply to the node. In case of conflict in label keys, the applied set may differ depending on the Kubernetes version -- it's best to assume the behavior is undefined and conflicts should be avoided. For more information, including usage and the valid values, see: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="memoryMb")
    def memory_mb(self) -> str:
        """
        The megabytes of memory for each node in the node pool.
        """
        return pulumi.get(self, "memory_mb")

    @property
    @pulumi.getter
    def replicas(self) -> str:
        """
        The number of nodes in the node pool.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def taints(self) -> Sequence['outputs.NodeTaintResponse']:
        """
        The initial taints assigned to nodes of this node pool.
        """
        return pulumi.get(self, "taints")

    @property
    @pulumi.getter(name="vsphereConfig")
    def vsphere_config(self) -> 'outputs.VmwareVsphereConfigResponse':
        """
        Specifies the vSphere config for node pool.
        """
        return pulumi.get(self, "vsphere_config")


@pulumi.output_type
class VmwareNodePoolAutoscalingConfigResponse(dict):
    """
    NodePoolAutoscaling config for the NodePool to allow for the kubernetes to scale NodePool.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxReplicas":
            suggest = "max_replicas"
        elif key == "minReplicas":
            suggest = "min_replicas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareNodePoolAutoscalingConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareNodePoolAutoscalingConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareNodePoolAutoscalingConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_replicas: int,
                 min_replicas: int):
        """
        NodePoolAutoscaling config for the NodePool to allow for the kubernetes to scale NodePool.
        :param int max_replicas: Maximum number of replicas in the NodePool.
        :param int min_replicas: Minimum number of replicas in the NodePool.
        """
        pulumi.set(__self__, "max_replicas", max_replicas)
        pulumi.set(__self__, "min_replicas", min_replicas)

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> int:
        """
        Maximum number of replicas in the NodePool.
        """
        return pulumi.get(self, "max_replicas")

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> int:
        """
        Minimum number of replicas in the NodePool.
        """
        return pulumi.get(self, "min_replicas")


@pulumi.output_type
class VmwareSeesawConfigResponse(dict):
    """
    VmwareSeesawConfig represents configuration parameters for an already existing Seesaw load balancer. IMPORTANT: Please note that the Anthos On-Prem API will not generate or update Seesaw configurations it can only bind a pre-existing configuration to a new user cluster. IMPORTANT: When attempting to create a user cluster with a pre-existing Seesaw load balancer you will need to follow some preparation steps before calling the 'CreateVmwareCluster' API method. First you will need to create the user cluster's namespace via kubectl. The namespace will need to use the following naming convention : -gke-onprem-mgmt or -gke-onprem-mgmt depending on whether you used the 'VmwareCluster.local_name' to disambiguate collisions; for more context see the documentation of 'VmwareCluster.local_name'. Once the namespace is created you will need to create a secret resource via kubectl. This secret will contain copies of your Seesaw credentials. The Secret must be called 'user-cluster-creds' and contain Seesaw's SSH and Cert credentials. The credentials must be keyed with the following names: 'seesaw-ssh-private-key', 'seesaw-ssh-public-key', 'seesaw-ssh-ca-key', 'seesaw-ssh-ca-cert'.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableHa":
            suggest = "enable_ha"
        elif key == "ipBlocks":
            suggest = "ip_blocks"
        elif key == "masterIp":
            suggest = "master_ip"
        elif key == "stackdriverName":
            suggest = "stackdriver_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareSeesawConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareSeesawConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareSeesawConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_ha: bool,
                 group: str,
                 ip_blocks: Sequence['outputs.VmwareIpBlockResponse'],
                 master_ip: str,
                 stackdriver_name: str,
                 vms: Sequence[str]):
        """
        VmwareSeesawConfig represents configuration parameters for an already existing Seesaw load balancer. IMPORTANT: Please note that the Anthos On-Prem API will not generate or update Seesaw configurations it can only bind a pre-existing configuration to a new user cluster. IMPORTANT: When attempting to create a user cluster with a pre-existing Seesaw load balancer you will need to follow some preparation steps before calling the 'CreateVmwareCluster' API method. First you will need to create the user cluster's namespace via kubectl. The namespace will need to use the following naming convention : -gke-onprem-mgmt or -gke-onprem-mgmt depending on whether you used the 'VmwareCluster.local_name' to disambiguate collisions; for more context see the documentation of 'VmwareCluster.local_name'. Once the namespace is created you will need to create a secret resource via kubectl. This secret will contain copies of your Seesaw credentials. The Secret must be called 'user-cluster-creds' and contain Seesaw's SSH and Cert credentials. The credentials must be keyed with the following names: 'seesaw-ssh-private-key', 'seesaw-ssh-public-key', 'seesaw-ssh-ca-key', 'seesaw-ssh-ca-cert'.
        :param bool enable_ha: Enable two load balancer VMs to achieve a highly-available Seesaw load balancer.
        :param str group: In general the following format should be used for the Seesaw group name: seesaw-for-[cluster_name].
        :param Sequence['VmwareIpBlockResponse'] ip_blocks: The IP Blocks to be used by the Seesaw load balancer
        :param str master_ip: MasterIP is the IP announced by the master of Seesaw group.
        :param str stackdriver_name: Name to be used by Stackdriver.
        :param Sequence[str] vms: Names of the VMs created for this Seesaw group.
        """
        pulumi.set(__self__, "enable_ha", enable_ha)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "ip_blocks", ip_blocks)
        pulumi.set(__self__, "master_ip", master_ip)
        pulumi.set(__self__, "stackdriver_name", stackdriver_name)
        pulumi.set(__self__, "vms", vms)

    @property
    @pulumi.getter(name="enableHa")
    def enable_ha(self) -> bool:
        """
        Enable two load balancer VMs to achieve a highly-available Seesaw load balancer.
        """
        return pulumi.get(self, "enable_ha")

    @property
    @pulumi.getter
    def group(self) -> str:
        """
        In general the following format should be used for the Seesaw group name: seesaw-for-[cluster_name].
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="ipBlocks")
    def ip_blocks(self) -> Sequence['outputs.VmwareIpBlockResponse']:
        """
        The IP Blocks to be used by the Seesaw load balancer
        """
        return pulumi.get(self, "ip_blocks")

    @property
    @pulumi.getter(name="masterIp")
    def master_ip(self) -> str:
        """
        MasterIP is the IP announced by the master of Seesaw group.
        """
        return pulumi.get(self, "master_ip")

    @property
    @pulumi.getter(name="stackdriverName")
    def stackdriver_name(self) -> str:
        """
        Name to be used by Stackdriver.
        """
        return pulumi.get(self, "stackdriver_name")

    @property
    @pulumi.getter
    def vms(self) -> Sequence[str]:
        """
        Names of the VMs created for this Seesaw group.
        """
        return pulumi.get(self, "vms")


@pulumi.output_type
class VmwareStaticIpConfigResponse(dict):
    """
    Represents the network configuration required for the VMware user clusters with Static IP configurations.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipBlocks":
            suggest = "ip_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareStaticIpConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareStaticIpConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareStaticIpConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_blocks: Sequence['outputs.VmwareIpBlockResponse']):
        """
        Represents the network configuration required for the VMware user clusters with Static IP configurations.
        :param Sequence['VmwareIpBlockResponse'] ip_blocks: Represents the configuration values for static IP allocation to nodes.
        """
        pulumi.set(__self__, "ip_blocks", ip_blocks)

    @property
    @pulumi.getter(name="ipBlocks")
    def ip_blocks(self) -> Sequence['outputs.VmwareIpBlockResponse']:
        """
        Represents the configuration values for static IP allocation to nodes.
        """
        return pulumi.get(self, "ip_blocks")


@pulumi.output_type
class VmwareStorageConfigResponse(dict):
    """
    Specifies vSphere CSI components deployment config in the VMware user cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vsphereCsiDisabled":
            suggest = "vsphere_csi_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareStorageConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareStorageConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareStorageConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vsphere_csi_disabled: bool):
        """
        Specifies vSphere CSI components deployment config in the VMware user cluster.
        :param bool vsphere_csi_disabled: Whether or not to deploy vSphere CSI components in the VMware user cluster. Enabled by default.
        """
        pulumi.set(__self__, "vsphere_csi_disabled", vsphere_csi_disabled)

    @property
    @pulumi.getter(name="vsphereCsiDisabled")
    def vsphere_csi_disabled(self) -> bool:
        """
        Whether or not to deploy vSphere CSI components in the VMware user cluster. Enabled by default.
        """
        return pulumi.get(self, "vsphere_csi_disabled")


@pulumi.output_type
class VmwareVCenterConfigResponse(dict):
    """
    Represents configuration for the VMware VCenter for the user cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertData":
            suggest = "ca_cert_data"
        elif key == "resourcePool":
            suggest = "resource_pool"
        elif key == "storagePolicyName":
            suggest = "storage_policy_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareVCenterConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareVCenterConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareVCenterConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: str,
                 ca_cert_data: str,
                 cluster: str,
                 datacenter: str,
                 datastore: str,
                 folder: str,
                 resource_pool: str,
                 storage_policy_name: str):
        """
        Represents configuration for the VMware VCenter for the user cluster.
        :param str address: The vCenter IP address.
        :param str ca_cert_data: Contains the vCenter CA certificate public key for SSL verification.
        :param str cluster: The name of the vCenter cluster for the user cluster.
        :param str datacenter: The name of the vCenter datacenter for the user cluster.
        :param str datastore: The name of the vCenter datastore for the user cluster.
        :param str folder: The name of the vCenter folder for the user cluster.
        :param str resource_pool: The name of the vCenter resource pool for the user cluster.
        :param str storage_policy_name: The name of the vCenter storage policy for the user cluster.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "ca_cert_data", ca_cert_data)
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "datacenter", datacenter)
        pulumi.set(__self__, "datastore", datastore)
        pulumi.set(__self__, "folder", folder)
        pulumi.set(__self__, "resource_pool", resource_pool)
        pulumi.set(__self__, "storage_policy_name", storage_policy_name)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The vCenter IP address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="caCertData")
    def ca_cert_data(self) -> str:
        """
        Contains the vCenter CA certificate public key for SSL verification.
        """
        return pulumi.get(self, "ca_cert_data")

    @property
    @pulumi.getter
    def cluster(self) -> str:
        """
        The name of the vCenter cluster for the user cluster.
        """
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter
    def datacenter(self) -> str:
        """
        The name of the vCenter datacenter for the user cluster.
        """
        return pulumi.get(self, "datacenter")

    @property
    @pulumi.getter
    def datastore(self) -> str:
        """
        The name of the vCenter datastore for the user cluster.
        """
        return pulumi.get(self, "datastore")

    @property
    @pulumi.getter
    def folder(self) -> str:
        """
        The name of the vCenter folder for the user cluster.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter(name="resourcePool")
    def resource_pool(self) -> str:
        """
        The name of the vCenter resource pool for the user cluster.
        """
        return pulumi.get(self, "resource_pool")

    @property
    @pulumi.getter(name="storagePolicyName")
    def storage_policy_name(self) -> str:
        """
        The name of the vCenter storage policy for the user cluster.
        """
        return pulumi.get(self, "storage_policy_name")


@pulumi.output_type
class VmwareVipConfigResponse(dict):
    """
    Specifies the VIP config for the VMware user cluster load balancer.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneVip":
            suggest = "control_plane_vip"
        elif key == "ingressVip":
            suggest = "ingress_vip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareVipConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareVipConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareVipConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_vip: str,
                 ingress_vip: str):
        """
        Specifies the VIP config for the VMware user cluster load balancer.
        :param str control_plane_vip: The VIP which you previously set aside for the Kubernetes API of this cluster.
        :param str ingress_vip: The VIP which you previously set aside for ingress traffic into this cluster.
        """
        pulumi.set(__self__, "control_plane_vip", control_plane_vip)
        pulumi.set(__self__, "ingress_vip", ingress_vip)

    @property
    @pulumi.getter(name="controlPlaneVip")
    def control_plane_vip(self) -> str:
        """
        The VIP which you previously set aside for the Kubernetes API of this cluster.
        """
        return pulumi.get(self, "control_plane_vip")

    @property
    @pulumi.getter(name="ingressVip")
    def ingress_vip(self) -> str:
        """
        The VIP which you previously set aside for ingress traffic into this cluster.
        """
        return pulumi.get(self, "ingress_vip")


@pulumi.output_type
class VmwareVsphereConfigResponse(dict):
    """
    VmwareVsphereConfig represents configuration for the VMware VCenter for node pool.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostGroups":
            suggest = "host_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareVsphereConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareVsphereConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareVsphereConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datastore: str,
                 host_groups: Sequence[str],
                 tags: Sequence['outputs.VmwareVsphereTagResponse']):
        """
        VmwareVsphereConfig represents configuration for the VMware VCenter for node pool.
        :param str datastore: The name of the vCenter datastore. Inherited from the user cluster.
        :param Sequence[str] host_groups: Vsphere host groups to apply to all VMs in the node pool
        :param Sequence['VmwareVsphereTagResponse'] tags: Tags to apply to VMs.
        """
        pulumi.set(__self__, "datastore", datastore)
        pulumi.set(__self__, "host_groups", host_groups)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def datastore(self) -> str:
        """
        The name of the vCenter datastore. Inherited from the user cluster.
        """
        return pulumi.get(self, "datastore")

    @property
    @pulumi.getter(name="hostGroups")
    def host_groups(self) -> Sequence[str]:
        """
        Vsphere host groups to apply to all VMs in the node pool
        """
        return pulumi.get(self, "host_groups")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.VmwareVsphereTagResponse']:
        """
        Tags to apply to VMs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class VmwareVsphereTagResponse(dict):
    """
    VmwareVsphereTag describes a vSphere tag to be placed on VMs in the node pool. For more information, see https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.vcenterhost.doc/GUID-E8E854DD-AA97-4E0C-8419-CE84F93C4058.html
    """
    def __init__(__self__, *,
                 category: str,
                 tag: str):
        """
        VmwareVsphereTag describes a vSphere tag to be placed on VMs in the node pool. For more information, see https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.vcenterhost.doc/GUID-E8E854DD-AA97-4E0C-8419-CE84F93C4058.html
        :param str category: The Vsphere tag category.
        :param str tag: The Vsphere tag name.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        The Vsphere tag category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        The Vsphere tag name.
        """
        return pulumi.get(self, "tag")


