# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AttestationAuthenticatorResponse',
    'AttestationSourceResponse',
    'AttestorPublicKeyResponse',
    'BindingResponse',
    'CheckResponse',
    'CheckSetResponse',
    'ExprResponse',
    'GkePolicyResponse',
    'ImageAllowlistResponse',
    'ImageFreshnessCheckResponse',
    'PkixPublicKeyResponse',
    'PkixPublicKeySetResponse',
    'ScopeResponse',
    'SimpleSigningAttestationCheckResponse',
    'SlsaCheckResponse',
    'TrustedDirectoryCheckResponse',
    'UserOwnedGrafeasNoteResponse',
    'VerificationRuleResponse',
    'VulnerabilityCheckResponse',
]

@pulumi.output_type
class AttestationAuthenticatorResponse(dict):
    """
    An attestation authenticator that will be used to verify attestations. Typically this is just a set of public keys. Conceptually, an authenticator can be treated as always returning either "authenticated" or "not authenticated" when presented with a signed attestation (almost always assumed to be a [DSSE](https://github.com/secure-systems-lab/dsse) attestation). The details of how an authenticator makes this decision are specific to the type of 'authenticator' that this message wraps.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "pkixPublicKeySet":
            suggest = "pkix_public_key_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AttestationAuthenticatorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AttestationAuthenticatorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AttestationAuthenticatorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: str,
                 pkix_public_key_set: 'outputs.PkixPublicKeySetResponse'):
        """
        An attestation authenticator that will be used to verify attestations. Typically this is just a set of public keys. Conceptually, an authenticator can be treated as always returning either "authenticated" or "not authenticated" when presented with a signed attestation (almost always assumed to be a [DSSE](https://github.com/secure-systems-lab/dsse) attestation). The details of how an authenticator makes this decision are specific to the type of 'authenticator' that this message wraps.
        :param str display_name: Optional. A user-provided name for this `AttestationAuthenticator`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
        :param 'PkixPublicKeySetResponse' pkix_public_key_set: Optional. A set of raw PKIX SubjectPublicKeyInfo format public keys. If any public key in the set validates the attestation signature, then the signature is considered authenticated (i.e. any one key is sufficient to authenticate).
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "pkix_public_key_set", pkix_public_key_set)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        Optional. A user-provided name for this `AttestationAuthenticator`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="pkixPublicKeySet")
    def pkix_public_key_set(self) -> 'outputs.PkixPublicKeySetResponse':
        """
        Optional. A set of raw PKIX SubjectPublicKeyInfo format public keys. If any public key in the set validates the attestation signature, then the signature is considered authenticated (i.e. any one key is sufficient to authenticate).
        """
        return pulumi.get(self, "pkix_public_key_set")


@pulumi.output_type
class AttestationSourceResponse(dict):
    """
    Specifies the locations for fetching the provenance attestations.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerAnalysisAttestationProjects":
            suggest = "container_analysis_attestation_projects"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AttestationSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AttestationSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AttestationSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_analysis_attestation_projects: Sequence[str]):
        """
        Specifies the locations for fetching the provenance attestations.
        :param Sequence[str] container_analysis_attestation_projects: The IDs of the GCP projects storing the SLSA attestations as Container Analysis Occurrences.
        """
        pulumi.set(__self__, "container_analysis_attestation_projects", container_analysis_attestation_projects)

    @property
    @pulumi.getter(name="containerAnalysisAttestationProjects")
    def container_analysis_attestation_projects(self) -> Sequence[str]:
        """
        The IDs of the GCP projects storing the SLSA attestations as Container Analysis Occurrences.
        """
        return pulumi.get(self, "container_analysis_attestation_projects")


@pulumi.output_type
class AttestorPublicKeyResponse(dict):
    """
    An attestor public key that will be used to verify attestations signed by this attestor.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "asciiArmoredPgpPublicKey":
            suggest = "ascii_armored_pgp_public_key"
        elif key == "pkixPublicKey":
            suggest = "pkix_public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AttestorPublicKeyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AttestorPublicKeyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AttestorPublicKeyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ascii_armored_pgp_public_key: str,
                 comment: str,
                 pkix_public_key: 'outputs.PkixPublicKeyResponse'):
        """
        An attestor public key that will be used to verify attestations signed by this attestor.
        :param str ascii_armored_pgp_public_key: ASCII-armored representation of a PGP public key, as the entire output by the command `gpg --export --armor foo@example.com` (either LF or CRLF line endings). When using this field, `id` should be left blank. The Binary Authorization API handlers will calculate the ID and fill it in automatically. Binary Authorization computes this ID as the OpenPGP RFC4880 V4 fingerprint, represented as upper-case hex. If `id` is provided by the caller, it will be overwritten by the API-calculated ID.
        :param str comment: Optional. A descriptive comment. This field may be updated.
        :param 'PkixPublicKeyResponse' pkix_public_key: A raw PKIX SubjectPublicKeyInfo format public key. NOTE: `id` may be explicitly provided by the caller when using this type of public key, but it MUST be a valid RFC3986 URI. If `id` is left blank, a default one will be computed based on the digest of the DER encoding of the public key.
        """
        pulumi.set(__self__, "ascii_armored_pgp_public_key", ascii_armored_pgp_public_key)
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "pkix_public_key", pkix_public_key)

    @property
    @pulumi.getter(name="asciiArmoredPgpPublicKey")
    def ascii_armored_pgp_public_key(self) -> str:
        """
        ASCII-armored representation of a PGP public key, as the entire output by the command `gpg --export --armor foo@example.com` (either LF or CRLF line endings). When using this field, `id` should be left blank. The Binary Authorization API handlers will calculate the ID and fill it in automatically. Binary Authorization computes this ID as the OpenPGP RFC4880 V4 fingerprint, represented as upper-case hex. If `id` is provided by the caller, it will be overwritten by the API-calculated ID.
        """
        return pulumi.get(self, "ascii_armored_pgp_public_key")

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        Optional. A descriptive comment. This field may be updated.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="pkixPublicKey")
    def pkix_public_key(self) -> 'outputs.PkixPublicKeyResponse':
        """
        A raw PKIX SubjectPublicKeyInfo format public key. NOTE: `id` may be explicitly provided by the caller when using this type of public key, but it MUST be a valid RFC3986 URI. If `id` is left blank, a default one will be computed based on the digest of the DER encoding of the public key.
        """
        return pulumi.get(self, "pkix_public_key")


@pulumi.output_type
class BindingResponse(dict):
    """
    Associates `members`, or principals, with a `role`.
    """
    def __init__(__self__, *,
                 condition: 'outputs.ExprResponse',
                 members: Sequence[str],
                 role: str):
        """
        Associates `members`, or principals, with a `role`.
        :param 'ExprResponse' condition: The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        :param Sequence[str] members: Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
        :param str role: Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "members", members)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.ExprResponse':
        """
        The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def members(self) -> Sequence[str]:
        """
        Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
        """
        return pulumi.get(self, "members")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class CheckResponse(dict):
    """
    A single check to perform against a Pod. Checks are grouped into `CheckSet` objects, which are defined by the top-level policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysDeny":
            suggest = "always_deny"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "imageAllowlist":
            suggest = "image_allowlist"
        elif key == "imageFreshnessCheck":
            suggest = "image_freshness_check"
        elif key == "simpleSigningAttestationCheck":
            suggest = "simple_signing_attestation_check"
        elif key == "slsaCheck":
            suggest = "slsa_check"
        elif key == "trustedDirectoryCheck":
            suggest = "trusted_directory_check"
        elif key == "vulnerabilityCheck":
            suggest = "vulnerability_check"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_deny: bool,
                 display_name: str,
                 image_allowlist: 'outputs.ImageAllowlistResponse',
                 image_freshness_check: 'outputs.ImageFreshnessCheckResponse',
                 simple_signing_attestation_check: 'outputs.SimpleSigningAttestationCheckResponse',
                 slsa_check: 'outputs.SlsaCheckResponse',
                 trusted_directory_check: 'outputs.TrustedDirectoryCheckResponse',
                 vulnerability_check: 'outputs.VulnerabilityCheckResponse'):
        """
        A single check to perform against a Pod. Checks are grouped into `CheckSet` objects, which are defined by the top-level policy.
        :param bool always_deny: Optional. A special-case check that always denies. Note that this still only applies when the scope of the `CheckSet` applies and the image isn't exempted by an image allowlist. This check is primarily useful for testing, or to set the default behavior for all unmatched scopes to "deny".
        :param str display_name: Optional. A user-provided name for this check. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
        :param 'ImageAllowlistResponse' image_allowlist: Optional. Images exempted from this check. If any of the patterns match the image url, the check will not be evaluated.
        :param 'ImageFreshnessCheckResponse' image_freshness_check: Optional. Require that an image is no older than a configured expiration time. Image age is determined by its upload time.
        :param 'SimpleSigningAttestationCheckResponse' simple_signing_attestation_check: Optional. Require a SimpleSigning-type attestation for every image in the deployment.
        :param 'SlsaCheckResponse' slsa_check: Optional. Require that an image was built by a trusted builder (such as Google Cloud Build), meets requirements for Supply chain Levels for Software Artifacts (SLSA), and was built from a trusted source code repostitory.
        :param 'TrustedDirectoryCheckResponse' trusted_directory_check: Optional. Require that an image lives in a trusted directory.
        :param 'VulnerabilityCheckResponse' vulnerability_check: Optional. Require that an image does not contain vulnerabilities that violate the configured rules, such as based on severity levels.
        """
        pulumi.set(__self__, "always_deny", always_deny)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "image_allowlist", image_allowlist)
        pulumi.set(__self__, "image_freshness_check", image_freshness_check)
        pulumi.set(__self__, "simple_signing_attestation_check", simple_signing_attestation_check)
        pulumi.set(__self__, "slsa_check", slsa_check)
        pulumi.set(__self__, "trusted_directory_check", trusted_directory_check)
        pulumi.set(__self__, "vulnerability_check", vulnerability_check)

    @property
    @pulumi.getter(name="alwaysDeny")
    def always_deny(self) -> bool:
        """
        Optional. A special-case check that always denies. Note that this still only applies when the scope of the `CheckSet` applies and the image isn't exempted by an image allowlist. This check is primarily useful for testing, or to set the default behavior for all unmatched scopes to "deny".
        """
        return pulumi.get(self, "always_deny")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        Optional. A user-provided name for this check. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="imageAllowlist")
    def image_allowlist(self) -> 'outputs.ImageAllowlistResponse':
        """
        Optional. Images exempted from this check. If any of the patterns match the image url, the check will not be evaluated.
        """
        return pulumi.get(self, "image_allowlist")

    @property
    @pulumi.getter(name="imageFreshnessCheck")
    def image_freshness_check(self) -> 'outputs.ImageFreshnessCheckResponse':
        """
        Optional. Require that an image is no older than a configured expiration time. Image age is determined by its upload time.
        """
        return pulumi.get(self, "image_freshness_check")

    @property
    @pulumi.getter(name="simpleSigningAttestationCheck")
    def simple_signing_attestation_check(self) -> 'outputs.SimpleSigningAttestationCheckResponse':
        """
        Optional. Require a SimpleSigning-type attestation for every image in the deployment.
        """
        return pulumi.get(self, "simple_signing_attestation_check")

    @property
    @pulumi.getter(name="slsaCheck")
    def slsa_check(self) -> 'outputs.SlsaCheckResponse':
        """
        Optional. Require that an image was built by a trusted builder (such as Google Cloud Build), meets requirements for Supply chain Levels for Software Artifacts (SLSA), and was built from a trusted source code repostitory.
        """
        return pulumi.get(self, "slsa_check")

    @property
    @pulumi.getter(name="trustedDirectoryCheck")
    def trusted_directory_check(self) -> 'outputs.TrustedDirectoryCheckResponse':
        """
        Optional. Require that an image lives in a trusted directory.
        """
        return pulumi.get(self, "trusted_directory_check")

    @property
    @pulumi.getter(name="vulnerabilityCheck")
    def vulnerability_check(self) -> 'outputs.VulnerabilityCheckResponse':
        """
        Optional. Require that an image does not contain vulnerabilities that violate the configured rules, such as based on severity levels.
        """
        return pulumi.get(self, "vulnerability_check")


@pulumi.output_type
class CheckSetResponse(dict):
    """
    A conjunction of policy checks, scoped to a particular namespace or Kubernetes service account. In order for evaluation of a `CheckSet` to return "allowed" for a given image in a given Pod, one of the following conditions must be satisfied: * The image is explicitly exempted by an entry in `image_allowlist`, OR * ALL of the `checks` evaluate to "allowed".
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "imageAllowlist":
            suggest = "image_allowlist"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckSetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckSetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckSetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 checks: Sequence['outputs.CheckResponse'],
                 display_name: str,
                 image_allowlist: 'outputs.ImageAllowlistResponse',
                 scope: 'outputs.ScopeResponse'):
        """
        A conjunction of policy checks, scoped to a particular namespace or Kubernetes service account. In order for evaluation of a `CheckSet` to return "allowed" for a given image in a given Pod, one of the following conditions must be satisfied: * The image is explicitly exempted by an entry in `image_allowlist`, OR * ALL of the `checks` evaluate to "allowed".
        :param Sequence['CheckResponse'] checks: Optional. The checks to apply. The ultimate result of evaluating the check set will be "allow" if and only if every check in `checks` evaluates to "allow". If `checks` is empty, the default behavior is "always allow".
        :param str display_name: Optional. A user-provided name for this `CheckSet`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
        :param 'ImageAllowlistResponse' image_allowlist: Optional. Images exempted from this `CheckSet`. If any of the patterns match the image being evaluated, no checks in the `CheckSet` will be evaluated.
        :param 'ScopeResponse' scope: Optional. The scope to which this `CheckSet` applies. If unset or an empty string (the default), applies to all namespaces and service accounts. See the `Scope` message documentation for details on scoping rules.
        """
        pulumi.set(__self__, "checks", checks)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "image_allowlist", image_allowlist)
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def checks(self) -> Sequence['outputs.CheckResponse']:
        """
        Optional. The checks to apply. The ultimate result of evaluating the check set will be "allow" if and only if every check in `checks` evaluates to "allow". If `checks` is empty, the default behavior is "always allow".
        """
        return pulumi.get(self, "checks")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        Optional. A user-provided name for this `CheckSet`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="imageAllowlist")
    def image_allowlist(self) -> 'outputs.ImageAllowlistResponse':
        """
        Optional. Images exempted from this `CheckSet`. If any of the patterns match the image being evaluated, no checks in the `CheckSet` will be evaluated.
        """
        return pulumi.get(self, "image_allowlist")

    @property
    @pulumi.getter
    def scope(self) -> 'outputs.ScopeResponse':
        """
        Optional. The scope to which this `CheckSet` applies. If unset or an empty string (the default), applies to all namespaces and service accounts. See the `Scope` message documentation for details on scoping rules.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class ExprResponse(dict):
    """
    Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
    """
    def __init__(__self__, *,
                 description: str,
                 expression: str,
                 location: str,
                 title: str):
        """
        Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
        :param str description: Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        :param str expression: Textual representation of an expression in Common Expression Language syntax.
        :param str location: Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
        :param str title: Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GkePolicyResponse(dict):
    """
    A Binary Authorization policy for a GKE cluster. This is one type of policy that can occur as a `PlatformPolicy`.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkSets":
            suggest = "check_sets"
        elif key == "imageAllowlist":
            suggest = "image_allowlist"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GkePolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GkePolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GkePolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_sets: Sequence['outputs.CheckSetResponse'],
                 image_allowlist: 'outputs.ImageAllowlistResponse'):
        """
        A Binary Authorization policy for a GKE cluster. This is one type of policy that can occur as a `PlatformPolicy`.
        :param Sequence['CheckSetResponse'] check_sets: Optional. The `CheckSet` objects to apply, scoped by namespace or namespace and service account. Exactly one `CheckSet` will be evaluated for a given Pod (unless the list is empty, in which case the behavior is "always allow"). If multiple `CheckSet` objects have scopes that match the namespace and service account of the Pod being evaluated, only the `CheckSet` with the MOST SPECIFIC scope will match. `CheckSet` objects must be listed in order of decreasing specificity, i.e. if a scope matches a given service account (which must include the namespace), it must come before a `CheckSet` with a scope matching just that namespace. This property is enforced by server-side validation. The purpose of this restriction is to ensure that if more than one `CheckSet` matches a given Pod, the `CheckSet` that will be evaluated will always be the first in the list to match (because if any other matches, it must be less specific). If `check_sets` is empty, the default behavior is to allow all images. If `check_sets` is non-empty, the last `check_sets` entry must always be a `CheckSet` with no scope set, i.e. a catchall to handle any situation not caught by the preceding `CheckSet` objects.
        :param 'ImageAllowlistResponse' image_allowlist: Optional. Images exempted from this policy. If any of the patterns match the image being evaluated, the rest of the policy will not be evaluated.
        """
        pulumi.set(__self__, "check_sets", check_sets)
        pulumi.set(__self__, "image_allowlist", image_allowlist)

    @property
    @pulumi.getter(name="checkSets")
    def check_sets(self) -> Sequence['outputs.CheckSetResponse']:
        """
        Optional. The `CheckSet` objects to apply, scoped by namespace or namespace and service account. Exactly one `CheckSet` will be evaluated for a given Pod (unless the list is empty, in which case the behavior is "always allow"). If multiple `CheckSet` objects have scopes that match the namespace and service account of the Pod being evaluated, only the `CheckSet` with the MOST SPECIFIC scope will match. `CheckSet` objects must be listed in order of decreasing specificity, i.e. if a scope matches a given service account (which must include the namespace), it must come before a `CheckSet` with a scope matching just that namespace. This property is enforced by server-side validation. The purpose of this restriction is to ensure that if more than one `CheckSet` matches a given Pod, the `CheckSet` that will be evaluated will always be the first in the list to match (because if any other matches, it must be less specific). If `check_sets` is empty, the default behavior is to allow all images. If `check_sets` is non-empty, the last `check_sets` entry must always be a `CheckSet` with no scope set, i.e. a catchall to handle any situation not caught by the preceding `CheckSet` objects.
        """
        return pulumi.get(self, "check_sets")

    @property
    @pulumi.getter(name="imageAllowlist")
    def image_allowlist(self) -> 'outputs.ImageAllowlistResponse':
        """
        Optional. Images exempted from this policy. If any of the patterns match the image being evaluated, the rest of the policy will not be evaluated.
        """
        return pulumi.get(self, "image_allowlist")


@pulumi.output_type
class ImageAllowlistResponse(dict):
    """
    Images that are exempted from normal checks based on name pattern only.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPattern":
            suggest = "allow_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageAllowlistResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageAllowlistResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageAllowlistResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_pattern: Sequence[str]):
        """
        Images that are exempted from normal checks based on name pattern only.
        :param Sequence[str] allow_pattern: A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
        """
        pulumi.set(__self__, "allow_pattern", allow_pattern)

    @property
    @pulumi.getter(name="allowPattern")
    def allow_pattern(self) -> Sequence[str]:
        """
        A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
        """
        return pulumi.get(self, "allow_pattern")


@pulumi.output_type
class ImageFreshnessCheckResponse(dict):
    """
    An image freshness check, which rejects images that were uploaded before the set number of days ago to the supported repositories.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxUploadAgeDays":
            suggest = "max_upload_age_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageFreshnessCheckResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageFreshnessCheckResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageFreshnessCheckResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_upload_age_days: int):
        """
        An image freshness check, which rejects images that were uploaded before the set number of days ago to the supported repositories.
        :param int max_upload_age_days: The max number of days that is allowed since the image was uploaded. Must be greater than zero.
        """
        pulumi.set(__self__, "max_upload_age_days", max_upload_age_days)

    @property
    @pulumi.getter(name="maxUploadAgeDays")
    def max_upload_age_days(self) -> int:
        """
        The max number of days that is allowed since the image was uploaded. Must be greater than zero.
        """
        return pulumi.get(self, "max_upload_age_days")


@pulumi.output_type
class PkixPublicKeyResponse(dict):
    """
    A public key in the PkixPublicKey [format](https://tools.ietf.org/html/rfc5280#section-4.1.2.7). Public keys of this type are typically textually encoded using the PEM format.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyId":
            suggest = "key_id"
        elif key == "publicKeyPem":
            suggest = "public_key_pem"
        elif key == "signatureAlgorithm":
            suggest = "signature_algorithm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PkixPublicKeyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PkixPublicKeyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PkixPublicKeyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_id: str,
                 public_key_pem: str,
                 signature_algorithm: str):
        """
        A public key in the PkixPublicKey [format](https://tools.ietf.org/html/rfc5280#section-4.1.2.7). Public keys of this type are typically textually encoded using the PEM format.
        :param str key_id: Optional. The ID of this public key. Signatures verified by Binary Authorization must include the ID of the public key that can be used to verify them, and that ID must match the contents of this field exactly. This may be explicitly provided by the caller, but it MUST be a valid RFC3986 URI. If `key_id` is left blank and this `PkixPublicKey` is not used in the context of a wrapper (see next paragraph), a default key ID will be computed based on the digest of the DER encoding of the public key. If this `PkixPublicKey` is used in the context of a wrapper that has its own notion of key ID (e.g. `AttestorPublicKey`), then this field can either: * Match that value exactly. * Or be left blank, in which case it behaves exactly as though it is equal to that wrapper value.
        :param str public_key_pem: A PEM-encoded public key, as described in https://tools.ietf.org/html/rfc7468#section-13
        :param str signature_algorithm: The signature algorithm used to verify a message against a signature using this key. These signature algorithm must match the structure and any object identifiers encoded in `public_key_pem` (i.e. this algorithm must match that of the public key).
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "public_key_pem", public_key_pem)
        pulumi.set(__self__, "signature_algorithm", signature_algorithm)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> str:
        """
        Optional. The ID of this public key. Signatures verified by Binary Authorization must include the ID of the public key that can be used to verify them, and that ID must match the contents of this field exactly. This may be explicitly provided by the caller, but it MUST be a valid RFC3986 URI. If `key_id` is left blank and this `PkixPublicKey` is not used in the context of a wrapper (see next paragraph), a default key ID will be computed based on the digest of the DER encoding of the public key. If this `PkixPublicKey` is used in the context of a wrapper that has its own notion of key ID (e.g. `AttestorPublicKey`), then this field can either: * Match that value exactly. * Or be left blank, in which case it behaves exactly as though it is equal to that wrapper value.
        """
        return pulumi.get(self, "key_id")

    @property
    @pulumi.getter(name="publicKeyPem")
    def public_key_pem(self) -> str:
        """
        A PEM-encoded public key, as described in https://tools.ietf.org/html/rfc7468#section-13
        """
        return pulumi.get(self, "public_key_pem")

    @property
    @pulumi.getter(name="signatureAlgorithm")
    def signature_algorithm(self) -> str:
        """
        The signature algorithm used to verify a message against a signature using this key. These signature algorithm must match the structure and any object identifiers encoded in `public_key_pem` (i.e. this algorithm must match that of the public key).
        """
        return pulumi.get(self, "signature_algorithm")


@pulumi.output_type
class PkixPublicKeySetResponse(dict):
    """
    A bundle of PKIX public keys, used to authenticate attestation signatures. Generally, a signature is considered to be authenticated by a `PkixPublicKeySet` if any of the public keys verify it (i.e. it is an "OR" of the keys).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pkixPublicKeys":
            suggest = "pkix_public_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PkixPublicKeySetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PkixPublicKeySetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PkixPublicKeySetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pkix_public_keys: Sequence['outputs.PkixPublicKeyResponse']):
        """
        A bundle of PKIX public keys, used to authenticate attestation signatures. Generally, a signature is considered to be authenticated by a `PkixPublicKeySet` if any of the public keys verify it (i.e. it is an "OR" of the keys).
        :param Sequence['PkixPublicKeyResponse'] pkix_public_keys: `pkix_public_keys` must have at least one entry.
        """
        pulumi.set(__self__, "pkix_public_keys", pkix_public_keys)

    @property
    @pulumi.getter(name="pkixPublicKeys")
    def pkix_public_keys(self) -> Sequence['outputs.PkixPublicKeyResponse']:
        """
        `pkix_public_keys` must have at least one entry.
        """
        return pulumi.get(self, "pkix_public_keys")


@pulumi.output_type
class ScopeResponse(dict):
    """
    A scope specifier for `CheckSet` objects.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kubernetesNamespace":
            suggest = "kubernetes_namespace"
        elif key == "kubernetesServiceAccount":
            suggest = "kubernetes_service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScopeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScopeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScopeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kubernetes_namespace: str,
                 kubernetes_service_account: str):
        """
        A scope specifier for `CheckSet` objects.
        :param str kubernetes_namespace: Optional. Matches all Kubernetes service accounts in the provided namespace, unless a more specific `kubernetes_service_account` scope already matched.
        :param str kubernetes_service_account: Optional. Matches a single Kubernetes service account, e.g. `my-namespace:my-service-account`. `kubernetes_service_account` scope is always more specific than `kubernetes_namespace` scope for the same namespace.
        """
        pulumi.set(__self__, "kubernetes_namespace", kubernetes_namespace)
        pulumi.set(__self__, "kubernetes_service_account", kubernetes_service_account)

    @property
    @pulumi.getter(name="kubernetesNamespace")
    def kubernetes_namespace(self) -> str:
        """
        Optional. Matches all Kubernetes service accounts in the provided namespace, unless a more specific `kubernetes_service_account` scope already matched.
        """
        return pulumi.get(self, "kubernetes_namespace")

    @property
    @pulumi.getter(name="kubernetesServiceAccount")
    def kubernetes_service_account(self) -> str:
        """
        Optional. Matches a single Kubernetes service account, e.g. `my-namespace:my-service-account`. `kubernetes_service_account` scope is always more specific than `kubernetes_namespace` scope for the same namespace.
        """
        return pulumi.get(self, "kubernetes_service_account")


@pulumi.output_type
class SimpleSigningAttestationCheckResponse(dict):
    """
    Require a signed [DSSE](https://github.com/secure-systems-lab/dsse) attestation with type SimpleSigning.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attestationAuthenticators":
            suggest = "attestation_authenticators"
        elif key == "containerAnalysisAttestationProjects":
            suggest = "container_analysis_attestation_projects"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SimpleSigningAttestationCheckResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SimpleSigningAttestationCheckResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SimpleSigningAttestationCheckResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attestation_authenticators: Sequence['outputs.AttestationAuthenticatorResponse'],
                 container_analysis_attestation_projects: Sequence[str]):
        """
        Require a signed [DSSE](https://github.com/secure-systems-lab/dsse) attestation with type SimpleSigning.
        :param Sequence['AttestationAuthenticatorResponse'] attestation_authenticators: The authenticators required by this check to verify an attestation. Typically this is one or more PKIX public keys for signature verification. Only one authenticator needs to consider an attestation verified in order for an attestation to be considered fully authenticated. In otherwords, this list of authenticators is an "OR" of the authenticator results. At least one authenticator is required.
        :param Sequence[str] container_analysis_attestation_projects: Optional. The projects where attestations are stored as Container Analysis Occurrences. Only one attestation needs to successfully verify an image for this check to pass, so a single verified attestation found in any of `container_analysis_attestation_projects` is sufficient for the check to pass. When fetching Occurrences from Container Analysis, only 'AttestationOccurrence' kinds are considered. In the future, additional Occurrence kinds may be added to the query.
        """
        pulumi.set(__self__, "attestation_authenticators", attestation_authenticators)
        pulumi.set(__self__, "container_analysis_attestation_projects", container_analysis_attestation_projects)

    @property
    @pulumi.getter(name="attestationAuthenticators")
    def attestation_authenticators(self) -> Sequence['outputs.AttestationAuthenticatorResponse']:
        """
        The authenticators required by this check to verify an attestation. Typically this is one or more PKIX public keys for signature verification. Only one authenticator needs to consider an attestation verified in order for an attestation to be considered fully authenticated. In otherwords, this list of authenticators is an "OR" of the authenticator results. At least one authenticator is required.
        """
        return pulumi.get(self, "attestation_authenticators")

    @property
    @pulumi.getter(name="containerAnalysisAttestationProjects")
    def container_analysis_attestation_projects(self) -> Sequence[str]:
        """
        Optional. The projects where attestations are stored as Container Analysis Occurrences. Only one attestation needs to successfully verify an image for this check to pass, so a single verified attestation found in any of `container_analysis_attestation_projects` is sufficient for the check to pass. When fetching Occurrences from Container Analysis, only 'AttestationOccurrence' kinds are considered. In the future, additional Occurrence kinds may be added to the query.
        """
        return pulumi.get(self, "container_analysis_attestation_projects")


@pulumi.output_type
class SlsaCheckResponse(dict):
    """
    A SLSA provenance attestation check, which ensures that images are built by a trusted builder using source code from its trusted repositories only.
    """
    def __init__(__self__, *,
                 rules: Sequence['outputs.VerificationRuleResponse']):
        """
        A SLSA provenance attestation check, which ensures that images are built by a trusted builder using source code from its trusted repositories only.
        :param Sequence['VerificationRuleResponse'] rules: Specifies a list of verification rules for the SLSA attestations. An image is considered compliant with the SlsaCheck if any of the rules are satisfied.
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.VerificationRuleResponse']:
        """
        Specifies a list of verification rules for the SLSA attestations. An image is considered compliant with the SlsaCheck if any of the rules are satisfied.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class TrustedDirectoryCheckResponse(dict):
    """
    A trusted directory check, which rejects images that do not come from the set of user-configured trusted directories.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustedDirPatterns":
            suggest = "trusted_dir_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrustedDirectoryCheckResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrustedDirectoryCheckResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrustedDirectoryCheckResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trusted_dir_patterns: Sequence[str]):
        """
        A trusted directory check, which rejects images that do not come from the set of user-configured trusted directories.
        :param Sequence[str] trusted_dir_patterns: List of trusted directory patterns. A pattern is in the form "registry/path/to/directory". The registry domain part is defined as two or more dot-separated words, e.g., `us.pkg.dev`, or `gcr.io`. Additionally, `*` can be used in three ways as wildcards: 1. leading `*` to match varying prefixes in registry subdomain (useful for location prefixes); 2. trailing `*` after registry/ to match varying endings; 3. trailing `**` after registry/ to match "/" as well. For example: -- `gcr.io/my-project/my-repo` is valid to match a single directory -- `*-docker.pkg.dev/my-project/my-repo` or `*.gcr.io/my-project` are valid to match varying prefixes -- `gcr.io/my-project/*` will match all direct directories in `my-project` -- `gcr.io/my-project/**` would match all directories in `my-project` -- `gcr.i*` is not allowed since the registry is not completely specified -- `sub*domain.gcr.io/nginx` is not valid because only leading `*` or trailing `*` are allowed. -- `*pkg.dev/my-project/my-repo` is not valid because leading `*` can only match subdomain -- `**-docker.pkg.dev` is not valid because one leading `*` is allowed, and that it cannot match `/`
        """
        pulumi.set(__self__, "trusted_dir_patterns", trusted_dir_patterns)

    @property
    @pulumi.getter(name="trustedDirPatterns")
    def trusted_dir_patterns(self) -> Sequence[str]:
        """
        List of trusted directory patterns. A pattern is in the form "registry/path/to/directory". The registry domain part is defined as two or more dot-separated words, e.g., `us.pkg.dev`, or `gcr.io`. Additionally, `*` can be used in three ways as wildcards: 1. leading `*` to match varying prefixes in registry subdomain (useful for location prefixes); 2. trailing `*` after registry/ to match varying endings; 3. trailing `**` after registry/ to match "/" as well. For example: -- `gcr.io/my-project/my-repo` is valid to match a single directory -- `*-docker.pkg.dev/my-project/my-repo` or `*.gcr.io/my-project` are valid to match varying prefixes -- `gcr.io/my-project/*` will match all direct directories in `my-project` -- `gcr.io/my-project/**` would match all directories in `my-project` -- `gcr.i*` is not allowed since the registry is not completely specified -- `sub*domain.gcr.io/nginx` is not valid because only leading `*` or trailing `*` are allowed. -- `*pkg.dev/my-project/my-repo` is not valid because leading `*` can only match subdomain -- `**-docker.pkg.dev` is not valid because one leading `*` is allowed, and that it cannot match `/`
        """
        return pulumi.get(self, "trusted_dir_patterns")


@pulumi.output_type
class UserOwnedGrafeasNoteResponse(dict):
    """
    An user owned Grafeas note references a Grafeas Attestation.Authority Note created by the user.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delegationServiceAccountEmail":
            suggest = "delegation_service_account_email"
        elif key == "noteReference":
            suggest = "note_reference"
        elif key == "publicKeys":
            suggest = "public_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserOwnedGrafeasNoteResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserOwnedGrafeasNoteResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserOwnedGrafeasNoteResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delegation_service_account_email: str,
                 note_reference: str,
                 public_keys: Sequence['outputs.AttestorPublicKeyResponse']):
        """
        An user owned Grafeas note references a Grafeas Attestation.Authority Note created by the user.
        :param str delegation_service_account_email: This field will contain the service account email address that this attestor will use as the principal when querying Container Analysis. Attestor administrators must grant this service account the IAM role needed to read attestations from the note_reference in Container Analysis (`containeranalysis.notes.occurrences.viewer`). This email address is fixed for the lifetime of the attestor, but callers should not make any other assumptions about the service account email; future versions may use an email based on a different naming pattern.
        :param str note_reference: The Grafeas resource name of a Attestation.Authority Note, created by the user, in the format: `projects/*/notes/*`. This field may not be updated. An attestation by this attestor is stored as a Grafeas Attestation.Authority Occurrence that names a container image and that links to this Note. Grafeas is an external dependency.
        :param Sequence['AttestorPublicKeyResponse'] public_keys: Optional. Public keys that verify attestations signed by this attestor. This field may be updated. If this field is non-empty, one of the specified public keys must verify that an attestation was signed by this attestor for the image specified in the admission request. If this field is empty, this attestor always returns that no valid attestations exist.
        """
        pulumi.set(__self__, "delegation_service_account_email", delegation_service_account_email)
        pulumi.set(__self__, "note_reference", note_reference)
        pulumi.set(__self__, "public_keys", public_keys)

    @property
    @pulumi.getter(name="delegationServiceAccountEmail")
    def delegation_service_account_email(self) -> str:
        """
        This field will contain the service account email address that this attestor will use as the principal when querying Container Analysis. Attestor administrators must grant this service account the IAM role needed to read attestations from the note_reference in Container Analysis (`containeranalysis.notes.occurrences.viewer`). This email address is fixed for the lifetime of the attestor, but callers should not make any other assumptions about the service account email; future versions may use an email based on a different naming pattern.
        """
        return pulumi.get(self, "delegation_service_account_email")

    @property
    @pulumi.getter(name="noteReference")
    def note_reference(self) -> str:
        """
        The Grafeas resource name of a Attestation.Authority Note, created by the user, in the format: `projects/*/notes/*`. This field may not be updated. An attestation by this attestor is stored as a Grafeas Attestation.Authority Occurrence that names a container image and that links to this Note. Grafeas is an external dependency.
        """
        return pulumi.get(self, "note_reference")

    @property
    @pulumi.getter(name="publicKeys")
    def public_keys(self) -> Sequence['outputs.AttestorPublicKeyResponse']:
        """
        Optional. Public keys that verify attestations signed by this attestor. This field may be updated. If this field is non-empty, one of the specified public keys must verify that an attestation was signed by this attestor for the image specified in the admission request. If this field is empty, this attestor always returns that no valid attestations exist.
        """
        return pulumi.get(self, "public_keys")


@pulumi.output_type
class VerificationRuleResponse(dict):
    """
    Specifies verification rules for evaluating the SLSA attestations including: which builders to trust, where to fetch the SLSA attestations generated by those builders, and other builder-specific evaluation rules such as which source repositories are trusted. An image is considered verified by the rule if any of the fetched SLSA attestations is verified.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attestationSource":
            suggest = "attestation_source"
        elif key == "configBasedBuildRequired":
            suggest = "config_based_build_required"
        elif key == "trustedBuilder":
            suggest = "trusted_builder"
        elif key == "trustedSourceRepoPatterns":
            suggest = "trusted_source_repo_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerificationRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerificationRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerificationRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attestation_source: 'outputs.AttestationSourceResponse',
                 config_based_build_required: bool,
                 trusted_builder: str,
                 trusted_source_repo_patterns: Sequence[str]):
        """
        Specifies verification rules for evaluating the SLSA attestations including: which builders to trust, where to fetch the SLSA attestations generated by those builders, and other builder-specific evaluation rules such as which source repositories are trusted. An image is considered verified by the rule if any of the fetched SLSA attestations is verified.
        :param 'AttestationSourceResponse' attestation_source: Specifies where to fetch the provenances attestations generated by the builder (group).
        :param bool config_based_build_required: If true, require the image to be built from a top-level configuration. `trusted_source_repo_patterns` specifies the repositories containing this configuration.
        :param str trusted_builder: Each verification rule is used for evaluation against provenances generated by a specific builder (group). For some of the builders, such as the Google Cloud Build, users don't need to explicitly specify their roots of trust in the policy since the evaluation service can automatically fetch them based on the builder (group).
        :param Sequence[str] trusted_source_repo_patterns: List of trusted source code repository URL patterns. These patterns match the full repository URL without its scheme (e.g. `https://`). The patterns must not include schemes. For example, the pattern `source.cloud.google.com/my-project/my-repo-name` matches the following URLs: - `source.cloud.google.com/my-project/my-repo-name` - `git+ssh://source.cloud.google.com/my-project/my-repo-name` - `https://source.cloud.google.com/my-project/my-repo-name` A pattern matches a URL either exactly or with `*` wildcards. `*` can be used in only two ways: 1. trailing `*` after hosturi/ to match varying endings; 2. trailing `**` after hosturi/ to match `/` as well. `*` and `**` can only be used as wildcards and can only occur at the end of the pattern after a `/`. (So it's not possible to match a URL that contains literal `*`.) For example: - `github.com/my-project/my-repo` is valid to match a single repo - `github.com/my-project/*` will match all direct repos in `my-project` - `github.com/**` matches all repos in GitHub
        """
        pulumi.set(__self__, "attestation_source", attestation_source)
        pulumi.set(__self__, "config_based_build_required", config_based_build_required)
        pulumi.set(__self__, "trusted_builder", trusted_builder)
        pulumi.set(__self__, "trusted_source_repo_patterns", trusted_source_repo_patterns)

    @property
    @pulumi.getter(name="attestationSource")
    def attestation_source(self) -> 'outputs.AttestationSourceResponse':
        """
        Specifies where to fetch the provenances attestations generated by the builder (group).
        """
        return pulumi.get(self, "attestation_source")

    @property
    @pulumi.getter(name="configBasedBuildRequired")
    def config_based_build_required(self) -> bool:
        """
        If true, require the image to be built from a top-level configuration. `trusted_source_repo_patterns` specifies the repositories containing this configuration.
        """
        return pulumi.get(self, "config_based_build_required")

    @property
    @pulumi.getter(name="trustedBuilder")
    def trusted_builder(self) -> str:
        """
        Each verification rule is used for evaluation against provenances generated by a specific builder (group). For some of the builders, such as the Google Cloud Build, users don't need to explicitly specify their roots of trust in the policy since the evaluation service can automatically fetch them based on the builder (group).
        """
        return pulumi.get(self, "trusted_builder")

    @property
    @pulumi.getter(name="trustedSourceRepoPatterns")
    def trusted_source_repo_patterns(self) -> Sequence[str]:
        """
        List of trusted source code repository URL patterns. These patterns match the full repository URL without its scheme (e.g. `https://`). The patterns must not include schemes. For example, the pattern `source.cloud.google.com/my-project/my-repo-name` matches the following URLs: - `source.cloud.google.com/my-project/my-repo-name` - `git+ssh://source.cloud.google.com/my-project/my-repo-name` - `https://source.cloud.google.com/my-project/my-repo-name` A pattern matches a URL either exactly or with `*` wildcards. `*` can be used in only two ways: 1. trailing `*` after hosturi/ to match varying endings; 2. trailing `**` after hosturi/ to match `/` as well. `*` and `**` can only be used as wildcards and can only occur at the end of the pattern after a `/`. (So it's not possible to match a URL that contains literal `*`.) For example: - `github.com/my-project/my-repo` is valid to match a single repo - `github.com/my-project/*` will match all direct repos in `my-project` - `github.com/**` matches all repos in GitHub
        """
        return pulumi.get(self, "trusted_source_repo_patterns")


@pulumi.output_type
class VulnerabilityCheckResponse(dict):
    """
    An image vulnerability check, which rejects images that violate the configured vulnerability rules.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedCves":
            suggest = "allowed_cves"
        elif key == "blockedCves":
            suggest = "blocked_cves"
        elif key == "containerAnalysisVulnerabilityProjects":
            suggest = "container_analysis_vulnerability_projects"
        elif key == "maximumFixableSeverity":
            suggest = "maximum_fixable_severity"
        elif key == "maximumUnfixableSeverity":
            suggest = "maximum_unfixable_severity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VulnerabilityCheckResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VulnerabilityCheckResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VulnerabilityCheckResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_cves: Sequence[str],
                 blocked_cves: Sequence[str],
                 container_analysis_vulnerability_projects: Sequence[str],
                 maximum_fixable_severity: str,
                 maximum_unfixable_severity: str):
        """
        An image vulnerability check, which rejects images that violate the configured vulnerability rules.
        :param Sequence[str] allowed_cves: Optional. A list of specific CVEs to ignore even if the vulnerability level violates `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will allow vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
        :param Sequence[str] blocked_cves: Optional. A list of specific CVEs to always raise warnings about even if the vulnerability level meets `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will block vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
        :param Sequence[str] container_analysis_vulnerability_projects: Optional. The projects where vulnerabilities are stored as Container Analysis Occurrences. Each project is expressed in the resource format of `projects/[PROJECT_ID]`, e.g., `projects/my-gcp-project`. An attempt will be made for each project to fetch vulnerabilities, and all valid vulnerabilities will be used to check against the vulnerability policy. If no valid scan is found in all projects configured here, an error will be returned for the check.
        :param str maximum_fixable_severity: The threshold for severity for which a fix is currently available. This field is required and must be set.
        :param str maximum_unfixable_severity: The threshold for severity for which a fix isn't currently available. This field is required and must be set.
        """
        pulumi.set(__self__, "allowed_cves", allowed_cves)
        pulumi.set(__self__, "blocked_cves", blocked_cves)
        pulumi.set(__self__, "container_analysis_vulnerability_projects", container_analysis_vulnerability_projects)
        pulumi.set(__self__, "maximum_fixable_severity", maximum_fixable_severity)
        pulumi.set(__self__, "maximum_unfixable_severity", maximum_unfixable_severity)

    @property
    @pulumi.getter(name="allowedCves")
    def allowed_cves(self) -> Sequence[str]:
        """
        Optional. A list of specific CVEs to ignore even if the vulnerability level violates `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will allow vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
        """
        return pulumi.get(self, "allowed_cves")

    @property
    @pulumi.getter(name="blockedCves")
    def blocked_cves(self) -> Sequence[str]:
        """
        Optional. A list of specific CVEs to always raise warnings about even if the vulnerability level meets `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will block vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
        """
        return pulumi.get(self, "blocked_cves")

    @property
    @pulumi.getter(name="containerAnalysisVulnerabilityProjects")
    def container_analysis_vulnerability_projects(self) -> Sequence[str]:
        """
        Optional. The projects where vulnerabilities are stored as Container Analysis Occurrences. Each project is expressed in the resource format of `projects/[PROJECT_ID]`, e.g., `projects/my-gcp-project`. An attempt will be made for each project to fetch vulnerabilities, and all valid vulnerabilities will be used to check against the vulnerability policy. If no valid scan is found in all projects configured here, an error will be returned for the check.
        """
        return pulumi.get(self, "container_analysis_vulnerability_projects")

    @property
    @pulumi.getter(name="maximumFixableSeverity")
    def maximum_fixable_severity(self) -> str:
        """
        The threshold for severity for which a fix is currently available. This field is required and must be set.
        """
        return pulumi.get(self, "maximum_fixable_severity")

    @property
    @pulumi.getter(name="maximumUnfixableSeverity")
    def maximum_unfixable_severity(self) -> str:
        """
        The threshold for severity for which a fix isn't currently available. This field is required and must be set.
        """
        return pulumi.get(self, "maximum_unfixable_severity")


