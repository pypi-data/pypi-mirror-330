# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs

__all__ = [
    'GetBackupResult',
    'AwaitableGetBackupResult',
    'get_backup',
    'get_backup_output',
]

@pulumi.output_type
class GetBackupResult:
    def __init__(__self__, annotations=None, cluster_name=None, cluster_uid=None, create_time=None, database_version=None, delete_time=None, description=None, display_name=None, encryption_config=None, encryption_info=None, etag=None, expiry_quantity=None, expiry_time=None, labels=None, name=None, reconciling=None, size_bytes=None, state=None, type=None, uid=None, update_time=None):
        if annotations and not isinstance(annotations, dict):
            raise TypeError("Expected argument 'annotations' to be a dict")
        pulumi.set(__self__, "annotations", annotations)
        if cluster_name and not isinstance(cluster_name, str):
            raise TypeError("Expected argument 'cluster_name' to be a str")
        pulumi.set(__self__, "cluster_name", cluster_name)
        if cluster_uid and not isinstance(cluster_uid, str):
            raise TypeError("Expected argument 'cluster_uid' to be a str")
        pulumi.set(__self__, "cluster_uid", cluster_uid)
        if create_time and not isinstance(create_time, str):
            raise TypeError("Expected argument 'create_time' to be a str")
        pulumi.set(__self__, "create_time", create_time)
        if database_version and not isinstance(database_version, str):
            raise TypeError("Expected argument 'database_version' to be a str")
        pulumi.set(__self__, "database_version", database_version)
        if delete_time and not isinstance(delete_time, str):
            raise TypeError("Expected argument 'delete_time' to be a str")
        pulumi.set(__self__, "delete_time", delete_time)
        if description and not isinstance(description, str):
            raise TypeError("Expected argument 'description' to be a str")
        pulumi.set(__self__, "description", description)
        if display_name and not isinstance(display_name, str):
            raise TypeError("Expected argument 'display_name' to be a str")
        pulumi.set(__self__, "display_name", display_name)
        if encryption_config and not isinstance(encryption_config, dict):
            raise TypeError("Expected argument 'encryption_config' to be a dict")
        pulumi.set(__self__, "encryption_config", encryption_config)
        if encryption_info and not isinstance(encryption_info, dict):
            raise TypeError("Expected argument 'encryption_info' to be a dict")
        pulumi.set(__self__, "encryption_info", encryption_info)
        if etag and not isinstance(etag, str):
            raise TypeError("Expected argument 'etag' to be a str")
        pulumi.set(__self__, "etag", etag)
        if expiry_quantity and not isinstance(expiry_quantity, dict):
            raise TypeError("Expected argument 'expiry_quantity' to be a dict")
        pulumi.set(__self__, "expiry_quantity", expiry_quantity)
        if expiry_time and not isinstance(expiry_time, str):
            raise TypeError("Expected argument 'expiry_time' to be a str")
        pulumi.set(__self__, "expiry_time", expiry_time)
        if labels and not isinstance(labels, dict):
            raise TypeError("Expected argument 'labels' to be a dict")
        pulumi.set(__self__, "labels", labels)
        if name and not isinstance(name, str):
            raise TypeError("Expected argument 'name' to be a str")
        pulumi.set(__self__, "name", name)
        if reconciling and not isinstance(reconciling, bool):
            raise TypeError("Expected argument 'reconciling' to be a bool")
        pulumi.set(__self__, "reconciling", reconciling)
        if size_bytes and not isinstance(size_bytes, str):
            raise TypeError("Expected argument 'size_bytes' to be a str")
        pulumi.set(__self__, "size_bytes", size_bytes)
        if state and not isinstance(state, str):
            raise TypeError("Expected argument 'state' to be a str")
        pulumi.set(__self__, "state", state)
        if type and not isinstance(type, str):
            raise TypeError("Expected argument 'type' to be a str")
        pulumi.set(__self__, "type", type)
        if uid and not isinstance(uid, str):
            raise TypeError("Expected argument 'uid' to be a str")
        pulumi.set(__self__, "uid", uid)
        if update_time and not isinstance(update_time, str):
            raise TypeError("Expected argument 'update_time' to be a str")
        pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def annotations(self) -> Mapping[str, str]:
        """
        Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels. https://google.aip.dev/128
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        The full resource name of the backup source cluster (e.g., projects/{project}/locations/{region}/clusters/{cluster_id}).
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="clusterUid")
    def cluster_uid(self) -> str:
        """
        The system-generated UID of the cluster which was used to create this resource.
        """
        return pulumi.get(self, "cluster_uid")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Create time stamp
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="databaseVersion")
    def database_version(self) -> str:
        """
        The database engine major version of the cluster this backup was created from. Any restored cluster created from this backup will have the same database version.
        """
        return pulumi.get(self, "database_version")

    @property
    @pulumi.getter(name="deleteTime")
    def delete_time(self) -> str:
        """
        Delete time stamp
        """
        return pulumi.get(self, "delete_time")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        User-provided description of the backup.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        User-settable and human-readable display name for the Backup.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="encryptionConfig")
    def encryption_config(self) -> 'outputs.EncryptionConfigResponse':
        """
        Optional. The encryption config can be specified to encrypt the backup with a customer-managed encryption key (CMEK). When this field is not specified, the backup will then use default encryption scheme to protect the user data.
        """
        return pulumi.get(self, "encryption_config")

    @property
    @pulumi.getter(name="encryptionInfo")
    def encryption_info(self) -> 'outputs.EncryptionInfoResponse':
        """
        The encryption information for the backup.
        """
        return pulumi.get(self, "encryption_info")

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        For Resource freshness validation (https://google.aip.dev/154)
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="expiryQuantity")
    def expiry_quantity(self) -> 'outputs.QuantityBasedExpiryResponse':
        """
        The QuantityBasedExpiry of the backup, specified by the backup's retention policy. Once the expiry quantity is over retention, the backup is eligible to be garbage collected.
        """
        return pulumi.get(self, "expiry_quantity")

    @property
    @pulumi.getter(name="expiryTime")
    def expiry_time(self) -> str:
        """
        The time at which after the backup is eligible to be garbage collected. It is the duration specified by the backup's retention policy, added to the backup's create_time.
        """
        return pulumi.get(self, "expiry_time")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Labels as key value pairs
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the backup resource with the format: * projects/{project}/locations/{region}/backups/{backup_id} where the cluster and backup ID segments should satisfy the regex expression `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`, e.g. 1-63 characters of lowercase letters, numbers, and dashes, starting with a letter, and ending with a letter or number. For more details see https://google.aip.dev/122. The prefix of the backup resource name is the name of the parent resource: * projects/{project}/locations/{region}
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def reconciling(self) -> bool:
        """
        Reconciling (https://google.aip.dev/128#reconciliation), if true, indicates that the service is actively updating the resource. This can happen due to user-triggered updates or system actions like failover or maintenance.
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> str:
        """
        The size of the backup in bytes.
        """
        return pulumi.get(self, "size_bytes")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the backup.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The backup type, which suggests the trigger for the backup.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uid(self) -> str:
        """
        The system-generated UID of the resource. The UID is assigned when the resource is created, and it is retained until it is deleted.
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> str:
        """
        Update time stamp
        """
        return pulumi.get(self, "update_time")


class AwaitableGetBackupResult(GetBackupResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetBackupResult(
            annotations=self.annotations,
            cluster_name=self.cluster_name,
            cluster_uid=self.cluster_uid,
            create_time=self.create_time,
            database_version=self.database_version,
            delete_time=self.delete_time,
            description=self.description,
            display_name=self.display_name,
            encryption_config=self.encryption_config,
            encryption_info=self.encryption_info,
            etag=self.etag,
            expiry_quantity=self.expiry_quantity,
            expiry_time=self.expiry_time,
            labels=self.labels,
            name=self.name,
            reconciling=self.reconciling,
            size_bytes=self.size_bytes,
            state=self.state,
            type=self.type,
            uid=self.uid,
            update_time=self.update_time)


def get_backup(backup_id: Optional[str] = None,
               location: Optional[str] = None,
               project: Optional[str] = None,
               opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetBackupResult:
    """
    Gets details of a single Backup.
    """
    __args__ = dict()
    __args__['backupId'] = backup_id
    __args__['location'] = location
    __args__['project'] = project
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('google-native:alloydb/v1beta:getBackup', __args__, opts=opts, typ=GetBackupResult).value

    return AwaitableGetBackupResult(
        annotations=pulumi.get(__ret__, 'annotations'),
        cluster_name=pulumi.get(__ret__, 'cluster_name'),
        cluster_uid=pulumi.get(__ret__, 'cluster_uid'),
        create_time=pulumi.get(__ret__, 'create_time'),
        database_version=pulumi.get(__ret__, 'database_version'),
        delete_time=pulumi.get(__ret__, 'delete_time'),
        description=pulumi.get(__ret__, 'description'),
        display_name=pulumi.get(__ret__, 'display_name'),
        encryption_config=pulumi.get(__ret__, 'encryption_config'),
        encryption_info=pulumi.get(__ret__, 'encryption_info'),
        etag=pulumi.get(__ret__, 'etag'),
        expiry_quantity=pulumi.get(__ret__, 'expiry_quantity'),
        expiry_time=pulumi.get(__ret__, 'expiry_time'),
        labels=pulumi.get(__ret__, 'labels'),
        name=pulumi.get(__ret__, 'name'),
        reconciling=pulumi.get(__ret__, 'reconciling'),
        size_bytes=pulumi.get(__ret__, 'size_bytes'),
        state=pulumi.get(__ret__, 'state'),
        type=pulumi.get(__ret__, 'type'),
        uid=pulumi.get(__ret__, 'uid'),
        update_time=pulumi.get(__ret__, 'update_time'))


@_utilities.lift_output_func(get_backup)
def get_backup_output(backup_id: Optional[pulumi.Input[str]] = None,
                      location: Optional[pulumi.Input[str]] = None,
                      project: Optional[pulumi.Input[Optional[str]]] = None,
                      opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetBackupResult]:
    """
    Gets details of a single Backup.
    """
    ...
