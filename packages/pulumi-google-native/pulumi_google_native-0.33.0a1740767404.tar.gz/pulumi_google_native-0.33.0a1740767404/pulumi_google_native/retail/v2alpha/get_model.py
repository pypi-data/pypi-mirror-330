# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs

__all__ = [
    'GetModelResult',
    'AwaitableGetModelResult',
    'get_model',
    'get_model_output',
]

@pulumi.output_type
class GetModelResult:
    def __init__(__self__, create_time=None, data_state=None, display_name=None, filtering_option=None, last_tune_time=None, model_features_config=None, name=None, optimization_objective=None, page_optimization_config=None, periodic_tuning_state=None, serving_config_lists=None, serving_state=None, training_state=None, tuning_operation=None, type=None, update_time=None):
        if create_time and not isinstance(create_time, str):
            raise TypeError("Expected argument 'create_time' to be a str")
        pulumi.set(__self__, "create_time", create_time)
        if data_state and not isinstance(data_state, str):
            raise TypeError("Expected argument 'data_state' to be a str")
        pulumi.set(__self__, "data_state", data_state)
        if display_name and not isinstance(display_name, str):
            raise TypeError("Expected argument 'display_name' to be a str")
        pulumi.set(__self__, "display_name", display_name)
        if filtering_option and not isinstance(filtering_option, str):
            raise TypeError("Expected argument 'filtering_option' to be a str")
        pulumi.set(__self__, "filtering_option", filtering_option)
        if last_tune_time and not isinstance(last_tune_time, str):
            raise TypeError("Expected argument 'last_tune_time' to be a str")
        pulumi.set(__self__, "last_tune_time", last_tune_time)
        if model_features_config and not isinstance(model_features_config, dict):
            raise TypeError("Expected argument 'model_features_config' to be a dict")
        pulumi.set(__self__, "model_features_config", model_features_config)
        if name and not isinstance(name, str):
            raise TypeError("Expected argument 'name' to be a str")
        pulumi.set(__self__, "name", name)
        if optimization_objective and not isinstance(optimization_objective, str):
            raise TypeError("Expected argument 'optimization_objective' to be a str")
        pulumi.set(__self__, "optimization_objective", optimization_objective)
        if page_optimization_config and not isinstance(page_optimization_config, dict):
            raise TypeError("Expected argument 'page_optimization_config' to be a dict")
        pulumi.set(__self__, "page_optimization_config", page_optimization_config)
        if periodic_tuning_state and not isinstance(periodic_tuning_state, str):
            raise TypeError("Expected argument 'periodic_tuning_state' to be a str")
        pulumi.set(__self__, "periodic_tuning_state", periodic_tuning_state)
        if serving_config_lists and not isinstance(serving_config_lists, list):
            raise TypeError("Expected argument 'serving_config_lists' to be a list")
        pulumi.set(__self__, "serving_config_lists", serving_config_lists)
        if serving_state and not isinstance(serving_state, str):
            raise TypeError("Expected argument 'serving_state' to be a str")
        pulumi.set(__self__, "serving_state", serving_state)
        if training_state and not isinstance(training_state, str):
            raise TypeError("Expected argument 'training_state' to be a str")
        pulumi.set(__self__, "training_state", training_state)
        if tuning_operation and not isinstance(tuning_operation, str):
            raise TypeError("Expected argument 'tuning_operation' to be a str")
        pulumi.set(__self__, "tuning_operation", tuning_operation)
        if type and not isinstance(type, str):
            raise TypeError("Expected argument 'type' to be a str")
        pulumi.set(__self__, "type", type)
        if update_time and not isinstance(update_time, str):
            raise TypeError("Expected argument 'update_time' to be a str")
        pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Timestamp the Recommendation Model was created at.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="dataState")
    def data_state(self) -> str:
        """
        The state of data requirements for this model: `DATA_OK` and `DATA_ERROR`. Recommendation model cannot be trained if the data is in `DATA_ERROR` state. Recommendation model can have `DATA_ERROR` state even if serving state is `ACTIVE`: models were trained successfully before, but cannot be refreshed because model no longer has sufficient data for training.
        """
        return pulumi.get(self, "data_state")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name of the model. Should be human readable, used to display Recommendation Models in the Retail Cloud Console Dashboard. UTF-8 encoded string with limit of 1024 characters.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="filteringOption")
    def filtering_option(self) -> str:
        """
        Optional. If `RECOMMENDATIONS_FILTERING_ENABLED`, recommendation filtering by attributes is enabled for the model.
        """
        return pulumi.get(self, "filtering_option")

    @property
    @pulumi.getter(name="lastTuneTime")
    def last_tune_time(self) -> str:
        """
        The timestamp when the latest successful tune finished.
        """
        return pulumi.get(self, "last_tune_time")

    @property
    @pulumi.getter(name="modelFeaturesConfig")
    def model_features_config(self) -> 'outputs.GoogleCloudRetailV2alphaModelModelFeaturesConfigResponse':
        """
        Optional. Additional model features config.
        """
        return pulumi.get(self, "model_features_config")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The fully qualified resource name of the model. Format: `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}/models/{model_id}` catalog_id has char limit of 50. recommendation_model_id has char limit of 40.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="optimizationObjective")
    def optimization_objective(self) -> str:
        """
        Optional. The optimization objective e.g. `cvr`. Currently supported values: `ctr`, `cvr`, `revenue-per-order`. If not specified, we choose default based on model type. Default depends on type of recommendation: `recommended-for-you` => `ctr` `others-you-may-like` => `ctr` `frequently-bought-together` => `revenue_per_order` This field together with optimization_objective describe model metadata to use to control model training and serving. See https://cloud.google.com/retail/docs/models for more details on what the model metadata control and which combination of parameters are valid. For invalid combinations of parameters (e.g. type = `frequently-bought-together` and optimization_objective = `ctr`), you receive an error 400 if you try to create/update a recommendation with this set of knobs.
        """
        return pulumi.get(self, "optimization_objective")

    @property
    @pulumi.getter(name="pageOptimizationConfig")
    def page_optimization_config(self) -> 'outputs.GoogleCloudRetailV2alphaModelPageOptimizationConfigResponse':
        """
        Optional. The page optimization config.
        """
        return pulumi.get(self, "page_optimization_config")

    @property
    @pulumi.getter(name="periodicTuningState")
    def periodic_tuning_state(self) -> str:
        """
        Optional. The state of periodic tuning. The period we use is 3 months - to do a one-off tune earlier use the `TuneModel` method. Default value is `PERIODIC_TUNING_ENABLED`.
        """
        return pulumi.get(self, "periodic_tuning_state")

    @property
    @pulumi.getter(name="servingConfigLists")
    def serving_config_lists(self) -> Sequence['outputs.GoogleCloudRetailV2alphaModelServingConfigListResponse']:
        """
        The list of valid serving configs associated with the PageOptimizationConfig.
        """
        return pulumi.get(self, "serving_config_lists")

    @property
    @pulumi.getter(name="servingState")
    def serving_state(self) -> str:
        """
        The serving state of the model: `ACTIVE`, `NOT_ACTIVE`.
        """
        return pulumi.get(self, "serving_state")

    @property
    @pulumi.getter(name="trainingState")
    def training_state(self) -> str:
        """
        Optional. The training state that the model is in (e.g. `TRAINING` or `PAUSED`). Since part of the cost of running the service is frequency of training - this can be used to determine when to train model in order to control cost. If not specified: the default value for `CreateModel` method is `TRAINING`. The default value for `UpdateModel` method is to keep the state the same as before.
        """
        return pulumi.get(self, "training_state")

    @property
    @pulumi.getter(name="tuningOperation")
    def tuning_operation(self) -> str:
        """
        The tune operation associated with the model. Can be used to determine if there is an ongoing tune for this recommendation. Empty field implies no tune is goig on.
        """
        return pulumi.get(self, "tuning_operation")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of model e.g. `home-page`. Currently supported values: `recommended-for-you`, `others-you-may-like`, `frequently-bought-together`, `page-optimization`, `similar-items`, `buy-it-again`, `on-sale-items`, and `recently-viewed`(readonly value). This field together with optimization_objective describe model metadata to use to control model training and serving. See https://cloud.google.com/retail/docs/models for more details on what the model metadata control and which combination of parameters are valid. For invalid combinations of parameters (e.g. type = `frequently-bought-together` and optimization_objective = `ctr`), you receive an error 400 if you try to create/update a recommendation with this set of knobs.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> str:
        """
        Timestamp the Recommendation Model was last updated. E.g. if a Recommendation Model was paused - this would be the time the pause was initiated.
        """
        return pulumi.get(self, "update_time")


class AwaitableGetModelResult(GetModelResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetModelResult(
            create_time=self.create_time,
            data_state=self.data_state,
            display_name=self.display_name,
            filtering_option=self.filtering_option,
            last_tune_time=self.last_tune_time,
            model_features_config=self.model_features_config,
            name=self.name,
            optimization_objective=self.optimization_objective,
            page_optimization_config=self.page_optimization_config,
            periodic_tuning_state=self.periodic_tuning_state,
            serving_config_lists=self.serving_config_lists,
            serving_state=self.serving_state,
            training_state=self.training_state,
            tuning_operation=self.tuning_operation,
            type=self.type,
            update_time=self.update_time)


def get_model(catalog_id: Optional[str] = None,
              location: Optional[str] = None,
              model_id: Optional[str] = None,
              project: Optional[str] = None,
              opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetModelResult:
    """
    Gets a model.
    """
    __args__ = dict()
    __args__['catalogId'] = catalog_id
    __args__['location'] = location
    __args__['modelId'] = model_id
    __args__['project'] = project
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('google-native:retail/v2alpha:getModel', __args__, opts=opts, typ=GetModelResult).value

    return AwaitableGetModelResult(
        create_time=pulumi.get(__ret__, 'create_time'),
        data_state=pulumi.get(__ret__, 'data_state'),
        display_name=pulumi.get(__ret__, 'display_name'),
        filtering_option=pulumi.get(__ret__, 'filtering_option'),
        last_tune_time=pulumi.get(__ret__, 'last_tune_time'),
        model_features_config=pulumi.get(__ret__, 'model_features_config'),
        name=pulumi.get(__ret__, 'name'),
        optimization_objective=pulumi.get(__ret__, 'optimization_objective'),
        page_optimization_config=pulumi.get(__ret__, 'page_optimization_config'),
        periodic_tuning_state=pulumi.get(__ret__, 'periodic_tuning_state'),
        serving_config_lists=pulumi.get(__ret__, 'serving_config_lists'),
        serving_state=pulumi.get(__ret__, 'serving_state'),
        training_state=pulumi.get(__ret__, 'training_state'),
        tuning_operation=pulumi.get(__ret__, 'tuning_operation'),
        type=pulumi.get(__ret__, 'type'),
        update_time=pulumi.get(__ret__, 'update_time'))


@_utilities.lift_output_func(get_model)
def get_model_output(catalog_id: Optional[pulumi.Input[str]] = None,
                     location: Optional[pulumi.Input[str]] = None,
                     model_id: Optional[pulumi.Input[str]] = None,
                     project: Optional[pulumi.Input[Optional[str]]] = None,
                     opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetModelResult]:
    """
    Gets a model.
    """
    ...
