# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from ._enums import *

__all__ = [
    'AggregationFunctionArgs',
    'AggregationArgs',
    'AlertChartArgs',
    'AxisArgs',
    'BreakdownArgs',
    'ChartOptionsArgs',
    'CollapsibleGroupArgs',
    'ColumnLayoutArgs',
    'ColumnSettingsArgs',
    'ColumnArgs',
    'DashboardFilterArgs',
    'DataSetArgs',
    'DimensionArgs',
    'EmptyArgs',
    'ErrorReportingPanelArgs',
    'GaugeViewArgs',
    'GridLayoutArgs',
    'IncidentListArgs',
    'LogsPanelArgs',
    'MeasureArgs',
    'MonitoredResourceArgs',
    'MosaicLayoutArgs',
    'OpsAnalyticsQueryArgs',
    'ParameterArgs',
    'PickTimeSeriesFilterArgs',
    'PieChartDataSetArgs',
    'PieChartArgs',
    'RatioPartArgs',
    'RowLayoutArgs',
    'RowArgs',
    'ScorecardArgs',
    'SparkChartViewArgs',
    'StatisticalTimeSeriesFilterArgs',
    'TableDataSetArgs',
    'TableDisplayOptionsArgs',
    'TextStyleArgs',
    'TextArgs',
    'ThresholdArgs',
    'TileArgs',
    'TimeSeriesFilterRatioArgs',
    'TimeSeriesFilterArgs',
    'TimeSeriesQueryArgs',
    'TimeSeriesTableArgs',
    'WidgetArgs',
    'XyChartArgs',
]

@pulumi.input_type
class AggregationFunctionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['ParameterArgs']]]] = None):
        """
        Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release.
        :param pulumi.Input[str] type: The type of aggregation function, must be one of the following: "none" - no function. "percentile" - APPROX_QUANTILES() - 1 parameter numeric value "average" - AVG() "count" - COUNT() "count-distinct" - COUNT(DISTINCT) "count-distinct-approx" - APPROX_COUNT_DISTINCT() "max" - MAX() "min" - MIN() "sum" - SUM()
        :param pulumi.Input[Sequence[pulumi.Input['ParameterArgs']]] parameters: Optional. Parameters applied to the aggregation function. Only used for functions that require them.
        """
        pulumi.set(__self__, "type", type)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of aggregation function, must be one of the following: "none" - no function. "percentile" - APPROX_QUANTILES() - 1 parameter numeric value "average" - AVG() "count" - COUNT() "count-distinct" - COUNT(DISTINCT) "count-distinct-approx" - APPROX_COUNT_DISTINCT() "max" - MAX() "min" - MIN() "sum" - SUM()
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ParameterArgs']]]]:
        """
        Optional. Parameters applied to the aggregation function. Only used for functions that require them.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class AggregationArgs:
    def __init__(__self__, *,
                 alignment_period: Optional[pulumi.Input[str]] = None,
                 cross_series_reducer: Optional[pulumi.Input['AggregationCrossSeriesReducer']] = None,
                 group_by_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 per_series_aligner: Optional[pulumi.Input['AggregationPerSeriesAligner']] = None):
        """
        Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example "the 95% latency across the average of all tasks in a cluster". This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation).
        :param pulumi.Input[str] alignment_period: The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
        :param pulumi.Input['AggregationCrossSeriesReducer'] cross_series_reducer: The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_by_fields: The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
        :param pulumi.Input['AggregationPerSeriesAligner'] per_series_aligner: An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
        """
        if alignment_period is not None:
            pulumi.set(__self__, "alignment_period", alignment_period)
        if cross_series_reducer is not None:
            pulumi.set(__self__, "cross_series_reducer", cross_series_reducer)
        if group_by_fields is not None:
            pulumi.set(__self__, "group_by_fields", group_by_fields)
        if per_series_aligner is not None:
            pulumi.set(__self__, "per_series_aligner", per_series_aligner)

    @property
    @pulumi.getter(name="alignmentPeriod")
    def alignment_period(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
        """
        return pulumi.get(self, "alignment_period")

    @alignment_period.setter
    def alignment_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alignment_period", value)

    @property
    @pulumi.getter(name="crossSeriesReducer")
    def cross_series_reducer(self) -> Optional[pulumi.Input['AggregationCrossSeriesReducer']]:
        """
        The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
        """
        return pulumi.get(self, "cross_series_reducer")

    @cross_series_reducer.setter
    def cross_series_reducer(self, value: Optional[pulumi.Input['AggregationCrossSeriesReducer']]):
        pulumi.set(self, "cross_series_reducer", value)

    @property
    @pulumi.getter(name="groupByFields")
    def group_by_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
        """
        return pulumi.get(self, "group_by_fields")

    @group_by_fields.setter
    def group_by_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_by_fields", value)

    @property
    @pulumi.getter(name="perSeriesAligner")
    def per_series_aligner(self) -> Optional[pulumi.Input['AggregationPerSeriesAligner']]:
        """
        An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
        """
        return pulumi.get(self, "per_series_aligner")

    @per_series_aligner.setter
    def per_series_aligner(self, value: Optional[pulumi.Input['AggregationPerSeriesAligner']]):
        pulumi.set(self, "per_series_aligner", value)


@pulumi.input_type
class AlertChartArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        A chart that displays alert policy data.
        :param pulumi.Input[str] name: The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID] 
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID] 
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class AxisArgs:
    def __init__(__self__, *,
                 label: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input['AxisScale']] = None):
        """
        A chart axis.
        :param pulumi.Input[str] label: The label of the axis.
        :param pulumi.Input['AxisScale'] scale: The axis scale. By default, a linear scale is used.
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input['AxisScale']]:
        """
        The axis scale. By default, a linear scale is used.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input['AxisScale']]):
        pulumi.set(self, "scale", value)


@pulumi.input_type
class BreakdownArgs:
    def __init__(__self__, *,
                 aggregation_function: pulumi.Input['AggregationFunctionArgs'],
                 column: pulumi.Input[str],
                 limit: pulumi.Input[int],
                 sort_order: pulumi.Input['BreakdownSortOrder']):
        """
        Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
        :param pulumi.Input['AggregationFunctionArgs'] aggregation_function: The Aggregation function is applied across all data in each breakdown created.
        :param pulumi.Input[str] column: The name of the column in the dataset containing the breakdown values.
        :param pulumi.Input[int] limit: A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
        :param pulumi.Input['BreakdownSortOrder'] sort_order: The sort order is applied to the values of the breakdown column.
        """
        pulumi.set(__self__, "aggregation_function", aggregation_function)
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "sort_order", sort_order)

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> pulumi.Input['AggregationFunctionArgs']:
        """
        The Aggregation function is applied across all data in each breakdown created.
        """
        return pulumi.get(self, "aggregation_function")

    @aggregation_function.setter
    def aggregation_function(self, value: pulumi.Input['AggregationFunctionArgs']):
        pulumi.set(self, "aggregation_function", value)

    @property
    @pulumi.getter
    def column(self) -> pulumi.Input[str]:
        """
        The name of the column in the dataset containing the breakdown values.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: pulumi.Input[str]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def limit(self) -> pulumi.Input[int]:
        """
        A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> pulumi.Input['BreakdownSortOrder']:
        """
        The sort order is applied to the values of the breakdown column.
        """
        return pulumi.get(self, "sort_order")

    @sort_order.setter
    def sort_order(self, value: pulumi.Input['BreakdownSortOrder']):
        pulumi.set(self, "sort_order", value)


@pulumi.input_type
class ChartOptionsArgs:
    def __init__(__self__, *,
                 display_horizontal: Optional[pulumi.Input[bool]] = None,
                 mode: Optional[pulumi.Input['ChartOptionsMode']] = None):
        """
        Options to control visual rendering of a chart.
        :param pulumi.Input[bool] display_horizontal: Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
        :param pulumi.Input['ChartOptionsMode'] mode: The chart mode.
        """
        if display_horizontal is not None:
            pulumi.set(__self__, "display_horizontal", display_horizontal)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="displayHorizontal")
    def display_horizontal(self) -> Optional[pulumi.Input[bool]]:
        """
        Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
        """
        return pulumi.get(self, "display_horizontal")

    @display_horizontal.setter
    def display_horizontal(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "display_horizontal", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input['ChartOptionsMode']]:
        """
        The chart mode.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input['ChartOptionsMode']]):
        pulumi.set(self, "mode", value)


@pulumi.input_type
class CollapsibleGroupArgs:
    def __init__(__self__, *,
                 collapsed: Optional[pulumi.Input[bool]] = None):
        """
        A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
        :param pulumi.Input[bool] collapsed: The collapsed state of the widget on first page load.
        """
        if collapsed is not None:
            pulumi.set(__self__, "collapsed", collapsed)

    @property
    @pulumi.getter
    def collapsed(self) -> Optional[pulumi.Input[bool]]:
        """
        The collapsed state of the widget on first page load.
        """
        return pulumi.get(self, "collapsed")

    @collapsed.setter
    def collapsed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "collapsed", value)


@pulumi.input_type
class ColumnLayoutArgs:
    def __init__(__self__, *,
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['ColumnArgs']]]] = None):
        """
        A simplified layout that divides the available space into vertical columns and arranges a set of widgets vertically in each column.
        :param pulumi.Input[Sequence[pulumi.Input['ColumnArgs']]] columns: The columns of content to display.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ColumnArgs']]]]:
        """
        The columns of content to display.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ColumnArgs']]]]):
        pulumi.set(self, "columns", value)


@pulumi.input_type
class ColumnSettingsArgs:
    def __init__(__self__, *,
                 column: pulumi.Input[str],
                 visible: pulumi.Input[bool]):
        """
        The persistent settings for a table's columns.
        :param pulumi.Input[str] column: The id of the column.
        :param pulumi.Input[bool] visible: Whether the column should be visible on page load.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "visible", visible)

    @property
    @pulumi.getter
    def column(self) -> pulumi.Input[str]:
        """
        The id of the column.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: pulumi.Input[str]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def visible(self) -> pulumi.Input[bool]:
        """
        Whether the column should be visible on page load.
        """
        return pulumi.get(self, "visible")

    @visible.setter
    def visible(self, value: pulumi.Input[bool]):
        pulumi.set(self, "visible", value)


@pulumi.input_type
class ColumnArgs:
    def __init__(__self__, *,
                 weight: Optional[pulumi.Input[str]] = None,
                 widgets: Optional[pulumi.Input[Sequence[pulumi.Input['WidgetArgs']]]] = None):
        """
        Defines the layout properties and content for a column.
        :param pulumi.Input[str] weight: The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.
        :param pulumi.Input[Sequence[pulumi.Input['WidgetArgs']]] widgets: The display widgets arranged vertically in this column.
        """
        if weight is not None:
            pulumi.set(__self__, "weight", weight)
        if widgets is not None:
            pulumi.set(__self__, "widgets", widgets)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[str]]:
        """
        The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "weight", value)

    @property
    @pulumi.getter
    def widgets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WidgetArgs']]]]:
        """
        The display widgets arranged vertically in this column.
        """
        return pulumi.get(self, "widgets")

    @widgets.setter
    def widgets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WidgetArgs']]]]):
        pulumi.set(self, "widgets", value)


@pulumi.input_type
class DashboardFilterArgs:
    def __init__(__self__, *,
                 label_key: pulumi.Input[str],
                 filter_type: Optional[pulumi.Input['DashboardFilterFilterType']] = None,
                 string_value: Optional[pulumi.Input[str]] = None,
                 template_variable: Optional[pulumi.Input[str]] = None):
        """
        A filter to reduce the amount of data charted in relevant widgets.
        :param pulumi.Input[str] label_key: The key for the label
        :param pulumi.Input['DashboardFilterFilterType'] filter_type: The specified filter type
        :param pulumi.Input[str] string_value: A variable-length string value.
        :param pulumi.Input[str] template_variable: The placeholder text that can be referenced in a filter string or MQL query. If omitted, the dashboard filter will be applied to all relevant widgets in the dashboard.
        """
        pulumi.set(__self__, "label_key", label_key)
        if filter_type is not None:
            pulumi.set(__self__, "filter_type", filter_type)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if template_variable is not None:
            pulumi.set(__self__, "template_variable", template_variable)

    @property
    @pulumi.getter(name="labelKey")
    def label_key(self) -> pulumi.Input[str]:
        """
        The key for the label
        """
        return pulumi.get(self, "label_key")

    @label_key.setter
    def label_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "label_key", value)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> Optional[pulumi.Input['DashboardFilterFilterType']]:
        """
        The specified filter type
        """
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: Optional[pulumi.Input['DashboardFilterFilterType']]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        A variable-length string value.
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)

    @property
    @pulumi.getter(name="templateVariable")
    def template_variable(self) -> Optional[pulumi.Input[str]]:
        """
        The placeholder text that can be referenced in a filter string or MQL query. If omitted, the dashboard filter will be applied to all relevant widgets in the dashboard.
        """
        return pulumi.get(self, "template_variable")

    @template_variable.setter
    def template_variable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template_variable", value)


@pulumi.input_type
class DataSetArgs:
    def __init__(__self__, *,
                 time_series_query: pulumi.Input['TimeSeriesQueryArgs'],
                 breakdowns: Optional[pulumi.Input[Sequence[pulumi.Input['BreakdownArgs']]]] = None,
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['DimensionArgs']]]] = None,
                 legend_template: Optional[pulumi.Input[str]] = None,
                 measures: Optional[pulumi.Input[Sequence[pulumi.Input['MeasureArgs']]]] = None,
                 min_alignment_period: Optional[pulumi.Input[str]] = None,
                 plot_type: Optional[pulumi.Input['DataSetPlotType']] = None,
                 target_axis: Optional[pulumi.Input['DataSetTargetAxis']] = None):
        """
        Groups a time series query definition with charting options.
        :param pulumi.Input['TimeSeriesQueryArgs'] time_series_query: Fields for querying time series data from the Stackdriver metrics API.
        :param pulumi.Input[Sequence[pulumi.Input['BreakdownArgs']]] breakdowns: Optional. The collection of breakdowns to be applied to the dataset.
        :param pulumi.Input[Sequence[pulumi.Input['DimensionArgs']]] dimensions: Optional. A collection of dimension columns.
        :param pulumi.Input[str] legend_template: A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value.
        :param pulumi.Input[Sequence[pulumi.Input['MeasureArgs']]] measures: Optional. A collection of measures.
        :param pulumi.Input[str] min_alignment_period: Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
        :param pulumi.Input['DataSetPlotType'] plot_type: How this data should be plotted on the chart.
        :param pulumi.Input['DataSetTargetAxis'] target_axis: Optional. The target axis to use for plotting the metric.
        """
        pulumi.set(__self__, "time_series_query", time_series_query)
        if breakdowns is not None:
            pulumi.set(__self__, "breakdowns", breakdowns)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if legend_template is not None:
            pulumi.set(__self__, "legend_template", legend_template)
        if measures is not None:
            pulumi.set(__self__, "measures", measures)
        if min_alignment_period is not None:
            pulumi.set(__self__, "min_alignment_period", min_alignment_period)
        if plot_type is not None:
            pulumi.set(__self__, "plot_type", plot_type)
        if target_axis is not None:
            pulumi.set(__self__, "target_axis", target_axis)

    @property
    @pulumi.getter(name="timeSeriesQuery")
    def time_series_query(self) -> pulumi.Input['TimeSeriesQueryArgs']:
        """
        Fields for querying time series data from the Stackdriver metrics API.
        """
        return pulumi.get(self, "time_series_query")

    @time_series_query.setter
    def time_series_query(self, value: pulumi.Input['TimeSeriesQueryArgs']):
        pulumi.set(self, "time_series_query", value)

    @property
    @pulumi.getter
    def breakdowns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BreakdownArgs']]]]:
        """
        Optional. The collection of breakdowns to be applied to the dataset.
        """
        return pulumi.get(self, "breakdowns")

    @breakdowns.setter
    def breakdowns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BreakdownArgs']]]]):
        pulumi.set(self, "breakdowns", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DimensionArgs']]]]:
        """
        Optional. A collection of dimension columns.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="legendTemplate")
    def legend_template(self) -> Optional[pulumi.Input[str]]:
        """
        A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value.
        """
        return pulumi.get(self, "legend_template")

    @legend_template.setter
    def legend_template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "legend_template", value)

    @property
    @pulumi.getter
    def measures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MeasureArgs']]]]:
        """
        Optional. A collection of measures.
        """
        return pulumi.get(self, "measures")

    @measures.setter
    def measures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MeasureArgs']]]]):
        pulumi.set(self, "measures", value)

    @property
    @pulumi.getter(name="minAlignmentPeriod")
    def min_alignment_period(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
        """
        return pulumi.get(self, "min_alignment_period")

    @min_alignment_period.setter
    def min_alignment_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_alignment_period", value)

    @property
    @pulumi.getter(name="plotType")
    def plot_type(self) -> Optional[pulumi.Input['DataSetPlotType']]:
        """
        How this data should be plotted on the chart.
        """
        return pulumi.get(self, "plot_type")

    @plot_type.setter
    def plot_type(self, value: Optional[pulumi.Input['DataSetPlotType']]):
        pulumi.set(self, "plot_type", value)

    @property
    @pulumi.getter(name="targetAxis")
    def target_axis(self) -> Optional[pulumi.Input['DataSetTargetAxis']]:
        """
        Optional. The target axis to use for plotting the metric.
        """
        return pulumi.get(self, "target_axis")

    @target_axis.setter
    def target_axis(self, value: Optional[pulumi.Input['DataSetTargetAxis']]):
        pulumi.set(self, "target_axis", value)


@pulumi.input_type
class DimensionArgs:
    def __init__(__self__, *,
                 column: pulumi.Input[str],
                 column_type: Optional[pulumi.Input[str]] = None,
                 float_bin_size: Optional[pulumi.Input[float]] = None,
                 max_bin_count: Optional[pulumi.Input[int]] = None,
                 numeric_bin_size: Optional[pulumi.Input[int]] = None,
                 sort_column: Optional[pulumi.Input[str]] = None,
                 sort_order: Optional[pulumi.Input['DimensionSortOrder']] = None,
                 time_bin_size: Optional[pulumi.Input[str]] = None):
        """
        Preview: A chart dimension for an SQL query. This is applied over the x-axis. This is a preview feature and may be subject to change before final release.
        :param pulumi.Input[str] column: The name of the column in the source SQL query that is used to chart the dimension.
        :param pulumi.Input[str] column_type: Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
        :param pulumi.Input[float] float_bin_size: Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
        :param pulumi.Input[int] max_bin_count: A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
        :param pulumi.Input[int] numeric_bin_size: numeric_bin_size is used when the column type used for a dimension is numeric or string.
        :param pulumi.Input[str] sort_column: The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
        :param pulumi.Input['DimensionSortOrder'] sort_order: The sort order applied to the sort column.
        :param pulumi.Input[str] time_bin_size: time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
        """
        pulumi.set(__self__, "column", column)
        if column_type is not None:
            pulumi.set(__self__, "column_type", column_type)
        if float_bin_size is not None:
            pulumi.set(__self__, "float_bin_size", float_bin_size)
        if max_bin_count is not None:
            pulumi.set(__self__, "max_bin_count", max_bin_count)
        if numeric_bin_size is not None:
            pulumi.set(__self__, "numeric_bin_size", numeric_bin_size)
        if sort_column is not None:
            pulumi.set(__self__, "sort_column", sort_column)
        if sort_order is not None:
            pulumi.set(__self__, "sort_order", sort_order)
        if time_bin_size is not None:
            pulumi.set(__self__, "time_bin_size", time_bin_size)

    @property
    @pulumi.getter
    def column(self) -> pulumi.Input[str]:
        """
        The name of the column in the source SQL query that is used to chart the dimension.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: pulumi.Input[str]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter(name="columnType")
    def column_type(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
        """
        return pulumi.get(self, "column_type")

    @column_type.setter
    def column_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column_type", value)

    @property
    @pulumi.getter(name="floatBinSize")
    def float_bin_size(self) -> Optional[pulumi.Input[float]]:
        """
        Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
        """
        return pulumi.get(self, "float_bin_size")

    @float_bin_size.setter
    def float_bin_size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_bin_size", value)

    @property
    @pulumi.getter(name="maxBinCount")
    def max_bin_count(self) -> Optional[pulumi.Input[int]]:
        """
        A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
        """
        return pulumi.get(self, "max_bin_count")

    @max_bin_count.setter
    def max_bin_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_bin_count", value)

    @property
    @pulumi.getter(name="numericBinSize")
    def numeric_bin_size(self) -> Optional[pulumi.Input[int]]:
        """
        numeric_bin_size is used when the column type used for a dimension is numeric or string.
        """
        return pulumi.get(self, "numeric_bin_size")

    @numeric_bin_size.setter
    def numeric_bin_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "numeric_bin_size", value)

    @property
    @pulumi.getter(name="sortColumn")
    def sort_column(self) -> Optional[pulumi.Input[str]]:
        """
        The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
        """
        return pulumi.get(self, "sort_column")

    @sort_column.setter
    def sort_column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort_column", value)

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> Optional[pulumi.Input['DimensionSortOrder']]:
        """
        The sort order applied to the sort column.
        """
        return pulumi.get(self, "sort_order")

    @sort_order.setter
    def sort_order(self, value: Optional[pulumi.Input['DimensionSortOrder']]):
        pulumi.set(self, "sort_order", value)

    @property
    @pulumi.getter(name="timeBinSize")
    def time_bin_size(self) -> Optional[pulumi.Input[str]]:
        """
        time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
        """
        return pulumi.get(self, "time_bin_size")

    @time_bin_size.setter
    def time_bin_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_bin_size", value)


@pulumi.input_type
class EmptyArgs:
    def __init__(__self__):
        """
        A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } 
        """
        pass


@pulumi.input_type
class ErrorReportingPanelArgs:
    def __init__(__self__, *,
                 project_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 versions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A widget that displays a list of error groups.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] project_names: The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] versions: Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
        """
        if project_names is not None:
            pulumi.set(__self__, "project_names", project_names)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @property
    @pulumi.getter(name="projectNames")
    def project_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
        """
        return pulumi.get(self, "project_names")

    @project_names.setter
    def project_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "project_names", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter
    def versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
        """
        return pulumi.get(self, "versions")

    @versions.setter
    def versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "versions", value)


@pulumi.input_type
class GaugeViewArgs:
    def __init__(__self__, *,
                 lower_bound: Optional[pulumi.Input[float]] = None,
                 upper_bound: Optional[pulumi.Input[float]] = None):
        """
        A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard's query (inclusive).
        :param pulumi.Input[float] lower_bound: The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
        :param pulumi.Input[float] upper_bound: The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
        """
        if lower_bound is not None:
            pulumi.set(__self__, "lower_bound", lower_bound)
        if upper_bound is not None:
            pulumi.set(__self__, "upper_bound", upper_bound)

    @property
    @pulumi.getter(name="lowerBound")
    def lower_bound(self) -> Optional[pulumi.Input[float]]:
        """
        The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
        """
        return pulumi.get(self, "lower_bound")

    @lower_bound.setter
    def lower_bound(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lower_bound", value)

    @property
    @pulumi.getter(name="upperBound")
    def upper_bound(self) -> Optional[pulumi.Input[float]]:
        """
        The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
        """
        return pulumi.get(self, "upper_bound")

    @upper_bound.setter
    def upper_bound(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "upper_bound", value)


@pulumi.input_type
class GridLayoutArgs:
    def __init__(__self__, *,
                 columns: Optional[pulumi.Input[str]] = None,
                 widgets: Optional[pulumi.Input[Sequence[pulumi.Input['WidgetArgs']]]] = None):
        """
        A basic layout divides the available space into vertical columns of equal width and arranges a list of widgets using a row-first strategy.
        :param pulumi.Input[str] columns: The number of columns into which the view's width is divided. If omitted or set to zero, a system default will be used while rendering.
        :param pulumi.Input[Sequence[pulumi.Input['WidgetArgs']]] widgets: The informational elements that are arranged into the columns row-first.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if widgets is not None:
            pulumi.set(__self__, "widgets", widgets)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[str]]:
        """
        The number of columns into which the view's width is divided. If omitted or set to zero, a system default will be used while rendering.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def widgets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WidgetArgs']]]]:
        """
        The informational elements that are arranged into the columns row-first.
        """
        return pulumi.get(self, "widgets")

    @widgets.setter
    def widgets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WidgetArgs']]]]):
        pulumi.set(self, "widgets", value)


@pulumi.input_type
class IncidentListArgs:
    def __init__(__self__, *,
                 monitored_resources: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceArgs']]]] = None,
                 policy_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A widget that displays a list of incidents
        :param pulumi.Input[Sequence[pulumi.Input['MonitoredResourceArgs']]] monitored_resources: Optional. The monitored resource for which incidents are listed. The resource doesn't need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] policy_names: Optional. A list of alert policy names to filter the incident list by. Don't include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
        """
        if monitored_resources is not None:
            pulumi.set(__self__, "monitored_resources", monitored_resources)
        if policy_names is not None:
            pulumi.set(__self__, "policy_names", policy_names)

    @property
    @pulumi.getter(name="monitoredResources")
    def monitored_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceArgs']]]]:
        """
        Optional. The monitored resource for which incidents are listed. The resource doesn't need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
        """
        return pulumi.get(self, "monitored_resources")

    @monitored_resources.setter
    def monitored_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredResourceArgs']]]]):
        pulumi.set(self, "monitored_resources", value)

    @property
    @pulumi.getter(name="policyNames")
    def policy_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. A list of alert policy names to filter the incident list by. Don't include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
        """
        return pulumi.get(self, "policy_names")

    @policy_names.setter
    def policy_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policy_names", value)


@pulumi.input_type
class LogsPanelArgs:
    def __init__(__self__, *,
                 filter: Optional[pulumi.Input[str]] = None,
                 resource_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A widget that displays a stream of log.
        :param pulumi.Input[str] filter: A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_names: The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
        """
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if resource_names is not None:
            pulumi.set(__self__, "resource_names", resource_names)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[str]]:
        """
        A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter(name="resourceNames")
    def resource_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
        """
        return pulumi.get(self, "resource_names")

    @resource_names.setter
    def resource_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_names", value)


@pulumi.input_type
class MeasureArgs:
    def __init__(__self__, *,
                 aggregation_function: pulumi.Input['AggregationFunctionArgs'],
                 column: pulumi.Input[str]):
        """
        Preview: A chart measure for an SQL query. This is applied over the y-axis. This is a preview feature and may be subject to change before final release.
        :param pulumi.Input['AggregationFunctionArgs'] aggregation_function: The aggregation function applied to the input column. This must not be set to "none" unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
        :param pulumi.Input[str] column: The column name within in the dataset used for the measure.
        """
        pulumi.set(__self__, "aggregation_function", aggregation_function)
        pulumi.set(__self__, "column", column)

    @property
    @pulumi.getter(name="aggregationFunction")
    def aggregation_function(self) -> pulumi.Input['AggregationFunctionArgs']:
        """
        The aggregation function applied to the input column. This must not be set to "none" unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
        """
        return pulumi.get(self, "aggregation_function")

    @aggregation_function.setter
    def aggregation_function(self, value: pulumi.Input['AggregationFunctionArgs']):
        pulumi.set(self, "aggregation_function", value)

    @property
    @pulumi.getter
    def column(self) -> pulumi.Input[str]:
        """
        The column name within in the dataset used for the measure.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: pulumi.Input[str]):
        pulumi.set(self, "column", value)


@pulumi.input_type
class MonitoredResourceArgs:
    def __init__(__self__, *,
                 labels: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 type: pulumi.Input[str]):
        """
        An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource's schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for "gce_instance" has labels "project_id", "instance_id" and "zone": { "type": "gce_instance", "labels": { "project_id": "my-project", "instance_id": "12345678901234", "zone": "us-central1-a" }} 
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
        :param pulumi.Input[str] type: The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
        """
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def labels(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class MosaicLayoutArgs:
    def __init__(__self__, *,
                 columns: Optional[pulumi.Input[int]] = None,
                 tiles: Optional[pulumi.Input[Sequence[pulumi.Input['TileArgs']]]] = None):
        """
        A mosaic layout divides the available space into a grid of blocks, and overlays the grid with tiles. Unlike GridLayout, tiles may span multiple grid blocks and can be placed at arbitrary locations in the grid.
        :param pulumi.Input[int] columns: The number of columns in the mosaic grid. The number of columns must be between 1 and 12, inclusive.
        :param pulumi.Input[Sequence[pulumi.Input['TileArgs']]] tiles: The tiles to display.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if tiles is not None:
            pulumi.set(__self__, "tiles", tiles)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[int]]:
        """
        The number of columns in the mosaic grid. The number of columns must be between 1 and 12, inclusive.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def tiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TileArgs']]]]:
        """
        The tiles to display.
        """
        return pulumi.get(self, "tiles")

    @tiles.setter
    def tiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TileArgs']]]]):
        pulumi.set(self, "tiles", value)


@pulumi.input_type
class OpsAnalyticsQueryArgs:
    def __init__(__self__, *,
                 sql: Optional[pulumi.Input[str]] = None):
        """
        Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release.
        :param pulumi.Input[str] sql: A SQL query to fetch time series, category series, or numeric series data.
        """
        if sql is not None:
            pulumi.set(__self__, "sql", sql)

    @property
    @pulumi.getter
    def sql(self) -> Optional[pulumi.Input[str]]:
        """
        A SQL query to fetch time series, category series, or numeric series data.
        """
        return pulumi.get(self, "sql")

    @sql.setter
    def sql(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sql", value)


@pulumi.input_type
class ParameterArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input[float]] = None,
                 int_value: Optional[pulumi.Input[str]] = None):
        """
        Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
        :param pulumi.Input[float] double_value: A floating-point parameter value.
        :param pulumi.Input[str] int_value: An integer parameter value.
        """
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int_value is not None:
            pulumi.set(__self__, "int_value", int_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input[float]]:
        """
        A floating-point parameter value.
        """
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="intValue")
    def int_value(self) -> Optional[pulumi.Input[str]]:
        """
        An integer parameter value.
        """
        return pulumi.get(self, "int_value")

    @int_value.setter
    def int_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "int_value", value)


@pulumi.input_type
class PickTimeSeriesFilterArgs:
    def __init__(__self__, *,
                 direction: Optional[pulumi.Input['PickTimeSeriesFilterDirection']] = None,
                 num_time_series: Optional[pulumi.Input[int]] = None,
                 ranking_method: Optional[pulumi.Input['PickTimeSeriesFilterRankingMethod']] = None):
        """
        Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter.
        :param pulumi.Input['PickTimeSeriesFilterDirection'] direction: How to use the ranking to select time series that pass through the filter.
        :param pulumi.Input[int] num_time_series: How many time series to allow to pass through the filter.
        :param pulumi.Input['PickTimeSeriesFilterRankingMethod'] ranking_method: ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if num_time_series is not None:
            pulumi.set(__self__, "num_time_series", num_time_series)
        if ranking_method is not None:
            pulumi.set(__self__, "ranking_method", ranking_method)

    @property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input['PickTimeSeriesFilterDirection']]:
        """
        How to use the ranking to select time series that pass through the filter.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input['PickTimeSeriesFilterDirection']]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter(name="numTimeSeries")
    def num_time_series(self) -> Optional[pulumi.Input[int]]:
        """
        How many time series to allow to pass through the filter.
        """
        return pulumi.get(self, "num_time_series")

    @num_time_series.setter
    def num_time_series(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_time_series", value)

    @property
    @pulumi.getter(name="rankingMethod")
    def ranking_method(self) -> Optional[pulumi.Input['PickTimeSeriesFilterRankingMethod']]:
        """
        ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
        """
        return pulumi.get(self, "ranking_method")

    @ranking_method.setter
    def ranking_method(self, value: Optional[pulumi.Input['PickTimeSeriesFilterRankingMethod']]):
        pulumi.set(self, "ranking_method", value)


@pulumi.input_type
class PieChartDataSetArgs:
    def __init__(__self__, *,
                 time_series_query: pulumi.Input['TimeSeriesQueryArgs'],
                 min_alignment_period: Optional[pulumi.Input[str]] = None,
                 slice_name_template: Optional[pulumi.Input[str]] = None):
        """
        Groups a time series query definition.
        :param pulumi.Input['TimeSeriesQueryArgs'] time_series_query: The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
        :param pulumi.Input[str] min_alignment_period: Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
        :param pulumi.Input[str] slice_name_template: Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone's value will be used for the name instead of the default name.
        """
        pulumi.set(__self__, "time_series_query", time_series_query)
        if min_alignment_period is not None:
            pulumi.set(__self__, "min_alignment_period", min_alignment_period)
        if slice_name_template is not None:
            pulumi.set(__self__, "slice_name_template", slice_name_template)

    @property
    @pulumi.getter(name="timeSeriesQuery")
    def time_series_query(self) -> pulumi.Input['TimeSeriesQueryArgs']:
        """
        The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
        """
        return pulumi.get(self, "time_series_query")

    @time_series_query.setter
    def time_series_query(self, value: pulumi.Input['TimeSeriesQueryArgs']):
        pulumi.set(self, "time_series_query", value)

    @property
    @pulumi.getter(name="minAlignmentPeriod")
    def min_alignment_period(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
        """
        return pulumi.get(self, "min_alignment_period")

    @min_alignment_period.setter
    def min_alignment_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_alignment_period", value)

    @property
    @pulumi.getter(name="sliceNameTemplate")
    def slice_name_template(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone's value will be used for the name instead of the default name.
        """
        return pulumi.get(self, "slice_name_template")

    @slice_name_template.setter
    def slice_name_template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slice_name_template", value)


@pulumi.input_type
class PieChartArgs:
    def __init__(__self__, *,
                 chart_type: pulumi.Input['PieChartChartType'],
                 data_sets: pulumi.Input[Sequence[pulumi.Input['PieChartDataSetArgs']]],
                 show_labels: Optional[pulumi.Input[bool]] = None):
        """
        A widget that displays timeseries data as a pie or a donut.
        :param pulumi.Input['PieChartChartType'] chart_type: Indicates the visualization type for the PieChart.
        :param pulumi.Input[Sequence[pulumi.Input['PieChartDataSetArgs']]] data_sets: The queries for the chart's data.
        :param pulumi.Input[bool] show_labels: Optional. Indicates whether or not the pie chart should show slices' labels
        """
        pulumi.set(__self__, "chart_type", chart_type)
        pulumi.set(__self__, "data_sets", data_sets)
        if show_labels is not None:
            pulumi.set(__self__, "show_labels", show_labels)

    @property
    @pulumi.getter(name="chartType")
    def chart_type(self) -> pulumi.Input['PieChartChartType']:
        """
        Indicates the visualization type for the PieChart.
        """
        return pulumi.get(self, "chart_type")

    @chart_type.setter
    def chart_type(self, value: pulumi.Input['PieChartChartType']):
        pulumi.set(self, "chart_type", value)

    @property
    @pulumi.getter(name="dataSets")
    def data_sets(self) -> pulumi.Input[Sequence[pulumi.Input['PieChartDataSetArgs']]]:
        """
        The queries for the chart's data.
        """
        return pulumi.get(self, "data_sets")

    @data_sets.setter
    def data_sets(self, value: pulumi.Input[Sequence[pulumi.Input['PieChartDataSetArgs']]]):
        pulumi.set(self, "data_sets", value)

    @property
    @pulumi.getter(name="showLabels")
    def show_labels(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. Indicates whether or not the pie chart should show slices' labels
        """
        return pulumi.get(self, "show_labels")

    @show_labels.setter
    def show_labels(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_labels", value)


@pulumi.input_type
class RatioPartArgs:
    def __init__(__self__, *,
                 filter: pulumi.Input[str],
                 aggregation: Optional[pulumi.Input['AggregationArgs']] = None):
        """
        Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio.
        :param pulumi.Input[str] filter: The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
        :param pulumi.Input['AggregationArgs'] aggregation: By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
        """
        pulumi.set(__self__, "filter", filter)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)

    @property
    @pulumi.getter
    def filter(self) -> pulumi.Input[str]:
        """
        The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[pulumi.Input['AggregationArgs']]:
        """
        By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: Optional[pulumi.Input['AggregationArgs']]):
        pulumi.set(self, "aggregation", value)


@pulumi.input_type
class RowLayoutArgs:
    def __init__(__self__, *,
                 rows: Optional[pulumi.Input[Sequence[pulumi.Input['RowArgs']]]] = None):
        """
        A simplified layout that divides the available space into rows and arranges a set of widgets horizontally in each row.
        :param pulumi.Input[Sequence[pulumi.Input['RowArgs']]] rows: The rows of content to display.
        """
        if rows is not None:
            pulumi.set(__self__, "rows", rows)

    @property
    @pulumi.getter
    def rows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RowArgs']]]]:
        """
        The rows of content to display.
        """
        return pulumi.get(self, "rows")

    @rows.setter
    def rows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RowArgs']]]]):
        pulumi.set(self, "rows", value)


@pulumi.input_type
class RowArgs:
    def __init__(__self__, *,
                 weight: Optional[pulumi.Input[str]] = None,
                 widgets: Optional[pulumi.Input[Sequence[pulumi.Input['WidgetArgs']]]] = None):
        """
        Defines the layout properties and content for a row.
        :param pulumi.Input[str] weight: The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.
        :param pulumi.Input[Sequence[pulumi.Input['WidgetArgs']]] widgets: The display widgets arranged horizontally in this row.
        """
        if weight is not None:
            pulumi.set(__self__, "weight", weight)
        if widgets is not None:
            pulumi.set(__self__, "widgets", widgets)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[str]]:
        """
        The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "weight", value)

    @property
    @pulumi.getter
    def widgets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WidgetArgs']]]]:
        """
        The display widgets arranged horizontally in this row.
        """
        return pulumi.get(self, "widgets")

    @widgets.setter
    def widgets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WidgetArgs']]]]):
        pulumi.set(self, "widgets", value)


@pulumi.input_type
class ScorecardArgs:
    def __init__(__self__, *,
                 time_series_query: pulumi.Input['TimeSeriesQueryArgs'],
                 blank_view: Optional[pulumi.Input['EmptyArgs']] = None,
                 gauge_view: Optional[pulumi.Input['GaugeViewArgs']] = None,
                 spark_chart_view: Optional[pulumi.Input['SparkChartViewArgs']] = None,
                 thresholds: Optional[pulumi.Input[Sequence[pulumi.Input['ThresholdArgs']]]] = None):
        """
        A widget showing the latest value of a metric, and how this value relates to one or more thresholds.
        :param pulumi.Input['TimeSeriesQueryArgs'] time_series_query: Fields for querying time series data from the Stackdriver metrics API.
        :param pulumi.Input['EmptyArgs'] blank_view: Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
        :param pulumi.Input['GaugeViewArgs'] gauge_view: Will cause the scorecard to show a gauge chart.
        :param pulumi.Input['SparkChartViewArgs'] spark_chart_view: Will cause the scorecard to show a spark chart.
        :param pulumi.Input[Sequence[pulumi.Input['ThresholdArgs']]] thresholds: The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: 'DANGER', trigger: 'ABOVE', }, { value: 70, category: 'WARNING', trigger: 'ABOVE', }, { value: 10, category: 'DANGER', trigger: 'BELOW', }, { value: 20, category: 'WARNING', trigger: 'BELOW', } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
        """
        pulumi.set(__self__, "time_series_query", time_series_query)
        if blank_view is not None:
            pulumi.set(__self__, "blank_view", blank_view)
        if gauge_view is not None:
            pulumi.set(__self__, "gauge_view", gauge_view)
        if spark_chart_view is not None:
            pulumi.set(__self__, "spark_chart_view", spark_chart_view)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter(name="timeSeriesQuery")
    def time_series_query(self) -> pulumi.Input['TimeSeriesQueryArgs']:
        """
        Fields for querying time series data from the Stackdriver metrics API.
        """
        return pulumi.get(self, "time_series_query")

    @time_series_query.setter
    def time_series_query(self, value: pulumi.Input['TimeSeriesQueryArgs']):
        pulumi.set(self, "time_series_query", value)

    @property
    @pulumi.getter(name="blankView")
    def blank_view(self) -> Optional[pulumi.Input['EmptyArgs']]:
        """
        Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
        """
        return pulumi.get(self, "blank_view")

    @blank_view.setter
    def blank_view(self, value: Optional[pulumi.Input['EmptyArgs']]):
        pulumi.set(self, "blank_view", value)

    @property
    @pulumi.getter(name="gaugeView")
    def gauge_view(self) -> Optional[pulumi.Input['GaugeViewArgs']]:
        """
        Will cause the scorecard to show a gauge chart.
        """
        return pulumi.get(self, "gauge_view")

    @gauge_view.setter
    def gauge_view(self, value: Optional[pulumi.Input['GaugeViewArgs']]):
        pulumi.set(self, "gauge_view", value)

    @property
    @pulumi.getter(name="sparkChartView")
    def spark_chart_view(self) -> Optional[pulumi.Input['SparkChartViewArgs']]:
        """
        Will cause the scorecard to show a spark chart.
        """
        return pulumi.get(self, "spark_chart_view")

    @spark_chart_view.setter
    def spark_chart_view(self, value: Optional[pulumi.Input['SparkChartViewArgs']]):
        pulumi.set(self, "spark_chart_view", value)

    @property
    @pulumi.getter
    def thresholds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ThresholdArgs']]]]:
        """
        The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: 'DANGER', trigger: 'ABOVE', }, { value: 70, category: 'WARNING', trigger: 'ABOVE', }, { value: 10, category: 'DANGER', trigger: 'BELOW', }, { value: 20, category: 'WARNING', trigger: 'BELOW', } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
        """
        return pulumi.get(self, "thresholds")

    @thresholds.setter
    def thresholds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ThresholdArgs']]]]):
        pulumi.set(self, "thresholds", value)


@pulumi.input_type
class SparkChartViewArgs:
    def __init__(__self__, *,
                 spark_chart_type: pulumi.Input['SparkChartViewSparkChartType'],
                 min_alignment_period: Optional[pulumi.Input[str]] = None):
        """
        A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard's timeseries.
        :param pulumi.Input['SparkChartViewSparkChartType'] spark_chart_type: The type of sparkchart to show in this chartView.
        :param pulumi.Input[str] min_alignment_period: The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
        """
        pulumi.set(__self__, "spark_chart_type", spark_chart_type)
        if min_alignment_period is not None:
            pulumi.set(__self__, "min_alignment_period", min_alignment_period)

    @property
    @pulumi.getter(name="sparkChartType")
    def spark_chart_type(self) -> pulumi.Input['SparkChartViewSparkChartType']:
        """
        The type of sparkchart to show in this chartView.
        """
        return pulumi.get(self, "spark_chart_type")

    @spark_chart_type.setter
    def spark_chart_type(self, value: pulumi.Input['SparkChartViewSparkChartType']):
        pulumi.set(self, "spark_chart_type", value)

    @property
    @pulumi.getter(name="minAlignmentPeriod")
    def min_alignment_period(self) -> Optional[pulumi.Input[str]]:
        """
        The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
        """
        return pulumi.get(self, "min_alignment_period")

    @min_alignment_period.setter
    def min_alignment_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_alignment_period", value)


@pulumi.input_type
class StatisticalTimeSeriesFilterArgs:
    def __init__(__self__, *,
                 num_time_series: Optional[pulumi.Input[int]] = None,
                 ranking_method: Optional[pulumi.Input['StatisticalTimeSeriesFilterRankingMethod']] = None):
        """
        A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API.
        :param pulumi.Input[int] num_time_series: How many time series to output.
        :param pulumi.Input['StatisticalTimeSeriesFilterRankingMethod'] ranking_method: rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
        """
        if num_time_series is not None:
            pulumi.set(__self__, "num_time_series", num_time_series)
        if ranking_method is not None:
            pulumi.set(__self__, "ranking_method", ranking_method)

    @property
    @pulumi.getter(name="numTimeSeries")
    def num_time_series(self) -> Optional[pulumi.Input[int]]:
        """
        How many time series to output.
        """
        return pulumi.get(self, "num_time_series")

    @num_time_series.setter
    def num_time_series(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_time_series", value)

    @property
    @pulumi.getter(name="rankingMethod")
    def ranking_method(self) -> Optional[pulumi.Input['StatisticalTimeSeriesFilterRankingMethod']]:
        """
        rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
        """
        return pulumi.get(self, "ranking_method")

    @ranking_method.setter
    def ranking_method(self, value: Optional[pulumi.Input['StatisticalTimeSeriesFilterRankingMethod']]):
        pulumi.set(self, "ranking_method", value)


@pulumi.input_type
class TableDataSetArgs:
    def __init__(__self__, *,
                 time_series_query: pulumi.Input['TimeSeriesQueryArgs'],
                 min_alignment_period: Optional[pulumi.Input[str]] = None,
                 table_display_options: Optional[pulumi.Input['TableDisplayOptionsArgs']] = None,
                 table_template: Optional[pulumi.Input[str]] = None):
        """
        Groups a time series query definition with table options.
        :param pulumi.Input['TimeSeriesQueryArgs'] time_series_query: Fields for querying time series data from the Stackdriver metrics API.
        :param pulumi.Input[str] min_alignment_period: Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
        :param pulumi.Input['TableDisplayOptionsArgs'] table_display_options: Optional. Table display options for configuring how the table is rendered.
        :param pulumi.Input[str] table_template: Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value i.e. "${resource.labels.project_id}."
        """
        pulumi.set(__self__, "time_series_query", time_series_query)
        if min_alignment_period is not None:
            pulumi.set(__self__, "min_alignment_period", min_alignment_period)
        if table_display_options is not None:
            pulumi.set(__self__, "table_display_options", table_display_options)
        if table_template is not None:
            pulumi.set(__self__, "table_template", table_template)

    @property
    @pulumi.getter(name="timeSeriesQuery")
    def time_series_query(self) -> pulumi.Input['TimeSeriesQueryArgs']:
        """
        Fields for querying time series data from the Stackdriver metrics API.
        """
        return pulumi.get(self, "time_series_query")

    @time_series_query.setter
    def time_series_query(self, value: pulumi.Input['TimeSeriesQueryArgs']):
        pulumi.set(self, "time_series_query", value)

    @property
    @pulumi.getter(name="minAlignmentPeriod")
    def min_alignment_period(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
        """
        return pulumi.get(self, "min_alignment_period")

    @min_alignment_period.setter
    def min_alignment_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_alignment_period", value)

    @property
    @pulumi.getter(name="tableDisplayOptions")
    def table_display_options(self) -> Optional[pulumi.Input['TableDisplayOptionsArgs']]:
        """
        Optional. Table display options for configuring how the table is rendered.
        """
        return pulumi.get(self, "table_display_options")

    @table_display_options.setter
    def table_display_options(self, value: Optional[pulumi.Input['TableDisplayOptionsArgs']]):
        pulumi.set(self, "table_display_options", value)

    @property
    @pulumi.getter(name="tableTemplate")
    def table_template(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value i.e. "${resource.labels.project_id}."
        """
        return pulumi.get(self, "table_template")

    @table_template.setter
    def table_template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "table_template", value)


@pulumi.input_type
class TableDisplayOptionsArgs:
    def __init__(__self__, *,
                 shown_columns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Table display options that can be reused.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] shown_columns: Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
        """
        if shown_columns is not None:
            pulumi.set(__self__, "shown_columns", shown_columns)

    @property
    @pulumi.getter(name="shownColumns")
    def shown_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
        """
        return pulumi.get(self, "shown_columns")

    @shown_columns.setter
    def shown_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "shown_columns", value)


@pulumi.input_type
class TextStyleArgs:
    def __init__(__self__, *,
                 background_color: Optional[pulumi.Input[str]] = None,
                 font_size: Optional[pulumi.Input['TextStyleFontSize']] = None,
                 horizontal_alignment: Optional[pulumi.Input['TextStyleHorizontalAlignment']] = None,
                 padding: Optional[pulumi.Input['TextStylePadding']] = None,
                 pointer_location: Optional[pulumi.Input['TextStylePointerLocation']] = None,
                 text_color: Optional[pulumi.Input[str]] = None,
                 vertical_alignment: Optional[pulumi.Input['TextStyleVerticalAlignment']] = None):
        """
        Properties that determine how the title and content are styled
        :param pulumi.Input[str] background_color: The background color as a hex string. "#RRGGBB" or "#RGB"
        :param pulumi.Input['TextStyleFontSize'] font_size: Font sizes for both the title and content. The title will still be larger relative to the content.
        :param pulumi.Input['TextStyleHorizontalAlignment'] horizontal_alignment: The horizontal alignment of both the title and content
        :param pulumi.Input['TextStylePadding'] padding: The amount of padding around the widget
        :param pulumi.Input['TextStylePointerLocation'] pointer_location: The pointer location for this widget (also sometimes called a "tail")
        :param pulumi.Input[str] text_color: The text color as a hex string. "#RRGGBB" or "#RGB"
        :param pulumi.Input['TextStyleVerticalAlignment'] vertical_alignment: The vertical alignment of both the title and content
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if horizontal_alignment is not None:
            pulumi.set(__self__, "horizontal_alignment", horizontal_alignment)
        if padding is not None:
            pulumi.set(__self__, "padding", padding)
        if pointer_location is not None:
            pulumi.set(__self__, "pointer_location", pointer_location)
        if text_color is not None:
            pulumi.set(__self__, "text_color", text_color)
        if vertical_alignment is not None:
            pulumi.set(__self__, "vertical_alignment", vertical_alignment)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input[str]]:
        """
        The background color as a hex string. "#RRGGBB" or "#RGB"
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "background_color", value)

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[pulumi.Input['TextStyleFontSize']]:
        """
        Font sizes for both the title and content. The title will still be larger relative to the content.
        """
        return pulumi.get(self, "font_size")

    @font_size.setter
    def font_size(self, value: Optional[pulumi.Input['TextStyleFontSize']]):
        pulumi.set(self, "font_size", value)

    @property
    @pulumi.getter(name="horizontalAlignment")
    def horizontal_alignment(self) -> Optional[pulumi.Input['TextStyleHorizontalAlignment']]:
        """
        The horizontal alignment of both the title and content
        """
        return pulumi.get(self, "horizontal_alignment")

    @horizontal_alignment.setter
    def horizontal_alignment(self, value: Optional[pulumi.Input['TextStyleHorizontalAlignment']]):
        pulumi.set(self, "horizontal_alignment", value)

    @property
    @pulumi.getter
    def padding(self) -> Optional[pulumi.Input['TextStylePadding']]:
        """
        The amount of padding around the widget
        """
        return pulumi.get(self, "padding")

    @padding.setter
    def padding(self, value: Optional[pulumi.Input['TextStylePadding']]):
        pulumi.set(self, "padding", value)

    @property
    @pulumi.getter(name="pointerLocation")
    def pointer_location(self) -> Optional[pulumi.Input['TextStylePointerLocation']]:
        """
        The pointer location for this widget (also sometimes called a "tail")
        """
        return pulumi.get(self, "pointer_location")

    @pointer_location.setter
    def pointer_location(self, value: Optional[pulumi.Input['TextStylePointerLocation']]):
        pulumi.set(self, "pointer_location", value)

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional[pulumi.Input[str]]:
        """
        The text color as a hex string. "#RRGGBB" or "#RGB"
        """
        return pulumi.get(self, "text_color")

    @text_color.setter
    def text_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_color", value)

    @property
    @pulumi.getter(name="verticalAlignment")
    def vertical_alignment(self) -> Optional[pulumi.Input['TextStyleVerticalAlignment']]:
        """
        The vertical alignment of both the title and content
        """
        return pulumi.get(self, "vertical_alignment")

    @vertical_alignment.setter
    def vertical_alignment(self, value: Optional[pulumi.Input['TextStyleVerticalAlignment']]):
        pulumi.set(self, "vertical_alignment", value)


@pulumi.input_type
class TextArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[str]] = None,
                 format: Optional[pulumi.Input['TextFormat']] = None,
                 style: Optional[pulumi.Input['TextStyleArgs']] = None):
        """
        A widget that displays textual content.
        :param pulumi.Input[str] content: The text content to be displayed.
        :param pulumi.Input['TextFormat'] format: How the text content is formatted.
        :param pulumi.Input['TextStyleArgs'] style: How the text is styled
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        The text content to be displayed.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input['TextFormat']]:
        """
        How the text content is formatted.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input['TextFormat']]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['TextStyleArgs']]:
        """
        How the text is styled
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['TextStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class ThresholdArgs:
    def __init__(__self__, *,
                 color: Optional[pulumi.Input['ThresholdColor']] = None,
                 direction: Optional[pulumi.Input['ThresholdDirection']] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 target_axis: Optional[pulumi.Input['ThresholdTargetAxis']] = None,
                 value: Optional[pulumi.Input[float]] = None):
        """
        Defines a threshold for categorizing time series values.
        :param pulumi.Input['ThresholdColor'] color: The state color for this threshold. Color is not allowed in a XyChart.
        :param pulumi.Input['ThresholdDirection'] direction: The direction for the current threshold. Direction is not allowed in a XyChart.
        :param pulumi.Input[str] label: A label for the threshold.
        :param pulumi.Input['ThresholdTargetAxis'] target_axis: The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
        :param pulumi.Input[float] value: The value of the threshold. The value should be defined in the native scale of the metric.
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if target_axis is not None:
            pulumi.set(__self__, "target_axis", target_axis)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input['ThresholdColor']]:
        """
        The state color for this threshold. Color is not allowed in a XyChart.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input['ThresholdColor']]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input['ThresholdDirection']]:
        """
        The direction for the current threshold. Direction is not allowed in a XyChart.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input['ThresholdDirection']]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        A label for the threshold.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter(name="targetAxis")
    def target_axis(self) -> Optional[pulumi.Input['ThresholdTargetAxis']]:
        """
        The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
        """
        return pulumi.get(self, "target_axis")

    @target_axis.setter
    def target_axis(self, value: Optional[pulumi.Input['ThresholdTargetAxis']]):
        pulumi.set(self, "target_axis", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[float]]:
        """
        The value of the threshold. The value should be defined in the native scale of the metric.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class TileArgs:
    def __init__(__self__, *,
                 height: Optional[pulumi.Input[int]] = None,
                 widget: Optional[pulumi.Input['WidgetArgs']] = None,
                 width: Optional[pulumi.Input[int]] = None,
                 x_pos: Optional[pulumi.Input[int]] = None,
                 y_pos: Optional[pulumi.Input[int]] = None):
        """
        A single tile in the mosaic. The placement and size of the tile are configurable.
        :param pulumi.Input[int] height: The height of the tile, measured in grid blocks. Tiles must have a minimum height of 1.
        :param pulumi.Input['WidgetArgs'] widget: The informational widget contained in the tile. For example an XyChart.
        :param pulumi.Input[int] width: The width of the tile, measured in grid blocks. Tiles must have a minimum width of 1.
        :param pulumi.Input[int] x_pos: The zero-indexed position of the tile in grid blocks relative to the left edge of the grid. Tiles must be contained within the specified number of columns. x_pos cannot be negative.
        :param pulumi.Input[int] y_pos: The zero-indexed position of the tile in grid blocks relative to the top edge of the grid. y_pos cannot be negative.
        """
        if height is not None:
            pulumi.set(__self__, "height", height)
        if widget is not None:
            pulumi.set(__self__, "widget", widget)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if x_pos is not None:
            pulumi.set(__self__, "x_pos", x_pos)
        if y_pos is not None:
            pulumi.set(__self__, "y_pos", y_pos)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        The height of the tile, measured in grid blocks. Tiles must have a minimum height of 1.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def widget(self) -> Optional[pulumi.Input['WidgetArgs']]:
        """
        The informational widget contained in the tile. For example an XyChart.
        """
        return pulumi.get(self, "widget")

    @widget.setter
    def widget(self, value: Optional[pulumi.Input['WidgetArgs']]):
        pulumi.set(self, "widget", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        The width of the tile, measured in grid blocks. Tiles must have a minimum width of 1.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)

    @property
    @pulumi.getter(name="xPos")
    def x_pos(self) -> Optional[pulumi.Input[int]]:
        """
        The zero-indexed position of the tile in grid blocks relative to the left edge of the grid. Tiles must be contained within the specified number of columns. x_pos cannot be negative.
        """
        return pulumi.get(self, "x_pos")

    @x_pos.setter
    def x_pos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "x_pos", value)

    @property
    @pulumi.getter(name="yPos")
    def y_pos(self) -> Optional[pulumi.Input[int]]:
        """
        The zero-indexed position of the tile in grid blocks relative to the top edge of the grid. y_pos cannot be negative.
        """
        return pulumi.get(self, "y_pos")

    @y_pos.setter
    def y_pos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "y_pos", value)


@pulumi.input_type
class TimeSeriesFilterRatioArgs:
    def __init__(__self__, *,
                 denominator: Optional[pulumi.Input['RatioPartArgs']] = None,
                 numerator: Optional[pulumi.Input['RatioPartArgs']] = None,
                 pick_time_series_filter: Optional[pulumi.Input['PickTimeSeriesFilterArgs']] = None,
                 secondary_aggregation: Optional[pulumi.Input['AggregationArgs']] = None,
                 statistical_time_series_filter: Optional[pulumi.Input['StatisticalTimeSeriesFilterArgs']] = None):
        """
        A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series.
        :param pulumi.Input['RatioPartArgs'] denominator: The denominator of the ratio.
        :param pulumi.Input['RatioPartArgs'] numerator: The numerator of the ratio.
        :param pulumi.Input['PickTimeSeriesFilterArgs'] pick_time_series_filter: Ranking based time series filter.
        :param pulumi.Input['AggregationArgs'] secondary_aggregation: Apply a second aggregation after the ratio is computed.
        :param pulumi.Input['StatisticalTimeSeriesFilterArgs'] statistical_time_series_filter: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
        """
        if denominator is not None:
            pulumi.set(__self__, "denominator", denominator)
        if numerator is not None:
            pulumi.set(__self__, "numerator", numerator)
        if pick_time_series_filter is not None:
            pulumi.set(__self__, "pick_time_series_filter", pick_time_series_filter)
        if secondary_aggregation is not None:
            pulumi.set(__self__, "secondary_aggregation", secondary_aggregation)
        if statistical_time_series_filter is not None:
            warnings.warn("""Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.""", DeprecationWarning)
            pulumi.log.warn("""statistical_time_series_filter is deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.""")
        if statistical_time_series_filter is not None:
            pulumi.set(__self__, "statistical_time_series_filter", statistical_time_series_filter)

    @property
    @pulumi.getter
    def denominator(self) -> Optional[pulumi.Input['RatioPartArgs']]:
        """
        The denominator of the ratio.
        """
        return pulumi.get(self, "denominator")

    @denominator.setter
    def denominator(self, value: Optional[pulumi.Input['RatioPartArgs']]):
        pulumi.set(self, "denominator", value)

    @property
    @pulumi.getter
    def numerator(self) -> Optional[pulumi.Input['RatioPartArgs']]:
        """
        The numerator of the ratio.
        """
        return pulumi.get(self, "numerator")

    @numerator.setter
    def numerator(self, value: Optional[pulumi.Input['RatioPartArgs']]):
        pulumi.set(self, "numerator", value)

    @property
    @pulumi.getter(name="pickTimeSeriesFilter")
    def pick_time_series_filter(self) -> Optional[pulumi.Input['PickTimeSeriesFilterArgs']]:
        """
        Ranking based time series filter.
        """
        return pulumi.get(self, "pick_time_series_filter")

    @pick_time_series_filter.setter
    def pick_time_series_filter(self, value: Optional[pulumi.Input['PickTimeSeriesFilterArgs']]):
        pulumi.set(self, "pick_time_series_filter", value)

    @property
    @pulumi.getter(name="secondaryAggregation")
    def secondary_aggregation(self) -> Optional[pulumi.Input['AggregationArgs']]:
        """
        Apply a second aggregation after the ratio is computed.
        """
        return pulumi.get(self, "secondary_aggregation")

    @secondary_aggregation.setter
    def secondary_aggregation(self, value: Optional[pulumi.Input['AggregationArgs']]):
        pulumi.set(self, "secondary_aggregation", value)

    @property
    @pulumi.getter(name="statisticalTimeSeriesFilter")
    @_utilities.deprecated("""Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.""")
    def statistical_time_series_filter(self) -> Optional[pulumi.Input['StatisticalTimeSeriesFilterArgs']]:
        """
        Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
        """
        return pulumi.get(self, "statistical_time_series_filter")

    @statistical_time_series_filter.setter
    def statistical_time_series_filter(self, value: Optional[pulumi.Input['StatisticalTimeSeriesFilterArgs']]):
        pulumi.set(self, "statistical_time_series_filter", value)


@pulumi.input_type
class TimeSeriesFilterArgs:
    def __init__(__self__, *,
                 filter: pulumi.Input[str],
                 aggregation: Optional[pulumi.Input['AggregationArgs']] = None,
                 pick_time_series_filter: Optional[pulumi.Input['PickTimeSeriesFilterArgs']] = None,
                 secondary_aggregation: Optional[pulumi.Input['AggregationArgs']] = None,
                 statistical_time_series_filter: Optional[pulumi.Input['StatisticalTimeSeriesFilterArgs']] = None):
        """
        A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method.
        :param pulumi.Input[str] filter: The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
        :param pulumi.Input['AggregationArgs'] aggregation: By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
        :param pulumi.Input['PickTimeSeriesFilterArgs'] pick_time_series_filter: Ranking based time series filter.
        :param pulumi.Input['AggregationArgs'] secondary_aggregation: Apply a second aggregation after aggregation is applied.
        :param pulumi.Input['StatisticalTimeSeriesFilterArgs'] statistical_time_series_filter: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
        """
        pulumi.set(__self__, "filter", filter)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if pick_time_series_filter is not None:
            pulumi.set(__self__, "pick_time_series_filter", pick_time_series_filter)
        if secondary_aggregation is not None:
            pulumi.set(__self__, "secondary_aggregation", secondary_aggregation)
        if statistical_time_series_filter is not None:
            warnings.warn("""Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.""", DeprecationWarning)
            pulumi.log.warn("""statistical_time_series_filter is deprecated: Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.""")
        if statistical_time_series_filter is not None:
            pulumi.set(__self__, "statistical_time_series_filter", statistical_time_series_filter)

    @property
    @pulumi.getter
    def filter(self) -> pulumi.Input[str]:
        """
        The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[pulumi.Input['AggregationArgs']]:
        """
        By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: Optional[pulumi.Input['AggregationArgs']]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter(name="pickTimeSeriesFilter")
    def pick_time_series_filter(self) -> Optional[pulumi.Input['PickTimeSeriesFilterArgs']]:
        """
        Ranking based time series filter.
        """
        return pulumi.get(self, "pick_time_series_filter")

    @pick_time_series_filter.setter
    def pick_time_series_filter(self, value: Optional[pulumi.Input['PickTimeSeriesFilterArgs']]):
        pulumi.set(self, "pick_time_series_filter", value)

    @property
    @pulumi.getter(name="secondaryAggregation")
    def secondary_aggregation(self) -> Optional[pulumi.Input['AggregationArgs']]:
        """
        Apply a second aggregation after aggregation is applied.
        """
        return pulumi.get(self, "secondary_aggregation")

    @secondary_aggregation.setter
    def secondary_aggregation(self, value: Optional[pulumi.Input['AggregationArgs']]):
        pulumi.set(self, "secondary_aggregation", value)

    @property
    @pulumi.getter(name="statisticalTimeSeriesFilter")
    @_utilities.deprecated("""Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.""")
    def statistical_time_series_filter(self) -> Optional[pulumi.Input['StatisticalTimeSeriesFilterArgs']]:
        """
        Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
        """
        return pulumi.get(self, "statistical_time_series_filter")

    @statistical_time_series_filter.setter
    def statistical_time_series_filter(self, value: Optional[pulumi.Input['StatisticalTimeSeriesFilterArgs']]):
        pulumi.set(self, "statistical_time_series_filter", value)


@pulumi.input_type
class TimeSeriesQueryArgs:
    def __init__(__self__, *,
                 ops_analytics_query: Optional[pulumi.Input['OpsAnalyticsQueryArgs']] = None,
                 output_full_duration: Optional[pulumi.Input[bool]] = None,
                 prometheus_query: Optional[pulumi.Input[str]] = None,
                 time_series_filter: Optional[pulumi.Input['TimeSeriesFilterArgs']] = None,
                 time_series_filter_ratio: Optional[pulumi.Input['TimeSeriesFilterRatioArgs']] = None,
                 time_series_query_language: Optional[pulumi.Input[str]] = None,
                 unit_override: Optional[pulumi.Input[str]] = None):
        """
        TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API.
        :param pulumi.Input['OpsAnalyticsQueryArgs'] ops_analytics_query: Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
        :param pulumi.Input[bool] output_full_duration: Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard's spark chart
        :param pulumi.Input[str] prometheus_query: A query used to fetch time series with PromQL.
        :param pulumi.Input['TimeSeriesFilterArgs'] time_series_filter: Filter parameters to fetch time series.
        :param pulumi.Input['TimeSeriesFilterRatioArgs'] time_series_filter_ratio: Parameters to fetch a ratio between two time series filters.
        :param pulumi.Input[str] time_series_query_language: A query used to fetch time series with MQL.
        :param pulumi.Input[str] unit_override: The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
        """
        if ops_analytics_query is not None:
            pulumi.set(__self__, "ops_analytics_query", ops_analytics_query)
        if output_full_duration is not None:
            pulumi.set(__self__, "output_full_duration", output_full_duration)
        if prometheus_query is not None:
            pulumi.set(__self__, "prometheus_query", prometheus_query)
        if time_series_filter is not None:
            pulumi.set(__self__, "time_series_filter", time_series_filter)
        if time_series_filter_ratio is not None:
            pulumi.set(__self__, "time_series_filter_ratio", time_series_filter_ratio)
        if time_series_query_language is not None:
            pulumi.set(__self__, "time_series_query_language", time_series_query_language)
        if unit_override is not None:
            pulumi.set(__self__, "unit_override", unit_override)

    @property
    @pulumi.getter(name="opsAnalyticsQuery")
    def ops_analytics_query(self) -> Optional[pulumi.Input['OpsAnalyticsQueryArgs']]:
        """
        Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
        """
        return pulumi.get(self, "ops_analytics_query")

    @ops_analytics_query.setter
    def ops_analytics_query(self, value: Optional[pulumi.Input['OpsAnalyticsQueryArgs']]):
        pulumi.set(self, "ops_analytics_query", value)

    @property
    @pulumi.getter(name="outputFullDuration")
    def output_full_duration(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard's spark chart
        """
        return pulumi.get(self, "output_full_duration")

    @output_full_duration.setter
    def output_full_duration(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "output_full_duration", value)

    @property
    @pulumi.getter(name="prometheusQuery")
    def prometheus_query(self) -> Optional[pulumi.Input[str]]:
        """
        A query used to fetch time series with PromQL.
        """
        return pulumi.get(self, "prometheus_query")

    @prometheus_query.setter
    def prometheus_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prometheus_query", value)

    @property
    @pulumi.getter(name="timeSeriesFilter")
    def time_series_filter(self) -> Optional[pulumi.Input['TimeSeriesFilterArgs']]:
        """
        Filter parameters to fetch time series.
        """
        return pulumi.get(self, "time_series_filter")

    @time_series_filter.setter
    def time_series_filter(self, value: Optional[pulumi.Input['TimeSeriesFilterArgs']]):
        pulumi.set(self, "time_series_filter", value)

    @property
    @pulumi.getter(name="timeSeriesFilterRatio")
    def time_series_filter_ratio(self) -> Optional[pulumi.Input['TimeSeriesFilterRatioArgs']]:
        """
        Parameters to fetch a ratio between two time series filters.
        """
        return pulumi.get(self, "time_series_filter_ratio")

    @time_series_filter_ratio.setter
    def time_series_filter_ratio(self, value: Optional[pulumi.Input['TimeSeriesFilterRatioArgs']]):
        pulumi.set(self, "time_series_filter_ratio", value)

    @property
    @pulumi.getter(name="timeSeriesQueryLanguage")
    def time_series_query_language(self) -> Optional[pulumi.Input[str]]:
        """
        A query used to fetch time series with MQL.
        """
        return pulumi.get(self, "time_series_query_language")

    @time_series_query_language.setter
    def time_series_query_language(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_series_query_language", value)

    @property
    @pulumi.getter(name="unitOverride")
    def unit_override(self) -> Optional[pulumi.Input[str]]:
        """
        The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
        """
        return pulumi.get(self, "unit_override")

    @unit_override.setter
    def unit_override(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unit_override", value)


@pulumi.input_type
class TimeSeriesTableArgs:
    def __init__(__self__, *,
                 data_sets: pulumi.Input[Sequence[pulumi.Input['TableDataSetArgs']]],
                 column_settings: Optional[pulumi.Input[Sequence[pulumi.Input['ColumnSettingsArgs']]]] = None,
                 metric_visualization: Optional[pulumi.Input['TimeSeriesTableMetricVisualization']] = None):
        """
        A table that displays time series data.
        :param pulumi.Input[Sequence[pulumi.Input['TableDataSetArgs']]] data_sets: The data displayed in this table.
        :param pulumi.Input[Sequence[pulumi.Input['ColumnSettingsArgs']]] column_settings: Optional. The list of the persistent column settings for the table.
        :param pulumi.Input['TimeSeriesTableMetricVisualization'] metric_visualization: Optional. Store rendering strategy
        """
        pulumi.set(__self__, "data_sets", data_sets)
        if column_settings is not None:
            pulumi.set(__self__, "column_settings", column_settings)
        if metric_visualization is not None:
            pulumi.set(__self__, "metric_visualization", metric_visualization)

    @property
    @pulumi.getter(name="dataSets")
    def data_sets(self) -> pulumi.Input[Sequence[pulumi.Input['TableDataSetArgs']]]:
        """
        The data displayed in this table.
        """
        return pulumi.get(self, "data_sets")

    @data_sets.setter
    def data_sets(self, value: pulumi.Input[Sequence[pulumi.Input['TableDataSetArgs']]]):
        pulumi.set(self, "data_sets", value)

    @property
    @pulumi.getter(name="columnSettings")
    def column_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ColumnSettingsArgs']]]]:
        """
        Optional. The list of the persistent column settings for the table.
        """
        return pulumi.get(self, "column_settings")

    @column_settings.setter
    def column_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ColumnSettingsArgs']]]]):
        pulumi.set(self, "column_settings", value)

    @property
    @pulumi.getter(name="metricVisualization")
    def metric_visualization(self) -> Optional[pulumi.Input['TimeSeriesTableMetricVisualization']]:
        """
        Optional. Store rendering strategy
        """
        return pulumi.get(self, "metric_visualization")

    @metric_visualization.setter
    def metric_visualization(self, value: Optional[pulumi.Input['TimeSeriesTableMetricVisualization']]):
        pulumi.set(self, "metric_visualization", value)


@pulumi.input_type
class WidgetArgs:
    def __init__(__self__, *,
                 alert_chart: Optional[pulumi.Input['AlertChartArgs']] = None,
                 blank: Optional[pulumi.Input['EmptyArgs']] = None,
                 collapsible_group: Optional[pulumi.Input['CollapsibleGroupArgs']] = None,
                 error_reporting_panel: Optional[pulumi.Input['ErrorReportingPanelArgs']] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 incident_list: Optional[pulumi.Input['IncidentListArgs']] = None,
                 logs_panel: Optional[pulumi.Input['LogsPanelArgs']] = None,
                 pie_chart: Optional[pulumi.Input['PieChartArgs']] = None,
                 scorecard: Optional[pulumi.Input['ScorecardArgs']] = None,
                 text: Optional[pulumi.Input['TextArgs']] = None,
                 time_series_table: Optional[pulumi.Input['TimeSeriesTableArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 xy_chart: Optional[pulumi.Input['XyChartArgs']] = None):
        """
        Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
        :param pulumi.Input['AlertChartArgs'] alert_chart: A chart of alert policy data.
        :param pulumi.Input['EmptyArgs'] blank: A blank space.
        :param pulumi.Input['CollapsibleGroupArgs'] collapsible_group: A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
        :param pulumi.Input['ErrorReportingPanelArgs'] error_reporting_panel: A widget that displays a list of error groups.
        :param pulumi.Input[str] id: Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
        :param pulumi.Input['IncidentListArgs'] incident_list: A widget that shows list of incidents.
        :param pulumi.Input['LogsPanelArgs'] logs_panel: A widget that shows a stream of logs.
        :param pulumi.Input['PieChartArgs'] pie_chart: A widget that displays timeseries data as a pie chart.
        :param pulumi.Input['ScorecardArgs'] scorecard: A scorecard summarizing time series data.
        :param pulumi.Input['TextArgs'] text: A raw string or markdown displaying textual content.
        :param pulumi.Input['TimeSeriesTableArgs'] time_series_table: A widget that displays time series data in a tabular format.
        :param pulumi.Input[str] title: Optional. The title of the widget.
        :param pulumi.Input['XyChartArgs'] xy_chart: A chart of time series data.
        """
        if alert_chart is not None:
            pulumi.set(__self__, "alert_chart", alert_chart)
        if blank is not None:
            pulumi.set(__self__, "blank", blank)
        if collapsible_group is not None:
            pulumi.set(__self__, "collapsible_group", collapsible_group)
        if error_reporting_panel is not None:
            pulumi.set(__self__, "error_reporting_panel", error_reporting_panel)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if incident_list is not None:
            pulumi.set(__self__, "incident_list", incident_list)
        if logs_panel is not None:
            pulumi.set(__self__, "logs_panel", logs_panel)
        if pie_chart is not None:
            pulumi.set(__self__, "pie_chart", pie_chart)
        if scorecard is not None:
            pulumi.set(__self__, "scorecard", scorecard)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if time_series_table is not None:
            pulumi.set(__self__, "time_series_table", time_series_table)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if xy_chart is not None:
            pulumi.set(__self__, "xy_chart", xy_chart)

    @property
    @pulumi.getter(name="alertChart")
    def alert_chart(self) -> Optional[pulumi.Input['AlertChartArgs']]:
        """
        A chart of alert policy data.
        """
        return pulumi.get(self, "alert_chart")

    @alert_chart.setter
    def alert_chart(self, value: Optional[pulumi.Input['AlertChartArgs']]):
        pulumi.set(self, "alert_chart", value)

    @property
    @pulumi.getter
    def blank(self) -> Optional[pulumi.Input['EmptyArgs']]:
        """
        A blank space.
        """
        return pulumi.get(self, "blank")

    @blank.setter
    def blank(self, value: Optional[pulumi.Input['EmptyArgs']]):
        pulumi.set(self, "blank", value)

    @property
    @pulumi.getter(name="collapsibleGroup")
    def collapsible_group(self) -> Optional[pulumi.Input['CollapsibleGroupArgs']]:
        """
        A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
        """
        return pulumi.get(self, "collapsible_group")

    @collapsible_group.setter
    def collapsible_group(self, value: Optional[pulumi.Input['CollapsibleGroupArgs']]):
        pulumi.set(self, "collapsible_group", value)

    @property
    @pulumi.getter(name="errorReportingPanel")
    def error_reporting_panel(self) -> Optional[pulumi.Input['ErrorReportingPanelArgs']]:
        """
        A widget that displays a list of error groups.
        """
        return pulumi.get(self, "error_reporting_panel")

    @error_reporting_panel.setter
    def error_reporting_panel(self, value: Optional[pulumi.Input['ErrorReportingPanelArgs']]):
        pulumi.set(self, "error_reporting_panel", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="incidentList")
    def incident_list(self) -> Optional[pulumi.Input['IncidentListArgs']]:
        """
        A widget that shows list of incidents.
        """
        return pulumi.get(self, "incident_list")

    @incident_list.setter
    def incident_list(self, value: Optional[pulumi.Input['IncidentListArgs']]):
        pulumi.set(self, "incident_list", value)

    @property
    @pulumi.getter(name="logsPanel")
    def logs_panel(self) -> Optional[pulumi.Input['LogsPanelArgs']]:
        """
        A widget that shows a stream of logs.
        """
        return pulumi.get(self, "logs_panel")

    @logs_panel.setter
    def logs_panel(self, value: Optional[pulumi.Input['LogsPanelArgs']]):
        pulumi.set(self, "logs_panel", value)

    @property
    @pulumi.getter(name="pieChart")
    def pie_chart(self) -> Optional[pulumi.Input['PieChartArgs']]:
        """
        A widget that displays timeseries data as a pie chart.
        """
        return pulumi.get(self, "pie_chart")

    @pie_chart.setter
    def pie_chart(self, value: Optional[pulumi.Input['PieChartArgs']]):
        pulumi.set(self, "pie_chart", value)

    @property
    @pulumi.getter
    def scorecard(self) -> Optional[pulumi.Input['ScorecardArgs']]:
        """
        A scorecard summarizing time series data.
        """
        return pulumi.get(self, "scorecard")

    @scorecard.setter
    def scorecard(self, value: Optional[pulumi.Input['ScorecardArgs']]):
        pulumi.set(self, "scorecard", value)

    @property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['TextArgs']]:
        """
        A raw string or markdown displaying textual content.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['TextArgs']]):
        pulumi.set(self, "text", value)

    @property
    @pulumi.getter(name="timeSeriesTable")
    def time_series_table(self) -> Optional[pulumi.Input['TimeSeriesTableArgs']]:
        """
        A widget that displays time series data in a tabular format.
        """
        return pulumi.get(self, "time_series_table")

    @time_series_table.setter
    def time_series_table(self, value: Optional[pulumi.Input['TimeSeriesTableArgs']]):
        pulumi.set(self, "time_series_table", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="xyChart")
    def xy_chart(self) -> Optional[pulumi.Input['XyChartArgs']]:
        """
        A chart of time series data.
        """
        return pulumi.get(self, "xy_chart")

    @xy_chart.setter
    def xy_chart(self, value: Optional[pulumi.Input['XyChartArgs']]):
        pulumi.set(self, "xy_chart", value)


@pulumi.input_type
class XyChartArgs:
    def __init__(__self__, *,
                 data_sets: pulumi.Input[Sequence[pulumi.Input['DataSetArgs']]],
                 chart_options: Optional[pulumi.Input['ChartOptionsArgs']] = None,
                 thresholds: Optional[pulumi.Input[Sequence[pulumi.Input['ThresholdArgs']]]] = None,
                 timeshift_duration: Optional[pulumi.Input[str]] = None,
                 x_axis: Optional[pulumi.Input['AxisArgs']] = None,
                 y2_axis: Optional[pulumi.Input['AxisArgs']] = None,
                 y_axis: Optional[pulumi.Input['AxisArgs']] = None):
        """
        A chart that displays data on a 2D (X and Y axes) plane.
        :param pulumi.Input[Sequence[pulumi.Input['DataSetArgs']]] data_sets: The data displayed in this chart.
        :param pulumi.Input['ChartOptionsArgs'] chart_options: Display options for the chart.
        :param pulumi.Input[Sequence[pulumi.Input['ThresholdArgs']]] thresholds: Threshold lines drawn horizontally across the chart.
        :param pulumi.Input[str] timeshift_duration: The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
        :param pulumi.Input['AxisArgs'] x_axis: The properties applied to the x-axis.
        :param pulumi.Input['AxisArgs'] y2_axis: The properties applied to the y2-axis.
        :param pulumi.Input['AxisArgs'] y_axis: The properties applied to the y-axis.
        """
        pulumi.set(__self__, "data_sets", data_sets)
        if chart_options is not None:
            pulumi.set(__self__, "chart_options", chart_options)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)
        if timeshift_duration is not None:
            pulumi.set(__self__, "timeshift_duration", timeshift_duration)
        if x_axis is not None:
            pulumi.set(__self__, "x_axis", x_axis)
        if y2_axis is not None:
            pulumi.set(__self__, "y2_axis", y2_axis)
        if y_axis is not None:
            pulumi.set(__self__, "y_axis", y_axis)

    @property
    @pulumi.getter(name="dataSets")
    def data_sets(self) -> pulumi.Input[Sequence[pulumi.Input['DataSetArgs']]]:
        """
        The data displayed in this chart.
        """
        return pulumi.get(self, "data_sets")

    @data_sets.setter
    def data_sets(self, value: pulumi.Input[Sequence[pulumi.Input['DataSetArgs']]]):
        pulumi.set(self, "data_sets", value)

    @property
    @pulumi.getter(name="chartOptions")
    def chart_options(self) -> Optional[pulumi.Input['ChartOptionsArgs']]:
        """
        Display options for the chart.
        """
        return pulumi.get(self, "chart_options")

    @chart_options.setter
    def chart_options(self, value: Optional[pulumi.Input['ChartOptionsArgs']]):
        pulumi.set(self, "chart_options", value)

    @property
    @pulumi.getter
    def thresholds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ThresholdArgs']]]]:
        """
        Threshold lines drawn horizontally across the chart.
        """
        return pulumi.get(self, "thresholds")

    @thresholds.setter
    def thresholds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ThresholdArgs']]]]):
        pulumi.set(self, "thresholds", value)

    @property
    @pulumi.getter(name="timeshiftDuration")
    def timeshift_duration(self) -> Optional[pulumi.Input[str]]:
        """
        The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
        """
        return pulumi.get(self, "timeshift_duration")

    @timeshift_duration.setter
    def timeshift_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeshift_duration", value)

    @property
    @pulumi.getter(name="xAxis")
    def x_axis(self) -> Optional[pulumi.Input['AxisArgs']]:
        """
        The properties applied to the x-axis.
        """
        return pulumi.get(self, "x_axis")

    @x_axis.setter
    def x_axis(self, value: Optional[pulumi.Input['AxisArgs']]):
        pulumi.set(self, "x_axis", value)

    @property
    @pulumi.getter(name="y2Axis")
    def y2_axis(self) -> Optional[pulumi.Input['AxisArgs']]:
        """
        The properties applied to the y2-axis.
        """
        return pulumi.get(self, "y2_axis")

    @y2_axis.setter
    def y2_axis(self, value: Optional[pulumi.Input['AxisArgs']]):
        pulumi.set(self, "y2_axis", value)

    @property
    @pulumi.getter(name="yAxis")
    def y_axis(self) -> Optional[pulumi.Input['AxisArgs']]:
        """
        The properties applied to the y-axis.
        """
        return pulumi.get(self, "y_axis")

    @y_axis.setter
    def y_axis(self, value: Optional[pulumi.Input['AxisArgs']]):
        pulumi.set(self, "y_axis", value)


