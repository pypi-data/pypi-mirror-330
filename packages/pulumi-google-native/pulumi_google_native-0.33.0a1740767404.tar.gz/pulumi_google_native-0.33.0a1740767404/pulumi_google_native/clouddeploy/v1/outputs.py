# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AdvanceChildRolloutJobResponse',
    'AdvanceRolloutRuleResponse',
    'AnthosClusterResponse',
    'AuditConfigResponse',
    'AuditLogConfigResponse',
    'AutomationResourceSelectorResponse',
    'AutomationRolloutMetadataResponse',
    'AutomationRuleConditionResponse',
    'AutomationRuleResponse',
    'BindingResponse',
    'BuildArtifactResponse',
    'CanaryDeploymentResponse',
    'CanaryResponse',
    'ChildRolloutJobsResponse',
    'CloudRunConfigResponse',
    'CloudRunLocationResponse',
    'CloudRunMetadataResponse',
    'CloudRunRenderMetadataResponse',
    'CreateChildRolloutJobResponse',
    'CustomCanaryDeploymentResponse',
    'DefaultPoolResponse',
    'DeliveryPipelineResponse',
    'DeployJobResponse',
    'DeployParametersResponse',
    'DeploymentJobsResponse',
    'ExecutionConfigResponse',
    'ExprResponse',
    'GatewayServiceMeshResponse',
    'GkeClusterResponse',
    'JobResponse',
    'KubernetesConfigResponse',
    'MetadataResponse',
    'MultiTargetResponse',
    'PhaseArtifactResponse',
    'PhaseConfigResponse',
    'PhaseResponse',
    'PipelineConditionResponse',
    'PipelineReadyConditionResponse',
    'PostdeployJobResponse',
    'PostdeployResponse',
    'PredeployJobResponse',
    'PredeployResponse',
    'PrivatePoolResponse',
    'PromoteReleaseRuleResponse',
    'ReleaseConditionResponse',
    'ReleaseReadyConditionResponse',
    'RenderMetadataResponse',
    'RepairModeResponse',
    'RepairRolloutRuleResponse',
    'RetryResponse',
    'RollbackResponse',
    'RuntimeConfigResponse',
    'SerialPipelineResponse',
    'ServiceNetworkingResponse',
    'SkaffoldSupportedConditionResponse',
    'StageResponse',
    'StandardResponse',
    'StrategyResponse',
    'TargetArtifactResponse',
    'TargetAttributeResponse',
    'TargetRenderResponse',
    'TargetResponse',
    'TargetsPresentConditionResponse',
    'TargetsTypeConditionResponse',
    'VerifyJobResponse',
]

@pulumi.output_type
class AdvanceChildRolloutJobResponse(dict):
    """
    An advanceChildRollout Job.
    """
    def __init__(__self__):
        """
        An advanceChildRollout Job.
        """
        pass


@pulumi.output_type
class AdvanceRolloutRuleResponse(dict):
    """
    The `AdvanceRollout` automation rule will automatically advance a successful Rollout to the next phase.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourcePhases":
            suggest = "source_phases"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvanceRolloutRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvanceRolloutRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvanceRolloutRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: 'outputs.AutomationRuleConditionResponse',
                 source_phases: Sequence[str],
                 wait: str):
        """
        The `AdvanceRollout` automation rule will automatically advance a successful Rollout to the next phase.
        :param 'AutomationRuleConditionResponse' condition: Information around the state of the Automation rule.
        :param Sequence[str] source_phases: Optional. Proceeds only after phase name matched any one in the list. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
        :param str wait: Optional. How long to wait after a rollout is finished.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "source_phases", source_phases)
        pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.AutomationRuleConditionResponse':
        """
        Information around the state of the Automation rule.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="sourcePhases")
    def source_phases(self) -> Sequence[str]:
        """
        Optional. Proceeds only after phase name matched any one in the list. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
        """
        return pulumi.get(self, "source_phases")

    @property
    @pulumi.getter
    def wait(self) -> str:
        """
        Optional. How long to wait after a rollout is finished.
        """
        return pulumi.get(self, "wait")


@pulumi.output_type
class AnthosClusterResponse(dict):
    """
    Information specifying an Anthos Cluster.
    """
    def __init__(__self__, *,
                 membership: str):
        """
        Information specifying an Anthos Cluster.
        :param str membership: Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is `projects/{project}/locations/{location}/memberships/{membership_name}`.
        """
        pulumi.set(__self__, "membership", membership)

    @property
    @pulumi.getter
    def membership(self) -> str:
        """
        Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is `projects/{project}/locations/{location}/memberships/{membership_name}`.
        """
        return pulumi.get(self, "membership")


@pulumi.output_type
class AuditConfigResponse(dict):
    """
    Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts `jose@example.com` from DATA_READ logging, and `aliya@example.com` from DATA_WRITE logging.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditLogConfigs":
            suggest = "audit_log_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audit_log_configs: Sequence['outputs.AuditLogConfigResponse'],
                 service: str):
        """
        Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts `jose@example.com` from DATA_READ logging, and `aliya@example.com` from DATA_WRITE logging.
        :param Sequence['AuditLogConfigResponse'] audit_log_configs: The configuration for logging of each type of permission.
        :param str service: Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
        """
        pulumi.set(__self__, "audit_log_configs", audit_log_configs)
        pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter(name="auditLogConfigs")
    def audit_log_configs(self) -> Sequence['outputs.AuditLogConfigResponse']:
        """
        The configuration for logging of each type of permission.
        """
        return pulumi.get(self, "audit_log_configs")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class AuditLogConfigResponse(dict):
    """
    Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exemptedMembers":
            suggest = "exempted_members"
        elif key == "logType":
            suggest = "log_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditLogConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditLogConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditLogConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exempted_members: Sequence[str],
                 log_type: str):
        """
        Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
        :param Sequence[str] exempted_members: Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
        :param str log_type: The log type that this config enables.
        """
        pulumi.set(__self__, "exempted_members", exempted_members)
        pulumi.set(__self__, "log_type", log_type)

    @property
    @pulumi.getter(name="exemptedMembers")
    def exempted_members(self) -> Sequence[str]:
        """
        Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
        """
        return pulumi.get(self, "exempted_members")

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> str:
        """
        The log type that this config enables.
        """
        return pulumi.get(self, "log_type")


@pulumi.output_type
class AutomationResourceSelectorResponse(dict):
    """
    AutomationResourceSelector contains the information to select the resources to which an Automation is going to be applied.
    """
    def __init__(__self__, *,
                 targets: Sequence['outputs.TargetAttributeResponse']):
        """
        AutomationResourceSelector contains the information to select the resources to which an Automation is going to be applied.
        :param Sequence['TargetAttributeResponse'] targets: Contains attributes about a target.
        """
        pulumi.set(__self__, "targets", targets)

    @property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.TargetAttributeResponse']:
        """
        Contains attributes about a target.
        """
        return pulumi.get(self, "targets")


@pulumi.output_type
class AutomationRolloutMetadataResponse(dict):
    """
    AutomationRolloutMetadata contains Automation-related actions that were performed on a rollout.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advanceAutomationRuns":
            suggest = "advance_automation_runs"
        elif key == "promoteAutomationRun":
            suggest = "promote_automation_run"
        elif key == "repairAutomationRuns":
            suggest = "repair_automation_runs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRolloutMetadataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRolloutMetadataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRolloutMetadataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advance_automation_runs: Sequence[str],
                 promote_automation_run: str,
                 repair_automation_runs: Sequence[str]):
        """
        AutomationRolloutMetadata contains Automation-related actions that were performed on a rollout.
        :param Sequence[str] advance_automation_runs: The IDs of the AutomationRuns initiated by an advance rollout rule.
        :param str promote_automation_run: The ID of the AutomationRun initiated by a promote release rule.
        :param Sequence[str] repair_automation_runs: The IDs of the AutomationRuns initiated by a repair rollout rule.
        """
        pulumi.set(__self__, "advance_automation_runs", advance_automation_runs)
        pulumi.set(__self__, "promote_automation_run", promote_automation_run)
        pulumi.set(__self__, "repair_automation_runs", repair_automation_runs)

    @property
    @pulumi.getter(name="advanceAutomationRuns")
    def advance_automation_runs(self) -> Sequence[str]:
        """
        The IDs of the AutomationRuns initiated by an advance rollout rule.
        """
        return pulumi.get(self, "advance_automation_runs")

    @property
    @pulumi.getter(name="promoteAutomationRun")
    def promote_automation_run(self) -> str:
        """
        The ID of the AutomationRun initiated by a promote release rule.
        """
        return pulumi.get(self, "promote_automation_run")

    @property
    @pulumi.getter(name="repairAutomationRuns")
    def repair_automation_runs(self) -> Sequence[str]:
        """
        The IDs of the AutomationRuns initiated by a repair rollout rule.
        """
        return pulumi.get(self, "repair_automation_runs")


@pulumi.output_type
class AutomationRuleConditionResponse(dict):
    """
    `AutomationRuleCondition` contains conditions relevant to an `Automation` rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetsPresentCondition":
            suggest = "targets_present_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRuleConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRuleConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRuleConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 targets_present_condition: 'outputs.TargetsPresentConditionResponse'):
        """
        `AutomationRuleCondition` contains conditions relevant to an `Automation` rule.
        :param 'TargetsPresentConditionResponse' targets_present_condition: Optional. Details around targets enumerated in the rule.
        """
        pulumi.set(__self__, "targets_present_condition", targets_present_condition)

    @property
    @pulumi.getter(name="targetsPresentCondition")
    def targets_present_condition(self) -> 'outputs.TargetsPresentConditionResponse':
        """
        Optional. Details around targets enumerated in the rule.
        """
        return pulumi.get(self, "targets_present_condition")


@pulumi.output_type
class AutomationRuleResponse(dict):
    """
    `AutomationRule` defines the automation activities.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advanceRolloutRule":
            suggest = "advance_rollout_rule"
        elif key == "promoteReleaseRule":
            suggest = "promote_release_rule"
        elif key == "repairRolloutRule":
            suggest = "repair_rollout_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advance_rollout_rule: 'outputs.AdvanceRolloutRuleResponse',
                 promote_release_rule: 'outputs.PromoteReleaseRuleResponse',
                 repair_rollout_rule: 'outputs.RepairRolloutRuleResponse'):
        """
        `AutomationRule` defines the automation activities.
        :param 'AdvanceRolloutRuleResponse' advance_rollout_rule: Optional. The `AdvanceRolloutRule` will automatically advance a successful Rollout.
        :param 'PromoteReleaseRuleResponse' promote_release_rule: Optional. `PromoteReleaseRule` will automatically promote a release from the current target to a specified target.
        :param 'RepairRolloutRuleResponse' repair_rollout_rule: Optional. The `RepairRolloutRule` will automatically repair a failed rollout.
        """
        pulumi.set(__self__, "advance_rollout_rule", advance_rollout_rule)
        pulumi.set(__self__, "promote_release_rule", promote_release_rule)
        pulumi.set(__self__, "repair_rollout_rule", repair_rollout_rule)

    @property
    @pulumi.getter(name="advanceRolloutRule")
    def advance_rollout_rule(self) -> 'outputs.AdvanceRolloutRuleResponse':
        """
        Optional. The `AdvanceRolloutRule` will automatically advance a successful Rollout.
        """
        return pulumi.get(self, "advance_rollout_rule")

    @property
    @pulumi.getter(name="promoteReleaseRule")
    def promote_release_rule(self) -> 'outputs.PromoteReleaseRuleResponse':
        """
        Optional. `PromoteReleaseRule` will automatically promote a release from the current target to a specified target.
        """
        return pulumi.get(self, "promote_release_rule")

    @property
    @pulumi.getter(name="repairRolloutRule")
    def repair_rollout_rule(self) -> 'outputs.RepairRolloutRuleResponse':
        """
        Optional. The `RepairRolloutRule` will automatically repair a failed rollout.
        """
        return pulumi.get(self, "repair_rollout_rule")


@pulumi.output_type
class BindingResponse(dict):
    """
    Associates `members`, or principals, with a `role`.
    """
    def __init__(__self__, *,
                 condition: 'outputs.ExprResponse',
                 members: Sequence[str],
                 role: str):
        """
        Associates `members`, or principals, with a `role`.
        :param 'ExprResponse' condition: The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        :param Sequence[str] members: Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
        :param str role: Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "members", members)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.ExprResponse':
        """
        The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def members(self) -> Sequence[str]:
        """
        Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
        """
        return pulumi.get(self, "members")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class BuildArtifactResponse(dict):
    """
    Description of an a image to use during Skaffold rendering.
    """
    def __init__(__self__, *,
                 image: str,
                 tag: str):
        """
        Description of an a image to use during Skaffold rendering.
        :param str image: Image name in Skaffold configuration.
        :param str tag: Image tag to use. This will generally be the full path to an image, such as "gcr.io/my-project/busybox:1.2.3" or "gcr.io/my-project/busybox@sha256:abc123".
        """
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def image(self) -> str:
        """
        Image name in Skaffold configuration.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        Image tag to use. This will generally be the full path to an image, such as "gcr.io/my-project/busybox:1.2.3" or "gcr.io/my-project/busybox@sha256:abc123".
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class CanaryDeploymentResponse(dict):
    """
    CanaryDeployment represents the canary deployment configuration
    """
    def __init__(__self__, *,
                 percentages: Sequence[int],
                 postdeploy: 'outputs.PostdeployResponse',
                 predeploy: 'outputs.PredeployResponse',
                 verify: bool):
        """
        CanaryDeployment represents the canary deployment configuration
        :param Sequence[int] percentages: The percentage based deployments that will occur as a part of a `Rollout`. List is expected in ascending order and each integer n is 0 <= n < 100.
        :param 'PostdeployResponse' postdeploy: Optional. Configuration for the postdeploy job of the last phase. If this is not configured, there will be no postdeploy job for this phase.
        :param 'PredeployResponse' predeploy: Optional. Configuration for the predeploy job of the first phase. If this is not configured, there will be no predeploy job for this phase.
        :param bool verify: Whether to run verify tests after each percentage deployment.
        """
        pulumi.set(__self__, "percentages", percentages)
        pulumi.set(__self__, "postdeploy", postdeploy)
        pulumi.set(__self__, "predeploy", predeploy)
        pulumi.set(__self__, "verify", verify)

    @property
    @pulumi.getter
    def percentages(self) -> Sequence[int]:
        """
        The percentage based deployments that will occur as a part of a `Rollout`. List is expected in ascending order and each integer n is 0 <= n < 100.
        """
        return pulumi.get(self, "percentages")

    @property
    @pulumi.getter
    def postdeploy(self) -> 'outputs.PostdeployResponse':
        """
        Optional. Configuration for the postdeploy job of the last phase. If this is not configured, there will be no postdeploy job for this phase.
        """
        return pulumi.get(self, "postdeploy")

    @property
    @pulumi.getter
    def predeploy(self) -> 'outputs.PredeployResponse':
        """
        Optional. Configuration for the predeploy job of the first phase. If this is not configured, there will be no predeploy job for this phase.
        """
        return pulumi.get(self, "predeploy")

    @property
    @pulumi.getter
    def verify(self) -> bool:
        """
        Whether to run verify tests after each percentage deployment.
        """
        return pulumi.get(self, "verify")


@pulumi.output_type
class CanaryResponse(dict):
    """
    Canary represents the canary deployment strategy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canaryDeployment":
            suggest = "canary_deployment"
        elif key == "customCanaryDeployment":
            suggest = "custom_canary_deployment"
        elif key == "runtimeConfig":
            suggest = "runtime_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CanaryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CanaryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CanaryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canary_deployment: 'outputs.CanaryDeploymentResponse',
                 custom_canary_deployment: 'outputs.CustomCanaryDeploymentResponse',
                 runtime_config: 'outputs.RuntimeConfigResponse'):
        """
        Canary represents the canary deployment strategy.
        :param 'CanaryDeploymentResponse' canary_deployment: Configures the progressive based deployment for a Target.
        :param 'CustomCanaryDeploymentResponse' custom_canary_deployment: Configures the progressive based deployment for a Target, but allows customizing at the phase level where a phase represents each of the percentage deployments.
        :param 'RuntimeConfigResponse' runtime_config: Optional. Runtime specific configurations for the deployment strategy. The runtime configuration is used to determine how Cloud Deploy will split traffic to enable a progressive deployment.
        """
        pulumi.set(__self__, "canary_deployment", canary_deployment)
        pulumi.set(__self__, "custom_canary_deployment", custom_canary_deployment)
        pulumi.set(__self__, "runtime_config", runtime_config)

    @property
    @pulumi.getter(name="canaryDeployment")
    def canary_deployment(self) -> 'outputs.CanaryDeploymentResponse':
        """
        Configures the progressive based deployment for a Target.
        """
        return pulumi.get(self, "canary_deployment")

    @property
    @pulumi.getter(name="customCanaryDeployment")
    def custom_canary_deployment(self) -> 'outputs.CustomCanaryDeploymentResponse':
        """
        Configures the progressive based deployment for a Target, but allows customizing at the phase level where a phase represents each of the percentage deployments.
        """
        return pulumi.get(self, "custom_canary_deployment")

    @property
    @pulumi.getter(name="runtimeConfig")
    def runtime_config(self) -> 'outputs.RuntimeConfigResponse':
        """
        Optional. Runtime specific configurations for the deployment strategy. The runtime configuration is used to determine how Cloud Deploy will split traffic to enable a progressive deployment.
        """
        return pulumi.get(self, "runtime_config")


@pulumi.output_type
class ChildRolloutJobsResponse(dict):
    """
    ChildRollouts job composition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advanceRolloutJobs":
            suggest = "advance_rollout_jobs"
        elif key == "createRolloutJobs":
            suggest = "create_rollout_jobs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChildRolloutJobsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChildRolloutJobsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChildRolloutJobsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advance_rollout_jobs: Sequence['outputs.JobResponse'],
                 create_rollout_jobs: Sequence['outputs.JobResponse']):
        """
        ChildRollouts job composition
        :param Sequence['JobResponse'] advance_rollout_jobs: List of AdvanceChildRolloutJobs
        :param Sequence['JobResponse'] create_rollout_jobs: List of CreateChildRolloutJobs
        """
        pulumi.set(__self__, "advance_rollout_jobs", advance_rollout_jobs)
        pulumi.set(__self__, "create_rollout_jobs", create_rollout_jobs)

    @property
    @pulumi.getter(name="advanceRolloutJobs")
    def advance_rollout_jobs(self) -> Sequence['outputs.JobResponse']:
        """
        List of AdvanceChildRolloutJobs
        """
        return pulumi.get(self, "advance_rollout_jobs")

    @property
    @pulumi.getter(name="createRolloutJobs")
    def create_rollout_jobs(self) -> Sequence['outputs.JobResponse']:
        """
        List of CreateChildRolloutJobs
        """
        return pulumi.get(self, "create_rollout_jobs")


@pulumi.output_type
class CloudRunConfigResponse(dict):
    """
    CloudRunConfig contains the Cloud Run runtime configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automaticTrafficControl":
            suggest = "automatic_traffic_control"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudRunConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudRunConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudRunConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automatic_traffic_control: bool):
        """
        CloudRunConfig contains the Cloud Run runtime configuration.
        :param bool automatic_traffic_control: Whether Cloud Deploy should update the traffic stanza in a Cloud Run Service on the user's behalf to facilitate traffic splitting. This is required to be true for CanaryDeployments, but optional for CustomCanaryDeployments.
        """
        pulumi.set(__self__, "automatic_traffic_control", automatic_traffic_control)

    @property
    @pulumi.getter(name="automaticTrafficControl")
    def automatic_traffic_control(self) -> bool:
        """
        Whether Cloud Deploy should update the traffic stanza in a Cloud Run Service on the user's behalf to facilitate traffic splitting. This is required to be true for CanaryDeployments, but optional for CustomCanaryDeployments.
        """
        return pulumi.get(self, "automatic_traffic_control")


@pulumi.output_type
class CloudRunLocationResponse(dict):
    """
    Information specifying where to deploy a Cloud Run Service.
    """
    def __init__(__self__, *,
                 location: str):
        """
        Information specifying where to deploy a Cloud Run Service.
        :param str location: The location for the Cloud Run Service. Format must be `projects/{project}/locations/{location}`.
        """
        pulumi.set(__self__, "location", location)

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The location for the Cloud Run Service. Format must be `projects/{project}/locations/{location}`.
        """
        return pulumi.get(self, "location")


@pulumi.output_type
class CloudRunMetadataResponse(dict):
    """
    CloudRunMetadata contains information from a Cloud Run deployment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceUrls":
            suggest = "service_urls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudRunMetadataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudRunMetadataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudRunMetadataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job: str,
                 revision: str,
                 service: str,
                 service_urls: Sequence[str]):
        """
        CloudRunMetadata contains information from a Cloud Run deployment.
        :param str job: The name of the Cloud Run job that is associated with a `Rollout`. Format is `projects/{project}/locations/{location}/jobs/{job_name}`.
        :param str revision: The Cloud Run Revision id associated with a `Rollout`.
        :param str service: The name of the Cloud Run Service that is associated with a `Rollout`. Format is `projects/{project}/locations/{location}/services/{service}`.
        :param Sequence[str] service_urls: The Cloud Run Service urls that are associated with a `Rollout`.
        """
        pulumi.set(__self__, "job", job)
        pulumi.set(__self__, "revision", revision)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "service_urls", service_urls)

    @property
    @pulumi.getter
    def job(self) -> str:
        """
        The name of the Cloud Run job that is associated with a `Rollout`. Format is `projects/{project}/locations/{location}/jobs/{job_name}`.
        """
        return pulumi.get(self, "job")

    @property
    @pulumi.getter
    def revision(self) -> str:
        """
        The Cloud Run Revision id associated with a `Rollout`.
        """
        return pulumi.get(self, "revision")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        The name of the Cloud Run Service that is associated with a `Rollout`. Format is `projects/{project}/locations/{location}/services/{service}`.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="serviceUrls")
    def service_urls(self) -> Sequence[str]:
        """
        The Cloud Run Service urls that are associated with a `Rollout`.
        """
        return pulumi.get(self, "service_urls")


@pulumi.output_type
class CloudRunRenderMetadataResponse(dict):
    """
    CloudRunRenderMetadata contains Cloud Run information associated with a `Release` render.
    """
    def __init__(__self__, *,
                 service: str):
        """
        CloudRunRenderMetadata contains Cloud Run information associated with a `Release` render.
        :param str service: The name of the Cloud Run Service in the rendered manifest. Format is `projects/{project}/locations/{location}/services/{service}`.
        """
        pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        The name of the Cloud Run Service in the rendered manifest. Format is `projects/{project}/locations/{location}/services/{service}`.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class CreateChildRolloutJobResponse(dict):
    """
    A createChildRollout Job.
    """
    def __init__(__self__):
        """
        A createChildRollout Job.
        """
        pass


@pulumi.output_type
class CustomCanaryDeploymentResponse(dict):
    """
    CustomCanaryDeployment represents the custom canary deployment configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "phaseConfigs":
            suggest = "phase_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomCanaryDeploymentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomCanaryDeploymentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomCanaryDeploymentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 phase_configs: Sequence['outputs.PhaseConfigResponse']):
        """
        CustomCanaryDeployment represents the custom canary deployment configuration.
        :param Sequence['PhaseConfigResponse'] phase_configs: Configuration for each phase in the canary deployment in the order executed.
        """
        pulumi.set(__self__, "phase_configs", phase_configs)

    @property
    @pulumi.getter(name="phaseConfigs")
    def phase_configs(self) -> Sequence['outputs.PhaseConfigResponse']:
        """
        Configuration for each phase in the canary deployment in the order executed.
        """
        return pulumi.get(self, "phase_configs")


@pulumi.output_type
class DefaultPoolResponse(dict):
    """
    Execution using the default Cloud Build pool.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "artifactStorage":
            suggest = "artifact_storage"
        elif key == "serviceAccount":
            suggest = "service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultPoolResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultPoolResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultPoolResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 artifact_storage: str,
                 service_account: str):
        """
        Execution using the default Cloud Build pool.
        :param str artifact_storage: Optional. Cloud Storage location where execution outputs should be stored. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
        :param str service_account: Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) will be used.
        """
        pulumi.set(__self__, "artifact_storage", artifact_storage)
        pulumi.set(__self__, "service_account", service_account)

    @property
    @pulumi.getter(name="artifactStorage")
    def artifact_storage(self) -> str:
        """
        Optional. Cloud Storage location where execution outputs should be stored. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
        """
        return pulumi.get(self, "artifact_storage")

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> str:
        """
        Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) will be used.
        """
        return pulumi.get(self, "service_account")


@pulumi.output_type
class DeliveryPipelineResponse(dict):
    """
    A `DeliveryPipeline` resource in the Cloud Deploy API. A `DeliveryPipeline` defines a pipeline through which a Skaffold configuration can progress.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createTime":
            suggest = "create_time"
        elif key == "serialPipeline":
            suggest = "serial_pipeline"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryPipelineResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryPipelineResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryPipelineResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations: Mapping[str, str],
                 condition: 'outputs.PipelineConditionResponse',
                 create_time: str,
                 description: str,
                 etag: str,
                 labels: Mapping[str, str],
                 name: str,
                 serial_pipeline: 'outputs.SerialPipelineResponse',
                 suspended: bool,
                 uid: str,
                 update_time: str):
        """
        A `DeliveryPipeline` resource in the Cloud Deploy API. A `DeliveryPipeline` defines a pipeline through which a Skaffold configuration can progress.
        :param Mapping[str, str] annotations: User annotations. These attributes can only be set and used by the user, and not by Cloud Deploy.
        :param 'PipelineConditionResponse' condition: Information around the state of the Delivery Pipeline.
        :param str create_time: Time at which the pipeline was created.
        :param str description: Description of the `DeliveryPipeline`. Max length is 255 characters.
        :param str etag: This checksum is computed by the server based on the value of other fields, and may be sent on update and delete requests to ensure the client has an up-to-date value before proceeding.
        :param Mapping[str, str] labels: Labels are attributes that can be set and used by both the user and by Cloud Deploy. Labels must meet the following constraints: * Keys and values can contain only lowercase letters, numeric characters, underscores, and dashes. * All characters must use UTF-8 encoding, and international characters are allowed. * Keys must start with a lowercase letter or international character. * Each resource is limited to a maximum of 64 labels. Both keys and values are additionally constrained to be <= 128 bytes.
        :param str name: Optional. Name of the `DeliveryPipeline`. Format is `projects/{project}/locations/{location}/deliveryPipelines/a-z{0,62}`.
        :param 'SerialPipelineResponse' serial_pipeline: SerialPipeline defines a sequential set of stages for a `DeliveryPipeline`.
        :param bool suspended: When suspended, no new releases or rollouts can be created, but in-progress ones will complete.
        :param str uid: Unique identifier of the `DeliveryPipeline`.
        :param str update_time: Most recent time at which the pipeline was updated.
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "etag", etag)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "serial_pipeline", serial_pipeline)
        pulumi.set(__self__, "suspended", suspended)
        pulumi.set(__self__, "uid", uid)
        pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def annotations(self) -> Mapping[str, str]:
        """
        User annotations. These attributes can only be set and used by the user, and not by Cloud Deploy.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.PipelineConditionResponse':
        """
        Information around the state of the Delivery Pipeline.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Time at which the pipeline was created.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the `DeliveryPipeline`. Max length is 255 characters.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        This checksum is computed by the server based on the value of other fields, and may be sent on update and delete requests to ensure the client has an up-to-date value before proceeding.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Labels are attributes that can be set and used by both the user and by Cloud Deploy. Labels must meet the following constraints: * Keys and values can contain only lowercase letters, numeric characters, underscores, and dashes. * All characters must use UTF-8 encoding, and international characters are allowed. * Keys must start with a lowercase letter or international character. * Each resource is limited to a maximum of 64 labels. Both keys and values are additionally constrained to be <= 128 bytes.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Optional. Name of the `DeliveryPipeline`. Format is `projects/{project}/locations/{location}/deliveryPipelines/a-z{0,62}`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serialPipeline")
    def serial_pipeline(self) -> 'outputs.SerialPipelineResponse':
        """
        SerialPipeline defines a sequential set of stages for a `DeliveryPipeline`.
        """
        return pulumi.get(self, "serial_pipeline")

    @property
    @pulumi.getter
    def suspended(self) -> bool:
        """
        When suspended, no new releases or rollouts can be created, but in-progress ones will complete.
        """
        return pulumi.get(self, "suspended")

    @property
    @pulumi.getter
    def uid(self) -> str:
        """
        Unique identifier of the `DeliveryPipeline`.
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> str:
        """
        Most recent time at which the pipeline was updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class DeployJobResponse(dict):
    """
    A deploy Job.
    """
    def __init__(__self__):
        """
        A deploy Job.
        """
        pass


@pulumi.output_type
class DeployParametersResponse(dict):
    """
    DeployParameters contains deploy parameters information.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchTargetLabels":
            suggest = "match_target_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeployParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeployParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeployParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_target_labels: Mapping[str, str],
                 values: Mapping[str, str]):
        """
        DeployParameters contains deploy parameters information.
        :param Mapping[str, str] match_target_labels: Optional. Deploy parameters are applied to targets with match labels. If unspecified, deploy parameters are applied to all targets (including child targets of a multi-target).
        :param Mapping[str, str] values: Values are deploy parameters in key-value pairs.
        """
        pulumi.set(__self__, "match_target_labels", match_target_labels)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="matchTargetLabels")
    def match_target_labels(self) -> Mapping[str, str]:
        """
        Optional. Deploy parameters are applied to targets with match labels. If unspecified, deploy parameters are applied to all targets (including child targets of a multi-target).
        """
        return pulumi.get(self, "match_target_labels")

    @property
    @pulumi.getter
    def values(self) -> Mapping[str, str]:
        """
        Values are deploy parameters in key-value pairs.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class DeploymentJobsResponse(dict):
    """
    Deployment job composition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployJob":
            suggest = "deploy_job"
        elif key == "postdeployJob":
            suggest = "postdeploy_job"
        elif key == "predeployJob":
            suggest = "predeploy_job"
        elif key == "verifyJob":
            suggest = "verify_job"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentJobsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentJobsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentJobsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deploy_job: 'outputs.JobResponse',
                 postdeploy_job: 'outputs.JobResponse',
                 predeploy_job: 'outputs.JobResponse',
                 verify_job: 'outputs.JobResponse'):
        """
        Deployment job composition.
        :param 'JobResponse' deploy_job: The deploy Job. This is the deploy job in the phase.
        :param 'JobResponse' postdeploy_job: The postdeploy Job, which is the last job on the phase.
        :param 'JobResponse' predeploy_job: The predeploy Job, which is the first job on the phase.
        :param 'JobResponse' verify_job: The verify Job. Runs after a deploy if the deploy succeeds.
        """
        pulumi.set(__self__, "deploy_job", deploy_job)
        pulumi.set(__self__, "postdeploy_job", postdeploy_job)
        pulumi.set(__self__, "predeploy_job", predeploy_job)
        pulumi.set(__self__, "verify_job", verify_job)

    @property
    @pulumi.getter(name="deployJob")
    def deploy_job(self) -> 'outputs.JobResponse':
        """
        The deploy Job. This is the deploy job in the phase.
        """
        return pulumi.get(self, "deploy_job")

    @property
    @pulumi.getter(name="postdeployJob")
    def postdeploy_job(self) -> 'outputs.JobResponse':
        """
        The postdeploy Job, which is the last job on the phase.
        """
        return pulumi.get(self, "postdeploy_job")

    @property
    @pulumi.getter(name="predeployJob")
    def predeploy_job(self) -> 'outputs.JobResponse':
        """
        The predeploy Job, which is the first job on the phase.
        """
        return pulumi.get(self, "predeploy_job")

    @property
    @pulumi.getter(name="verifyJob")
    def verify_job(self) -> 'outputs.JobResponse':
        """
        The verify Job. Runs after a deploy if the deploy succeeds.
        """
        return pulumi.get(self, "verify_job")


@pulumi.output_type
class ExecutionConfigResponse(dict):
    """
    Configuration of the environment to use when calling Skaffold.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "artifactStorage":
            suggest = "artifact_storage"
        elif key == "defaultPool":
            suggest = "default_pool"
        elif key == "executionTimeout":
            suggest = "execution_timeout"
        elif key == "privatePool":
            suggest = "private_pool"
        elif key == "serviceAccount":
            suggest = "service_account"
        elif key == "workerPool":
            suggest = "worker_pool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExecutionConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExecutionConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExecutionConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 artifact_storage: str,
                 default_pool: 'outputs.DefaultPoolResponse',
                 execution_timeout: str,
                 private_pool: 'outputs.PrivatePoolResponse',
                 service_account: str,
                 usages: Sequence[str],
                 worker_pool: str):
        """
        Configuration of the environment to use when calling Skaffold.
        :param str artifact_storage: Optional. Cloud Storage location in which to store execution outputs. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
        :param 'DefaultPoolResponse' default_pool: Optional. Use default Cloud Build pool.
        :param str execution_timeout: Optional. Execution timeout for a Cloud Build Execution. This must be between 10m and 24h in seconds format. If unspecified, a default timeout of 1h is used.
        :param 'PrivatePoolResponse' private_pool: Optional. Use private Cloud Build pool.
        :param str service_account: Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) is used.
        :param Sequence[str] usages: Usages when this configuration should be applied.
        :param str worker_pool: Optional. The resource name of the `WorkerPool`, with the format `projects/{project}/locations/{location}/workerPools/{worker_pool}`. If this optional field is unspecified, the default Cloud Build pool will be used.
        """
        pulumi.set(__self__, "artifact_storage", artifact_storage)
        pulumi.set(__self__, "default_pool", default_pool)
        pulumi.set(__self__, "execution_timeout", execution_timeout)
        pulumi.set(__self__, "private_pool", private_pool)
        pulumi.set(__self__, "service_account", service_account)
        pulumi.set(__self__, "usages", usages)
        pulumi.set(__self__, "worker_pool", worker_pool)

    @property
    @pulumi.getter(name="artifactStorage")
    def artifact_storage(self) -> str:
        """
        Optional. Cloud Storage location in which to store execution outputs. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
        """
        return pulumi.get(self, "artifact_storage")

    @property
    @pulumi.getter(name="defaultPool")
    def default_pool(self) -> 'outputs.DefaultPoolResponse':
        """
        Optional. Use default Cloud Build pool.
        """
        return pulumi.get(self, "default_pool")

    @property
    @pulumi.getter(name="executionTimeout")
    def execution_timeout(self) -> str:
        """
        Optional. Execution timeout for a Cloud Build Execution. This must be between 10m and 24h in seconds format. If unspecified, a default timeout of 1h is used.
        """
        return pulumi.get(self, "execution_timeout")

    @property
    @pulumi.getter(name="privatePool")
    def private_pool(self) -> 'outputs.PrivatePoolResponse':
        """
        Optional. Use private Cloud Build pool.
        """
        return pulumi.get(self, "private_pool")

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> str:
        """
        Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) is used.
        """
        return pulumi.get(self, "service_account")

    @property
    @pulumi.getter
    def usages(self) -> Sequence[str]:
        """
        Usages when this configuration should be applied.
        """
        return pulumi.get(self, "usages")

    @property
    @pulumi.getter(name="workerPool")
    def worker_pool(self) -> str:
        """
        Optional. The resource name of the `WorkerPool`, with the format `projects/{project}/locations/{location}/workerPools/{worker_pool}`. If this optional field is unspecified, the default Cloud Build pool will be used.
        """
        return pulumi.get(self, "worker_pool")


@pulumi.output_type
class ExprResponse(dict):
    """
    Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
    """
    def __init__(__self__, *,
                 description: str,
                 expression: str,
                 location: str,
                 title: str):
        """
        Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
        :param str description: Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        :param str expression: Textual representation of an expression in Common Expression Language syntax.
        :param str location: Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
        :param str title: Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GatewayServiceMeshResponse(dict):
    """
    Information about the Kubernetes Gateway API service mesh configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpRoute":
            suggest = "http_route"
        elif key == "routeUpdateWaitTime":
            suggest = "route_update_wait_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayServiceMeshResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayServiceMeshResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayServiceMeshResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment: str,
                 http_route: str,
                 route_update_wait_time: str,
                 service: str):
        """
        Information about the Kubernetes Gateway API service mesh configuration.
        :param str deployment: Name of the Kubernetes Deployment whose traffic is managed by the specified HTTPRoute and Service.
        :param str http_route: Name of the Gateway API HTTPRoute.
        :param str route_update_wait_time: Optional. The time to wait for route updates to propagate. The maximum configurable time is 3 hours, in seconds format. If unspecified, there is no wait time.
        :param str service: Name of the Kubernetes Service.
        """
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "http_route", http_route)
        pulumi.set(__self__, "route_update_wait_time", route_update_wait_time)
        pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def deployment(self) -> str:
        """
        Name of the Kubernetes Deployment whose traffic is managed by the specified HTTPRoute and Service.
        """
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter(name="httpRoute")
    def http_route(self) -> str:
        """
        Name of the Gateway API HTTPRoute.
        """
        return pulumi.get(self, "http_route")

    @property
    @pulumi.getter(name="routeUpdateWaitTime")
    def route_update_wait_time(self) -> str:
        """
        Optional. The time to wait for route updates to propagate. The maximum configurable time is 3 hours, in seconds format. If unspecified, there is no wait time.
        """
        return pulumi.get(self, "route_update_wait_time")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        Name of the Kubernetes Service.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GkeClusterResponse(dict):
    """
    Information specifying a GKE Cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalIp":
            suggest = "internal_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GkeClusterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GkeClusterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GkeClusterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster: str,
                 internal_ip: bool):
        """
        Information specifying a GKE Cluster.
        :param str cluster: Information specifying a GKE Cluster. Format is `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`.
        :param bool internal_ip: Optional. If true, `cluster` is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used. The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise. Only specify this option when `cluster` is a [private GKE cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
        """
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "internal_ip", internal_ip)

    @property
    @pulumi.getter
    def cluster(self) -> str:
        """
        Information specifying a GKE Cluster. Format is `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`.
        """
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> bool:
        """
        Optional. If true, `cluster` is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used. The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise. Only specify this option when `cluster` is a [private GKE cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
        """
        return pulumi.get(self, "internal_ip")


@pulumi.output_type
class JobResponse(dict):
    """
    Job represents an operation for a `Rollout`.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advanceChildRolloutJob":
            suggest = "advance_child_rollout_job"
        elif key == "createChildRolloutJob":
            suggest = "create_child_rollout_job"
        elif key == "deployJob":
            suggest = "deploy_job"
        elif key == "jobRun":
            suggest = "job_run"
        elif key == "postdeployJob":
            suggest = "postdeploy_job"
        elif key == "predeployJob":
            suggest = "predeploy_job"
        elif key == "skipMessage":
            suggest = "skip_message"
        elif key == "verifyJob":
            suggest = "verify_job"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advance_child_rollout_job: 'outputs.AdvanceChildRolloutJobResponse',
                 create_child_rollout_job: 'outputs.CreateChildRolloutJobResponse',
                 deploy_job: 'outputs.DeployJobResponse',
                 job_run: str,
                 postdeploy_job: 'outputs.PostdeployJobResponse',
                 predeploy_job: 'outputs.PredeployJobResponse',
                 skip_message: str,
                 state: str,
                 verify_job: 'outputs.VerifyJobResponse'):
        """
        Job represents an operation for a `Rollout`.
        :param 'AdvanceChildRolloutJobResponse' advance_child_rollout_job: An advanceChildRollout Job.
        :param 'CreateChildRolloutJobResponse' create_child_rollout_job: A createChildRollout Job.
        :param 'DeployJobResponse' deploy_job: A deploy Job.
        :param str job_run: The name of the `JobRun` responsible for the most recent invocation of this Job.
        :param 'PostdeployJobResponse' postdeploy_job: A postdeploy Job.
        :param 'PredeployJobResponse' predeploy_job: A predeploy Job.
        :param str skip_message: Additional information on why the Job was skipped, if available.
        :param str state: The current state of the Job.
        :param 'VerifyJobResponse' verify_job: A verify Job.
        """
        pulumi.set(__self__, "advance_child_rollout_job", advance_child_rollout_job)
        pulumi.set(__self__, "create_child_rollout_job", create_child_rollout_job)
        pulumi.set(__self__, "deploy_job", deploy_job)
        pulumi.set(__self__, "job_run", job_run)
        pulumi.set(__self__, "postdeploy_job", postdeploy_job)
        pulumi.set(__self__, "predeploy_job", predeploy_job)
        pulumi.set(__self__, "skip_message", skip_message)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "verify_job", verify_job)

    @property
    @pulumi.getter(name="advanceChildRolloutJob")
    def advance_child_rollout_job(self) -> 'outputs.AdvanceChildRolloutJobResponse':
        """
        An advanceChildRollout Job.
        """
        return pulumi.get(self, "advance_child_rollout_job")

    @property
    @pulumi.getter(name="createChildRolloutJob")
    def create_child_rollout_job(self) -> 'outputs.CreateChildRolloutJobResponse':
        """
        A createChildRollout Job.
        """
        return pulumi.get(self, "create_child_rollout_job")

    @property
    @pulumi.getter(name="deployJob")
    def deploy_job(self) -> 'outputs.DeployJobResponse':
        """
        A deploy Job.
        """
        return pulumi.get(self, "deploy_job")

    @property
    @pulumi.getter(name="jobRun")
    def job_run(self) -> str:
        """
        The name of the `JobRun` responsible for the most recent invocation of this Job.
        """
        return pulumi.get(self, "job_run")

    @property
    @pulumi.getter(name="postdeployJob")
    def postdeploy_job(self) -> 'outputs.PostdeployJobResponse':
        """
        A postdeploy Job.
        """
        return pulumi.get(self, "postdeploy_job")

    @property
    @pulumi.getter(name="predeployJob")
    def predeploy_job(self) -> 'outputs.PredeployJobResponse':
        """
        A predeploy Job.
        """
        return pulumi.get(self, "predeploy_job")

    @property
    @pulumi.getter(name="skipMessage")
    def skip_message(self) -> str:
        """
        Additional information on why the Job was skipped, if available.
        """
        return pulumi.get(self, "skip_message")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the Job.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="verifyJob")
    def verify_job(self) -> 'outputs.VerifyJobResponse':
        """
        A verify Job.
        """
        return pulumi.get(self, "verify_job")


@pulumi.output_type
class KubernetesConfigResponse(dict):
    """
    KubernetesConfig contains the Kubernetes runtime configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gatewayServiceMesh":
            suggest = "gateway_service_mesh"
        elif key == "serviceNetworking":
            suggest = "service_networking"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gateway_service_mesh: 'outputs.GatewayServiceMeshResponse',
                 service_networking: 'outputs.ServiceNetworkingResponse'):
        """
        KubernetesConfig contains the Kubernetes runtime configuration.
        :param 'GatewayServiceMeshResponse' gateway_service_mesh: Kubernetes Gateway API service mesh configuration.
        :param 'ServiceNetworkingResponse' service_networking: Kubernetes Service networking configuration.
        """
        pulumi.set(__self__, "gateway_service_mesh", gateway_service_mesh)
        pulumi.set(__self__, "service_networking", service_networking)

    @property
    @pulumi.getter(name="gatewayServiceMesh")
    def gateway_service_mesh(self) -> 'outputs.GatewayServiceMeshResponse':
        """
        Kubernetes Gateway API service mesh configuration.
        """
        return pulumi.get(self, "gateway_service_mesh")

    @property
    @pulumi.getter(name="serviceNetworking")
    def service_networking(self) -> 'outputs.ServiceNetworkingResponse':
        """
        Kubernetes Service networking configuration.
        """
        return pulumi.get(self, "service_networking")


@pulumi.output_type
class MetadataResponse(dict):
    """
    Metadata includes information associated with a `Rollout`.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudRun":
            suggest = "cloud_run"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetadataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetadataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetadataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automation: 'outputs.AutomationRolloutMetadataResponse',
                 cloud_run: 'outputs.CloudRunMetadataResponse'):
        """
        Metadata includes information associated with a `Rollout`.
        :param 'AutomationRolloutMetadataResponse' automation: AutomationRolloutMetadata contains the information about the interactions between Automation service and this rollout.
        :param 'CloudRunMetadataResponse' cloud_run: The name of the Cloud Run Service that is associated with a `Rollout`.
        """
        pulumi.set(__self__, "automation", automation)
        pulumi.set(__self__, "cloud_run", cloud_run)

    @property
    @pulumi.getter
    def automation(self) -> 'outputs.AutomationRolloutMetadataResponse':
        """
        AutomationRolloutMetadata contains the information about the interactions between Automation service and this rollout.
        """
        return pulumi.get(self, "automation")

    @property
    @pulumi.getter(name="cloudRun")
    def cloud_run(self) -> 'outputs.CloudRunMetadataResponse':
        """
        The name of the Cloud Run Service that is associated with a `Rollout`.
        """
        return pulumi.get(self, "cloud_run")


@pulumi.output_type
class MultiTargetResponse(dict):
    """
    Information specifying a multiTarget.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetIds":
            suggest = "target_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultiTargetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultiTargetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultiTargetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_ids: Sequence[str]):
        """
        Information specifying a multiTarget.
        :param Sequence[str] target_ids: The target_ids of this multiTarget.
        """
        pulumi.set(__self__, "target_ids", target_ids)

    @property
    @pulumi.getter(name="targetIds")
    def target_ids(self) -> Sequence[str]:
        """
        The target_ids of this multiTarget.
        """
        return pulumi.get(self, "target_ids")


@pulumi.output_type
class PhaseArtifactResponse(dict):
    """
    Contains the paths to the artifacts, relative to the URI, for a phase.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobManifestsPath":
            suggest = "job_manifests_path"
        elif key == "manifestPath":
            suggest = "manifest_path"
        elif key == "skaffoldConfigPath":
            suggest = "skaffold_config_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PhaseArtifactResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PhaseArtifactResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PhaseArtifactResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_manifests_path: str,
                 manifest_path: str,
                 skaffold_config_path: str):
        """
        Contains the paths to the artifacts, relative to the URI, for a phase.
        :param str job_manifests_path: File path of the directory of rendered job manifests relative to the URI. This is only set if it is applicable.
        :param str manifest_path: File path of the rendered manifest relative to the URI.
        :param str skaffold_config_path: File path of the resolved Skaffold configuration relative to the URI.
        """
        pulumi.set(__self__, "job_manifests_path", job_manifests_path)
        pulumi.set(__self__, "manifest_path", manifest_path)
        pulumi.set(__self__, "skaffold_config_path", skaffold_config_path)

    @property
    @pulumi.getter(name="jobManifestsPath")
    def job_manifests_path(self) -> str:
        """
        File path of the directory of rendered job manifests relative to the URI. This is only set if it is applicable.
        """
        return pulumi.get(self, "job_manifests_path")

    @property
    @pulumi.getter(name="manifestPath")
    def manifest_path(self) -> str:
        """
        File path of the rendered manifest relative to the URI.
        """
        return pulumi.get(self, "manifest_path")

    @property
    @pulumi.getter(name="skaffoldConfigPath")
    def skaffold_config_path(self) -> str:
        """
        File path of the resolved Skaffold configuration relative to the URI.
        """
        return pulumi.get(self, "skaffold_config_path")


@pulumi.output_type
class PhaseConfigResponse(dict):
    """
    PhaseConfig represents the configuration for a phase in the custom canary deployment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "phaseId":
            suggest = "phase_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PhaseConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PhaseConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PhaseConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 percentage: int,
                 phase_id: str,
                 postdeploy: 'outputs.PostdeployResponse',
                 predeploy: 'outputs.PredeployResponse',
                 profiles: Sequence[str],
                 verify: bool):
        """
        PhaseConfig represents the configuration for a phase in the custom canary deployment.
        :param int percentage: Percentage deployment for the phase.
        :param str phase_id: The ID to assign to the `Rollout` phase. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
        :param 'PostdeployResponse' postdeploy: Optional. Configuration for the postdeploy job of this phase. If this is not configured, there will be no postdeploy job for this phase.
        :param 'PredeployResponse' predeploy: Optional. Configuration for the predeploy job of this phase. If this is not configured, there will be no predeploy job for this phase.
        :param Sequence[str] profiles: Skaffold profiles to use when rendering the manifest for this phase. These are in addition to the profiles list specified in the `DeliveryPipeline` stage.
        :param bool verify: Whether to run verify tests after the deployment.
        """
        pulumi.set(__self__, "percentage", percentage)
        pulumi.set(__self__, "phase_id", phase_id)
        pulumi.set(__self__, "postdeploy", postdeploy)
        pulumi.set(__self__, "predeploy", predeploy)
        pulumi.set(__self__, "profiles", profiles)
        pulumi.set(__self__, "verify", verify)

    @property
    @pulumi.getter
    def percentage(self) -> int:
        """
        Percentage deployment for the phase.
        """
        return pulumi.get(self, "percentage")

    @property
    @pulumi.getter(name="phaseId")
    def phase_id(self) -> str:
        """
        The ID to assign to the `Rollout` phase. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
        """
        return pulumi.get(self, "phase_id")

    @property
    @pulumi.getter
    def postdeploy(self) -> 'outputs.PostdeployResponse':
        """
        Optional. Configuration for the postdeploy job of this phase. If this is not configured, there will be no postdeploy job for this phase.
        """
        return pulumi.get(self, "postdeploy")

    @property
    @pulumi.getter
    def predeploy(self) -> 'outputs.PredeployResponse':
        """
        Optional. Configuration for the predeploy job of this phase. If this is not configured, there will be no predeploy job for this phase.
        """
        return pulumi.get(self, "predeploy")

    @property
    @pulumi.getter
    def profiles(self) -> Sequence[str]:
        """
        Skaffold profiles to use when rendering the manifest for this phase. These are in addition to the profiles list specified in the `DeliveryPipeline` stage.
        """
        return pulumi.get(self, "profiles")

    @property
    @pulumi.getter
    def verify(self) -> bool:
        """
        Whether to run verify tests after the deployment.
        """
        return pulumi.get(self, "verify")


@pulumi.output_type
class PhaseResponse(dict):
    """
    Phase represents a collection of jobs that are logically grouped together for a `Rollout`.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "childRolloutJobs":
            suggest = "child_rollout_jobs"
        elif key == "deploymentJobs":
            suggest = "deployment_jobs"
        elif key == "skipMessage":
            suggest = "skip_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PhaseResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PhaseResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PhaseResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 child_rollout_jobs: 'outputs.ChildRolloutJobsResponse',
                 deployment_jobs: 'outputs.DeploymentJobsResponse',
                 skip_message: str,
                 state: str):
        """
        Phase represents a collection of jobs that are logically grouped together for a `Rollout`.
        :param 'ChildRolloutJobsResponse' child_rollout_jobs: ChildRollout job composition.
        :param 'DeploymentJobsResponse' deployment_jobs: Deployment job composition.
        :param str skip_message: Additional information on why the Phase was skipped, if available.
        :param str state: Current state of the Phase.
        """
        pulumi.set(__self__, "child_rollout_jobs", child_rollout_jobs)
        pulumi.set(__self__, "deployment_jobs", deployment_jobs)
        pulumi.set(__self__, "skip_message", skip_message)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="childRolloutJobs")
    def child_rollout_jobs(self) -> 'outputs.ChildRolloutJobsResponse':
        """
        ChildRollout job composition.
        """
        return pulumi.get(self, "child_rollout_jobs")

    @property
    @pulumi.getter(name="deploymentJobs")
    def deployment_jobs(self) -> 'outputs.DeploymentJobsResponse':
        """
        Deployment job composition.
        """
        return pulumi.get(self, "deployment_jobs")

    @property
    @pulumi.getter(name="skipMessage")
    def skip_message(self) -> str:
        """
        Additional information on why the Phase was skipped, if available.
        """
        return pulumi.get(self, "skip_message")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of the Phase.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class PipelineConditionResponse(dict):
    """
    PipelineCondition contains all conditions relevant to a Delivery Pipeline.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pipelineReadyCondition":
            suggest = "pipeline_ready_condition"
        elif key == "targetsPresentCondition":
            suggest = "targets_present_condition"
        elif key == "targetsTypeCondition":
            suggest = "targets_type_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pipeline_ready_condition: 'outputs.PipelineReadyConditionResponse',
                 targets_present_condition: 'outputs.TargetsPresentConditionResponse',
                 targets_type_condition: 'outputs.TargetsTypeConditionResponse'):
        """
        PipelineCondition contains all conditions relevant to a Delivery Pipeline.
        :param 'PipelineReadyConditionResponse' pipeline_ready_condition: Details around the Pipeline's overall status.
        :param 'TargetsPresentConditionResponse' targets_present_condition: Details around targets enumerated in the pipeline.
        :param 'TargetsTypeConditionResponse' targets_type_condition: Details on the whether the targets enumerated in the pipeline are of the same type.
        """
        pulumi.set(__self__, "pipeline_ready_condition", pipeline_ready_condition)
        pulumi.set(__self__, "targets_present_condition", targets_present_condition)
        pulumi.set(__self__, "targets_type_condition", targets_type_condition)

    @property
    @pulumi.getter(name="pipelineReadyCondition")
    def pipeline_ready_condition(self) -> 'outputs.PipelineReadyConditionResponse':
        """
        Details around the Pipeline's overall status.
        """
        return pulumi.get(self, "pipeline_ready_condition")

    @property
    @pulumi.getter(name="targetsPresentCondition")
    def targets_present_condition(self) -> 'outputs.TargetsPresentConditionResponse':
        """
        Details around targets enumerated in the pipeline.
        """
        return pulumi.get(self, "targets_present_condition")

    @property
    @pulumi.getter(name="targetsTypeCondition")
    def targets_type_condition(self) -> 'outputs.TargetsTypeConditionResponse':
        """
        Details on the whether the targets enumerated in the pipeline are of the same type.
        """
        return pulumi.get(self, "targets_type_condition")


@pulumi.output_type
class PipelineReadyConditionResponse(dict):
    """
    PipelineReadyCondition contains information around the status of the Pipeline.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineReadyConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineReadyConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineReadyConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: bool,
                 update_time: str):
        """
        PipelineReadyCondition contains information around the status of the Pipeline.
        :param bool status: True if the Pipeline is in a valid state. Otherwise at least one condition in `PipelineCondition` is in an invalid state. Iterate over those conditions and see which condition(s) has status = false to find out what is wrong with the Pipeline.
        :param str update_time: Last time the condition was updated.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def status(self) -> bool:
        """
        True if the Pipeline is in a valid state. Otherwise at least one condition in `PipelineCondition` is in an invalid state. Iterate over those conditions and see which condition(s) has status = false to find out what is wrong with the Pipeline.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> str:
        """
        Last time the condition was updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class PostdeployJobResponse(dict):
    """
    A postdeploy Job.
    """
    def __init__(__self__, *,
                 actions: Sequence[str]):
        """
        A postdeploy Job.
        :param Sequence[str] actions: The custom actions that the postdeploy Job executes.
        """
        pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        """
        The custom actions that the postdeploy Job executes.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class PostdeployResponse(dict):
    """
    Postdeploy contains the postdeploy job configuration information.
    """
    def __init__(__self__, *,
                 actions: Sequence[str]):
        """
        Postdeploy contains the postdeploy job configuration information.
        :param Sequence[str] actions: Optional. A sequence of Skaffold custom actions to invoke during execution of the postdeploy job.
        """
        pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        """
        Optional. A sequence of Skaffold custom actions to invoke during execution of the postdeploy job.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class PredeployJobResponse(dict):
    """
    A predeploy Job.
    """
    def __init__(__self__, *,
                 actions: Sequence[str]):
        """
        A predeploy Job.
        :param Sequence[str] actions: The custom actions that the predeploy Job executes.
        """
        pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        """
        The custom actions that the predeploy Job executes.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class PredeployResponse(dict):
    """
    Predeploy contains the predeploy job configuration information.
    """
    def __init__(__self__, *,
                 actions: Sequence[str]):
        """
        Predeploy contains the predeploy job configuration information.
        :param Sequence[str] actions: Optional. A sequence of Skaffold custom actions to invoke during execution of the predeploy job.
        """
        pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        """
        Optional. A sequence of Skaffold custom actions to invoke during execution of the predeploy job.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class PrivatePoolResponse(dict):
    """
    Execution using a private Cloud Build pool.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "artifactStorage":
            suggest = "artifact_storage"
        elif key == "serviceAccount":
            suggest = "service_account"
        elif key == "workerPool":
            suggest = "worker_pool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivatePoolResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivatePoolResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivatePoolResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 artifact_storage: str,
                 service_account: str,
                 worker_pool: str):
        """
        Execution using a private Cloud Build pool.
        :param str artifact_storage: Optional. Cloud Storage location where execution outputs should be stored. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
        :param str service_account: Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) will be used.
        :param str worker_pool: Resource name of the Cloud Build worker pool to use. The format is `projects/{project}/locations/{location}/workerPools/{pool}`.
        """
        pulumi.set(__self__, "artifact_storage", artifact_storage)
        pulumi.set(__self__, "service_account", service_account)
        pulumi.set(__self__, "worker_pool", worker_pool)

    @property
    @pulumi.getter(name="artifactStorage")
    def artifact_storage(self) -> str:
        """
        Optional. Cloud Storage location where execution outputs should be stored. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
        """
        return pulumi.get(self, "artifact_storage")

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> str:
        """
        Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) will be used.
        """
        return pulumi.get(self, "service_account")

    @property
    @pulumi.getter(name="workerPool")
    def worker_pool(self) -> str:
        """
        Resource name of the Cloud Build worker pool to use. The format is `projects/{project}/locations/{location}/workerPools/{pool}`.
        """
        return pulumi.get(self, "worker_pool")


@pulumi.output_type
class PromoteReleaseRuleResponse(dict):
    """
    `PromoteRelease` rule will automatically promote a release from the current target to a specified target.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPhase":
            suggest = "destination_phase"
        elif key == "destinationTargetId":
            suggest = "destination_target_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromoteReleaseRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromoteReleaseRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromoteReleaseRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: 'outputs.AutomationRuleConditionResponse',
                 destination_phase: str,
                 destination_target_id: str,
                 wait: str):
        """
        `PromoteRelease` rule will automatically promote a release from the current target to a specified target.
        :param 'AutomationRuleConditionResponse' condition: Information around the state of the Automation rule.
        :param str destination_phase: Optional. The starting phase of the rollout created by this operation. Default to the first phase.
        :param str destination_target_id: Optional. The ID of the stage in the pipeline to which this `Release` is deploying. If unspecified, default it to the next stage in the promotion flow. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine if the target is one of the stages in the promotion sequence defined in the pipeline. * "@next", the next target in the promotion sequence.
        :param str wait: Optional. How long the release need to be paused until being promoted to the next target.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "destination_phase", destination_phase)
        pulumi.set(__self__, "destination_target_id", destination_target_id)
        pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.AutomationRuleConditionResponse':
        """
        Information around the state of the Automation rule.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="destinationPhase")
    def destination_phase(self) -> str:
        """
        Optional. The starting phase of the rollout created by this operation. Default to the first phase.
        """
        return pulumi.get(self, "destination_phase")

    @property
    @pulumi.getter(name="destinationTargetId")
    def destination_target_id(self) -> str:
        """
        Optional. The ID of the stage in the pipeline to which this `Release` is deploying. If unspecified, default it to the next stage in the promotion flow. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine if the target is one of the stages in the promotion sequence defined in the pipeline. * "@next", the next target in the promotion sequence.
        """
        return pulumi.get(self, "destination_target_id")

    @property
    @pulumi.getter
    def wait(self) -> str:
        """
        Optional. How long the release need to be paused until being promoted to the next target.
        """
        return pulumi.get(self, "wait")


@pulumi.output_type
class ReleaseConditionResponse(dict):
    """
    ReleaseCondition contains all conditions relevant to a Release.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseReadyCondition":
            suggest = "release_ready_condition"
        elif key == "skaffoldSupportedCondition":
            suggest = "skaffold_supported_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 release_ready_condition: 'outputs.ReleaseReadyConditionResponse',
                 skaffold_supported_condition: 'outputs.SkaffoldSupportedConditionResponse'):
        """
        ReleaseCondition contains all conditions relevant to a Release.
        :param 'ReleaseReadyConditionResponse' release_ready_condition: Details around the Releases's overall status.
        :param 'SkaffoldSupportedConditionResponse' skaffold_supported_condition: Details around the support state of the release's skaffold version.
        """
        pulumi.set(__self__, "release_ready_condition", release_ready_condition)
        pulumi.set(__self__, "skaffold_supported_condition", skaffold_supported_condition)

    @property
    @pulumi.getter(name="releaseReadyCondition")
    def release_ready_condition(self) -> 'outputs.ReleaseReadyConditionResponse':
        """
        Details around the Releases's overall status.
        """
        return pulumi.get(self, "release_ready_condition")

    @property
    @pulumi.getter(name="skaffoldSupportedCondition")
    def skaffold_supported_condition(self) -> 'outputs.SkaffoldSupportedConditionResponse':
        """
        Details around the support state of the release's skaffold version.
        """
        return pulumi.get(self, "skaffold_supported_condition")


@pulumi.output_type
class ReleaseReadyConditionResponse(dict):
    """
    ReleaseReadyCondition contains information around the status of the Release. If a release is not ready, you cannot create a rollout with the release.
    """
    def __init__(__self__, *,
                 status: bool):
        """
        ReleaseReadyCondition contains information around the status of the Release. If a release is not ready, you cannot create a rollout with the release.
        :param bool status: True if the Release is in a valid state. Otherwise at least one condition in `ReleaseCondition` is in an invalid state. Iterate over those conditions and see which condition(s) has status = false to find out what is wrong with the Release.
        """
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def status(self) -> bool:
        """
        True if the Release is in a valid state. Otherwise at least one condition in `ReleaseCondition` is in an invalid state. Iterate over those conditions and see which condition(s) has status = false to find out what is wrong with the Release.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class RenderMetadataResponse(dict):
    """
    RenderMetadata includes information associated with a `Release` render.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudRun":
            suggest = "cloud_run"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RenderMetadataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RenderMetadataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RenderMetadataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_run: 'outputs.CloudRunRenderMetadataResponse'):
        """
        RenderMetadata includes information associated with a `Release` render.
        :param 'CloudRunRenderMetadataResponse' cloud_run: Metadata associated with rendering for Cloud Run.
        """
        pulumi.set(__self__, "cloud_run", cloud_run)

    @property
    @pulumi.getter(name="cloudRun")
    def cloud_run(self) -> 'outputs.CloudRunRenderMetadataResponse':
        """
        Metadata associated with rendering for Cloud Run.
        """
        return pulumi.get(self, "cloud_run")


@pulumi.output_type
class RepairModeResponse(dict):
    """
    Configuration of the repair action.
    """
    def __init__(__self__, *,
                 retry: 'outputs.RetryResponse',
                 rollback: 'outputs.RollbackResponse'):
        """
        Configuration of the repair action.
        :param 'RetryResponse' retry: Optional. Retries a failed job.
        :param 'RollbackResponse' rollback: Optional. Rolls back a `Rollout`.
        """
        pulumi.set(__self__, "retry", retry)
        pulumi.set(__self__, "rollback", rollback)

    @property
    @pulumi.getter
    def retry(self) -> 'outputs.RetryResponse':
        """
        Optional. Retries a failed job.
        """
        return pulumi.get(self, "retry")

    @property
    @pulumi.getter
    def rollback(self) -> 'outputs.RollbackResponse':
        """
        Optional. Rolls back a `Rollout`.
        """
        return pulumi.get(self, "rollback")


@pulumi.output_type
class RepairRolloutRuleResponse(dict):
    """
    The `RepairRolloutRule` automation rule will automatically repair a failed `Rollout`.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repairModes":
            suggest = "repair_modes"
        elif key == "sourcePhases":
            suggest = "source_phases"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RepairRolloutRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RepairRolloutRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RepairRolloutRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: 'outputs.AutomationRuleConditionResponse',
                 jobs: Sequence[str],
                 repair_modes: Sequence['outputs.RepairModeResponse'],
                 source_phases: Sequence[str]):
        """
        The `RepairRolloutRule` automation rule will automatically repair a failed `Rollout`.
        :param 'AutomationRuleConditionResponse' condition: Information around the state of the 'Automation' rule.
        :param Sequence[str] jobs: Optional. Jobs to repair. Proceeds only after job name matched any one in the list, or for all jobs if unspecified or empty. The phase that includes the job must match the phase ID specified in `source_phase`. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
        :param Sequence['RepairModeResponse'] repair_modes: Defines the types of automatic repair actions for failed jobs.
        :param Sequence[str] source_phases: Optional. Phases within which jobs are subject to automatic repair actions on failure. Proceeds only after phase name matched any one in the list, or for all phases if unspecified. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "jobs", jobs)
        pulumi.set(__self__, "repair_modes", repair_modes)
        pulumi.set(__self__, "source_phases", source_phases)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.AutomationRuleConditionResponse':
        """
        Information around the state of the 'Automation' rule.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def jobs(self) -> Sequence[str]:
        """
        Optional. Jobs to repair. Proceeds only after job name matched any one in the list, or for all jobs if unspecified or empty. The phase that includes the job must match the phase ID specified in `source_phase`. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
        """
        return pulumi.get(self, "jobs")

    @property
    @pulumi.getter(name="repairModes")
    def repair_modes(self) -> Sequence['outputs.RepairModeResponse']:
        """
        Defines the types of automatic repair actions for failed jobs.
        """
        return pulumi.get(self, "repair_modes")

    @property
    @pulumi.getter(name="sourcePhases")
    def source_phases(self) -> Sequence[str]:
        """
        Optional. Phases within which jobs are subject to automatic repair actions on failure. Proceeds only after phase name matched any one in the list, or for all phases if unspecified. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
        """
        return pulumi.get(self, "source_phases")


@pulumi.output_type
class RetryResponse(dict):
    """
    Retries the failed job.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backoffMode":
            suggest = "backoff_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RetryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RetryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RetryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attempts: str,
                 backoff_mode: str,
                 wait: str):
        """
        Retries the failed job.
        :param str attempts: Total number of retries. Retry will skipped if set to 0; The minimum value is 1, and the maximum value is 10.
        :param str backoff_mode: Optional. The pattern of how wait time will be increased. Default is linear. Backoff mode will be ignored if `wait` is 0.
        :param str wait: Optional. How long to wait for the first retry. Default is 0, and the maximum value is 14d.
        """
        pulumi.set(__self__, "attempts", attempts)
        pulumi.set(__self__, "backoff_mode", backoff_mode)
        pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def attempts(self) -> str:
        """
        Total number of retries. Retry will skipped if set to 0; The minimum value is 1, and the maximum value is 10.
        """
        return pulumi.get(self, "attempts")

    @property
    @pulumi.getter(name="backoffMode")
    def backoff_mode(self) -> str:
        """
        Optional. The pattern of how wait time will be increased. Default is linear. Backoff mode will be ignored if `wait` is 0.
        """
        return pulumi.get(self, "backoff_mode")

    @property
    @pulumi.getter
    def wait(self) -> str:
        """
        Optional. How long to wait for the first retry. Default is 0, and the maximum value is 14d.
        """
        return pulumi.get(self, "wait")


@pulumi.output_type
class RollbackResponse(dict):
    """
    Rolls back a `Rollout`.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPhase":
            suggest = "destination_phase"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RollbackResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RollbackResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RollbackResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_phase: str):
        """
        Rolls back a `Rollout`.
        :param str destination_phase: Optional. The starting phase ID for the `Rollout`. If unspecified, the `Rollout` will start in the stable phase.
        """
        pulumi.set(__self__, "destination_phase", destination_phase)

    @property
    @pulumi.getter(name="destinationPhase")
    def destination_phase(self) -> str:
        """
        Optional. The starting phase ID for the `Rollout`. If unspecified, the `Rollout` will start in the stable phase.
        """
        return pulumi.get(self, "destination_phase")


@pulumi.output_type
class RuntimeConfigResponse(dict):
    """
    RuntimeConfig contains the runtime specific configurations for a deployment strategy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudRun":
            suggest = "cloud_run"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuntimeConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuntimeConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuntimeConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_run: 'outputs.CloudRunConfigResponse',
                 kubernetes: 'outputs.KubernetesConfigResponse'):
        """
        RuntimeConfig contains the runtime specific configurations for a deployment strategy.
        :param 'CloudRunConfigResponse' cloud_run: Cloud Run runtime configuration.
        :param 'KubernetesConfigResponse' kubernetes: Kubernetes runtime configuration.
        """
        pulumi.set(__self__, "cloud_run", cloud_run)
        pulumi.set(__self__, "kubernetes", kubernetes)

    @property
    @pulumi.getter(name="cloudRun")
    def cloud_run(self) -> 'outputs.CloudRunConfigResponse':
        """
        Cloud Run runtime configuration.
        """
        return pulumi.get(self, "cloud_run")

    @property
    @pulumi.getter
    def kubernetes(self) -> 'outputs.KubernetesConfigResponse':
        """
        Kubernetes runtime configuration.
        """
        return pulumi.get(self, "kubernetes")


@pulumi.output_type
class SerialPipelineResponse(dict):
    """
    SerialPipeline defines a sequential set of stages for a `DeliveryPipeline`.
    """
    def __init__(__self__, *,
                 stages: Sequence['outputs.StageResponse']):
        """
        SerialPipeline defines a sequential set of stages for a `DeliveryPipeline`.
        :param Sequence['StageResponse'] stages: Each stage specifies configuration for a `Target`. The ordering of this list defines the promotion flow.
        """
        pulumi.set(__self__, "stages", stages)

    @property
    @pulumi.getter
    def stages(self) -> Sequence['outputs.StageResponse']:
        """
        Each stage specifies configuration for a `Target`. The ordering of this list defines the promotion flow.
        """
        return pulumi.get(self, "stages")


@pulumi.output_type
class ServiceNetworkingResponse(dict):
    """
    Information about the Kubernetes Service networking configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disablePodOverprovisioning":
            suggest = "disable_pod_overprovisioning"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNetworkingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNetworkingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNetworkingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment: str,
                 disable_pod_overprovisioning: bool,
                 service: str):
        """
        Information about the Kubernetes Service networking configuration.
        :param str deployment: Name of the Kubernetes Deployment whose traffic is managed by the specified Service.
        :param bool disable_pod_overprovisioning: Optional. Whether to disable Pod overprovisioning. If Pod overprovisioning is disabled then Cloud Deploy will limit the number of total Pods used for the deployment strategy to the number of Pods the Deployment has on the cluster.
        :param str service: Name of the Kubernetes Service.
        """
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "disable_pod_overprovisioning", disable_pod_overprovisioning)
        pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def deployment(self) -> str:
        """
        Name of the Kubernetes Deployment whose traffic is managed by the specified Service.
        """
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter(name="disablePodOverprovisioning")
    def disable_pod_overprovisioning(self) -> bool:
        """
        Optional. Whether to disable Pod overprovisioning. If Pod overprovisioning is disabled then Cloud Deploy will limit the number of total Pods used for the deployment strategy to the number of Pods the Deployment has on the cluster.
        """
        return pulumi.get(self, "disable_pod_overprovisioning")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        Name of the Kubernetes Service.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class SkaffoldSupportedConditionResponse(dict):
    """
    SkaffoldSupportedCondition contains information about when support for the release's version of skaffold ends.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maintenanceModeTime":
            suggest = "maintenance_mode_time"
        elif key == "skaffoldSupportState":
            suggest = "skaffold_support_state"
        elif key == "supportExpirationTime":
            suggest = "support_expiration_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SkaffoldSupportedConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SkaffoldSupportedConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SkaffoldSupportedConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maintenance_mode_time: str,
                 skaffold_support_state: str,
                 status: bool,
                 support_expiration_time: str):
        """
        SkaffoldSupportedCondition contains information about when support for the release's version of skaffold ends.
        :param str maintenance_mode_time: The time at which this release's version of skaffold will enter maintenance mode.
        :param str skaffold_support_state: The skaffold support state for this release's version of skaffold.
        :param bool status: True if the version of skaffold used by this release is supported.
        :param str support_expiration_time: The time at which this release's version of skaffold will no longer be supported.
        """
        pulumi.set(__self__, "maintenance_mode_time", maintenance_mode_time)
        pulumi.set(__self__, "skaffold_support_state", skaffold_support_state)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "support_expiration_time", support_expiration_time)

    @property
    @pulumi.getter(name="maintenanceModeTime")
    def maintenance_mode_time(self) -> str:
        """
        The time at which this release's version of skaffold will enter maintenance mode.
        """
        return pulumi.get(self, "maintenance_mode_time")

    @property
    @pulumi.getter(name="skaffoldSupportState")
    def skaffold_support_state(self) -> str:
        """
        The skaffold support state for this release's version of skaffold.
        """
        return pulumi.get(self, "skaffold_support_state")

    @property
    @pulumi.getter
    def status(self) -> bool:
        """
        True if the version of skaffold used by this release is supported.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="supportExpirationTime")
    def support_expiration_time(self) -> str:
        """
        The time at which this release's version of skaffold will no longer be supported.
        """
        return pulumi.get(self, "support_expiration_time")


@pulumi.output_type
class StageResponse(dict):
    """
    Stage specifies a location to which to deploy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployParameters":
            suggest = "deploy_parameters"
        elif key == "targetId":
            suggest = "target_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StageResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StageResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StageResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deploy_parameters: Sequence['outputs.DeployParametersResponse'],
                 profiles: Sequence[str],
                 strategy: 'outputs.StrategyResponse',
                 target_id: str):
        """
        Stage specifies a location to which to deploy.
        :param Sequence['DeployParametersResponse'] deploy_parameters: Optional. The deploy parameters to use for the target in this stage.
        :param Sequence[str] profiles: Skaffold profiles to use when rendering the manifest for this stage's `Target`.
        :param 'StrategyResponse' strategy: Optional. The strategy to use for a `Rollout` to this stage.
        :param str target_id: The target_id to which this stage points. This field refers exclusively to the last segment of a target name. For example, this field would just be `my-target` (rather than `projects/project/locations/location/targets/my-target`). The location of the `Target` is inferred to be the same as the location of the `DeliveryPipeline` that contains this `Stage`.
        """
        pulumi.set(__self__, "deploy_parameters", deploy_parameters)
        pulumi.set(__self__, "profiles", profiles)
        pulumi.set(__self__, "strategy", strategy)
        pulumi.set(__self__, "target_id", target_id)

    @property
    @pulumi.getter(name="deployParameters")
    def deploy_parameters(self) -> Sequence['outputs.DeployParametersResponse']:
        """
        Optional. The deploy parameters to use for the target in this stage.
        """
        return pulumi.get(self, "deploy_parameters")

    @property
    @pulumi.getter
    def profiles(self) -> Sequence[str]:
        """
        Skaffold profiles to use when rendering the manifest for this stage's `Target`.
        """
        return pulumi.get(self, "profiles")

    @property
    @pulumi.getter
    def strategy(self) -> 'outputs.StrategyResponse':
        """
        Optional. The strategy to use for a `Rollout` to this stage.
        """
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        The target_id to which this stage points. This field refers exclusively to the last segment of a target name. For example, this field would just be `my-target` (rather than `projects/project/locations/location/targets/my-target`). The location of the `Target` is inferred to be the same as the location of the `DeliveryPipeline` that contains this `Stage`.
        """
        return pulumi.get(self, "target_id")


@pulumi.output_type
class StandardResponse(dict):
    """
    Standard represents the standard deployment strategy.
    """
    def __init__(__self__, *,
                 postdeploy: 'outputs.PostdeployResponse',
                 predeploy: 'outputs.PredeployResponse',
                 verify: bool):
        """
        Standard represents the standard deployment strategy.
        :param 'PostdeployResponse' postdeploy: Optional. Configuration for the postdeploy job. If this is not configured, postdeploy job will not be present.
        :param 'PredeployResponse' predeploy: Optional. Configuration for the predeploy job. If this is not configured, predeploy job will not be present.
        :param bool verify: Whether to verify a deployment.
        """
        pulumi.set(__self__, "postdeploy", postdeploy)
        pulumi.set(__self__, "predeploy", predeploy)
        pulumi.set(__self__, "verify", verify)

    @property
    @pulumi.getter
    def postdeploy(self) -> 'outputs.PostdeployResponse':
        """
        Optional. Configuration for the postdeploy job. If this is not configured, postdeploy job will not be present.
        """
        return pulumi.get(self, "postdeploy")

    @property
    @pulumi.getter
    def predeploy(self) -> 'outputs.PredeployResponse':
        """
        Optional. Configuration for the predeploy job. If this is not configured, predeploy job will not be present.
        """
        return pulumi.get(self, "predeploy")

    @property
    @pulumi.getter
    def verify(self) -> bool:
        """
        Whether to verify a deployment.
        """
        return pulumi.get(self, "verify")


@pulumi.output_type
class StrategyResponse(dict):
    """
    Strategy contains deployment strategy information.
    """
    def __init__(__self__, *,
                 canary: 'outputs.CanaryResponse',
                 standard: 'outputs.StandardResponse'):
        """
        Strategy contains deployment strategy information.
        :param 'CanaryResponse' canary: Canary deployment strategy provides progressive percentage based deployments to a Target.
        :param 'StandardResponse' standard: Standard deployment strategy executes a single deploy and allows verifying the deployment.
        """
        pulumi.set(__self__, "canary", canary)
        pulumi.set(__self__, "standard", standard)

    @property
    @pulumi.getter
    def canary(self) -> 'outputs.CanaryResponse':
        """
        Canary deployment strategy provides progressive percentage based deployments to a Target.
        """
        return pulumi.get(self, "canary")

    @property
    @pulumi.getter
    def standard(self) -> 'outputs.StandardResponse':
        """
        Standard deployment strategy executes a single deploy and allows verifying the deployment.
        """
        return pulumi.get(self, "standard")


@pulumi.output_type
class TargetArtifactResponse(dict):
    """
    The artifacts produced by a target render operation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "artifactUri":
            suggest = "artifact_uri"
        elif key == "manifestPath":
            suggest = "manifest_path"
        elif key == "phaseArtifacts":
            suggest = "phase_artifacts"
        elif key == "skaffoldConfigPath":
            suggest = "skaffold_config_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetArtifactResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetArtifactResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetArtifactResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 artifact_uri: str,
                 manifest_path: str,
                 phase_artifacts: Mapping[str, 'outputs.PhaseArtifactResponse'],
                 skaffold_config_path: str):
        """
        The artifacts produced by a target render operation.
        :param str artifact_uri: URI of a directory containing the artifacts. This contains deployment configuration used by Skaffold during a rollout, and all paths are relative to this location.
        :param str manifest_path: File path of the rendered manifest relative to the URI.
        :param Mapping[str, 'PhaseArtifactResponse'] phase_artifacts: Map from the phase ID to the phase artifacts for the `Target`.
        :param str skaffold_config_path: File path of the resolved Skaffold configuration relative to the URI.
        """
        pulumi.set(__self__, "artifact_uri", artifact_uri)
        pulumi.set(__self__, "manifest_path", manifest_path)
        pulumi.set(__self__, "phase_artifacts", phase_artifacts)
        pulumi.set(__self__, "skaffold_config_path", skaffold_config_path)

    @property
    @pulumi.getter(name="artifactUri")
    def artifact_uri(self) -> str:
        """
        URI of a directory containing the artifacts. This contains deployment configuration used by Skaffold during a rollout, and all paths are relative to this location.
        """
        return pulumi.get(self, "artifact_uri")

    @property
    @pulumi.getter(name="manifestPath")
    def manifest_path(self) -> str:
        """
        File path of the rendered manifest relative to the URI.
        """
        return pulumi.get(self, "manifest_path")

    @property
    @pulumi.getter(name="phaseArtifacts")
    def phase_artifacts(self) -> Mapping[str, 'outputs.PhaseArtifactResponse']:
        """
        Map from the phase ID to the phase artifacts for the `Target`.
        """
        return pulumi.get(self, "phase_artifacts")

    @property
    @pulumi.getter(name="skaffoldConfigPath")
    def skaffold_config_path(self) -> str:
        """
        File path of the resolved Skaffold configuration relative to the URI.
        """
        return pulumi.get(self, "skaffold_config_path")


@pulumi.output_type
class TargetAttributeResponse(dict):
    """
    Contains criteria for selecting Targets. Attributes provided must match the target resource in order for policy restrictions to apply. E.g. if id "prod" and labels "foo: bar" are given the target resource must match both that id and have that label in order to be selected.
    """
    def __init__(__self__, *,
                 labels: Mapping[str, str]):
        """
        Contains criteria for selecting Targets. Attributes provided must match the target resource in order for policy restrictions to apply. E.g. if id "prod" and labels "foo: bar" are given the target resource must match both that id and have that label in order to be selected.
        :param Mapping[str, str] labels: Target labels.
        """
        pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Target labels.
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class TargetRenderResponse(dict):
    """
    Details of rendering for a single target.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureCause":
            suggest = "failure_cause"
        elif key == "failureMessage":
            suggest = "failure_message"
        elif key == "renderingBuild":
            suggest = "rendering_build"
        elif key == "renderingState":
            suggest = "rendering_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetRenderResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetRenderResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetRenderResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_cause: str,
                 failure_message: str,
                 metadata: 'outputs.RenderMetadataResponse',
                 rendering_build: str,
                 rendering_state: str):
        """
        Details of rendering for a single target.
        :param str failure_cause: Reason this render failed. This will always be unspecified while the render in progress.
        :param str failure_message: Additional information about the render failure, if available.
        :param 'RenderMetadataResponse' metadata: Metadata related to the `Release` render for this Target.
        :param str rendering_build: The resource name of the Cloud Build `Build` object that is used to render the manifest for this target. Format is `projects/{project}/locations/{location}/builds/{build}`.
        :param str rendering_state: Current state of the render operation for this Target.
        """
        pulumi.set(__self__, "failure_cause", failure_cause)
        pulumi.set(__self__, "failure_message", failure_message)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "rendering_build", rendering_build)
        pulumi.set(__self__, "rendering_state", rendering_state)

    @property
    @pulumi.getter(name="failureCause")
    def failure_cause(self) -> str:
        """
        Reason this render failed. This will always be unspecified while the render in progress.
        """
        return pulumi.get(self, "failure_cause")

    @property
    @pulumi.getter(name="failureMessage")
    def failure_message(self) -> str:
        """
        Additional information about the render failure, if available.
        """
        return pulumi.get(self, "failure_message")

    @property
    @pulumi.getter
    def metadata(self) -> 'outputs.RenderMetadataResponse':
        """
        Metadata related to the `Release` render for this Target.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="renderingBuild")
    def rendering_build(self) -> str:
        """
        The resource name of the Cloud Build `Build` object that is used to render the manifest for this target. Format is `projects/{project}/locations/{location}/builds/{build}`.
        """
        return pulumi.get(self, "rendering_build")

    @property
    @pulumi.getter(name="renderingState")
    def rendering_state(self) -> str:
        """
        Current state of the render operation for this Target.
        """
        return pulumi.get(self, "rendering_state")


@pulumi.output_type
class TargetResponse(dict):
    """
    A `Target` resource in the Cloud Deploy API. A `Target` defines a location to which a Skaffold configuration can be deployed.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anthosCluster":
            suggest = "anthos_cluster"
        elif key == "createTime":
            suggest = "create_time"
        elif key == "deployParameters":
            suggest = "deploy_parameters"
        elif key == "executionConfigs":
            suggest = "execution_configs"
        elif key == "multiTarget":
            suggest = "multi_target"
        elif key == "requireApproval":
            suggest = "require_approval"
        elif key == "targetId":
            suggest = "target_id"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations: Mapping[str, str],
                 anthos_cluster: 'outputs.AnthosClusterResponse',
                 create_time: str,
                 deploy_parameters: Mapping[str, str],
                 description: str,
                 etag: str,
                 execution_configs: Sequence['outputs.ExecutionConfigResponse'],
                 gke: 'outputs.GkeClusterResponse',
                 labels: Mapping[str, str],
                 multi_target: 'outputs.MultiTargetResponse',
                 name: str,
                 require_approval: bool,
                 run: 'outputs.CloudRunLocationResponse',
                 target_id: str,
                 uid: str,
                 update_time: str):
        """
        A `Target` resource in the Cloud Deploy API. A `Target` defines a location to which a Skaffold configuration can be deployed.
        :param Mapping[str, str] annotations: Optional. User annotations. These attributes can only be set and used by the user, and not by Cloud Deploy. See https://google.aip.dev/128#annotations for more details such as format and size limitations.
        :param 'AnthosClusterResponse' anthos_cluster: Optional. Information specifying an Anthos Cluster.
        :param str create_time: Time at which the `Target` was created.
        :param Mapping[str, str] deploy_parameters: Optional. The deploy parameters to use for this target.
        :param str description: Optional. Description of the `Target`. Max length is 255 characters.
        :param str etag: Optional. This checksum is computed by the server based on the value of other fields, and may be sent on update and delete requests to ensure the client has an up-to-date value before proceeding.
        :param Sequence['ExecutionConfigResponse'] execution_configs: Configurations for all execution that relates to this `Target`. Each `ExecutionEnvironmentUsage` value may only be used in a single configuration; using the same value multiple times is an error. When one or more configurations are specified, they must include the `RENDER` and `DEPLOY` `ExecutionEnvironmentUsage` values. When no configurations are specified, execution will use the default specified in `DefaultPool`.
        :param 'GkeClusterResponse' gke: Optional. Information specifying a GKE Cluster.
        :param Mapping[str, str] labels: Optional. Labels are attributes that can be set and used by both the user and by Cloud Deploy. Labels must meet the following constraints: * Keys and values can contain only lowercase letters, numeric characters, underscores, and dashes. * All characters must use UTF-8 encoding, and international characters are allowed. * Keys must start with a lowercase letter or international character. * Each resource is limited to a maximum of 64 labels. Both keys and values are additionally constrained to be <= 128 bytes.
        :param 'MultiTargetResponse' multi_target: Optional. Information specifying a multiTarget.
        :param str name: Optional. Name of the `Target`. Format is `projects/{project}/locations/{location}/targets/a-z{0,62}`.
        :param bool require_approval: Optional. Whether or not the `Target` requires approval.
        :param 'CloudRunLocationResponse' run: Optional. Information specifying a Cloud Run deployment target.
        :param str target_id: Resource id of the `Target`.
        :param str uid: Unique identifier of the `Target`.
        :param str update_time: Most recent time at which the `Target` was updated.
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "anthos_cluster", anthos_cluster)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "deploy_parameters", deploy_parameters)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "etag", etag)
        pulumi.set(__self__, "execution_configs", execution_configs)
        pulumi.set(__self__, "gke", gke)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "multi_target", multi_target)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "require_approval", require_approval)
        pulumi.set(__self__, "run", run)
        pulumi.set(__self__, "target_id", target_id)
        pulumi.set(__self__, "uid", uid)
        pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter
    def annotations(self) -> Mapping[str, str]:
        """
        Optional. User annotations. These attributes can only be set and used by the user, and not by Cloud Deploy. See https://google.aip.dev/128#annotations for more details such as format and size limitations.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="anthosCluster")
    def anthos_cluster(self) -> 'outputs.AnthosClusterResponse':
        """
        Optional. Information specifying an Anthos Cluster.
        """
        return pulumi.get(self, "anthos_cluster")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        Time at which the `Target` was created.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="deployParameters")
    def deploy_parameters(self) -> Mapping[str, str]:
        """
        Optional. The deploy parameters to use for this target.
        """
        return pulumi.get(self, "deploy_parameters")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Optional. Description of the `Target`. Max length is 255 characters.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        Optional. This checksum is computed by the server based on the value of other fields, and may be sent on update and delete requests to ensure the client has an up-to-date value before proceeding.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="executionConfigs")
    def execution_configs(self) -> Sequence['outputs.ExecutionConfigResponse']:
        """
        Configurations for all execution that relates to this `Target`. Each `ExecutionEnvironmentUsage` value may only be used in a single configuration; using the same value multiple times is an error. When one or more configurations are specified, they must include the `RENDER` and `DEPLOY` `ExecutionEnvironmentUsage` values. When no configurations are specified, execution will use the default specified in `DefaultPool`.
        """
        return pulumi.get(self, "execution_configs")

    @property
    @pulumi.getter
    def gke(self) -> 'outputs.GkeClusterResponse':
        """
        Optional. Information specifying a GKE Cluster.
        """
        return pulumi.get(self, "gke")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Optional. Labels are attributes that can be set and used by both the user and by Cloud Deploy. Labels must meet the following constraints: * Keys and values can contain only lowercase letters, numeric characters, underscores, and dashes. * All characters must use UTF-8 encoding, and international characters are allowed. * Keys must start with a lowercase letter or international character. * Each resource is limited to a maximum of 64 labels. Both keys and values are additionally constrained to be <= 128 bytes.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="multiTarget")
    def multi_target(self) -> 'outputs.MultiTargetResponse':
        """
        Optional. Information specifying a multiTarget.
        """
        return pulumi.get(self, "multi_target")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Optional. Name of the `Target`. Format is `projects/{project}/locations/{location}/targets/a-z{0,62}`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="requireApproval")
    def require_approval(self) -> bool:
        """
        Optional. Whether or not the `Target` requires approval.
        """
        return pulumi.get(self, "require_approval")

    @property
    @pulumi.getter
    def run(self) -> 'outputs.CloudRunLocationResponse':
        """
        Optional. Information specifying a Cloud Run deployment target.
        """
        return pulumi.get(self, "run")

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> str:
        """
        Resource id of the `Target`.
        """
        return pulumi.get(self, "target_id")

    @property
    @pulumi.getter
    def uid(self) -> str:
        """
        Unique identifier of the `Target`.
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> str:
        """
        Most recent time at which the `Target` was updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class TargetsPresentConditionResponse(dict):
    """
    TargetsPresentCondition contains information on any Targets defined in the Delivery Pipeline that do not actually exist.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "missingTargets":
            suggest = "missing_targets"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetsPresentConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetsPresentConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetsPresentConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 missing_targets: Sequence[str],
                 status: bool,
                 update_time: str):
        """
        TargetsPresentCondition contains information on any Targets defined in the Delivery Pipeline that do not actually exist.
        :param Sequence[str] missing_targets: The list of Target names that do not exist. For example, `projects/{project_id}/locations/{location_name}/targets/{target_name}`.
        :param bool status: True if there aren't any missing Targets.
        :param str update_time: Last time the condition was updated.
        """
        pulumi.set(__self__, "missing_targets", missing_targets)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="missingTargets")
    def missing_targets(self) -> Sequence[str]:
        """
        The list of Target names that do not exist. For example, `projects/{project_id}/locations/{location_name}/targets/{target_name}`.
        """
        return pulumi.get(self, "missing_targets")

    @property
    @pulumi.getter
    def status(self) -> bool:
        """
        True if there aren't any missing Targets.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> str:
        """
        Last time the condition was updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class TargetsTypeConditionResponse(dict):
    """
    TargetsTypeCondition contains information on whether the Targets defined in the Delivery Pipeline are of the same type.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorDetails":
            suggest = "error_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetsTypeConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetsTypeConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetsTypeConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_details: str,
                 status: bool):
        """
        TargetsTypeCondition contains information on whether the Targets defined in the Delivery Pipeline are of the same type.
        :param str error_details: Human readable error message.
        :param bool status: True if the targets are all a comparable type. For example this is true if all targets are GKE clusters. This is false if some targets are Cloud Run targets and others are GKE clusters.
        """
        pulumi.set(__self__, "error_details", error_details)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="errorDetails")
    def error_details(self) -> str:
        """
        Human readable error message.
        """
        return pulumi.get(self, "error_details")

    @property
    @pulumi.getter
    def status(self) -> bool:
        """
        True if the targets are all a comparable type. For example this is true if all targets are GKE clusters. This is false if some targets are Cloud Run targets and others are GKE clusters.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class VerifyJobResponse(dict):
    """
    A verify Job.
    """
    def __init__(__self__):
        """
        A verify Job.
        """
        pass


