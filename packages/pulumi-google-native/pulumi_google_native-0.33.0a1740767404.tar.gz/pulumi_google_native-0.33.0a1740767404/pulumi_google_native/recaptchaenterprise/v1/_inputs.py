# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from ._enums import *

__all__ = [
    'GoogleCloudRecaptchaenterpriseV1AndroidKeySettingsArgs',
    'GoogleCloudRecaptchaenterpriseV1AppleDeveloperIdArgs',
    'GoogleCloudRecaptchaenterpriseV1FirewallActionAllowActionArgs',
    'GoogleCloudRecaptchaenterpriseV1FirewallActionBlockActionArgs',
    'GoogleCloudRecaptchaenterpriseV1FirewallActionRedirectActionArgs',
    'GoogleCloudRecaptchaenterpriseV1FirewallActionSetHeaderActionArgs',
    'GoogleCloudRecaptchaenterpriseV1FirewallActionSubstituteActionArgs',
    'GoogleCloudRecaptchaenterpriseV1FirewallActionArgs',
    'GoogleCloudRecaptchaenterpriseV1IOSKeySettingsArgs',
    'GoogleCloudRecaptchaenterpriseV1TestingOptionsArgs',
    'GoogleCloudRecaptchaenterpriseV1WafSettingsArgs',
    'GoogleCloudRecaptchaenterpriseV1WebKeySettingsArgs',
]

@pulumi.input_type
class GoogleCloudRecaptchaenterpriseV1AndroidKeySettingsArgs:
    def __init__(__self__, *,
                 allow_all_package_names: Optional[pulumi.Input[bool]] = None,
                 allowed_package_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 support_non_google_app_store_distribution: Optional[pulumi.Input[bool]] = None):
        """
        Settings specific to keys that can be used by Android apps.
        :param pulumi.Input[bool] allow_all_package_names: Optional. If set to true, allowed_package_names are not enforced.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_package_names: Optional. Android package names of apps allowed to use the key. Example: 'com.companyname.appname'
        :param pulumi.Input[bool] support_non_google_app_store_distribution: Optional. Set to true for keys that are used in an Android application that is available for download in app stores in addition to the Google Play Store.
        """
        if allow_all_package_names is not None:
            pulumi.set(__self__, "allow_all_package_names", allow_all_package_names)
        if allowed_package_names is not None:
            pulumi.set(__self__, "allowed_package_names", allowed_package_names)
        if support_non_google_app_store_distribution is not None:
            pulumi.set(__self__, "support_non_google_app_store_distribution", support_non_google_app_store_distribution)

    @property
    @pulumi.getter(name="allowAllPackageNames")
    def allow_all_package_names(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. If set to true, allowed_package_names are not enforced.
        """
        return pulumi.get(self, "allow_all_package_names")

    @allow_all_package_names.setter
    def allow_all_package_names(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_all_package_names", value)

    @property
    @pulumi.getter(name="allowedPackageNames")
    def allowed_package_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. Android package names of apps allowed to use the key. Example: 'com.companyname.appname'
        """
        return pulumi.get(self, "allowed_package_names")

    @allowed_package_names.setter
    def allowed_package_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_package_names", value)

    @property
    @pulumi.getter(name="supportNonGoogleAppStoreDistribution")
    def support_non_google_app_store_distribution(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. Set to true for keys that are used in an Android application that is available for download in app stores in addition to the Google Play Store.
        """
        return pulumi.get(self, "support_non_google_app_store_distribution")

    @support_non_google_app_store_distribution.setter
    def support_non_google_app_store_distribution(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_non_google_app_store_distribution", value)


@pulumi.input_type
class GoogleCloudRecaptchaenterpriseV1AppleDeveloperIdArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[str],
                 private_key: pulumi.Input[str],
                 team_id: pulumi.Input[str]):
        """
        Contains fields that are required to perform Apple-specific integrity checks.
        :param pulumi.Input[str] key_id: The Apple developer key ID (10-character string).
        :param pulumi.Input[str] private_key: Input only. A private key (downloaded as a text file with a .p8 file extension) generated for your Apple Developer account. Ensure that Apple DeviceCheck is enabled for the private key.
        :param pulumi.Input[str] team_id: The Apple team ID (10-character string) owning the provisioning profile used to build your application.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[str]:
        """
        The Apple developer key ID (10-character string).
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_id", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[str]:
        """
        Input only. A private key (downloaded as a text file with a .p8 file extension) generated for your Apple Developer account. Ensure that Apple DeviceCheck is enabled for the private key.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[str]:
        """
        The Apple team ID (10-character string) owning the provisioning profile used to build your application.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "team_id", value)


@pulumi.input_type
class GoogleCloudRecaptchaenterpriseV1FirewallActionAllowActionArgs:
    def __init__(__self__):
        """
        An allow action continues processing a request unimpeded.
        """
        pass


@pulumi.input_type
class GoogleCloudRecaptchaenterpriseV1FirewallActionBlockActionArgs:
    def __init__(__self__):
        """
        A block action serves an HTTP error code a prevents the request from hitting the backend.
        """
        pass


@pulumi.input_type
class GoogleCloudRecaptchaenterpriseV1FirewallActionRedirectActionArgs:
    def __init__(__self__):
        """
        A redirect action returns a 307 (temporary redirect) response, pointing the user to a ReCaptcha interstitial page to attach a token.
        """
        pass


@pulumi.input_type
class GoogleCloudRecaptchaenterpriseV1FirewallActionSetHeaderActionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        A set header action sets a header and forwards the request to the backend. This can be used to trigger custom protection implemented on the backend.
        :param pulumi.Input[str] key: Optional. The header key to set in the request to the backend server.
        :param pulumi.Input[str] value: Optional. The header value to set in the request to the backend server.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The header key to set in the request to the backend server.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The header value to set in the request to the backend server.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class GoogleCloudRecaptchaenterpriseV1FirewallActionSubstituteActionArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[str]] = None):
        """
        A substitute action transparently serves a different page than the one requested.
        :param pulumi.Input[str] path: Optional. The address to redirect to. The target is a relative path in the current host. Example: "/blog/404.html".
        """
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The address to redirect to. The target is a relative path in the current host. Example: "/blog/404.html".
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class GoogleCloudRecaptchaenterpriseV1FirewallActionArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1FirewallActionAllowActionArgs']] = None,
                 block: Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1FirewallActionBlockActionArgs']] = None,
                 redirect: Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1FirewallActionRedirectActionArgs']] = None,
                 set_header: Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1FirewallActionSetHeaderActionArgs']] = None,
                 substitute: Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1FirewallActionSubstituteActionArgs']] = None):
        """
        An individual action. Each action represents what to do if a policy matches.
        :param pulumi.Input['GoogleCloudRecaptchaenterpriseV1FirewallActionAllowActionArgs'] allow: The user request did not match any policy and should be allowed access to the requested resource.
        :param pulumi.Input['GoogleCloudRecaptchaenterpriseV1FirewallActionBlockActionArgs'] block: This action will deny access to a given page. The user will get an HTTP error code.
        :param pulumi.Input['GoogleCloudRecaptchaenterpriseV1FirewallActionRedirectActionArgs'] redirect: This action will redirect the request to a ReCaptcha interstitial to attach a token.
        :param pulumi.Input['GoogleCloudRecaptchaenterpriseV1FirewallActionSetHeaderActionArgs'] set_header: This action will set a custom header but allow the request to continue to the customer backend.
        :param pulumi.Input['GoogleCloudRecaptchaenterpriseV1FirewallActionSubstituteActionArgs'] substitute: This action will transparently serve a different page to an offending user.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)
        if set_header is not None:
            pulumi.set(__self__, "set_header", set_header)
        if substitute is not None:
            pulumi.set(__self__, "substitute", substitute)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1FirewallActionAllowActionArgs']]:
        """
        The user request did not match any policy and should be allowed access to the requested resource.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1FirewallActionAllowActionArgs']]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1FirewallActionBlockActionArgs']]:
        """
        This action will deny access to a given page. The user will get an HTTP error code.
        """
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1FirewallActionBlockActionArgs']]):
        pulumi.set(self, "block", value)

    @property
    @pulumi.getter
    def redirect(self) -> Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1FirewallActionRedirectActionArgs']]:
        """
        This action will redirect the request to a ReCaptcha interstitial to attach a token.
        """
        return pulumi.get(self, "redirect")

    @redirect.setter
    def redirect(self, value: Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1FirewallActionRedirectActionArgs']]):
        pulumi.set(self, "redirect", value)

    @property
    @pulumi.getter(name="setHeader")
    def set_header(self) -> Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1FirewallActionSetHeaderActionArgs']]:
        """
        This action will set a custom header but allow the request to continue to the customer backend.
        """
        return pulumi.get(self, "set_header")

    @set_header.setter
    def set_header(self, value: Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1FirewallActionSetHeaderActionArgs']]):
        pulumi.set(self, "set_header", value)

    @property
    @pulumi.getter
    def substitute(self) -> Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1FirewallActionSubstituteActionArgs']]:
        """
        This action will transparently serve a different page to an offending user.
        """
        return pulumi.get(self, "substitute")

    @substitute.setter
    def substitute(self, value: Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1FirewallActionSubstituteActionArgs']]):
        pulumi.set(self, "substitute", value)


@pulumi.input_type
class GoogleCloudRecaptchaenterpriseV1IOSKeySettingsArgs:
    def __init__(__self__, *,
                 allow_all_bundle_ids: Optional[pulumi.Input[bool]] = None,
                 allowed_bundle_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 apple_developer_id: Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1AppleDeveloperIdArgs']] = None):
        """
        Settings specific to keys that can be used by iOS apps.
        :param pulumi.Input[bool] allow_all_bundle_ids: Optional. If set to true, allowed_bundle_ids are not enforced.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_bundle_ids: Optional. iOS bundle ids of apps allowed to use the key. Example: 'com.companyname.productname.appname'
        :param pulumi.Input['GoogleCloudRecaptchaenterpriseV1AppleDeveloperIdArgs'] apple_developer_id: Optional. Apple Developer account details for the app that is protected by the reCAPTCHA Key. reCAPTCHA Enterprise leverages platform-specific checks like Apple App Attest and Apple DeviceCheck to protect your app from abuse. Providing these fields allows reCAPTCHA Enterprise to get a better assessment of the integrity of your app.
        """
        if allow_all_bundle_ids is not None:
            pulumi.set(__self__, "allow_all_bundle_ids", allow_all_bundle_ids)
        if allowed_bundle_ids is not None:
            pulumi.set(__self__, "allowed_bundle_ids", allowed_bundle_ids)
        if apple_developer_id is not None:
            pulumi.set(__self__, "apple_developer_id", apple_developer_id)

    @property
    @pulumi.getter(name="allowAllBundleIds")
    def allow_all_bundle_ids(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. If set to true, allowed_bundle_ids are not enforced.
        """
        return pulumi.get(self, "allow_all_bundle_ids")

    @allow_all_bundle_ids.setter
    def allow_all_bundle_ids(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_all_bundle_ids", value)

    @property
    @pulumi.getter(name="allowedBundleIds")
    def allowed_bundle_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. iOS bundle ids of apps allowed to use the key. Example: 'com.companyname.productname.appname'
        """
        return pulumi.get(self, "allowed_bundle_ids")

    @allowed_bundle_ids.setter
    def allowed_bundle_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_bundle_ids", value)

    @property
    @pulumi.getter(name="appleDeveloperId")
    def apple_developer_id(self) -> Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1AppleDeveloperIdArgs']]:
        """
        Optional. Apple Developer account details for the app that is protected by the reCAPTCHA Key. reCAPTCHA Enterprise leverages platform-specific checks like Apple App Attest and Apple DeviceCheck to protect your app from abuse. Providing these fields allows reCAPTCHA Enterprise to get a better assessment of the integrity of your app.
        """
        return pulumi.get(self, "apple_developer_id")

    @apple_developer_id.setter
    def apple_developer_id(self, value: Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1AppleDeveloperIdArgs']]):
        pulumi.set(self, "apple_developer_id", value)


@pulumi.input_type
class GoogleCloudRecaptchaenterpriseV1TestingOptionsArgs:
    def __init__(__self__, *,
                 testing_challenge: Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1TestingOptionsTestingChallenge']] = None,
                 testing_score: Optional[pulumi.Input[float]] = None):
        """
        Options for user acceptance testing.
        :param pulumi.Input['GoogleCloudRecaptchaenterpriseV1TestingOptionsTestingChallenge'] testing_challenge: Optional. For challenge-based keys only (CHECKBOX, INVISIBLE), all challenge requests for this site will return nocaptcha if NOCAPTCHA, or an unsolvable challenge if CHALLENGE.
        :param pulumi.Input[float] testing_score: Optional. All assessments for this Key will return this score. Must be between 0 (likely not legitimate) and 1 (likely legitimate) inclusive.
        """
        if testing_challenge is not None:
            pulumi.set(__self__, "testing_challenge", testing_challenge)
        if testing_score is not None:
            pulumi.set(__self__, "testing_score", testing_score)

    @property
    @pulumi.getter(name="testingChallenge")
    def testing_challenge(self) -> Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1TestingOptionsTestingChallenge']]:
        """
        Optional. For challenge-based keys only (CHECKBOX, INVISIBLE), all challenge requests for this site will return nocaptcha if NOCAPTCHA, or an unsolvable challenge if CHALLENGE.
        """
        return pulumi.get(self, "testing_challenge")

    @testing_challenge.setter
    def testing_challenge(self, value: Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1TestingOptionsTestingChallenge']]):
        pulumi.set(self, "testing_challenge", value)

    @property
    @pulumi.getter(name="testingScore")
    def testing_score(self) -> Optional[pulumi.Input[float]]:
        """
        Optional. All assessments for this Key will return this score. Must be between 0 (likely not legitimate) and 1 (likely legitimate) inclusive.
        """
        return pulumi.get(self, "testing_score")

    @testing_score.setter
    def testing_score(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "testing_score", value)


@pulumi.input_type
class GoogleCloudRecaptchaenterpriseV1WafSettingsArgs:
    def __init__(__self__, *,
                 waf_feature: pulumi.Input['GoogleCloudRecaptchaenterpriseV1WafSettingsWafFeature'],
                 waf_service: pulumi.Input['GoogleCloudRecaptchaenterpriseV1WafSettingsWafService']):
        """
        Settings specific to keys that can be used for WAF (Web Application Firewall).
        :param pulumi.Input['GoogleCloudRecaptchaenterpriseV1WafSettingsWafFeature'] waf_feature: The WAF feature for which this key is enabled.
        :param pulumi.Input['GoogleCloudRecaptchaenterpriseV1WafSettingsWafService'] waf_service: The WAF service that uses this key.
        """
        pulumi.set(__self__, "waf_feature", waf_feature)
        pulumi.set(__self__, "waf_service", waf_service)

    @property
    @pulumi.getter(name="wafFeature")
    def waf_feature(self) -> pulumi.Input['GoogleCloudRecaptchaenterpriseV1WafSettingsWafFeature']:
        """
        The WAF feature for which this key is enabled.
        """
        return pulumi.get(self, "waf_feature")

    @waf_feature.setter
    def waf_feature(self, value: pulumi.Input['GoogleCloudRecaptchaenterpriseV1WafSettingsWafFeature']):
        pulumi.set(self, "waf_feature", value)

    @property
    @pulumi.getter(name="wafService")
    def waf_service(self) -> pulumi.Input['GoogleCloudRecaptchaenterpriseV1WafSettingsWafService']:
        """
        The WAF service that uses this key.
        """
        return pulumi.get(self, "waf_service")

    @waf_service.setter
    def waf_service(self, value: pulumi.Input['GoogleCloudRecaptchaenterpriseV1WafSettingsWafService']):
        pulumi.set(self, "waf_service", value)


@pulumi.input_type
class GoogleCloudRecaptchaenterpriseV1WebKeySettingsArgs:
    def __init__(__self__, *,
                 integration_type: pulumi.Input['GoogleCloudRecaptchaenterpriseV1WebKeySettingsIntegrationType'],
                 allow_all_domains: Optional[pulumi.Input[bool]] = None,
                 allow_amp_traffic: Optional[pulumi.Input[bool]] = None,
                 allowed_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 challenge_security_preference: Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1WebKeySettingsChallengeSecurityPreference']] = None):
        """
        Settings specific to keys that can be used by websites.
        :param pulumi.Input['GoogleCloudRecaptchaenterpriseV1WebKeySettingsIntegrationType'] integration_type: Describes how this key is integrated with the website.
        :param pulumi.Input[bool] allow_all_domains: Optional. If set to true, it means allowed_domains will not be enforced.
        :param pulumi.Input[bool] allow_amp_traffic: Optional. If set to true, the key can be used on AMP (Accelerated Mobile Pages) websites. This is supported only for the SCORE integration type.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_domains: Optional. Domains or subdomains of websites allowed to use the key. All subdomains of an allowed domain are automatically allowed. A valid domain requires a host and must not include any path, port, query or fragment. Examples: 'example.com' or 'subdomain.example.com'
        :param pulumi.Input['GoogleCloudRecaptchaenterpriseV1WebKeySettingsChallengeSecurityPreference'] challenge_security_preference: Optional. Settings for the frequency and difficulty at which this key triggers captcha challenges. This should only be specified for IntegrationTypes CHECKBOX and INVISIBLE.
        """
        pulumi.set(__self__, "integration_type", integration_type)
        if allow_all_domains is not None:
            pulumi.set(__self__, "allow_all_domains", allow_all_domains)
        if allow_amp_traffic is not None:
            pulumi.set(__self__, "allow_amp_traffic", allow_amp_traffic)
        if allowed_domains is not None:
            pulumi.set(__self__, "allowed_domains", allowed_domains)
        if challenge_security_preference is not None:
            pulumi.set(__self__, "challenge_security_preference", challenge_security_preference)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> pulumi.Input['GoogleCloudRecaptchaenterpriseV1WebKeySettingsIntegrationType']:
        """
        Describes how this key is integrated with the website.
        """
        return pulumi.get(self, "integration_type")

    @integration_type.setter
    def integration_type(self, value: pulumi.Input['GoogleCloudRecaptchaenterpriseV1WebKeySettingsIntegrationType']):
        pulumi.set(self, "integration_type", value)

    @property
    @pulumi.getter(name="allowAllDomains")
    def allow_all_domains(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. If set to true, it means allowed_domains will not be enforced.
        """
        return pulumi.get(self, "allow_all_domains")

    @allow_all_domains.setter
    def allow_all_domains(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_all_domains", value)

    @property
    @pulumi.getter(name="allowAmpTraffic")
    def allow_amp_traffic(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. If set to true, the key can be used on AMP (Accelerated Mobile Pages) websites. This is supported only for the SCORE integration type.
        """
        return pulumi.get(self, "allow_amp_traffic")

    @allow_amp_traffic.setter
    def allow_amp_traffic(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_amp_traffic", value)

    @property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. Domains or subdomains of websites allowed to use the key. All subdomains of an allowed domain are automatically allowed. A valid domain requires a host and must not include any path, port, query or fragment. Examples: 'example.com' or 'subdomain.example.com'
        """
        return pulumi.get(self, "allowed_domains")

    @allowed_domains.setter
    def allowed_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_domains", value)

    @property
    @pulumi.getter(name="challengeSecurityPreference")
    def challenge_security_preference(self) -> Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1WebKeySettingsChallengeSecurityPreference']]:
        """
        Optional. Settings for the frequency and difficulty at which this key triggers captcha challenges. This should only be specified for IntegrationTypes CHECKBOX and INVISIBLE.
        """
        return pulumi.get(self, "challenge_security_preference")

    @challenge_security_preference.setter
    def challenge_security_preference(self, value: Optional[pulumi.Input['GoogleCloudRecaptchaenterpriseV1WebKeySettingsChallengeSecurityPreference']]):
        pulumi.set(self, "challenge_security_preference", value)


