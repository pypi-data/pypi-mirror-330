# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'GoogleCloudRecaptchaenterpriseV1AndroidKeySettingsResponse',
    'GoogleCloudRecaptchaenterpriseV1AppleDeveloperIdResponse',
    'GoogleCloudRecaptchaenterpriseV1FirewallActionAllowActionResponse',
    'GoogleCloudRecaptchaenterpriseV1FirewallActionBlockActionResponse',
    'GoogleCloudRecaptchaenterpriseV1FirewallActionRedirectActionResponse',
    'GoogleCloudRecaptchaenterpriseV1FirewallActionResponse',
    'GoogleCloudRecaptchaenterpriseV1FirewallActionSetHeaderActionResponse',
    'GoogleCloudRecaptchaenterpriseV1FirewallActionSubstituteActionResponse',
    'GoogleCloudRecaptchaenterpriseV1IOSKeySettingsResponse',
    'GoogleCloudRecaptchaenterpriseV1TestingOptionsResponse',
    'GoogleCloudRecaptchaenterpriseV1WafSettingsResponse',
    'GoogleCloudRecaptchaenterpriseV1WebKeySettingsResponse',
]

@pulumi.output_type
class GoogleCloudRecaptchaenterpriseV1AndroidKeySettingsResponse(dict):
    """
    Settings specific to keys that can be used by Android apps.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowAllPackageNames":
            suggest = "allow_all_package_names"
        elif key == "allowedPackageNames":
            suggest = "allowed_package_names"
        elif key == "supportNonGoogleAppStoreDistribution":
            suggest = "support_non_google_app_store_distribution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GoogleCloudRecaptchaenterpriseV1AndroidKeySettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GoogleCloudRecaptchaenterpriseV1AndroidKeySettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GoogleCloudRecaptchaenterpriseV1AndroidKeySettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_all_package_names: bool,
                 allowed_package_names: Sequence[str],
                 support_non_google_app_store_distribution: bool):
        """
        Settings specific to keys that can be used by Android apps.
        :param bool allow_all_package_names: Optional. If set to true, allowed_package_names are not enforced.
        :param Sequence[str] allowed_package_names: Optional. Android package names of apps allowed to use the key. Example: 'com.companyname.appname'
        :param bool support_non_google_app_store_distribution: Optional. Set to true for keys that are used in an Android application that is available for download in app stores in addition to the Google Play Store.
        """
        pulumi.set(__self__, "allow_all_package_names", allow_all_package_names)
        pulumi.set(__self__, "allowed_package_names", allowed_package_names)
        pulumi.set(__self__, "support_non_google_app_store_distribution", support_non_google_app_store_distribution)

    @property
    @pulumi.getter(name="allowAllPackageNames")
    def allow_all_package_names(self) -> bool:
        """
        Optional. If set to true, allowed_package_names are not enforced.
        """
        return pulumi.get(self, "allow_all_package_names")

    @property
    @pulumi.getter(name="allowedPackageNames")
    def allowed_package_names(self) -> Sequence[str]:
        """
        Optional. Android package names of apps allowed to use the key. Example: 'com.companyname.appname'
        """
        return pulumi.get(self, "allowed_package_names")

    @property
    @pulumi.getter(name="supportNonGoogleAppStoreDistribution")
    def support_non_google_app_store_distribution(self) -> bool:
        """
        Optional. Set to true for keys that are used in an Android application that is available for download in app stores in addition to the Google Play Store.
        """
        return pulumi.get(self, "support_non_google_app_store_distribution")


@pulumi.output_type
class GoogleCloudRecaptchaenterpriseV1AppleDeveloperIdResponse(dict):
    """
    Contains fields that are required to perform Apple-specific integrity checks.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyId":
            suggest = "key_id"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "teamId":
            suggest = "team_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GoogleCloudRecaptchaenterpriseV1AppleDeveloperIdResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GoogleCloudRecaptchaenterpriseV1AppleDeveloperIdResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GoogleCloudRecaptchaenterpriseV1AppleDeveloperIdResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_id: str,
                 private_key: str,
                 team_id: str):
        """
        Contains fields that are required to perform Apple-specific integrity checks.
        :param str key_id: The Apple developer key ID (10-character string).
        :param str private_key: Input only. A private key (downloaded as a text file with a .p8 file extension) generated for your Apple Developer account. Ensure that Apple DeviceCheck is enabled for the private key.
        :param str team_id: The Apple team ID (10-character string) owning the provisioning profile used to build your application.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> str:
        """
        The Apple developer key ID (10-character string).
        """
        return pulumi.get(self, "key_id")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        """
        Input only. A private key (downloaded as a text file with a .p8 file extension) generated for your Apple Developer account. Ensure that Apple DeviceCheck is enabled for the private key.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        """
        The Apple team ID (10-character string) owning the provisioning profile used to build your application.
        """
        return pulumi.get(self, "team_id")


@pulumi.output_type
class GoogleCloudRecaptchaenterpriseV1FirewallActionAllowActionResponse(dict):
    """
    An allow action continues processing a request unimpeded.
    """
    def __init__(__self__):
        """
        An allow action continues processing a request unimpeded.
        """
        pass


@pulumi.output_type
class GoogleCloudRecaptchaenterpriseV1FirewallActionBlockActionResponse(dict):
    """
    A block action serves an HTTP error code a prevents the request from hitting the backend.
    """
    def __init__(__self__):
        """
        A block action serves an HTTP error code a prevents the request from hitting the backend.
        """
        pass


@pulumi.output_type
class GoogleCloudRecaptchaenterpriseV1FirewallActionRedirectActionResponse(dict):
    """
    A redirect action returns a 307 (temporary redirect) response, pointing the user to a ReCaptcha interstitial page to attach a token.
    """
    def __init__(__self__):
        """
        A redirect action returns a 307 (temporary redirect) response, pointing the user to a ReCaptcha interstitial page to attach a token.
        """
        pass


@pulumi.output_type
class GoogleCloudRecaptchaenterpriseV1FirewallActionResponse(dict):
    """
    An individual action. Each action represents what to do if a policy matches.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "setHeader":
            suggest = "set_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GoogleCloudRecaptchaenterpriseV1FirewallActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GoogleCloudRecaptchaenterpriseV1FirewallActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GoogleCloudRecaptchaenterpriseV1FirewallActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow: 'outputs.GoogleCloudRecaptchaenterpriseV1FirewallActionAllowActionResponse',
                 block: 'outputs.GoogleCloudRecaptchaenterpriseV1FirewallActionBlockActionResponse',
                 redirect: 'outputs.GoogleCloudRecaptchaenterpriseV1FirewallActionRedirectActionResponse',
                 set_header: 'outputs.GoogleCloudRecaptchaenterpriseV1FirewallActionSetHeaderActionResponse',
                 substitute: 'outputs.GoogleCloudRecaptchaenterpriseV1FirewallActionSubstituteActionResponse'):
        """
        An individual action. Each action represents what to do if a policy matches.
        :param 'GoogleCloudRecaptchaenterpriseV1FirewallActionAllowActionResponse' allow: The user request did not match any policy and should be allowed access to the requested resource.
        :param 'GoogleCloudRecaptchaenterpriseV1FirewallActionBlockActionResponse' block: This action will deny access to a given page. The user will get an HTTP error code.
        :param 'GoogleCloudRecaptchaenterpriseV1FirewallActionRedirectActionResponse' redirect: This action will redirect the request to a ReCaptcha interstitial to attach a token.
        :param 'GoogleCloudRecaptchaenterpriseV1FirewallActionSetHeaderActionResponse' set_header: This action will set a custom header but allow the request to continue to the customer backend.
        :param 'GoogleCloudRecaptchaenterpriseV1FirewallActionSubstituteActionResponse' substitute: This action will transparently serve a different page to an offending user.
        """
        pulumi.set(__self__, "allow", allow)
        pulumi.set(__self__, "block", block)
        pulumi.set(__self__, "redirect", redirect)
        pulumi.set(__self__, "set_header", set_header)
        pulumi.set(__self__, "substitute", substitute)

    @property
    @pulumi.getter
    def allow(self) -> 'outputs.GoogleCloudRecaptchaenterpriseV1FirewallActionAllowActionResponse':
        """
        The user request did not match any policy and should be allowed access to the requested resource.
        """
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def block(self) -> 'outputs.GoogleCloudRecaptchaenterpriseV1FirewallActionBlockActionResponse':
        """
        This action will deny access to a given page. The user will get an HTTP error code.
        """
        return pulumi.get(self, "block")

    @property
    @pulumi.getter
    def redirect(self) -> 'outputs.GoogleCloudRecaptchaenterpriseV1FirewallActionRedirectActionResponse':
        """
        This action will redirect the request to a ReCaptcha interstitial to attach a token.
        """
        return pulumi.get(self, "redirect")

    @property
    @pulumi.getter(name="setHeader")
    def set_header(self) -> 'outputs.GoogleCloudRecaptchaenterpriseV1FirewallActionSetHeaderActionResponse':
        """
        This action will set a custom header but allow the request to continue to the customer backend.
        """
        return pulumi.get(self, "set_header")

    @property
    @pulumi.getter
    def substitute(self) -> 'outputs.GoogleCloudRecaptchaenterpriseV1FirewallActionSubstituteActionResponse':
        """
        This action will transparently serve a different page to an offending user.
        """
        return pulumi.get(self, "substitute")


@pulumi.output_type
class GoogleCloudRecaptchaenterpriseV1FirewallActionSetHeaderActionResponse(dict):
    """
    A set header action sets a header and forwards the request to the backend. This can be used to trigger custom protection implemented on the backend.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A set header action sets a header and forwards the request to the backend. This can be used to trigger custom protection implemented on the backend.
        :param str key: Optional. The header key to set in the request to the backend server.
        :param str value: Optional. The header value to set in the request to the backend server.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Optional. The header key to set in the request to the backend server.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Optional. The header value to set in the request to the backend server.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GoogleCloudRecaptchaenterpriseV1FirewallActionSubstituteActionResponse(dict):
    """
    A substitute action transparently serves a different page than the one requested.
    """
    def __init__(__self__, *,
                 path: str):
        """
        A substitute action transparently serves a different page than the one requested.
        :param str path: Optional. The address to redirect to. The target is a relative path in the current host. Example: "/blog/404.html".
        """
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Optional. The address to redirect to. The target is a relative path in the current host. Example: "/blog/404.html".
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GoogleCloudRecaptchaenterpriseV1IOSKeySettingsResponse(dict):
    """
    Settings specific to keys that can be used by iOS apps.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowAllBundleIds":
            suggest = "allow_all_bundle_ids"
        elif key == "allowedBundleIds":
            suggest = "allowed_bundle_ids"
        elif key == "appleDeveloperId":
            suggest = "apple_developer_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GoogleCloudRecaptchaenterpriseV1IOSKeySettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GoogleCloudRecaptchaenterpriseV1IOSKeySettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GoogleCloudRecaptchaenterpriseV1IOSKeySettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_all_bundle_ids: bool,
                 allowed_bundle_ids: Sequence[str],
                 apple_developer_id: 'outputs.GoogleCloudRecaptchaenterpriseV1AppleDeveloperIdResponse'):
        """
        Settings specific to keys that can be used by iOS apps.
        :param bool allow_all_bundle_ids: Optional. If set to true, allowed_bundle_ids are not enforced.
        :param Sequence[str] allowed_bundle_ids: Optional. iOS bundle ids of apps allowed to use the key. Example: 'com.companyname.productname.appname'
        :param 'GoogleCloudRecaptchaenterpriseV1AppleDeveloperIdResponse' apple_developer_id: Optional. Apple Developer account details for the app that is protected by the reCAPTCHA Key. reCAPTCHA Enterprise leverages platform-specific checks like Apple App Attest and Apple DeviceCheck to protect your app from abuse. Providing these fields allows reCAPTCHA Enterprise to get a better assessment of the integrity of your app.
        """
        pulumi.set(__self__, "allow_all_bundle_ids", allow_all_bundle_ids)
        pulumi.set(__self__, "allowed_bundle_ids", allowed_bundle_ids)
        pulumi.set(__self__, "apple_developer_id", apple_developer_id)

    @property
    @pulumi.getter(name="allowAllBundleIds")
    def allow_all_bundle_ids(self) -> bool:
        """
        Optional. If set to true, allowed_bundle_ids are not enforced.
        """
        return pulumi.get(self, "allow_all_bundle_ids")

    @property
    @pulumi.getter(name="allowedBundleIds")
    def allowed_bundle_ids(self) -> Sequence[str]:
        """
        Optional. iOS bundle ids of apps allowed to use the key. Example: 'com.companyname.productname.appname'
        """
        return pulumi.get(self, "allowed_bundle_ids")

    @property
    @pulumi.getter(name="appleDeveloperId")
    def apple_developer_id(self) -> 'outputs.GoogleCloudRecaptchaenterpriseV1AppleDeveloperIdResponse':
        """
        Optional. Apple Developer account details for the app that is protected by the reCAPTCHA Key. reCAPTCHA Enterprise leverages platform-specific checks like Apple App Attest and Apple DeviceCheck to protect your app from abuse. Providing these fields allows reCAPTCHA Enterprise to get a better assessment of the integrity of your app.
        """
        return pulumi.get(self, "apple_developer_id")


@pulumi.output_type
class GoogleCloudRecaptchaenterpriseV1TestingOptionsResponse(dict):
    """
    Options for user acceptance testing.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "testingChallenge":
            suggest = "testing_challenge"
        elif key == "testingScore":
            suggest = "testing_score"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GoogleCloudRecaptchaenterpriseV1TestingOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GoogleCloudRecaptchaenterpriseV1TestingOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GoogleCloudRecaptchaenterpriseV1TestingOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 testing_challenge: str,
                 testing_score: float):
        """
        Options for user acceptance testing.
        :param str testing_challenge: Optional. For challenge-based keys only (CHECKBOX, INVISIBLE), all challenge requests for this site will return nocaptcha if NOCAPTCHA, or an unsolvable challenge if CHALLENGE.
        :param float testing_score: Optional. All assessments for this Key will return this score. Must be between 0 (likely not legitimate) and 1 (likely legitimate) inclusive.
        """
        pulumi.set(__self__, "testing_challenge", testing_challenge)
        pulumi.set(__self__, "testing_score", testing_score)

    @property
    @pulumi.getter(name="testingChallenge")
    def testing_challenge(self) -> str:
        """
        Optional. For challenge-based keys only (CHECKBOX, INVISIBLE), all challenge requests for this site will return nocaptcha if NOCAPTCHA, or an unsolvable challenge if CHALLENGE.
        """
        return pulumi.get(self, "testing_challenge")

    @property
    @pulumi.getter(name="testingScore")
    def testing_score(self) -> float:
        """
        Optional. All assessments for this Key will return this score. Must be between 0 (likely not legitimate) and 1 (likely legitimate) inclusive.
        """
        return pulumi.get(self, "testing_score")


@pulumi.output_type
class GoogleCloudRecaptchaenterpriseV1WafSettingsResponse(dict):
    """
    Settings specific to keys that can be used for WAF (Web Application Firewall).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wafFeature":
            suggest = "waf_feature"
        elif key == "wafService":
            suggest = "waf_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GoogleCloudRecaptchaenterpriseV1WafSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GoogleCloudRecaptchaenterpriseV1WafSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GoogleCloudRecaptchaenterpriseV1WafSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 waf_feature: str,
                 waf_service: str):
        """
        Settings specific to keys that can be used for WAF (Web Application Firewall).
        :param str waf_feature: The WAF feature for which this key is enabled.
        :param str waf_service: The WAF service that uses this key.
        """
        pulumi.set(__self__, "waf_feature", waf_feature)
        pulumi.set(__self__, "waf_service", waf_service)

    @property
    @pulumi.getter(name="wafFeature")
    def waf_feature(self) -> str:
        """
        The WAF feature for which this key is enabled.
        """
        return pulumi.get(self, "waf_feature")

    @property
    @pulumi.getter(name="wafService")
    def waf_service(self) -> str:
        """
        The WAF service that uses this key.
        """
        return pulumi.get(self, "waf_service")


@pulumi.output_type
class GoogleCloudRecaptchaenterpriseV1WebKeySettingsResponse(dict):
    """
    Settings specific to keys that can be used by websites.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowAllDomains":
            suggest = "allow_all_domains"
        elif key == "allowAmpTraffic":
            suggest = "allow_amp_traffic"
        elif key == "allowedDomains":
            suggest = "allowed_domains"
        elif key == "challengeSecurityPreference":
            suggest = "challenge_security_preference"
        elif key == "integrationType":
            suggest = "integration_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GoogleCloudRecaptchaenterpriseV1WebKeySettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GoogleCloudRecaptchaenterpriseV1WebKeySettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GoogleCloudRecaptchaenterpriseV1WebKeySettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_all_domains: bool,
                 allow_amp_traffic: bool,
                 allowed_domains: Sequence[str],
                 challenge_security_preference: str,
                 integration_type: str):
        """
        Settings specific to keys that can be used by websites.
        :param bool allow_all_domains: Optional. If set to true, it means allowed_domains will not be enforced.
        :param bool allow_amp_traffic: Optional. If set to true, the key can be used on AMP (Accelerated Mobile Pages) websites. This is supported only for the SCORE integration type.
        :param Sequence[str] allowed_domains: Optional. Domains or subdomains of websites allowed to use the key. All subdomains of an allowed domain are automatically allowed. A valid domain requires a host and must not include any path, port, query or fragment. Examples: 'example.com' or 'subdomain.example.com'
        :param str challenge_security_preference: Optional. Settings for the frequency and difficulty at which this key triggers captcha challenges. This should only be specified for IntegrationTypes CHECKBOX and INVISIBLE.
        :param str integration_type: Describes how this key is integrated with the website.
        """
        pulumi.set(__self__, "allow_all_domains", allow_all_domains)
        pulumi.set(__self__, "allow_amp_traffic", allow_amp_traffic)
        pulumi.set(__self__, "allowed_domains", allowed_domains)
        pulumi.set(__self__, "challenge_security_preference", challenge_security_preference)
        pulumi.set(__self__, "integration_type", integration_type)

    @property
    @pulumi.getter(name="allowAllDomains")
    def allow_all_domains(self) -> bool:
        """
        Optional. If set to true, it means allowed_domains will not be enforced.
        """
        return pulumi.get(self, "allow_all_domains")

    @property
    @pulumi.getter(name="allowAmpTraffic")
    def allow_amp_traffic(self) -> bool:
        """
        Optional. If set to true, the key can be used on AMP (Accelerated Mobile Pages) websites. This is supported only for the SCORE integration type.
        """
        return pulumi.get(self, "allow_amp_traffic")

    @property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> Sequence[str]:
        """
        Optional. Domains or subdomains of websites allowed to use the key. All subdomains of an allowed domain are automatically allowed. A valid domain requires a host and must not include any path, port, query or fragment. Examples: 'example.com' or 'subdomain.example.com'
        """
        return pulumi.get(self, "allowed_domains")

    @property
    @pulumi.getter(name="challengeSecurityPreference")
    def challenge_security_preference(self) -> str:
        """
        Optional. Settings for the frequency and difficulty at which this key triggers captcha challenges. This should only be specified for IntegrationTypes CHECKBOX and INVISIBLE.
        """
        return pulumi.get(self, "challenge_security_preference")

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        """
        Describes how this key is integrated with the website.
        """
        return pulumi.get(self, "integration_type")


