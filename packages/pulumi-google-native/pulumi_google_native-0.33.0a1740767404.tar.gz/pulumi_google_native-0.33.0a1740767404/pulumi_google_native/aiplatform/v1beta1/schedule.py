# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *
from ._inputs import *

__all__ = ['ScheduleArgs', 'Schedule']

@pulumi.input_type
class ScheduleArgs:
    def __init__(__self__, *,
                 display_name: pulumi.Input[str],
                 max_concurrent_run_count: pulumi.Input[str],
                 allow_queueing: Optional[pulumi.Input[bool]] = None,
                 create_pipeline_job_request: Optional[pulumi.Input['GoogleCloudAiplatformV1beta1CreatePipelineJobRequestArgs']] = None,
                 cron: Optional[pulumi.Input[str]] = None,
                 end_time: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 max_run_count: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 project: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        The set of arguments for constructing a Schedule resource.
        :param pulumi.Input[str] display_name: User provided name of the Schedule. The name can be up to 128 characters long and can consist of any UTF-8 characters.
        :param pulumi.Input[str] max_concurrent_run_count: Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the operations/jobs created by the requests (if applicable).
        :param pulumi.Input[bool] allow_queueing: Optional. Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be queued instead of skipped. Default to false.
        :param pulumi.Input['GoogleCloudAiplatformV1beta1CreatePipelineJobRequestArgs'] create_pipeline_job_request: Request for PipelineService.CreatePipelineJob. CreatePipelineJobRequest.parent field is required (format: projects/{project}/locations/{location}).
        :param pulumi.Input[str] cron: Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
        :param pulumi.Input[str] end_time: Optional. Timestamp after which no new runs can be scheduled. If specified, The schedule will be completed when either end_time is reached or when scheduled_run_count >= max_run_count. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
        :param pulumi.Input[str] max_run_count: Optional. Maximum run count of the schedule. If specified, The schedule will be completed when either started_run_count >= max_run_count or when end_time is reached. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
        :param pulumi.Input[str] name: Immutable. The resource name of the Schedule.
        :param pulumi.Input[str] start_time: Optional. Timestamp after which the first run can be scheduled. Default to Schedule create time if not specified.
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "max_concurrent_run_count", max_concurrent_run_count)
        if allow_queueing is not None:
            pulumi.set(__self__, "allow_queueing", allow_queueing)
        if create_pipeline_job_request is not None:
            pulumi.set(__self__, "create_pipeline_job_request", create_pipeline_job_request)
        if cron is not None:
            pulumi.set(__self__, "cron", cron)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if max_run_count is not None:
            pulumi.set(__self__, "max_run_count", max_run_count)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[str]:
        """
        User provided name of the Schedule. The name can be up to 128 characters long and can consist of any UTF-8 characters.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="maxConcurrentRunCount")
    def max_concurrent_run_count(self) -> pulumi.Input[str]:
        """
        Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the operations/jobs created by the requests (if applicable).
        """
        return pulumi.get(self, "max_concurrent_run_count")

    @max_concurrent_run_count.setter
    def max_concurrent_run_count(self, value: pulumi.Input[str]):
        pulumi.set(self, "max_concurrent_run_count", value)

    @property
    @pulumi.getter(name="allowQueueing")
    def allow_queueing(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be queued instead of skipped. Default to false.
        """
        return pulumi.get(self, "allow_queueing")

    @allow_queueing.setter
    def allow_queueing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_queueing", value)

    @property
    @pulumi.getter(name="createPipelineJobRequest")
    def create_pipeline_job_request(self) -> Optional[pulumi.Input['GoogleCloudAiplatformV1beta1CreatePipelineJobRequestArgs']]:
        """
        Request for PipelineService.CreatePipelineJob. CreatePipelineJobRequest.parent field is required (format: projects/{project}/locations/{location}).
        """
        return pulumi.get(self, "create_pipeline_job_request")

    @create_pipeline_job_request.setter
    def create_pipeline_job_request(self, value: Optional[pulumi.Input['GoogleCloudAiplatformV1beta1CreatePipelineJobRequestArgs']]):
        pulumi.set(self, "create_pipeline_job_request", value)

    @property
    @pulumi.getter
    def cron(self) -> Optional[pulumi.Input[str]]:
        """
        Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
        """
        return pulumi.get(self, "cron")

    @cron.setter
    def cron(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cron", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Timestamp after which no new runs can be scheduled. If specified, The schedule will be completed when either end_time is reached or when scheduled_run_count >= max_run_count. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="maxRunCount")
    def max_run_count(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Maximum run count of the schedule. If specified, The schedule will be completed when either started_run_count >= max_run_count or when end_time is reached. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
        """
        return pulumi.get(self, "max_run_count")

    @max_run_count.setter
    def max_run_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_run_count", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Immutable. The resource name of the Schedule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def project(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Timestamp after which the first run can be scheduled. Default to Schedule create time if not specified.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


class Schedule(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 allow_queueing: Optional[pulumi.Input[bool]] = None,
                 create_pipeline_job_request: Optional[pulumi.Input[pulumi.InputType['GoogleCloudAiplatformV1beta1CreatePipelineJobRequestArgs']]] = None,
                 cron: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 end_time: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 max_concurrent_run_count: Optional[pulumi.Input[str]] = None,
                 max_run_count: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 project: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        """
        Creates a Schedule.

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[bool] allow_queueing: Optional. Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be queued instead of skipped. Default to false.
        :param pulumi.Input[pulumi.InputType['GoogleCloudAiplatformV1beta1CreatePipelineJobRequestArgs']] create_pipeline_job_request: Request for PipelineService.CreatePipelineJob. CreatePipelineJobRequest.parent field is required (format: projects/{project}/locations/{location}).
        :param pulumi.Input[str] cron: Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
        :param pulumi.Input[str] display_name: User provided name of the Schedule. The name can be up to 128 characters long and can consist of any UTF-8 characters.
        :param pulumi.Input[str] end_time: Optional. Timestamp after which no new runs can be scheduled. If specified, The schedule will be completed when either end_time is reached or when scheduled_run_count >= max_run_count. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
        :param pulumi.Input[str] max_concurrent_run_count: Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the operations/jobs created by the requests (if applicable).
        :param pulumi.Input[str] max_run_count: Optional. Maximum run count of the schedule. If specified, The schedule will be completed when either started_run_count >= max_run_count or when end_time is reached. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
        :param pulumi.Input[str] name: Immutable. The resource name of the Schedule.
        :param pulumi.Input[str] start_time: Optional. Timestamp after which the first run can be scheduled. Default to Schedule create time if not specified.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: ScheduleArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Creates a Schedule.

        :param str resource_name: The name of the resource.
        :param ScheduleArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(ScheduleArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 allow_queueing: Optional[pulumi.Input[bool]] = None,
                 create_pipeline_job_request: Optional[pulumi.Input[pulumi.InputType['GoogleCloudAiplatformV1beta1CreatePipelineJobRequestArgs']]] = None,
                 cron: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 end_time: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 max_concurrent_run_count: Optional[pulumi.Input[str]] = None,
                 max_run_count: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 project: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = ScheduleArgs.__new__(ScheduleArgs)

            __props__.__dict__["allow_queueing"] = allow_queueing
            __props__.__dict__["create_pipeline_job_request"] = create_pipeline_job_request
            __props__.__dict__["cron"] = cron
            if display_name is None and not opts.urn:
                raise TypeError("Missing required property 'display_name'")
            __props__.__dict__["display_name"] = display_name
            __props__.__dict__["end_time"] = end_time
            __props__.__dict__["location"] = location
            if max_concurrent_run_count is None and not opts.urn:
                raise TypeError("Missing required property 'max_concurrent_run_count'")
            __props__.__dict__["max_concurrent_run_count"] = max_concurrent_run_count
            __props__.__dict__["max_run_count"] = max_run_count
            __props__.__dict__["name"] = name
            __props__.__dict__["project"] = project
            __props__.__dict__["start_time"] = start_time
            __props__.__dict__["catch_up"] = None
            __props__.__dict__["create_time"] = None
            __props__.__dict__["last_pause_time"] = None
            __props__.__dict__["last_resume_time"] = None
            __props__.__dict__["last_scheduled_run_response"] = None
            __props__.__dict__["next_run_time"] = None
            __props__.__dict__["started_run_count"] = None
            __props__.__dict__["state"] = None
            __props__.__dict__["update_time"] = None
        replace_on_changes = pulumi.ResourceOptions(replace_on_changes=["location", "project"])
        opts = pulumi.ResourceOptions.merge(opts, replace_on_changes)
        super(Schedule, __self__).__init__(
            'google-native:aiplatform/v1beta1:Schedule',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None) -> 'Schedule':
        """
        Get an existing Schedule resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = ScheduleArgs.__new__(ScheduleArgs)

        __props__.__dict__["allow_queueing"] = None
        __props__.__dict__["catch_up"] = None
        __props__.__dict__["create_pipeline_job_request"] = None
        __props__.__dict__["create_time"] = None
        __props__.__dict__["cron"] = None
        __props__.__dict__["display_name"] = None
        __props__.__dict__["end_time"] = None
        __props__.__dict__["last_pause_time"] = None
        __props__.__dict__["last_resume_time"] = None
        __props__.__dict__["last_scheduled_run_response"] = None
        __props__.__dict__["location"] = None
        __props__.__dict__["max_concurrent_run_count"] = None
        __props__.__dict__["max_run_count"] = None
        __props__.__dict__["name"] = None
        __props__.__dict__["next_run_time"] = None
        __props__.__dict__["project"] = None
        __props__.__dict__["start_time"] = None
        __props__.__dict__["started_run_count"] = None
        __props__.__dict__["state"] = None
        __props__.__dict__["update_time"] = None
        return Schedule(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="allowQueueing")
    def allow_queueing(self) -> pulumi.Output[bool]:
        """
        Optional. Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be queued instead of skipped. Default to false.
        """
        return pulumi.get(self, "allow_queueing")

    @property
    @pulumi.getter(name="catchUp")
    def catch_up(self) -> pulumi.Output[bool]:
        """
        Whether to backfill missed runs when the schedule is resumed from PAUSED state. If set to true, all missed runs will be scheduled. New runs will be scheduled after the backfill is complete. Default to false.
        """
        return pulumi.get(self, "catch_up")

    @property
    @pulumi.getter(name="createPipelineJobRequest")
    def create_pipeline_job_request(self) -> pulumi.Output['outputs.GoogleCloudAiplatformV1beta1CreatePipelineJobRequestResponse']:
        """
        Request for PipelineService.CreatePipelineJob. CreatePipelineJobRequest.parent field is required (format: projects/{project}/locations/{location}).
        """
        return pulumi.get(self, "create_pipeline_job_request")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> pulumi.Output[str]:
        """
        Timestamp when this Schedule was created.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter
    def cron(self) -> pulumi.Output[str]:
        """
        Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York 1 * * * *".
        """
        return pulumi.get(self, "cron")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Output[str]:
        """
        User provided name of the Schedule. The name can be up to 128 characters long and can consist of any UTF-8 characters.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Output[str]:
        """
        Optional. Timestamp after which no new runs can be scheduled. If specified, The schedule will be completed when either end_time is reached or when scheduled_run_count >= max_run_count. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="lastPauseTime")
    def last_pause_time(self) -> pulumi.Output[str]:
        """
        Timestamp when this Schedule was last paused. Unset if never paused.
        """
        return pulumi.get(self, "last_pause_time")

    @property
    @pulumi.getter(name="lastResumeTime")
    def last_resume_time(self) -> pulumi.Output[str]:
        """
        Timestamp when this Schedule was last resumed. Unset if never resumed from pause.
        """
        return pulumi.get(self, "last_resume_time")

    @property
    @pulumi.getter(name="lastScheduledRunResponse")
    def last_scheduled_run_response(self) -> pulumi.Output['outputs.GoogleCloudAiplatformV1beta1ScheduleRunResponseResponse']:
        """
        Response of the last scheduled run. This is the response for starting the scheduled requests and not the execution of the operations/jobs created by the requests (if applicable). Unset if no run has been scheduled yet.
        """
        return pulumi.get(self, "last_scheduled_run_response")

    @property
    @pulumi.getter
    def location(self) -> pulumi.Output[str]:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="maxConcurrentRunCount")
    def max_concurrent_run_count(self) -> pulumi.Output[str]:
        """
        Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the operations/jobs created by the requests (if applicable).
        """
        return pulumi.get(self, "max_concurrent_run_count")

    @property
    @pulumi.getter(name="maxRunCount")
    def max_run_count(self) -> pulumi.Output[str]:
        """
        Optional. Maximum run count of the schedule. If specified, The schedule will be completed when either started_run_count >= max_run_count or when end_time is reached. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
        """
        return pulumi.get(self, "max_run_count")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        """
        Immutable. The resource name of the Schedule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nextRunTime")
    def next_run_time(self) -> pulumi.Output[str]:
        """
        Timestamp when this Schedule should schedule the next run. Having a next_run_time in the past means the runs are being started behind schedule.
        """
        return pulumi.get(self, "next_run_time")

    @property
    @pulumi.getter
    def project(self) -> pulumi.Output[str]:
        return pulumi.get(self, "project")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Output[str]:
        """
        Optional. Timestamp after which the first run can be scheduled. Default to Schedule create time if not specified.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="startedRunCount")
    def started_run_count(self) -> pulumi.Output[str]:
        """
        The number of runs started by this schedule.
        """
        return pulumi.get(self, "started_run_count")

    @property
    @pulumi.getter
    def state(self) -> pulumi.Output[str]:
        """
        The state of this Schedule.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> pulumi.Output[str]:
        """
        Timestamp when this Schedule was updated.
        """
        return pulumi.get(self, "update_time")

