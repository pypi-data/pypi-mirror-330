# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AuditConfigResponse',
    'AuditLogConfigResponse',
    'BackupConfigResponse',
    'BindingResponse',
    'ClusterMetadataResponse',
    'ClusterResourceRestoreScopeResponse',
    'EncryptionKeyResponse',
    'ExprResponse',
    'GroupKindResponse',
    'NamespacedNameResponse',
    'NamespacedNamesResponse',
    'NamespacesResponse',
    'ResourceFilterResponse',
    'RestoreConfigResponse',
    'RetentionPolicyResponse',
    'ScheduleResponse',
    'SubstitutionRuleResponse',
    'TransformationRuleActionResponse',
    'TransformationRuleResponse',
]

@pulumi.output_type
class AuditConfigResponse(dict):
    """
    Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts `jose@example.com` from DATA_READ logging, and `aliya@example.com` from DATA_WRITE logging.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditLogConfigs":
            suggest = "audit_log_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audit_log_configs: Sequence['outputs.AuditLogConfigResponse'],
                 service: str):
        """
        Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts `jose@example.com` from DATA_READ logging, and `aliya@example.com` from DATA_WRITE logging.
        :param Sequence['AuditLogConfigResponse'] audit_log_configs: The configuration for logging of each type of permission.
        :param str service: Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
        """
        pulumi.set(__self__, "audit_log_configs", audit_log_configs)
        pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter(name="auditLogConfigs")
    def audit_log_configs(self) -> Sequence['outputs.AuditLogConfigResponse']:
        """
        The configuration for logging of each type of permission.
        """
        return pulumi.get(self, "audit_log_configs")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class AuditLogConfigResponse(dict):
    """
    Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exemptedMembers":
            suggest = "exempted_members"
        elif key == "logType":
            suggest = "log_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditLogConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditLogConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditLogConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exempted_members: Sequence[str],
                 log_type: str):
        """
        Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
        :param Sequence[str] exempted_members: Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
        :param str log_type: The log type that this config enables.
        """
        pulumi.set(__self__, "exempted_members", exempted_members)
        pulumi.set(__self__, "log_type", log_type)

    @property
    @pulumi.getter(name="exemptedMembers")
    def exempted_members(self) -> Sequence[str]:
        """
        Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
        """
        return pulumi.get(self, "exempted_members")

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> str:
        """
        The log type that this config enables.
        """
        return pulumi.get(self, "log_type")


@pulumi.output_type
class BackupConfigResponse(dict):
    """
    BackupConfig defines the configuration of Backups created via this BackupPlan.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allNamespaces":
            suggest = "all_namespaces"
        elif key == "encryptionKey":
            suggest = "encryption_key"
        elif key == "includeSecrets":
            suggest = "include_secrets"
        elif key == "includeVolumeData":
            suggest = "include_volume_data"
        elif key == "selectedApplications":
            suggest = "selected_applications"
        elif key == "selectedNamespaces":
            suggest = "selected_namespaces"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_namespaces: bool,
                 encryption_key: 'outputs.EncryptionKeyResponse',
                 include_secrets: bool,
                 include_volume_data: bool,
                 selected_applications: 'outputs.NamespacedNamesResponse',
                 selected_namespaces: 'outputs.NamespacesResponse'):
        """
        BackupConfig defines the configuration of Backups created via this BackupPlan.
        :param bool all_namespaces: If True, include all namespaced resources
        :param 'EncryptionKeyResponse' encryption_key: Optional. This defines a customer managed encryption key that will be used to encrypt the "config" portion (the Kubernetes resources) of Backups created via this plan. Default (empty): Config backup artifacts will not be encrypted.
        :param bool include_secrets: Optional. This flag specifies whether Kubernetes Secret resources should be included when they fall into the scope of Backups. Default: False
        :param bool include_volume_data: Optional. This flag specifies whether volume data should be backed up when PVCs are included in the scope of a Backup. Default: False
        :param 'NamespacedNamesResponse' selected_applications: If set, include just the resources referenced by the listed ProtectedApplications.
        :param 'NamespacesResponse' selected_namespaces: If set, include just the resources in the listed namespaces.
        """
        pulumi.set(__self__, "all_namespaces", all_namespaces)
        pulumi.set(__self__, "encryption_key", encryption_key)
        pulumi.set(__self__, "include_secrets", include_secrets)
        pulumi.set(__self__, "include_volume_data", include_volume_data)
        pulumi.set(__self__, "selected_applications", selected_applications)
        pulumi.set(__self__, "selected_namespaces", selected_namespaces)

    @property
    @pulumi.getter(name="allNamespaces")
    def all_namespaces(self) -> bool:
        """
        If True, include all namespaced resources
        """
        return pulumi.get(self, "all_namespaces")

    @property
    @pulumi.getter(name="encryptionKey")
    def encryption_key(self) -> 'outputs.EncryptionKeyResponse':
        """
        Optional. This defines a customer managed encryption key that will be used to encrypt the "config" portion (the Kubernetes resources) of Backups created via this plan. Default (empty): Config backup artifacts will not be encrypted.
        """
        return pulumi.get(self, "encryption_key")

    @property
    @pulumi.getter(name="includeSecrets")
    def include_secrets(self) -> bool:
        """
        Optional. This flag specifies whether Kubernetes Secret resources should be included when they fall into the scope of Backups. Default: False
        """
        return pulumi.get(self, "include_secrets")

    @property
    @pulumi.getter(name="includeVolumeData")
    def include_volume_data(self) -> bool:
        """
        Optional. This flag specifies whether volume data should be backed up when PVCs are included in the scope of a Backup. Default: False
        """
        return pulumi.get(self, "include_volume_data")

    @property
    @pulumi.getter(name="selectedApplications")
    def selected_applications(self) -> 'outputs.NamespacedNamesResponse':
        """
        If set, include just the resources referenced by the listed ProtectedApplications.
        """
        return pulumi.get(self, "selected_applications")

    @property
    @pulumi.getter(name="selectedNamespaces")
    def selected_namespaces(self) -> 'outputs.NamespacesResponse':
        """
        If set, include just the resources in the listed namespaces.
        """
        return pulumi.get(self, "selected_namespaces")


@pulumi.output_type
class BindingResponse(dict):
    """
    Associates `members`, or principals, with a `role`.
    """
    def __init__(__self__, *,
                 condition: 'outputs.ExprResponse',
                 members: Sequence[str],
                 role: str):
        """
        Associates `members`, or principals, with a `role`.
        :param 'ExprResponse' condition: The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        :param Sequence[str] members: Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
        :param str role: Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "members", members)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def condition(self) -> 'outputs.ExprResponse':
        """
        The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def members(self) -> Sequence[str]:
        """
        Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
        """
        return pulumi.get(self, "members")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class ClusterMetadataResponse(dict):
    """
    Information about the GKE cluster from which this Backup was created.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anthosVersion":
            suggest = "anthos_version"
        elif key == "backupCrdVersions":
            suggest = "backup_crd_versions"
        elif key == "gkeVersion":
            suggest = "gke_version"
        elif key == "k8sVersion":
            suggest = "k8s_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterMetadataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterMetadataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterMetadataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anthos_version: str,
                 backup_crd_versions: Mapping[str, str],
                 cluster: str,
                 gke_version: str,
                 k8s_version: str):
        """
        Information about the GKE cluster from which this Backup was created.
        :param str anthos_version: Anthos version
        :param Mapping[str, str] backup_crd_versions: A list of the Backup for GKE CRD versions found in the cluster.
        :param str cluster: The source cluster from which this Backup was created. Valid formats: - `projects/*/locations/*/clusters/*` - `projects/*/zones/*/clusters/*` This is inherited from the parent BackupPlan's cluster field.
        :param str gke_version: GKE version
        :param str k8s_version: The Kubernetes server version of the source cluster.
        """
        pulumi.set(__self__, "anthos_version", anthos_version)
        pulumi.set(__self__, "backup_crd_versions", backup_crd_versions)
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "gke_version", gke_version)
        pulumi.set(__self__, "k8s_version", k8s_version)

    @property
    @pulumi.getter(name="anthosVersion")
    def anthos_version(self) -> str:
        """
        Anthos version
        """
        return pulumi.get(self, "anthos_version")

    @property
    @pulumi.getter(name="backupCrdVersions")
    def backup_crd_versions(self) -> Mapping[str, str]:
        """
        A list of the Backup for GKE CRD versions found in the cluster.
        """
        return pulumi.get(self, "backup_crd_versions")

    @property
    @pulumi.getter
    def cluster(self) -> str:
        """
        The source cluster from which this Backup was created. Valid formats: - `projects/*/locations/*/clusters/*` - `projects/*/zones/*/clusters/*` This is inherited from the parent BackupPlan's cluster field.
        """
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="gkeVersion")
    def gke_version(self) -> str:
        """
        GKE version
        """
        return pulumi.get(self, "gke_version")

    @property
    @pulumi.getter(name="k8sVersion")
    def k8s_version(self) -> str:
        """
        The Kubernetes server version of the source cluster.
        """
        return pulumi.get(self, "k8s_version")


@pulumi.output_type
class ClusterResourceRestoreScopeResponse(dict):
    """
    Defines the scope of cluster-scoped resources to restore. Some group kinds are not reasonable choices for a restore, and will cause an error if selected here. Any scope selection that would restore "all valid" resources automatically excludes these group kinds. - gkebackup.gke.io/BackupJob - gkebackup.gke.io/RestoreJob - metrics.k8s.io/NodeMetrics - migration.k8s.io/StorageState - migration.k8s.io/StorageVersionMigration - Node - snapshot.storage.k8s.io/VolumeSnapshotContent - storage.k8s.io/CSINode Some group kinds are driven by restore configuration elsewhere, and will cause an error if selected here. - Namespace - PersistentVolume
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allGroupKinds":
            suggest = "all_group_kinds"
        elif key == "excludedGroupKinds":
            suggest = "excluded_group_kinds"
        elif key == "noGroupKinds":
            suggest = "no_group_kinds"
        elif key == "selectedGroupKinds":
            suggest = "selected_group_kinds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterResourceRestoreScopeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterResourceRestoreScopeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterResourceRestoreScopeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_group_kinds: bool,
                 excluded_group_kinds: Sequence['outputs.GroupKindResponse'],
                 no_group_kinds: bool,
                 selected_group_kinds: Sequence['outputs.GroupKindResponse']):
        """
        Defines the scope of cluster-scoped resources to restore. Some group kinds are not reasonable choices for a restore, and will cause an error if selected here. Any scope selection that would restore "all valid" resources automatically excludes these group kinds. - gkebackup.gke.io/BackupJob - gkebackup.gke.io/RestoreJob - metrics.k8s.io/NodeMetrics - migration.k8s.io/StorageState - migration.k8s.io/StorageVersionMigration - Node - snapshot.storage.k8s.io/VolumeSnapshotContent - storage.k8s.io/CSINode Some group kinds are driven by restore configuration elsewhere, and will cause an error if selected here. - Namespace - PersistentVolume
        :param bool all_group_kinds: Optional. If True, all valid cluster-scoped resources will be restored. Mutually exclusive to any other field in the message.
        :param Sequence['GroupKindResponse'] excluded_group_kinds: Optional. A list of cluster-scoped resource group kinds to NOT restore from the backup. If specified, all valid cluster-scoped resources will be restored except for those specified in the list. Mutually exclusive to any other field in the message.
        :param bool no_group_kinds: Optional. If True, no cluster-scoped resources will be restored. This has the same restore scope as if the message is not defined. Mutually exclusive to any other field in the message.
        :param Sequence['GroupKindResponse'] selected_group_kinds: Optional. A list of cluster-scoped resource group kinds to restore from the backup. If specified, only the selected resources will be restored. Mutually exclusive to any other field in the message.
        """
        pulumi.set(__self__, "all_group_kinds", all_group_kinds)
        pulumi.set(__self__, "excluded_group_kinds", excluded_group_kinds)
        pulumi.set(__self__, "no_group_kinds", no_group_kinds)
        pulumi.set(__self__, "selected_group_kinds", selected_group_kinds)

    @property
    @pulumi.getter(name="allGroupKinds")
    def all_group_kinds(self) -> bool:
        """
        Optional. If True, all valid cluster-scoped resources will be restored. Mutually exclusive to any other field in the message.
        """
        return pulumi.get(self, "all_group_kinds")

    @property
    @pulumi.getter(name="excludedGroupKinds")
    def excluded_group_kinds(self) -> Sequence['outputs.GroupKindResponse']:
        """
        Optional. A list of cluster-scoped resource group kinds to NOT restore from the backup. If specified, all valid cluster-scoped resources will be restored except for those specified in the list. Mutually exclusive to any other field in the message.
        """
        return pulumi.get(self, "excluded_group_kinds")

    @property
    @pulumi.getter(name="noGroupKinds")
    def no_group_kinds(self) -> bool:
        """
        Optional. If True, no cluster-scoped resources will be restored. This has the same restore scope as if the message is not defined. Mutually exclusive to any other field in the message.
        """
        return pulumi.get(self, "no_group_kinds")

    @property
    @pulumi.getter(name="selectedGroupKinds")
    def selected_group_kinds(self) -> Sequence['outputs.GroupKindResponse']:
        """
        Optional. A list of cluster-scoped resource group kinds to restore from the backup. If specified, only the selected resources will be restored. Mutually exclusive to any other field in the message.
        """
        return pulumi.get(self, "selected_group_kinds")


@pulumi.output_type
class EncryptionKeyResponse(dict):
    """
    Defined a customer managed encryption key that will be used to encrypt Backup artifacts.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gcpKmsEncryptionKey":
            suggest = "gcp_kms_encryption_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionKeyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionKeyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionKeyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gcp_kms_encryption_key: str):
        """
        Defined a customer managed encryption key that will be used to encrypt Backup artifacts.
        :param str gcp_kms_encryption_key: Optional. Google Cloud KMS encryption key. Format: `projects/*/locations/*/keyRings/*/cryptoKeys/*`
        """
        pulumi.set(__self__, "gcp_kms_encryption_key", gcp_kms_encryption_key)

    @property
    @pulumi.getter(name="gcpKmsEncryptionKey")
    def gcp_kms_encryption_key(self) -> str:
        """
        Optional. Google Cloud KMS encryption key. Format: `projects/*/locations/*/keyRings/*/cryptoKeys/*`
        """
        return pulumi.get(self, "gcp_kms_encryption_key")


@pulumi.output_type
class ExprResponse(dict):
    """
    Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
    """
    def __init__(__self__, *,
                 description: str,
                 expression: str,
                 location: str,
                 title: str):
        """
        Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
        :param str description: Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        :param str expression: Textual representation of an expression in Common Expression Language syntax.
        :param str location: Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
        :param str title: Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GroupKindResponse(dict):
    """
    This is a direct map to the Kubernetes GroupKind type [GroupKind](https://godoc.org/k8s.io/apimachinery/pkg/runtime/schema#GroupKind) and is used for identifying specific "types" of resources to restore.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroup":
            suggest = "resource_group"
        elif key == "resourceKind":
            suggest = "resource_kind"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupKindResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupKindResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupKindResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_group: str,
                 resource_kind: str):
        """
        This is a direct map to the Kubernetes GroupKind type [GroupKind](https://godoc.org/k8s.io/apimachinery/pkg/runtime/schema#GroupKind) and is used for identifying specific "types" of resources to restore.
        :param str resource_group: Optional. API group string of a Kubernetes resource, e.g. "apiextensions.k8s.io", "storage.k8s.io", etc. Note: use empty string for core API group
        :param str resource_kind: Optional. Kind of a Kubernetes resource, must be in UpperCamelCase (PascalCase) and singular form. E.g. "CustomResourceDefinition", "StorageClass", etc.
        """
        pulumi.set(__self__, "resource_group", resource_group)
        pulumi.set(__self__, "resource_kind", resource_kind)

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> str:
        """
        Optional. API group string of a Kubernetes resource, e.g. "apiextensions.k8s.io", "storage.k8s.io", etc. Note: use empty string for core API group
        """
        return pulumi.get(self, "resource_group")

    @property
    @pulumi.getter(name="resourceKind")
    def resource_kind(self) -> str:
        """
        Optional. Kind of a Kubernetes resource, must be in UpperCamelCase (PascalCase) and singular form. E.g. "CustomResourceDefinition", "StorageClass", etc.
        """
        return pulumi.get(self, "resource_kind")


@pulumi.output_type
class NamespacedNameResponse(dict):
    """
    A reference to a namespaced resource in Kubernetes.
    """
    def __init__(__self__, *,
                 name: str,
                 namespace: str):
        """
        A reference to a namespaced resource in Kubernetes.
        :param str name: Optional. The name of the Kubernetes resource.
        :param str namespace: Optional. The Namespace of the Kubernetes resource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Optional. The name of the Kubernetes resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Optional. The Namespace of the Kubernetes resource.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class NamespacedNamesResponse(dict):
    """
    A list of namespaced Kubernetes resources.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespacedNames":
            suggest = "namespaced_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespacedNamesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespacedNamesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespacedNamesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 namespaced_names: Sequence['outputs.NamespacedNameResponse']):
        """
        A list of namespaced Kubernetes resources.
        :param Sequence['NamespacedNameResponse'] namespaced_names: Optional. A list of namespaced Kubernetes resources.
        """
        pulumi.set(__self__, "namespaced_names", namespaced_names)

    @property
    @pulumi.getter(name="namespacedNames")
    def namespaced_names(self) -> Sequence['outputs.NamespacedNameResponse']:
        """
        Optional. A list of namespaced Kubernetes resources.
        """
        return pulumi.get(self, "namespaced_names")


@pulumi.output_type
class NamespacesResponse(dict):
    """
    A list of Kubernetes Namespaces
    """
    def __init__(__self__, *,
                 namespaces: Sequence[str]):
        """
        A list of Kubernetes Namespaces
        :param Sequence[str] namespaces: Optional. A list of Kubernetes Namespaces
        """
        pulumi.set(__self__, "namespaces", namespaces)

    @property
    @pulumi.getter
    def namespaces(self) -> Sequence[str]:
        """
        Optional. A list of Kubernetes Namespaces
        """
        return pulumi.get(self, "namespaces")


@pulumi.output_type
class ResourceFilterResponse(dict):
    """
    ResourceFilter specifies matching criteria to limit the scope of a change to a specific set of kubernetes resources that are selected for restoration from a backup.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupKinds":
            suggest = "group_kinds"
        elif key == "jsonPath":
            suggest = "json_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_kinds: Sequence['outputs.GroupKindResponse'],
                 json_path: str,
                 namespaces: Sequence[str]):
        """
        ResourceFilter specifies matching criteria to limit the scope of a change to a specific set of kubernetes resources that are selected for restoration from a backup.
        :param Sequence['GroupKindResponse'] group_kinds: Optional. (Filtering parameter) Any resource subject to transformation must belong to one of the listed "types". If this field is not provided, no type filtering will be performed (all resources of all types matching previous filtering parameters will be candidates for transformation).
        :param str json_path: Optional. This is a [JSONPath] (https://github.com/json-path/JsonPath/blob/master/README.md) expression that matches specific fields of candidate resources and it operates as a filtering parameter (resources that are not matched with this expression will not be candidates for transformation).
        :param Sequence[str] namespaces: Optional. (Filtering parameter) Any resource subject to transformation must be contained within one of the listed Kubernetes Namespace in the Backup. If this field is not provided, no namespace filtering will be performed (all resources in all Namespaces, including all cluster-scoped resources, will be candidates for transformation).
        """
        pulumi.set(__self__, "group_kinds", group_kinds)
        pulumi.set(__self__, "json_path", json_path)
        pulumi.set(__self__, "namespaces", namespaces)

    @property
    @pulumi.getter(name="groupKinds")
    def group_kinds(self) -> Sequence['outputs.GroupKindResponse']:
        """
        Optional. (Filtering parameter) Any resource subject to transformation must belong to one of the listed "types". If this field is not provided, no type filtering will be performed (all resources of all types matching previous filtering parameters will be candidates for transformation).
        """
        return pulumi.get(self, "group_kinds")

    @property
    @pulumi.getter(name="jsonPath")
    def json_path(self) -> str:
        """
        Optional. This is a [JSONPath] (https://github.com/json-path/JsonPath/blob/master/README.md) expression that matches specific fields of candidate resources and it operates as a filtering parameter (resources that are not matched with this expression will not be candidates for transformation).
        """
        return pulumi.get(self, "json_path")

    @property
    @pulumi.getter
    def namespaces(self) -> Sequence[str]:
        """
        Optional. (Filtering parameter) Any resource subject to transformation must be contained within one of the listed Kubernetes Namespace in the Backup. If this field is not provided, no namespace filtering will be performed (all resources in all Namespaces, including all cluster-scoped resources, will be candidates for transformation).
        """
        return pulumi.get(self, "namespaces")


@pulumi.output_type
class RestoreConfigResponse(dict):
    """
    Configuration of a restore. Next id: 13
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allNamespaces":
            suggest = "all_namespaces"
        elif key == "clusterResourceConflictPolicy":
            suggest = "cluster_resource_conflict_policy"
        elif key == "clusterResourceRestoreScope":
            suggest = "cluster_resource_restore_scope"
        elif key == "excludedNamespaces":
            suggest = "excluded_namespaces"
        elif key == "namespacedResourceRestoreMode":
            suggest = "namespaced_resource_restore_mode"
        elif key == "noNamespaces":
            suggest = "no_namespaces"
        elif key == "selectedApplications":
            suggest = "selected_applications"
        elif key == "selectedNamespaces":
            suggest = "selected_namespaces"
        elif key == "substitutionRules":
            suggest = "substitution_rules"
        elif key == "transformationRules":
            suggest = "transformation_rules"
        elif key == "volumeDataRestorePolicy":
            suggest = "volume_data_restore_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RestoreConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RestoreConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RestoreConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_namespaces: bool,
                 cluster_resource_conflict_policy: str,
                 cluster_resource_restore_scope: 'outputs.ClusterResourceRestoreScopeResponse',
                 excluded_namespaces: 'outputs.NamespacesResponse',
                 namespaced_resource_restore_mode: str,
                 no_namespaces: bool,
                 selected_applications: 'outputs.NamespacedNamesResponse',
                 selected_namespaces: 'outputs.NamespacesResponse',
                 substitution_rules: Sequence['outputs.SubstitutionRuleResponse'],
                 transformation_rules: Sequence['outputs.TransformationRuleResponse'],
                 volume_data_restore_policy: str):
        """
        Configuration of a restore. Next id: 13
        :param bool all_namespaces: Restore all namespaced resources in the Backup if set to "True". Specifying this field to "False" is an error.
        :param str cluster_resource_conflict_policy: Optional. Defines the behavior for handling the situation where cluster-scoped resources being restored already exist in the target cluster. This MUST be set to a value other than CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED if cluster_resource_restore_scope is not empty.
        :param 'ClusterResourceRestoreScopeResponse' cluster_resource_restore_scope: Optional. Identifies the cluster-scoped resources to restore from the Backup. Not specifying it means NO cluster resource will be restored.
        :param 'NamespacesResponse' excluded_namespaces: A list of selected namespaces excluded from restoration. All namespaces except those in this list will be restored.
        :param str namespaced_resource_restore_mode: Optional. Defines the behavior for handling the situation where sets of namespaced resources being restored already exist in the target cluster. This MUST be set to a value other than NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED.
        :param bool no_namespaces: Do not restore any namespaced resources if set to "True". Specifying this field to "False" is not allowed.
        :param 'NamespacedNamesResponse' selected_applications: A list of selected ProtectedApplications to restore. The listed ProtectedApplications and all the resources to which they refer will be restored.
        :param 'NamespacesResponse' selected_namespaces: A list of selected Namespaces to restore from the Backup. The listed Namespaces and all resources contained in them will be restored.
        :param Sequence['SubstitutionRuleResponse'] substitution_rules: Optional. A list of transformation rules to be applied against Kubernetes resources as they are selected for restoration from a Backup. Rules are executed in order defined - this order matters, as changes made by a rule may impact the filtering logic of subsequent rules. An empty list means no substitution will occur.
        :param Sequence['TransformationRuleResponse'] transformation_rules: Optional. A list of transformation rules to be applied against Kubernetes resources as they are selected for restoration from a Backup. Rules are executed in order defined - this order matters, as changes made by a rule may impact the filtering logic of subsequent rules. An empty list means no transformation will occur.
        :param str volume_data_restore_policy: Optional. Specifies the mechanism to be used to restore volume data. Default: VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED (will be treated as NO_VOLUME_DATA_RESTORATION).
        """
        pulumi.set(__self__, "all_namespaces", all_namespaces)
        pulumi.set(__self__, "cluster_resource_conflict_policy", cluster_resource_conflict_policy)
        pulumi.set(__self__, "cluster_resource_restore_scope", cluster_resource_restore_scope)
        pulumi.set(__self__, "excluded_namespaces", excluded_namespaces)
        pulumi.set(__self__, "namespaced_resource_restore_mode", namespaced_resource_restore_mode)
        pulumi.set(__self__, "no_namespaces", no_namespaces)
        pulumi.set(__self__, "selected_applications", selected_applications)
        pulumi.set(__self__, "selected_namespaces", selected_namespaces)
        pulumi.set(__self__, "substitution_rules", substitution_rules)
        pulumi.set(__self__, "transformation_rules", transformation_rules)
        pulumi.set(__self__, "volume_data_restore_policy", volume_data_restore_policy)

    @property
    @pulumi.getter(name="allNamespaces")
    def all_namespaces(self) -> bool:
        """
        Restore all namespaced resources in the Backup if set to "True". Specifying this field to "False" is an error.
        """
        return pulumi.get(self, "all_namespaces")

    @property
    @pulumi.getter(name="clusterResourceConflictPolicy")
    def cluster_resource_conflict_policy(self) -> str:
        """
        Optional. Defines the behavior for handling the situation where cluster-scoped resources being restored already exist in the target cluster. This MUST be set to a value other than CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED if cluster_resource_restore_scope is not empty.
        """
        return pulumi.get(self, "cluster_resource_conflict_policy")

    @property
    @pulumi.getter(name="clusterResourceRestoreScope")
    def cluster_resource_restore_scope(self) -> 'outputs.ClusterResourceRestoreScopeResponse':
        """
        Optional. Identifies the cluster-scoped resources to restore from the Backup. Not specifying it means NO cluster resource will be restored.
        """
        return pulumi.get(self, "cluster_resource_restore_scope")

    @property
    @pulumi.getter(name="excludedNamespaces")
    def excluded_namespaces(self) -> 'outputs.NamespacesResponse':
        """
        A list of selected namespaces excluded from restoration. All namespaces except those in this list will be restored.
        """
        return pulumi.get(self, "excluded_namespaces")

    @property
    @pulumi.getter(name="namespacedResourceRestoreMode")
    def namespaced_resource_restore_mode(self) -> str:
        """
        Optional. Defines the behavior for handling the situation where sets of namespaced resources being restored already exist in the target cluster. This MUST be set to a value other than NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED.
        """
        return pulumi.get(self, "namespaced_resource_restore_mode")

    @property
    @pulumi.getter(name="noNamespaces")
    def no_namespaces(self) -> bool:
        """
        Do not restore any namespaced resources if set to "True". Specifying this field to "False" is not allowed.
        """
        return pulumi.get(self, "no_namespaces")

    @property
    @pulumi.getter(name="selectedApplications")
    def selected_applications(self) -> 'outputs.NamespacedNamesResponse':
        """
        A list of selected ProtectedApplications to restore. The listed ProtectedApplications and all the resources to which they refer will be restored.
        """
        return pulumi.get(self, "selected_applications")

    @property
    @pulumi.getter(name="selectedNamespaces")
    def selected_namespaces(self) -> 'outputs.NamespacesResponse':
        """
        A list of selected Namespaces to restore from the Backup. The listed Namespaces and all resources contained in them will be restored.
        """
        return pulumi.get(self, "selected_namespaces")

    @property
    @pulumi.getter(name="substitutionRules")
    def substitution_rules(self) -> Sequence['outputs.SubstitutionRuleResponse']:
        """
        Optional. A list of transformation rules to be applied against Kubernetes resources as they are selected for restoration from a Backup. Rules are executed in order defined - this order matters, as changes made by a rule may impact the filtering logic of subsequent rules. An empty list means no substitution will occur.
        """
        return pulumi.get(self, "substitution_rules")

    @property
    @pulumi.getter(name="transformationRules")
    def transformation_rules(self) -> Sequence['outputs.TransformationRuleResponse']:
        """
        Optional. A list of transformation rules to be applied against Kubernetes resources as they are selected for restoration from a Backup. Rules are executed in order defined - this order matters, as changes made by a rule may impact the filtering logic of subsequent rules. An empty list means no transformation will occur.
        """
        return pulumi.get(self, "transformation_rules")

    @property
    @pulumi.getter(name="volumeDataRestorePolicy")
    def volume_data_restore_policy(self) -> str:
        """
        Optional. Specifies the mechanism to be used to restore volume data. Default: VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED (will be treated as NO_VOLUME_DATA_RESTORATION).
        """
        return pulumi.get(self, "volume_data_restore_policy")


@pulumi.output_type
class RetentionPolicyResponse(dict):
    """
    RetentionPolicy defines a Backup retention policy for a BackupPlan.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupDeleteLockDays":
            suggest = "backup_delete_lock_days"
        elif key == "backupRetainDays":
            suggest = "backup_retain_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RetentionPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RetentionPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RetentionPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_delete_lock_days: int,
                 backup_retain_days: int,
                 locked: bool):
        """
        RetentionPolicy defines a Backup retention policy for a BackupPlan.
        :param int backup_delete_lock_days: Optional. Minimum age for Backups created via this BackupPlan (in days). This field MUST be an integer value between 0-90 (inclusive). A Backup created under this BackupPlan will NOT be deletable until it reaches Backup's (create_time + backup_delete_lock_days). Updating this field of a BackupPlan does NOT affect existing Backups under it. Backups created AFTER a successful update will inherit the new value. Default: 0 (no delete blocking)
        :param int backup_retain_days: Optional. The default maximum age of a Backup created via this BackupPlan. This field MUST be an integer value >= 0 and <= 365. If specified, a Backup created under this BackupPlan will be automatically deleted after its age reaches (create_time + backup_retain_days). If not specified, Backups created under this BackupPlan will NOT be subject to automatic deletion. Updating this field does NOT affect existing Backups under it. Backups created AFTER a successful update will automatically pick up the new value. NOTE: backup_retain_days must be >= backup_delete_lock_days. If cron_schedule is defined, then this must be <= 360 * the creation interval. If rpo_config is defined, then this must be <= 360 * target_rpo_minutes / (1440minutes/day). Default: 0 (no automatic deletion)
        :param bool locked: Optional. This flag denotes whether the retention policy of this BackupPlan is locked. If set to True, no further update is allowed on this policy, including the `locked` field itself. Default: False
        """
        pulumi.set(__self__, "backup_delete_lock_days", backup_delete_lock_days)
        pulumi.set(__self__, "backup_retain_days", backup_retain_days)
        pulumi.set(__self__, "locked", locked)

    @property
    @pulumi.getter(name="backupDeleteLockDays")
    def backup_delete_lock_days(self) -> int:
        """
        Optional. Minimum age for Backups created via this BackupPlan (in days). This field MUST be an integer value between 0-90 (inclusive). A Backup created under this BackupPlan will NOT be deletable until it reaches Backup's (create_time + backup_delete_lock_days). Updating this field of a BackupPlan does NOT affect existing Backups under it. Backups created AFTER a successful update will inherit the new value. Default: 0 (no delete blocking)
        """
        return pulumi.get(self, "backup_delete_lock_days")

    @property
    @pulumi.getter(name="backupRetainDays")
    def backup_retain_days(self) -> int:
        """
        Optional. The default maximum age of a Backup created via this BackupPlan. This field MUST be an integer value >= 0 and <= 365. If specified, a Backup created under this BackupPlan will be automatically deleted after its age reaches (create_time + backup_retain_days). If not specified, Backups created under this BackupPlan will NOT be subject to automatic deletion. Updating this field does NOT affect existing Backups under it. Backups created AFTER a successful update will automatically pick up the new value. NOTE: backup_retain_days must be >= backup_delete_lock_days. If cron_schedule is defined, then this must be <= 360 * the creation interval. If rpo_config is defined, then this must be <= 360 * target_rpo_minutes / (1440minutes/day). Default: 0 (no automatic deletion)
        """
        return pulumi.get(self, "backup_retain_days")

    @property
    @pulumi.getter
    def locked(self) -> bool:
        """
        Optional. This flag denotes whether the retention policy of this BackupPlan is locked. If set to True, no further update is allowed on this policy, including the `locked` field itself. Default: False
        """
        return pulumi.get(self, "locked")


@pulumi.output_type
class ScheduleResponse(dict):
    """
    Defines scheduling parameters for automatically creating Backups via this BackupPlan.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronSchedule":
            suggest = "cron_schedule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_schedule: str,
                 paused: bool):
        """
        Defines scheduling parameters for automatically creating Backups via this BackupPlan.
        :param str cron_schedule: Optional. A standard [cron](https://wikipedia.com/wiki/cron) string that defines a repeating schedule for creating Backups via this BackupPlan. This is mutually exclusive with the rpo_config field since at most one schedule can be defined for a BackupPlan. If this is defined, then backup_retain_days must also be defined. Default (empty): no automatic backup creation will occur.
        :param bool paused: Optional. This flag denotes whether automatic Backup creation is paused for this BackupPlan. Default: False
        """
        pulumi.set(__self__, "cron_schedule", cron_schedule)
        pulumi.set(__self__, "paused", paused)

    @property
    @pulumi.getter(name="cronSchedule")
    def cron_schedule(self) -> str:
        """
        Optional. A standard [cron](https://wikipedia.com/wiki/cron) string that defines a repeating schedule for creating Backups via this BackupPlan. This is mutually exclusive with the rpo_config field since at most one schedule can be defined for a BackupPlan. If this is defined, then backup_retain_days must also be defined. Default (empty): no automatic backup creation will occur.
        """
        return pulumi.get(self, "cron_schedule")

    @property
    @pulumi.getter
    def paused(self) -> bool:
        """
        Optional. This flag denotes whether automatic Backup creation is paused for this BackupPlan. Default: False
        """
        return pulumi.get(self, "paused")


@pulumi.output_type
class SubstitutionRuleResponse(dict):
    """
    A transformation rule to be applied against Kubernetes resources as they are selected for restoration from a Backup. A rule contains both filtering logic (which resources are subject to substitution) and substitution logic.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "newValue":
            suggest = "new_value"
        elif key == "originalValuePattern":
            suggest = "original_value_pattern"
        elif key == "targetGroupKinds":
            suggest = "target_group_kinds"
        elif key == "targetJsonPath":
            suggest = "target_json_path"
        elif key == "targetNamespaces":
            suggest = "target_namespaces"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubstitutionRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubstitutionRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubstitutionRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 new_value: str,
                 original_value_pattern: str,
                 target_group_kinds: Sequence['outputs.GroupKindResponse'],
                 target_json_path: str,
                 target_namespaces: Sequence[str]):
        """
        A transformation rule to be applied against Kubernetes resources as they are selected for restoration from a Backup. A rule contains both filtering logic (which resources are subject to substitution) and substitution logic.
        :param str new_value: Optional. This is the new value to set for any fields that pass the filtering and selection criteria. To remove a value from a Kubernetes resource, either leave this field unspecified, or set it to the empty string ("").
        :param str original_value_pattern: Optional. (Filtering parameter) This is a [regular expression] (https://en.wikipedia.org/wiki/Regular_expression) that is compared against the fields matched by the target_json_path expression (and must also have passed the previous filters). Substitution will not be performed against fields whose value does not match this expression. If this field is NOT specified, then ALL fields matched by the target_json_path expression will undergo substitution. Note that an empty (e.g., "", rather than unspecified) value for this field will only match empty fields.
        :param Sequence['GroupKindResponse'] target_group_kinds: Optional. (Filtering parameter) Any resource subject to substitution must belong to one of the listed "types". If this field is not provided, no type filtering will be performed (all resources of all types matching previous filtering parameters will be candidates for substitution).
        :param str target_json_path: This is a [JSONPath] (https://kubernetes.io/docs/reference/kubectl/jsonpath/) expression that matches specific fields of candidate resources and it operates as both a filtering parameter (resources that are not matched with this expression will not be candidates for substitution) as well as a field identifier (identifies exactly which fields out of the candidate resources will be modified).
        :param Sequence[str] target_namespaces: Optional. (Filtering parameter) Any resource subject to substitution must be contained within one of the listed Kubernetes Namespace in the Backup. If this field is not provided, no namespace filtering will be performed (all resources in all Namespaces, including all cluster-scoped resources, will be candidates for substitution). To mix cluster-scoped and namespaced resources in the same rule, use an empty string ("") as one of the target namespaces.
        """
        pulumi.set(__self__, "new_value", new_value)
        pulumi.set(__self__, "original_value_pattern", original_value_pattern)
        pulumi.set(__self__, "target_group_kinds", target_group_kinds)
        pulumi.set(__self__, "target_json_path", target_json_path)
        pulumi.set(__self__, "target_namespaces", target_namespaces)

    @property
    @pulumi.getter(name="newValue")
    def new_value(self) -> str:
        """
        Optional. This is the new value to set for any fields that pass the filtering and selection criteria. To remove a value from a Kubernetes resource, either leave this field unspecified, or set it to the empty string ("").
        """
        return pulumi.get(self, "new_value")

    @property
    @pulumi.getter(name="originalValuePattern")
    def original_value_pattern(self) -> str:
        """
        Optional. (Filtering parameter) This is a [regular expression] (https://en.wikipedia.org/wiki/Regular_expression) that is compared against the fields matched by the target_json_path expression (and must also have passed the previous filters). Substitution will not be performed against fields whose value does not match this expression. If this field is NOT specified, then ALL fields matched by the target_json_path expression will undergo substitution. Note that an empty (e.g., "", rather than unspecified) value for this field will only match empty fields.
        """
        return pulumi.get(self, "original_value_pattern")

    @property
    @pulumi.getter(name="targetGroupKinds")
    def target_group_kinds(self) -> Sequence['outputs.GroupKindResponse']:
        """
        Optional. (Filtering parameter) Any resource subject to substitution must belong to one of the listed "types". If this field is not provided, no type filtering will be performed (all resources of all types matching previous filtering parameters will be candidates for substitution).
        """
        return pulumi.get(self, "target_group_kinds")

    @property
    @pulumi.getter(name="targetJsonPath")
    def target_json_path(self) -> str:
        """
        This is a [JSONPath] (https://kubernetes.io/docs/reference/kubectl/jsonpath/) expression that matches specific fields of candidate resources and it operates as both a filtering parameter (resources that are not matched with this expression will not be candidates for substitution) as well as a field identifier (identifies exactly which fields out of the candidate resources will be modified).
        """
        return pulumi.get(self, "target_json_path")

    @property
    @pulumi.getter(name="targetNamespaces")
    def target_namespaces(self) -> Sequence[str]:
        """
        Optional. (Filtering parameter) Any resource subject to substitution must be contained within one of the listed Kubernetes Namespace in the Backup. If this field is not provided, no namespace filtering will be performed (all resources in all Namespaces, including all cluster-scoped resources, will be candidates for substitution). To mix cluster-scoped and namespaced resources in the same rule, use an empty string ("") as one of the target namespaces.
        """
        return pulumi.get(self, "target_namespaces")


@pulumi.output_type
class TransformationRuleActionResponse(dict):
    """
    TransformationRuleAction defines a TransformationRule action based on the JSON Patch RFC (https://www.rfc-editor.org/rfc/rfc6902)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPath":
            suggest = "from_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransformationRuleActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransformationRuleActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransformationRuleActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_path: str,
                 op: str,
                 path: str,
                 value: str):
        """
        TransformationRuleAction defines a TransformationRule action based on the JSON Patch RFC (https://www.rfc-editor.org/rfc/rfc6902)
        :param str from_path: Optional. A string containing a JSON Pointer value that references the location in the target document to move the value from.
        :param str op: op specifies the operation to perform.
        :param str path: Optional. A string containing a JSON-Pointer value that references a location within the target document where the operation is performed.
        :param str value: Optional. A string that specifies the desired value in string format to use for transformation.
        """
        pulumi.set(__self__, "from_path", from_path)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="fromPath")
    def from_path(self) -> str:
        """
        Optional. A string containing a JSON Pointer value that references the location in the target document to move the value from.
        """
        return pulumi.get(self, "from_path")

    @property
    @pulumi.getter
    def op(self) -> str:
        """
        op specifies the operation to perform.
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Optional. A string containing a JSON-Pointer value that references a location within the target document where the operation is performed.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Optional. A string that specifies the desired value in string format to use for transformation.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TransformationRuleResponse(dict):
    """
    A transformation rule to be applied against Kubernetes resources as they are selected for restoration from a Backup. A rule contains both filtering logic (which resources are subject to transform) and transformation logic.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldActions":
            suggest = "field_actions"
        elif key == "resourceFilter":
            suggest = "resource_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransformationRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransformationRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransformationRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 field_actions: Sequence['outputs.TransformationRuleActionResponse'],
                 resource_filter: 'outputs.ResourceFilterResponse'):
        """
        A transformation rule to be applied against Kubernetes resources as they are selected for restoration from a Backup. A rule contains both filtering logic (which resources are subject to transform) and transformation logic.
        :param str description: Optional. The description is a user specified string description of the transformation rule.
        :param Sequence['TransformationRuleActionResponse'] field_actions: A list of transformation rule actions to take against candidate resources. Actions are executed in order defined - this order matters, as they could potentially interfere with each other and the first operation could affect the outcome of the second operation.
        :param 'ResourceFilterResponse' resource_filter: Optional. This field is used to specify a set of fields that should be used to determine which resources in backup should be acted upon by the supplied transformation rule actions, and this will ensure that only specific resources are affected by transformation rule actions.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "field_actions", field_actions)
        pulumi.set(__self__, "resource_filter", resource_filter)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Optional. The description is a user specified string description of the transformation rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="fieldActions")
    def field_actions(self) -> Sequence['outputs.TransformationRuleActionResponse']:
        """
        A list of transformation rule actions to take against candidate resources. Actions are executed in order defined - this order matters, as they could potentially interfere with each other and the first operation could affect the outcome of the second operation.
        """
        return pulumi.get(self, "field_actions")

    @property
    @pulumi.getter(name="resourceFilter")
    def resource_filter(self) -> 'outputs.ResourceFilterResponse':
        """
        Optional. This field is used to specify a set of fields that should be used to determine which resources in backup should be acted upon by the supplied transformation rule actions, and this will ensure that only specific resources are affected by transformation rule actions.
        """
        return pulumi.get(self, "resource_filter")


