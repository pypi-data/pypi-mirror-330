# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from ._enums import *

__all__ = [
    'AdvanceRolloutRuleArgs',
    'AnthosClusterArgs',
    'AuditConfigArgs',
    'AuditLogConfigArgs',
    'AutomationResourceSelectorArgs',
    'AutomationRuleArgs',
    'BindingArgs',
    'BuildArtifactArgs',
    'CanaryDeploymentArgs',
    'CanaryArgs',
    'CloudRunConfigArgs',
    'CloudRunLocationArgs',
    'CustomCanaryDeploymentArgs',
    'DefaultPoolArgs',
    'DeployParametersArgs',
    'ExecutionConfigArgs',
    'ExprArgs',
    'GatewayServiceMeshArgs',
    'GkeClusterArgs',
    'KubernetesConfigArgs',
    'MultiTargetArgs',
    'PhaseConfigArgs',
    'PostdeployArgs',
    'PredeployArgs',
    'PrivatePoolArgs',
    'PromoteReleaseRuleArgs',
    'RepairModeArgs',
    'RepairRolloutRuleArgs',
    'RetryArgs',
    'RollbackArgs',
    'RuntimeConfigArgs',
    'SerialPipelineArgs',
    'ServiceNetworkingArgs',
    'StageArgs',
    'StandardArgs',
    'StrategyArgs',
    'TargetAttributeArgs',
]

@pulumi.input_type
class AdvanceRolloutRuleArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 source_phases: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 wait: Optional[pulumi.Input[str]] = None):
        """
        The `AdvanceRollout` automation rule will automatically advance a successful Rollout to the next phase.
        :param pulumi.Input[str] id: ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_phases: Optional. Proceeds only after phase name matched any one in the list. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
        :param pulumi.Input[str] wait: Optional. How long to wait after a rollout is finished.
        """
        pulumi.set(__self__, "id", id)
        if source_phases is not None:
            pulumi.set(__self__, "source_phases", source_phases)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="sourcePhases")
    def source_phases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. Proceeds only after phase name matched any one in the list. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
        """
        return pulumi.get(self, "source_phases")

    @source_phases.setter
    def source_phases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_phases", value)

    @property
    @pulumi.getter
    def wait(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. How long to wait after a rollout is finished.
        """
        return pulumi.get(self, "wait")

    @wait.setter
    def wait(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wait", value)


@pulumi.input_type
class AnthosClusterArgs:
    def __init__(__self__, *,
                 membership: Optional[pulumi.Input[str]] = None):
        """
        Information specifying an Anthos Cluster.
        :param pulumi.Input[str] membership: Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is `projects/{project}/locations/{location}/memberships/{membership_name}`.
        """
        if membership is not None:
            pulumi.set(__self__, "membership", membership)

    @property
    @pulumi.getter
    def membership(self) -> Optional[pulumi.Input[str]]:
        """
        Membership of the GKE Hub-registered cluster to which to apply the Skaffold configuration. Format is `projects/{project}/locations/{location}/memberships/{membership_name}`.
        """
        return pulumi.get(self, "membership")

    @membership.setter
    def membership(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "membership", value)


@pulumi.input_type
class AuditConfigArgs:
    def __init__(__self__, *,
                 audit_log_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AuditLogConfigArgs']]]] = None,
                 service: Optional[pulumi.Input[str]] = None):
        """
        Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts `jose@example.com` from DATA_READ logging, and `aliya@example.com` from DATA_WRITE logging.
        :param pulumi.Input[Sequence[pulumi.Input['AuditLogConfigArgs']]] audit_log_configs: The configuration for logging of each type of permission.
        :param pulumi.Input[str] service: Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
        """
        if audit_log_configs is not None:
            pulumi.set(__self__, "audit_log_configs", audit_log_configs)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter(name="auditLogConfigs")
    def audit_log_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuditLogConfigArgs']]]]:
        """
        The configuration for logging of each type of permission.
        """
        return pulumi.get(self, "audit_log_configs")

    @audit_log_configs.setter
    def audit_log_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuditLogConfigArgs']]]]):
        pulumi.set(self, "audit_log_configs", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)


@pulumi.input_type
class AuditLogConfigArgs:
    def __init__(__self__, *,
                 exempted_members: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 log_type: Optional[pulumi.Input['AuditLogConfigLogType']] = None):
        """
        Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exempted_members: Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
        :param pulumi.Input['AuditLogConfigLogType'] log_type: The log type that this config enables.
        """
        if exempted_members is not None:
            pulumi.set(__self__, "exempted_members", exempted_members)
        if log_type is not None:
            pulumi.set(__self__, "log_type", log_type)

    @property
    @pulumi.getter(name="exemptedMembers")
    def exempted_members(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
        """
        return pulumi.get(self, "exempted_members")

    @exempted_members.setter
    def exempted_members(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exempted_members", value)

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> Optional[pulumi.Input['AuditLogConfigLogType']]:
        """
        The log type that this config enables.
        """
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: Optional[pulumi.Input['AuditLogConfigLogType']]):
        pulumi.set(self, "log_type", value)


@pulumi.input_type
class AutomationResourceSelectorArgs:
    def __init__(__self__, *,
                 targets: Optional[pulumi.Input[Sequence[pulumi.Input['TargetAttributeArgs']]]] = None):
        """
        AutomationResourceSelector contains the information to select the resources to which an Automation is going to be applied.
        :param pulumi.Input[Sequence[pulumi.Input['TargetAttributeArgs']]] targets: Contains attributes about a target.
        """
        if targets is not None:
            pulumi.set(__self__, "targets", targets)

    @property
    @pulumi.getter
    def targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetAttributeArgs']]]]:
        """
        Contains attributes about a target.
        """
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetAttributeArgs']]]]):
        pulumi.set(self, "targets", value)


@pulumi.input_type
class AutomationRuleArgs:
    def __init__(__self__, *,
                 advance_rollout_rule: Optional[pulumi.Input['AdvanceRolloutRuleArgs']] = None,
                 promote_release_rule: Optional[pulumi.Input['PromoteReleaseRuleArgs']] = None,
                 repair_rollout_rule: Optional[pulumi.Input['RepairRolloutRuleArgs']] = None):
        """
        `AutomationRule` defines the automation activities.
        :param pulumi.Input['AdvanceRolloutRuleArgs'] advance_rollout_rule: Optional. The `AdvanceRolloutRule` will automatically advance a successful Rollout.
        :param pulumi.Input['PromoteReleaseRuleArgs'] promote_release_rule: Optional. `PromoteReleaseRule` will automatically promote a release from the current target to a specified target.
        :param pulumi.Input['RepairRolloutRuleArgs'] repair_rollout_rule: Optional. The `RepairRolloutRule` will automatically repair a failed rollout.
        """
        if advance_rollout_rule is not None:
            pulumi.set(__self__, "advance_rollout_rule", advance_rollout_rule)
        if promote_release_rule is not None:
            pulumi.set(__self__, "promote_release_rule", promote_release_rule)
        if repair_rollout_rule is not None:
            pulumi.set(__self__, "repair_rollout_rule", repair_rollout_rule)

    @property
    @pulumi.getter(name="advanceRolloutRule")
    def advance_rollout_rule(self) -> Optional[pulumi.Input['AdvanceRolloutRuleArgs']]:
        """
        Optional. The `AdvanceRolloutRule` will automatically advance a successful Rollout.
        """
        return pulumi.get(self, "advance_rollout_rule")

    @advance_rollout_rule.setter
    def advance_rollout_rule(self, value: Optional[pulumi.Input['AdvanceRolloutRuleArgs']]):
        pulumi.set(self, "advance_rollout_rule", value)

    @property
    @pulumi.getter(name="promoteReleaseRule")
    def promote_release_rule(self) -> Optional[pulumi.Input['PromoteReleaseRuleArgs']]:
        """
        Optional. `PromoteReleaseRule` will automatically promote a release from the current target to a specified target.
        """
        return pulumi.get(self, "promote_release_rule")

    @promote_release_rule.setter
    def promote_release_rule(self, value: Optional[pulumi.Input['PromoteReleaseRuleArgs']]):
        pulumi.set(self, "promote_release_rule", value)

    @property
    @pulumi.getter(name="repairRolloutRule")
    def repair_rollout_rule(self) -> Optional[pulumi.Input['RepairRolloutRuleArgs']]:
        """
        Optional. The `RepairRolloutRule` will automatically repair a failed rollout.
        """
        return pulumi.get(self, "repair_rollout_rule")

    @repair_rollout_rule.setter
    def repair_rollout_rule(self, value: Optional[pulumi.Input['RepairRolloutRuleArgs']]):
        pulumi.set(self, "repair_rollout_rule", value)


@pulumi.input_type
class BindingArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input['ExprArgs']] = None,
                 members: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 role: Optional[pulumi.Input[str]] = None):
        """
        Associates `members`, or principals, with a `role`.
        :param pulumi.Input['ExprArgs'] condition: The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] members: Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
        :param pulumi.Input[str] role: Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if members is not None:
            pulumi.set(__self__, "members", members)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['ExprArgs']]:
        """
        The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['ExprArgs']]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def members(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
        """
        return pulumi.get(self, "members")

    @members.setter
    def members(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "members", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)


@pulumi.input_type
class BuildArtifactArgs:
    def __init__(__self__, *,
                 image: Optional[pulumi.Input[str]] = None,
                 tag: Optional[pulumi.Input[str]] = None):
        """
        Description of an a image to use during Skaffold rendering.
        :param pulumi.Input[str] image: Image name in Skaffold configuration.
        :param pulumi.Input[str] tag: Image tag to use. This will generally be the full path to an image, such as "gcr.io/my-project/busybox:1.2.3" or "gcr.io/my-project/busybox@sha256:abc123".
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Image name in Skaffold configuration.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        """
        Image tag to use. This will generally be the full path to an image, such as "gcr.io/my-project/busybox:1.2.3" or "gcr.io/my-project/busybox@sha256:abc123".
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)


@pulumi.input_type
class CanaryDeploymentArgs:
    def __init__(__self__, *,
                 percentages: pulumi.Input[Sequence[pulumi.Input[int]]],
                 postdeploy: Optional[pulumi.Input['PostdeployArgs']] = None,
                 predeploy: Optional[pulumi.Input['PredeployArgs']] = None,
                 verify: Optional[pulumi.Input[bool]] = None):
        """
        CanaryDeployment represents the canary deployment configuration
        :param pulumi.Input[Sequence[pulumi.Input[int]]] percentages: The percentage based deployments that will occur as a part of a `Rollout`. List is expected in ascending order and each integer n is 0 <= n < 100.
        :param pulumi.Input['PostdeployArgs'] postdeploy: Optional. Configuration for the postdeploy job of the last phase. If this is not configured, there will be no postdeploy job for this phase.
        :param pulumi.Input['PredeployArgs'] predeploy: Optional. Configuration for the predeploy job of the first phase. If this is not configured, there will be no predeploy job for this phase.
        :param pulumi.Input[bool] verify: Whether to run verify tests after each percentage deployment.
        """
        pulumi.set(__self__, "percentages", percentages)
        if postdeploy is not None:
            pulumi.set(__self__, "postdeploy", postdeploy)
        if predeploy is not None:
            pulumi.set(__self__, "predeploy", predeploy)
        if verify is not None:
            pulumi.set(__self__, "verify", verify)

    @property
    @pulumi.getter
    def percentages(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        The percentage based deployments that will occur as a part of a `Rollout`. List is expected in ascending order and each integer n is 0 <= n < 100.
        """
        return pulumi.get(self, "percentages")

    @percentages.setter
    def percentages(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "percentages", value)

    @property
    @pulumi.getter
    def postdeploy(self) -> Optional[pulumi.Input['PostdeployArgs']]:
        """
        Optional. Configuration for the postdeploy job of the last phase. If this is not configured, there will be no postdeploy job for this phase.
        """
        return pulumi.get(self, "postdeploy")

    @postdeploy.setter
    def postdeploy(self, value: Optional[pulumi.Input['PostdeployArgs']]):
        pulumi.set(self, "postdeploy", value)

    @property
    @pulumi.getter
    def predeploy(self) -> Optional[pulumi.Input['PredeployArgs']]:
        """
        Optional. Configuration for the predeploy job of the first phase. If this is not configured, there will be no predeploy job for this phase.
        """
        return pulumi.get(self, "predeploy")

    @predeploy.setter
    def predeploy(self, value: Optional[pulumi.Input['PredeployArgs']]):
        pulumi.set(self, "predeploy", value)

    @property
    @pulumi.getter
    def verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to run verify tests after each percentage deployment.
        """
        return pulumi.get(self, "verify")

    @verify.setter
    def verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "verify", value)


@pulumi.input_type
class CanaryArgs:
    def __init__(__self__, *,
                 canary_deployment: Optional[pulumi.Input['CanaryDeploymentArgs']] = None,
                 custom_canary_deployment: Optional[pulumi.Input['CustomCanaryDeploymentArgs']] = None,
                 runtime_config: Optional[pulumi.Input['RuntimeConfigArgs']] = None):
        """
        Canary represents the canary deployment strategy.
        :param pulumi.Input['CanaryDeploymentArgs'] canary_deployment: Configures the progressive based deployment for a Target.
        :param pulumi.Input['CustomCanaryDeploymentArgs'] custom_canary_deployment: Configures the progressive based deployment for a Target, but allows customizing at the phase level where a phase represents each of the percentage deployments.
        :param pulumi.Input['RuntimeConfigArgs'] runtime_config: Optional. Runtime specific configurations for the deployment strategy. The runtime configuration is used to determine how Cloud Deploy will split traffic to enable a progressive deployment.
        """
        if canary_deployment is not None:
            pulumi.set(__self__, "canary_deployment", canary_deployment)
        if custom_canary_deployment is not None:
            pulumi.set(__self__, "custom_canary_deployment", custom_canary_deployment)
        if runtime_config is not None:
            pulumi.set(__self__, "runtime_config", runtime_config)

    @property
    @pulumi.getter(name="canaryDeployment")
    def canary_deployment(self) -> Optional[pulumi.Input['CanaryDeploymentArgs']]:
        """
        Configures the progressive based deployment for a Target.
        """
        return pulumi.get(self, "canary_deployment")

    @canary_deployment.setter
    def canary_deployment(self, value: Optional[pulumi.Input['CanaryDeploymentArgs']]):
        pulumi.set(self, "canary_deployment", value)

    @property
    @pulumi.getter(name="customCanaryDeployment")
    def custom_canary_deployment(self) -> Optional[pulumi.Input['CustomCanaryDeploymentArgs']]:
        """
        Configures the progressive based deployment for a Target, but allows customizing at the phase level where a phase represents each of the percentage deployments.
        """
        return pulumi.get(self, "custom_canary_deployment")

    @custom_canary_deployment.setter
    def custom_canary_deployment(self, value: Optional[pulumi.Input['CustomCanaryDeploymentArgs']]):
        pulumi.set(self, "custom_canary_deployment", value)

    @property
    @pulumi.getter(name="runtimeConfig")
    def runtime_config(self) -> Optional[pulumi.Input['RuntimeConfigArgs']]:
        """
        Optional. Runtime specific configurations for the deployment strategy. The runtime configuration is used to determine how Cloud Deploy will split traffic to enable a progressive deployment.
        """
        return pulumi.get(self, "runtime_config")

    @runtime_config.setter
    def runtime_config(self, value: Optional[pulumi.Input['RuntimeConfigArgs']]):
        pulumi.set(self, "runtime_config", value)


@pulumi.input_type
class CloudRunConfigArgs:
    def __init__(__self__, *,
                 automatic_traffic_control: Optional[pulumi.Input[bool]] = None):
        """
        CloudRunConfig contains the Cloud Run runtime configuration.
        :param pulumi.Input[bool] automatic_traffic_control: Whether Cloud Deploy should update the traffic stanza in a Cloud Run Service on the user's behalf to facilitate traffic splitting. This is required to be true for CanaryDeployments, but optional for CustomCanaryDeployments.
        """
        if automatic_traffic_control is not None:
            pulumi.set(__self__, "automatic_traffic_control", automatic_traffic_control)

    @property
    @pulumi.getter(name="automaticTrafficControl")
    def automatic_traffic_control(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether Cloud Deploy should update the traffic stanza in a Cloud Run Service on the user's behalf to facilitate traffic splitting. This is required to be true for CanaryDeployments, but optional for CustomCanaryDeployments.
        """
        return pulumi.get(self, "automatic_traffic_control")

    @automatic_traffic_control.setter
    def automatic_traffic_control(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "automatic_traffic_control", value)


@pulumi.input_type
class CloudRunLocationArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[str]):
        """
        Information specifying where to deploy a Cloud Run Service.
        :param pulumi.Input[str] location: The location for the Cloud Run Service. Format must be `projects/{project}/locations/{location}`.
        """
        pulumi.set(__self__, "location", location)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[str]:
        """
        The location for the Cloud Run Service. Format must be `projects/{project}/locations/{location}`.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[str]):
        pulumi.set(self, "location", value)


@pulumi.input_type
class CustomCanaryDeploymentArgs:
    def __init__(__self__, *,
                 phase_configs: pulumi.Input[Sequence[pulumi.Input['PhaseConfigArgs']]]):
        """
        CustomCanaryDeployment represents the custom canary deployment configuration.
        :param pulumi.Input[Sequence[pulumi.Input['PhaseConfigArgs']]] phase_configs: Configuration for each phase in the canary deployment in the order executed.
        """
        pulumi.set(__self__, "phase_configs", phase_configs)

    @property
    @pulumi.getter(name="phaseConfigs")
    def phase_configs(self) -> pulumi.Input[Sequence[pulumi.Input['PhaseConfigArgs']]]:
        """
        Configuration for each phase in the canary deployment in the order executed.
        """
        return pulumi.get(self, "phase_configs")

    @phase_configs.setter
    def phase_configs(self, value: pulumi.Input[Sequence[pulumi.Input['PhaseConfigArgs']]]):
        pulumi.set(self, "phase_configs", value)


@pulumi.input_type
class DefaultPoolArgs:
    def __init__(__self__, *,
                 artifact_storage: Optional[pulumi.Input[str]] = None,
                 service_account: Optional[pulumi.Input[str]] = None):
        """
        Execution using the default Cloud Build pool.
        :param pulumi.Input[str] artifact_storage: Optional. Cloud Storage location where execution outputs should be stored. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
        :param pulumi.Input[str] service_account: Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) will be used.
        """
        if artifact_storage is not None:
            pulumi.set(__self__, "artifact_storage", artifact_storage)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)

    @property
    @pulumi.getter(name="artifactStorage")
    def artifact_storage(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Cloud Storage location where execution outputs should be stored. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
        """
        return pulumi.get(self, "artifact_storage")

    @artifact_storage.setter
    def artifact_storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "artifact_storage", value)

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) will be used.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account", value)


@pulumi.input_type
class DeployParametersArgs:
    def __init__(__self__, *,
                 values: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 match_target_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        DeployParameters contains deploy parameters information.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] values: Values are deploy parameters in key-value pairs.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_target_labels: Optional. Deploy parameters are applied to targets with match labels. If unspecified, deploy parameters are applied to all targets (including child targets of a multi-target).
        """
        pulumi.set(__self__, "values", values)
        if match_target_labels is not None:
            pulumi.set(__self__, "match_target_labels", match_target_labels)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        Values are deploy parameters in key-value pairs.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="matchTargetLabels")
    def match_target_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Optional. Deploy parameters are applied to targets with match labels. If unspecified, deploy parameters are applied to all targets (including child targets of a multi-target).
        """
        return pulumi.get(self, "match_target_labels")

    @match_target_labels.setter
    def match_target_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_target_labels", value)


@pulumi.input_type
class ExecutionConfigArgs:
    def __init__(__self__, *,
                 usages: pulumi.Input[Sequence[pulumi.Input['ExecutionConfigUsagesItem']]],
                 artifact_storage: Optional[pulumi.Input[str]] = None,
                 default_pool: Optional[pulumi.Input['DefaultPoolArgs']] = None,
                 execution_timeout: Optional[pulumi.Input[str]] = None,
                 private_pool: Optional[pulumi.Input['PrivatePoolArgs']] = None,
                 service_account: Optional[pulumi.Input[str]] = None,
                 worker_pool: Optional[pulumi.Input[str]] = None):
        """
        Configuration of the environment to use when calling Skaffold.
        :param pulumi.Input[Sequence[pulumi.Input['ExecutionConfigUsagesItem']]] usages: Usages when this configuration should be applied.
        :param pulumi.Input[str] artifact_storage: Optional. Cloud Storage location in which to store execution outputs. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
        :param pulumi.Input['DefaultPoolArgs'] default_pool: Optional. Use default Cloud Build pool.
        :param pulumi.Input[str] execution_timeout: Optional. Execution timeout for a Cloud Build Execution. This must be between 10m and 24h in seconds format. If unspecified, a default timeout of 1h is used.
        :param pulumi.Input['PrivatePoolArgs'] private_pool: Optional. Use private Cloud Build pool.
        :param pulumi.Input[str] service_account: Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) is used.
        :param pulumi.Input[str] worker_pool: Optional. The resource name of the `WorkerPool`, with the format `projects/{project}/locations/{location}/workerPools/{worker_pool}`. If this optional field is unspecified, the default Cloud Build pool will be used.
        """
        pulumi.set(__self__, "usages", usages)
        if artifact_storage is not None:
            pulumi.set(__self__, "artifact_storage", artifact_storage)
        if default_pool is not None:
            pulumi.set(__self__, "default_pool", default_pool)
        if execution_timeout is not None:
            pulumi.set(__self__, "execution_timeout", execution_timeout)
        if private_pool is not None:
            pulumi.set(__self__, "private_pool", private_pool)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if worker_pool is not None:
            pulumi.set(__self__, "worker_pool", worker_pool)

    @property
    @pulumi.getter
    def usages(self) -> pulumi.Input[Sequence[pulumi.Input['ExecutionConfigUsagesItem']]]:
        """
        Usages when this configuration should be applied.
        """
        return pulumi.get(self, "usages")

    @usages.setter
    def usages(self, value: pulumi.Input[Sequence[pulumi.Input['ExecutionConfigUsagesItem']]]):
        pulumi.set(self, "usages", value)

    @property
    @pulumi.getter(name="artifactStorage")
    def artifact_storage(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Cloud Storage location in which to store execution outputs. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
        """
        return pulumi.get(self, "artifact_storage")

    @artifact_storage.setter
    def artifact_storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "artifact_storage", value)

    @property
    @pulumi.getter(name="defaultPool")
    def default_pool(self) -> Optional[pulumi.Input['DefaultPoolArgs']]:
        """
        Optional. Use default Cloud Build pool.
        """
        return pulumi.get(self, "default_pool")

    @default_pool.setter
    def default_pool(self, value: Optional[pulumi.Input['DefaultPoolArgs']]):
        pulumi.set(self, "default_pool", value)

    @property
    @pulumi.getter(name="executionTimeout")
    def execution_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Execution timeout for a Cloud Build Execution. This must be between 10m and 24h in seconds format. If unspecified, a default timeout of 1h is used.
        """
        return pulumi.get(self, "execution_timeout")

    @execution_timeout.setter
    def execution_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "execution_timeout", value)

    @property
    @pulumi.getter(name="privatePool")
    def private_pool(self) -> Optional[pulumi.Input['PrivatePoolArgs']]:
        """
        Optional. Use private Cloud Build pool.
        """
        return pulumi.get(self, "private_pool")

    @private_pool.setter
    def private_pool(self, value: Optional[pulumi.Input['PrivatePoolArgs']]):
        pulumi.set(self, "private_pool", value)

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) is used.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account", value)

    @property
    @pulumi.getter(name="workerPool")
    def worker_pool(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The resource name of the `WorkerPool`, with the format `projects/{project}/locations/{location}/workerPools/{worker_pool}`. If this optional field is unspecified, the default Cloud Build pool will be used.
        """
        return pulumi.get(self, "worker_pool")

    @worker_pool.setter
    def worker_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "worker_pool", value)


@pulumi.input_type
class ExprArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
        :param pulumi.Input[str] description: Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        :param pulumi.Input[str] expression: Textual representation of an expression in Common Expression Language syntax.
        :param pulumi.Input[str] location: Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
        :param pulumi.Input[str] title: Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class GatewayServiceMeshArgs:
    def __init__(__self__, *,
                 deployment: pulumi.Input[str],
                 http_route: pulumi.Input[str],
                 service: pulumi.Input[str],
                 route_update_wait_time: Optional[pulumi.Input[str]] = None):
        """
        Information about the Kubernetes Gateway API service mesh configuration.
        :param pulumi.Input[str] deployment: Name of the Kubernetes Deployment whose traffic is managed by the specified HTTPRoute and Service.
        :param pulumi.Input[str] http_route: Name of the Gateway API HTTPRoute.
        :param pulumi.Input[str] service: Name of the Kubernetes Service.
        :param pulumi.Input[str] route_update_wait_time: Optional. The time to wait for route updates to propagate. The maximum configurable time is 3 hours, in seconds format. If unspecified, there is no wait time.
        """
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "http_route", http_route)
        pulumi.set(__self__, "service", service)
        if route_update_wait_time is not None:
            pulumi.set(__self__, "route_update_wait_time", route_update_wait_time)

    @property
    @pulumi.getter
    def deployment(self) -> pulumi.Input[str]:
        """
        Name of the Kubernetes Deployment whose traffic is managed by the specified HTTPRoute and Service.
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: pulumi.Input[str]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter(name="httpRoute")
    def http_route(self) -> pulumi.Input[str]:
        """
        Name of the Gateway API HTTPRoute.
        """
        return pulumi.get(self, "http_route")

    @http_route.setter
    def http_route(self, value: pulumi.Input[str]):
        pulumi.set(self, "http_route", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        Name of the Kubernetes Service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="routeUpdateWaitTime")
    def route_update_wait_time(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The time to wait for route updates to propagate. The maximum configurable time is 3 hours, in seconds format. If unspecified, there is no wait time.
        """
        return pulumi.get(self, "route_update_wait_time")

    @route_update_wait_time.setter
    def route_update_wait_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_update_wait_time", value)


@pulumi.input_type
class GkeClusterArgs:
    def __init__(__self__, *,
                 cluster: Optional[pulumi.Input[str]] = None,
                 internal_ip: Optional[pulumi.Input[bool]] = None):
        """
        Information specifying a GKE Cluster.
        :param pulumi.Input[str] cluster: Information specifying a GKE Cluster. Format is `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`.
        :param pulumi.Input[bool] internal_ip: Optional. If true, `cluster` is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used. The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise. Only specify this option when `cluster` is a [private GKE cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
        """
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)

    @property
    @pulumi.getter
    def cluster(self) -> Optional[pulumi.Input[str]]:
        """
        Information specifying a GKE Cluster. Format is `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`.
        """
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster", value)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. If true, `cluster` is accessed using the private IP address of the control plane endpoint. Otherwise, the default IP address of the control plane endpoint is used. The default IP address is the private IP address for clusters with private control-plane endpoints and the public IP address otherwise. Only specify this option when `cluster` is a [private GKE cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
        """
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "internal_ip", value)


@pulumi.input_type
class KubernetesConfigArgs:
    def __init__(__self__, *,
                 gateway_service_mesh: Optional[pulumi.Input['GatewayServiceMeshArgs']] = None,
                 service_networking: Optional[pulumi.Input['ServiceNetworkingArgs']] = None):
        """
        KubernetesConfig contains the Kubernetes runtime configuration.
        :param pulumi.Input['GatewayServiceMeshArgs'] gateway_service_mesh: Kubernetes Gateway API service mesh configuration.
        :param pulumi.Input['ServiceNetworkingArgs'] service_networking: Kubernetes Service networking configuration.
        """
        if gateway_service_mesh is not None:
            pulumi.set(__self__, "gateway_service_mesh", gateway_service_mesh)
        if service_networking is not None:
            pulumi.set(__self__, "service_networking", service_networking)

    @property
    @pulumi.getter(name="gatewayServiceMesh")
    def gateway_service_mesh(self) -> Optional[pulumi.Input['GatewayServiceMeshArgs']]:
        """
        Kubernetes Gateway API service mesh configuration.
        """
        return pulumi.get(self, "gateway_service_mesh")

    @gateway_service_mesh.setter
    def gateway_service_mesh(self, value: Optional[pulumi.Input['GatewayServiceMeshArgs']]):
        pulumi.set(self, "gateway_service_mesh", value)

    @property
    @pulumi.getter(name="serviceNetworking")
    def service_networking(self) -> Optional[pulumi.Input['ServiceNetworkingArgs']]:
        """
        Kubernetes Service networking configuration.
        """
        return pulumi.get(self, "service_networking")

    @service_networking.setter
    def service_networking(self, value: Optional[pulumi.Input['ServiceNetworkingArgs']]):
        pulumi.set(self, "service_networking", value)


@pulumi.input_type
class MultiTargetArgs:
    def __init__(__self__, *,
                 target_ids: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Information specifying a multiTarget.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_ids: The target_ids of this multiTarget.
        """
        pulumi.set(__self__, "target_ids", target_ids)

    @property
    @pulumi.getter(name="targetIds")
    def target_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The target_ids of this multiTarget.
        """
        return pulumi.get(self, "target_ids")

    @target_ids.setter
    def target_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "target_ids", value)


@pulumi.input_type
class PhaseConfigArgs:
    def __init__(__self__, *,
                 percentage: pulumi.Input[int],
                 phase_id: pulumi.Input[str],
                 postdeploy: Optional[pulumi.Input['PostdeployArgs']] = None,
                 predeploy: Optional[pulumi.Input['PredeployArgs']] = None,
                 profiles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 verify: Optional[pulumi.Input[bool]] = None):
        """
        PhaseConfig represents the configuration for a phase in the custom canary deployment.
        :param pulumi.Input[int] percentage: Percentage deployment for the phase.
        :param pulumi.Input[str] phase_id: The ID to assign to the `Rollout` phase. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
        :param pulumi.Input['PostdeployArgs'] postdeploy: Optional. Configuration for the postdeploy job of this phase. If this is not configured, there will be no postdeploy job for this phase.
        :param pulumi.Input['PredeployArgs'] predeploy: Optional. Configuration for the predeploy job of this phase. If this is not configured, there will be no predeploy job for this phase.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] profiles: Skaffold profiles to use when rendering the manifest for this phase. These are in addition to the profiles list specified in the `DeliveryPipeline` stage.
        :param pulumi.Input[bool] verify: Whether to run verify tests after the deployment.
        """
        pulumi.set(__self__, "percentage", percentage)
        pulumi.set(__self__, "phase_id", phase_id)
        if postdeploy is not None:
            pulumi.set(__self__, "postdeploy", postdeploy)
        if predeploy is not None:
            pulumi.set(__self__, "predeploy", predeploy)
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)
        if verify is not None:
            pulumi.set(__self__, "verify", verify)

    @property
    @pulumi.getter
    def percentage(self) -> pulumi.Input[int]:
        """
        Percentage deployment for the phase.
        """
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: pulumi.Input[int]):
        pulumi.set(self, "percentage", value)

    @property
    @pulumi.getter(name="phaseId")
    def phase_id(self) -> pulumi.Input[str]:
        """
        The ID to assign to the `Rollout` phase. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
        """
        return pulumi.get(self, "phase_id")

    @phase_id.setter
    def phase_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "phase_id", value)

    @property
    @pulumi.getter
    def postdeploy(self) -> Optional[pulumi.Input['PostdeployArgs']]:
        """
        Optional. Configuration for the postdeploy job of this phase. If this is not configured, there will be no postdeploy job for this phase.
        """
        return pulumi.get(self, "postdeploy")

    @postdeploy.setter
    def postdeploy(self, value: Optional[pulumi.Input['PostdeployArgs']]):
        pulumi.set(self, "postdeploy", value)

    @property
    @pulumi.getter
    def predeploy(self) -> Optional[pulumi.Input['PredeployArgs']]:
        """
        Optional. Configuration for the predeploy job of this phase. If this is not configured, there will be no predeploy job for this phase.
        """
        return pulumi.get(self, "predeploy")

    @predeploy.setter
    def predeploy(self, value: Optional[pulumi.Input['PredeployArgs']]):
        pulumi.set(self, "predeploy", value)

    @property
    @pulumi.getter
    def profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Skaffold profiles to use when rendering the manifest for this phase. These are in addition to the profiles list specified in the `DeliveryPipeline` stage.
        """
        return pulumi.get(self, "profiles")

    @profiles.setter
    def profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "profiles", value)

    @property
    @pulumi.getter
    def verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to run verify tests after the deployment.
        """
        return pulumi.get(self, "verify")

    @verify.setter
    def verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "verify", value)


@pulumi.input_type
class PostdeployArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Postdeploy contains the postdeploy job configuration information.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Optional. A sequence of Skaffold custom actions to invoke during execution of the postdeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. A sequence of Skaffold custom actions to invoke during execution of the postdeploy job.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "actions", value)


@pulumi.input_type
class PredeployArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Predeploy contains the predeploy job configuration information.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Optional. A sequence of Skaffold custom actions to invoke during execution of the predeploy job.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. A sequence of Skaffold custom actions to invoke during execution of the predeploy job.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "actions", value)


@pulumi.input_type
class PrivatePoolArgs:
    def __init__(__self__, *,
                 worker_pool: pulumi.Input[str],
                 artifact_storage: Optional[pulumi.Input[str]] = None,
                 service_account: Optional[pulumi.Input[str]] = None):
        """
        Execution using a private Cloud Build pool.
        :param pulumi.Input[str] worker_pool: Resource name of the Cloud Build worker pool to use. The format is `projects/{project}/locations/{location}/workerPools/{pool}`.
        :param pulumi.Input[str] artifact_storage: Optional. Cloud Storage location where execution outputs should be stored. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
        :param pulumi.Input[str] service_account: Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) will be used.
        """
        pulumi.set(__self__, "worker_pool", worker_pool)
        if artifact_storage is not None:
            pulumi.set(__self__, "artifact_storage", artifact_storage)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)

    @property
    @pulumi.getter(name="workerPool")
    def worker_pool(self) -> pulumi.Input[str]:
        """
        Resource name of the Cloud Build worker pool to use. The format is `projects/{project}/locations/{location}/workerPools/{pool}`.
        """
        return pulumi.get(self, "worker_pool")

    @worker_pool.setter
    def worker_pool(self, value: pulumi.Input[str]):
        pulumi.set(self, "worker_pool", value)

    @property
    @pulumi.getter(name="artifactStorage")
    def artifact_storage(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Cloud Storage location where execution outputs should be stored. This can either be a bucket ("gs://my-bucket") or a path within a bucket ("gs://my-bucket/my-dir"). If unspecified, a default bucket located in the same region will be used.
        """
        return pulumi.get(self, "artifact_storage")

    @artifact_storage.setter
    def artifact_storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "artifact_storage", value)

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Google service account to use for execution. If unspecified, the project execution service account (-compute@developer.gserviceaccount.com) will be used.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account", value)


@pulumi.input_type
class PromoteReleaseRuleArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 destination_phase: Optional[pulumi.Input[str]] = None,
                 destination_target_id: Optional[pulumi.Input[str]] = None,
                 wait: Optional[pulumi.Input[str]] = None):
        """
        `PromoteRelease` rule will automatically promote a release from the current target to a specified target.
        :param pulumi.Input[str] id: ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        :param pulumi.Input[str] destination_phase: Optional. The starting phase of the rollout created by this operation. Default to the first phase.
        :param pulumi.Input[str] destination_target_id: Optional. The ID of the stage in the pipeline to which this `Release` is deploying. If unspecified, default it to the next stage in the promotion flow. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine if the target is one of the stages in the promotion sequence defined in the pipeline. * "@next", the next target in the promotion sequence.
        :param pulumi.Input[str] wait: Optional. How long the release need to be paused until being promoted to the next target.
        """
        pulumi.set(__self__, "id", id)
        if destination_phase is not None:
            pulumi.set(__self__, "destination_phase", destination_phase)
        if destination_target_id is not None:
            pulumi.set(__self__, "destination_target_id", destination_target_id)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="destinationPhase")
    def destination_phase(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The starting phase of the rollout created by this operation. Default to the first phase.
        """
        return pulumi.get(self, "destination_phase")

    @destination_phase.setter
    def destination_phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_phase", value)

    @property
    @pulumi.getter(name="destinationTargetId")
    def destination_target_id(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The ID of the stage in the pipeline to which this `Release` is deploying. If unspecified, default it to the next stage in the promotion flow. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine if the target is one of the stages in the promotion sequence defined in the pipeline. * "@next", the next target in the promotion sequence.
        """
        return pulumi.get(self, "destination_target_id")

    @destination_target_id.setter
    def destination_target_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_target_id", value)

    @property
    @pulumi.getter
    def wait(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. How long the release need to be paused until being promoted to the next target.
        """
        return pulumi.get(self, "wait")

    @wait.setter
    def wait(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wait", value)


@pulumi.input_type
class RepairModeArgs:
    def __init__(__self__, *,
                 retry: Optional[pulumi.Input['RetryArgs']] = None,
                 rollback: Optional[pulumi.Input['RollbackArgs']] = None):
        """
        Configuration of the repair action.
        :param pulumi.Input['RetryArgs'] retry: Optional. Retries a failed job.
        :param pulumi.Input['RollbackArgs'] rollback: Optional. Rolls back a `Rollout`.
        """
        if retry is not None:
            pulumi.set(__self__, "retry", retry)
        if rollback is not None:
            pulumi.set(__self__, "rollback", rollback)

    @property
    @pulumi.getter
    def retry(self) -> Optional[pulumi.Input['RetryArgs']]:
        """
        Optional. Retries a failed job.
        """
        return pulumi.get(self, "retry")

    @retry.setter
    def retry(self, value: Optional[pulumi.Input['RetryArgs']]):
        pulumi.set(self, "retry", value)

    @property
    @pulumi.getter
    def rollback(self) -> Optional[pulumi.Input['RollbackArgs']]:
        """
        Optional. Rolls back a `Rollout`.
        """
        return pulumi.get(self, "rollback")

    @rollback.setter
    def rollback(self, value: Optional[pulumi.Input['RollbackArgs']]):
        pulumi.set(self, "rollback", value)


@pulumi.input_type
class RepairRolloutRuleArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 repair_modes: pulumi.Input[Sequence[pulumi.Input['RepairModeArgs']]],
                 jobs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 source_phases: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The `RepairRolloutRule` automation rule will automatically repair a failed `Rollout`.
        :param pulumi.Input[str] id: ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        :param pulumi.Input[Sequence[pulumi.Input['RepairModeArgs']]] repair_modes: Defines the types of automatic repair actions for failed jobs.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jobs: Optional. Jobs to repair. Proceeds only after job name matched any one in the list, or for all jobs if unspecified or empty. The phase that includes the job must match the phase ID specified in `source_phase`. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_phases: Optional. Phases within which jobs are subject to automatic repair actions on failure. Proceeds only after phase name matched any one in the list, or for all phases if unspecified. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "repair_modes", repair_modes)
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if source_phases is not None:
            pulumi.set(__self__, "source_phases", source_phases)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the rule. This id must be unique in the `Automation` resource to which this rule belongs. The format is `a-z{0,62}`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="repairModes")
    def repair_modes(self) -> pulumi.Input[Sequence[pulumi.Input['RepairModeArgs']]]:
        """
        Defines the types of automatic repair actions for failed jobs.
        """
        return pulumi.get(self, "repair_modes")

    @repair_modes.setter
    def repair_modes(self, value: pulumi.Input[Sequence[pulumi.Input['RepairModeArgs']]]):
        pulumi.set(self, "repair_modes", value)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. Jobs to repair. Proceeds only after job name matched any one in the list, or for all jobs if unspecified or empty. The phase that includes the job must match the phase ID specified in `source_phase`. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
        """
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jobs", value)

    @property
    @pulumi.getter(name="sourcePhases")
    def source_phases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. Phases within which jobs are subject to automatic repair actions on failure. Proceeds only after phase name matched any one in the list, or for all phases if unspecified. This value must consist of lower-case letters, numbers, and hyphens, start with a letter and end with a letter or a number, and have a max length of 63 characters. In other words, it must match the following regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
        """
        return pulumi.get(self, "source_phases")

    @source_phases.setter
    def source_phases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_phases", value)


@pulumi.input_type
class RetryArgs:
    def __init__(__self__, *,
                 attempts: pulumi.Input[str],
                 backoff_mode: Optional[pulumi.Input['RetryBackoffMode']] = None,
                 wait: Optional[pulumi.Input[str]] = None):
        """
        Retries the failed job.
        :param pulumi.Input[str] attempts: Total number of retries. Retry will skipped if set to 0; The minimum value is 1, and the maximum value is 10.
        :param pulumi.Input['RetryBackoffMode'] backoff_mode: Optional. The pattern of how wait time will be increased. Default is linear. Backoff mode will be ignored if `wait` is 0.
        :param pulumi.Input[str] wait: Optional. How long to wait for the first retry. Default is 0, and the maximum value is 14d.
        """
        pulumi.set(__self__, "attempts", attempts)
        if backoff_mode is not None:
            pulumi.set(__self__, "backoff_mode", backoff_mode)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def attempts(self) -> pulumi.Input[str]:
        """
        Total number of retries. Retry will skipped if set to 0; The minimum value is 1, and the maximum value is 10.
        """
        return pulumi.get(self, "attempts")

    @attempts.setter
    def attempts(self, value: pulumi.Input[str]):
        pulumi.set(self, "attempts", value)

    @property
    @pulumi.getter(name="backoffMode")
    def backoff_mode(self) -> Optional[pulumi.Input['RetryBackoffMode']]:
        """
        Optional. The pattern of how wait time will be increased. Default is linear. Backoff mode will be ignored if `wait` is 0.
        """
        return pulumi.get(self, "backoff_mode")

    @backoff_mode.setter
    def backoff_mode(self, value: Optional[pulumi.Input['RetryBackoffMode']]):
        pulumi.set(self, "backoff_mode", value)

    @property
    @pulumi.getter
    def wait(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. How long to wait for the first retry. Default is 0, and the maximum value is 14d.
        """
        return pulumi.get(self, "wait")

    @wait.setter
    def wait(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wait", value)


@pulumi.input_type
class RollbackArgs:
    def __init__(__self__, *,
                 destination_phase: Optional[pulumi.Input[str]] = None):
        """
        Rolls back a `Rollout`.
        :param pulumi.Input[str] destination_phase: Optional. The starting phase ID for the `Rollout`. If unspecified, the `Rollout` will start in the stable phase.
        """
        if destination_phase is not None:
            pulumi.set(__self__, "destination_phase", destination_phase)

    @property
    @pulumi.getter(name="destinationPhase")
    def destination_phase(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The starting phase ID for the `Rollout`. If unspecified, the `Rollout` will start in the stable phase.
        """
        return pulumi.get(self, "destination_phase")

    @destination_phase.setter
    def destination_phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_phase", value)


@pulumi.input_type
class RuntimeConfigArgs:
    def __init__(__self__, *,
                 cloud_run: Optional[pulumi.Input['CloudRunConfigArgs']] = None,
                 kubernetes: Optional[pulumi.Input['KubernetesConfigArgs']] = None):
        """
        RuntimeConfig contains the runtime specific configurations for a deployment strategy.
        :param pulumi.Input['CloudRunConfigArgs'] cloud_run: Cloud Run runtime configuration.
        :param pulumi.Input['KubernetesConfigArgs'] kubernetes: Kubernetes runtime configuration.
        """
        if cloud_run is not None:
            pulumi.set(__self__, "cloud_run", cloud_run)
        if kubernetes is not None:
            pulumi.set(__self__, "kubernetes", kubernetes)

    @property
    @pulumi.getter(name="cloudRun")
    def cloud_run(self) -> Optional[pulumi.Input['CloudRunConfigArgs']]:
        """
        Cloud Run runtime configuration.
        """
        return pulumi.get(self, "cloud_run")

    @cloud_run.setter
    def cloud_run(self, value: Optional[pulumi.Input['CloudRunConfigArgs']]):
        pulumi.set(self, "cloud_run", value)

    @property
    @pulumi.getter
    def kubernetes(self) -> Optional[pulumi.Input['KubernetesConfigArgs']]:
        """
        Kubernetes runtime configuration.
        """
        return pulumi.get(self, "kubernetes")

    @kubernetes.setter
    def kubernetes(self, value: Optional[pulumi.Input['KubernetesConfigArgs']]):
        pulumi.set(self, "kubernetes", value)


@pulumi.input_type
class SerialPipelineArgs:
    def __init__(__self__, *,
                 stages: Optional[pulumi.Input[Sequence[pulumi.Input['StageArgs']]]] = None):
        """
        SerialPipeline defines a sequential set of stages for a `DeliveryPipeline`.
        :param pulumi.Input[Sequence[pulumi.Input['StageArgs']]] stages: Each stage specifies configuration for a `Target`. The ordering of this list defines the promotion flow.
        """
        if stages is not None:
            pulumi.set(__self__, "stages", stages)

    @property
    @pulumi.getter
    def stages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StageArgs']]]]:
        """
        Each stage specifies configuration for a `Target`. The ordering of this list defines the promotion flow.
        """
        return pulumi.get(self, "stages")

    @stages.setter
    def stages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StageArgs']]]]):
        pulumi.set(self, "stages", value)


@pulumi.input_type
class ServiceNetworkingArgs:
    def __init__(__self__, *,
                 deployment: pulumi.Input[str],
                 service: pulumi.Input[str],
                 disable_pod_overprovisioning: Optional[pulumi.Input[bool]] = None):
        """
        Information about the Kubernetes Service networking configuration.
        :param pulumi.Input[str] deployment: Name of the Kubernetes Deployment whose traffic is managed by the specified Service.
        :param pulumi.Input[str] service: Name of the Kubernetes Service.
        :param pulumi.Input[bool] disable_pod_overprovisioning: Optional. Whether to disable Pod overprovisioning. If Pod overprovisioning is disabled then Cloud Deploy will limit the number of total Pods used for the deployment strategy to the number of Pods the Deployment has on the cluster.
        """
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "service", service)
        if disable_pod_overprovisioning is not None:
            pulumi.set(__self__, "disable_pod_overprovisioning", disable_pod_overprovisioning)

    @property
    @pulumi.getter
    def deployment(self) -> pulumi.Input[str]:
        """
        Name of the Kubernetes Deployment whose traffic is managed by the specified Service.
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: pulumi.Input[str]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        Name of the Kubernetes Service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="disablePodOverprovisioning")
    def disable_pod_overprovisioning(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. Whether to disable Pod overprovisioning. If Pod overprovisioning is disabled then Cloud Deploy will limit the number of total Pods used for the deployment strategy to the number of Pods the Deployment has on the cluster.
        """
        return pulumi.get(self, "disable_pod_overprovisioning")

    @disable_pod_overprovisioning.setter
    def disable_pod_overprovisioning(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_pod_overprovisioning", value)


@pulumi.input_type
class StageArgs:
    def __init__(__self__, *,
                 deploy_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['DeployParametersArgs']]]] = None,
                 profiles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 strategy: Optional[pulumi.Input['StrategyArgs']] = None,
                 target_id: Optional[pulumi.Input[str]] = None):
        """
        Stage specifies a location to which to deploy.
        :param pulumi.Input[Sequence[pulumi.Input['DeployParametersArgs']]] deploy_parameters: Optional. The deploy parameters to use for the target in this stage.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] profiles: Skaffold profiles to use when rendering the manifest for this stage's `Target`.
        :param pulumi.Input['StrategyArgs'] strategy: Optional. The strategy to use for a `Rollout` to this stage.
        :param pulumi.Input[str] target_id: The target_id to which this stage points. This field refers exclusively to the last segment of a target name. For example, this field would just be `my-target` (rather than `projects/project/locations/location/targets/my-target`). The location of the `Target` is inferred to be the same as the location of the `DeliveryPipeline` that contains this `Stage`.
        """
        if deploy_parameters is not None:
            pulumi.set(__self__, "deploy_parameters", deploy_parameters)
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)
        if target_id is not None:
            pulumi.set(__self__, "target_id", target_id)

    @property
    @pulumi.getter(name="deployParameters")
    def deploy_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployParametersArgs']]]]:
        """
        Optional. The deploy parameters to use for the target in this stage.
        """
        return pulumi.get(self, "deploy_parameters")

    @deploy_parameters.setter
    def deploy_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployParametersArgs']]]]):
        pulumi.set(self, "deploy_parameters", value)

    @property
    @pulumi.getter
    def profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Skaffold profiles to use when rendering the manifest for this stage's `Target`.
        """
        return pulumi.get(self, "profiles")

    @profiles.setter
    def profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "profiles", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input['StrategyArgs']]:
        """
        Optional. The strategy to use for a `Rollout` to this stage.
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input['StrategyArgs']]):
        pulumi.set(self, "strategy", value)

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> Optional[pulumi.Input[str]]:
        """
        The target_id to which this stage points. This field refers exclusively to the last segment of a target name. For example, this field would just be `my-target` (rather than `projects/project/locations/location/targets/my-target`). The location of the `Target` is inferred to be the same as the location of the `DeliveryPipeline` that contains this `Stage`.
        """
        return pulumi.get(self, "target_id")

    @target_id.setter
    def target_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_id", value)


@pulumi.input_type
class StandardArgs:
    def __init__(__self__, *,
                 postdeploy: Optional[pulumi.Input['PostdeployArgs']] = None,
                 predeploy: Optional[pulumi.Input['PredeployArgs']] = None,
                 verify: Optional[pulumi.Input[bool]] = None):
        """
        Standard represents the standard deployment strategy.
        :param pulumi.Input['PostdeployArgs'] postdeploy: Optional. Configuration for the postdeploy job. If this is not configured, postdeploy job will not be present.
        :param pulumi.Input['PredeployArgs'] predeploy: Optional. Configuration for the predeploy job. If this is not configured, predeploy job will not be present.
        :param pulumi.Input[bool] verify: Whether to verify a deployment.
        """
        if postdeploy is not None:
            pulumi.set(__self__, "postdeploy", postdeploy)
        if predeploy is not None:
            pulumi.set(__self__, "predeploy", predeploy)
        if verify is not None:
            pulumi.set(__self__, "verify", verify)

    @property
    @pulumi.getter
    def postdeploy(self) -> Optional[pulumi.Input['PostdeployArgs']]:
        """
        Optional. Configuration for the postdeploy job. If this is not configured, postdeploy job will not be present.
        """
        return pulumi.get(self, "postdeploy")

    @postdeploy.setter
    def postdeploy(self, value: Optional[pulumi.Input['PostdeployArgs']]):
        pulumi.set(self, "postdeploy", value)

    @property
    @pulumi.getter
    def predeploy(self) -> Optional[pulumi.Input['PredeployArgs']]:
        """
        Optional. Configuration for the predeploy job. If this is not configured, predeploy job will not be present.
        """
        return pulumi.get(self, "predeploy")

    @predeploy.setter
    def predeploy(self, value: Optional[pulumi.Input['PredeployArgs']]):
        pulumi.set(self, "predeploy", value)

    @property
    @pulumi.getter
    def verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to verify a deployment.
        """
        return pulumi.get(self, "verify")

    @verify.setter
    def verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "verify", value)


@pulumi.input_type
class StrategyArgs:
    def __init__(__self__, *,
                 canary: Optional[pulumi.Input['CanaryArgs']] = None,
                 standard: Optional[pulumi.Input['StandardArgs']] = None):
        """
        Strategy contains deployment strategy information.
        :param pulumi.Input['CanaryArgs'] canary: Canary deployment strategy provides progressive percentage based deployments to a Target.
        :param pulumi.Input['StandardArgs'] standard: Standard deployment strategy executes a single deploy and allows verifying the deployment.
        """
        if canary is not None:
            pulumi.set(__self__, "canary", canary)
        if standard is not None:
            pulumi.set(__self__, "standard", standard)

    @property
    @pulumi.getter
    def canary(self) -> Optional[pulumi.Input['CanaryArgs']]:
        """
        Canary deployment strategy provides progressive percentage based deployments to a Target.
        """
        return pulumi.get(self, "canary")

    @canary.setter
    def canary(self, value: Optional[pulumi.Input['CanaryArgs']]):
        pulumi.set(self, "canary", value)

    @property
    @pulumi.getter
    def standard(self) -> Optional[pulumi.Input['StandardArgs']]:
        """
        Standard deployment strategy executes a single deploy and allows verifying the deployment.
        """
        return pulumi.get(self, "standard")

    @standard.setter
    def standard(self, value: Optional[pulumi.Input['StandardArgs']]):
        pulumi.set(self, "standard", value)


@pulumi.input_type
class TargetAttributeArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Contains criteria for selecting Targets. Attributes provided must match the target resource in order for policy restrictions to apply. E.g. if id "prod" and labels "foo: bar" are given the target resource must match both that id and have that label in order to be selected.
        :param pulumi.Input[str] id: ID of the `Target`. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine which target is being referred to * "*", all targets in a location.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Target labels.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the `Target`. The value of this field could be one of the following: * The last segment of a target name. It only needs the ID to determine which target is being referred to * "*", all targets in a location.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Target labels.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)


