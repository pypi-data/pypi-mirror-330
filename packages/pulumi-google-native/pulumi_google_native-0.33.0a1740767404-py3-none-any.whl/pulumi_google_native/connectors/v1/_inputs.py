# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from ._enums import *

__all__ = [
    'AuditConfigArgs',
    'AuditLogConfigArgs',
    'AuthConfigArgs',
    'BindingArgs',
    'ConfigVariableArgs',
    'ConnectorsLogConfigArgs',
    'DestinationConfigArgs',
    'DestinationArgs',
    'EncryptionKeyArgs',
    'EndPointArgs',
    'EventSubscriptionDestinationArgs',
    'EventingConfigArgs',
    'ExprArgs',
    'HeaderArgs',
    'JMSArgs',
    'JwtClaimsArgs',
    'LockConfigArgs',
    'NodeConfigArgs',
    'Oauth2AuthCodeFlowArgs',
    'Oauth2ClientCredentialsArgs',
    'Oauth2JwtBearerArgs',
    'SecretArgs',
    'SshPublicKeyArgs',
    'SslConfigArgs',
    'UserPasswordArgs',
]

@pulumi.input_type
class AuditConfigArgs:
    def __init__(__self__, *,
                 audit_log_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AuditLogConfigArgs']]]] = None,
                 service: Optional[pulumi.Input[str]] = None):
        """
        Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts `jose@example.com` from DATA_READ logging, and `aliya@example.com` from DATA_WRITE logging.
        :param pulumi.Input[Sequence[pulumi.Input['AuditLogConfigArgs']]] audit_log_configs: The configuration for logging of each type of permission.
        :param pulumi.Input[str] service: Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
        """
        if audit_log_configs is not None:
            pulumi.set(__self__, "audit_log_configs", audit_log_configs)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter(name="auditLogConfigs")
    def audit_log_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuditLogConfigArgs']]]]:
        """
        The configuration for logging of each type of permission.
        """
        return pulumi.get(self, "audit_log_configs")

    @audit_log_configs.setter
    def audit_log_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuditLogConfigArgs']]]]):
        pulumi.set(self, "audit_log_configs", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)


@pulumi.input_type
class AuditLogConfigArgs:
    def __init__(__self__, *,
                 exempted_members: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 log_type: Optional[pulumi.Input['AuditLogConfigLogType']] = None):
        """
        Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exempted_members: Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
        :param pulumi.Input['AuditLogConfigLogType'] log_type: The log type that this config enables.
        """
        if exempted_members is not None:
            pulumi.set(__self__, "exempted_members", exempted_members)
        if log_type is not None:
            pulumi.set(__self__, "log_type", log_type)

    @property
    @pulumi.getter(name="exemptedMembers")
    def exempted_members(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
        """
        return pulumi.get(self, "exempted_members")

    @exempted_members.setter
    def exempted_members(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exempted_members", value)

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> Optional[pulumi.Input['AuditLogConfigLogType']]:
        """
        The log type that this config enables.
        """
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: Optional[pulumi.Input['AuditLogConfigLogType']]):
        pulumi.set(self, "log_type", value)


@pulumi.input_type
class AuthConfigArgs:
    def __init__(__self__, *,
                 additional_variables: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigVariableArgs']]]] = None,
                 auth_key: Optional[pulumi.Input[str]] = None,
                 auth_type: Optional[pulumi.Input['AuthConfigAuthType']] = None,
                 oauth2_auth_code_flow: Optional[pulumi.Input['Oauth2AuthCodeFlowArgs']] = None,
                 oauth2_client_credentials: Optional[pulumi.Input['Oauth2ClientCredentialsArgs']] = None,
                 oauth2_jwt_bearer: Optional[pulumi.Input['Oauth2JwtBearerArgs']] = None,
                 ssh_public_key: Optional[pulumi.Input['SshPublicKeyArgs']] = None,
                 user_password: Optional[pulumi.Input['UserPasswordArgs']] = None):
        """
        AuthConfig defines details of a authentication type.
        :param pulumi.Input[Sequence[pulumi.Input['ConfigVariableArgs']]] additional_variables: List containing additional auth configs.
        :param pulumi.Input[str] auth_key: Identifier key for auth config
        :param pulumi.Input['AuthConfigAuthType'] auth_type: The type of authentication configured.
        :param pulumi.Input['Oauth2AuthCodeFlowArgs'] oauth2_auth_code_flow: Oauth2AuthCodeFlow.
        :param pulumi.Input['Oauth2ClientCredentialsArgs'] oauth2_client_credentials: Oauth2ClientCredentials.
        :param pulumi.Input['Oauth2JwtBearerArgs'] oauth2_jwt_bearer: Oauth2JwtBearer.
        :param pulumi.Input['SshPublicKeyArgs'] ssh_public_key: SSH Public Key.
        :param pulumi.Input['UserPasswordArgs'] user_password: UserPassword.
        """
        if additional_variables is not None:
            pulumi.set(__self__, "additional_variables", additional_variables)
        if auth_key is not None:
            pulumi.set(__self__, "auth_key", auth_key)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if oauth2_auth_code_flow is not None:
            pulumi.set(__self__, "oauth2_auth_code_flow", oauth2_auth_code_flow)
        if oauth2_client_credentials is not None:
            pulumi.set(__self__, "oauth2_client_credentials", oauth2_client_credentials)
        if oauth2_jwt_bearer is not None:
            pulumi.set(__self__, "oauth2_jwt_bearer", oauth2_jwt_bearer)
        if ssh_public_key is not None:
            pulumi.set(__self__, "ssh_public_key", ssh_public_key)
        if user_password is not None:
            pulumi.set(__self__, "user_password", user_password)

    @property
    @pulumi.getter(name="additionalVariables")
    def additional_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfigVariableArgs']]]]:
        """
        List containing additional auth configs.
        """
        return pulumi.get(self, "additional_variables")

    @additional_variables.setter
    def additional_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigVariableArgs']]]]):
        pulumi.set(self, "additional_variables", value)

    @property
    @pulumi.getter(name="authKey")
    def auth_key(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier key for auth config
        """
        return pulumi.get(self, "auth_key")

    @auth_key.setter
    def auth_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_key", value)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input['AuthConfigAuthType']]:
        """
        The type of authentication configured.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input['AuthConfigAuthType']]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="oauth2AuthCodeFlow")
    def oauth2_auth_code_flow(self) -> Optional[pulumi.Input['Oauth2AuthCodeFlowArgs']]:
        """
        Oauth2AuthCodeFlow.
        """
        return pulumi.get(self, "oauth2_auth_code_flow")

    @oauth2_auth_code_flow.setter
    def oauth2_auth_code_flow(self, value: Optional[pulumi.Input['Oauth2AuthCodeFlowArgs']]):
        pulumi.set(self, "oauth2_auth_code_flow", value)

    @property
    @pulumi.getter(name="oauth2ClientCredentials")
    def oauth2_client_credentials(self) -> Optional[pulumi.Input['Oauth2ClientCredentialsArgs']]:
        """
        Oauth2ClientCredentials.
        """
        return pulumi.get(self, "oauth2_client_credentials")

    @oauth2_client_credentials.setter
    def oauth2_client_credentials(self, value: Optional[pulumi.Input['Oauth2ClientCredentialsArgs']]):
        pulumi.set(self, "oauth2_client_credentials", value)

    @property
    @pulumi.getter(name="oauth2JwtBearer")
    def oauth2_jwt_bearer(self) -> Optional[pulumi.Input['Oauth2JwtBearerArgs']]:
        """
        Oauth2JwtBearer.
        """
        return pulumi.get(self, "oauth2_jwt_bearer")

    @oauth2_jwt_bearer.setter
    def oauth2_jwt_bearer(self, value: Optional[pulumi.Input['Oauth2JwtBearerArgs']]):
        pulumi.set(self, "oauth2_jwt_bearer", value)

    @property
    @pulumi.getter(name="sshPublicKey")
    def ssh_public_key(self) -> Optional[pulumi.Input['SshPublicKeyArgs']]:
        """
        SSH Public Key.
        """
        return pulumi.get(self, "ssh_public_key")

    @ssh_public_key.setter
    def ssh_public_key(self, value: Optional[pulumi.Input['SshPublicKeyArgs']]):
        pulumi.set(self, "ssh_public_key", value)

    @property
    @pulumi.getter(name="userPassword")
    def user_password(self) -> Optional[pulumi.Input['UserPasswordArgs']]:
        """
        UserPassword.
        """
        return pulumi.get(self, "user_password")

    @user_password.setter
    def user_password(self, value: Optional[pulumi.Input['UserPasswordArgs']]):
        pulumi.set(self, "user_password", value)


@pulumi.input_type
class BindingArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input['ExprArgs']] = None,
                 members: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 role: Optional[pulumi.Input[str]] = None):
        """
        Associates `members`, or principals, with a `role`.
        :param pulumi.Input['ExprArgs'] condition: The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] members: Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
        :param pulumi.Input[str] role: Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if members is not None:
            pulumi.set(__self__, "members", members)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['ExprArgs']]:
        """
        The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['ExprArgs']]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def members(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
        """
        return pulumi.get(self, "members")

    @members.setter
    def members(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "members", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)


@pulumi.input_type
class ConfigVariableArgs:
    def __init__(__self__, *,
                 bool_value: Optional[pulumi.Input[bool]] = None,
                 encryption_key_value: Optional[pulumi.Input['EncryptionKeyArgs']] = None,
                 int_value: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 secret_value: Optional[pulumi.Input['SecretArgs']] = None,
                 string_value: Optional[pulumi.Input[str]] = None):
        """
        ConfigVariable represents a configuration variable present in a Connection. or AuthConfig.
        :param pulumi.Input[bool] bool_value: Value is a bool.
        :param pulumi.Input['EncryptionKeyArgs'] encryption_key_value: Value is a Encryption Key.
        :param pulumi.Input[str] int_value: Value is an integer
        :param pulumi.Input[str] key: Key of the config variable.
        :param pulumi.Input['SecretArgs'] secret_value: Value is a secret.
        :param pulumi.Input[str] string_value: Value is a string.
        """
        if bool_value is not None:
            pulumi.set(__self__, "bool_value", bool_value)
        if encryption_key_value is not None:
            pulumi.set(__self__, "encryption_key_value", encryption_key_value)
        if int_value is not None:
            pulumi.set(__self__, "int_value", int_value)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if secret_value is not None:
            pulumi.set(__self__, "secret_value", secret_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)

    @property
    @pulumi.getter(name="boolValue")
    def bool_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Value is a bool.
        """
        return pulumi.get(self, "bool_value")

    @bool_value.setter
    def bool_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bool_value", value)

    @property
    @pulumi.getter(name="encryptionKeyValue")
    def encryption_key_value(self) -> Optional[pulumi.Input['EncryptionKeyArgs']]:
        """
        Value is a Encryption Key.
        """
        return pulumi.get(self, "encryption_key_value")

    @encryption_key_value.setter
    def encryption_key_value(self, value: Optional[pulumi.Input['EncryptionKeyArgs']]):
        pulumi.set(self, "encryption_key_value", value)

    @property
    @pulumi.getter(name="intValue")
    def int_value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is an integer
        """
        return pulumi.get(self, "int_value")

    @int_value.setter
    def int_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "int_value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key of the config variable.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretValue")
    def secret_value(self) -> Optional[pulumi.Input['SecretArgs']]:
        """
        Value is a secret.
        """
        return pulumi.get(self, "secret_value")

    @secret_value.setter
    def secret_value(self, value: Optional[pulumi.Input['SecretArgs']]):
        pulumi.set(self, "secret_value", value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is a string.
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)


@pulumi.input_type
class ConnectorsLogConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        Log configuration for the connection.
        :param pulumi.Input[bool] enabled: Enabled represents whether logging is enabled or not for a connection.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enabled represents whether logging is enabled or not for a connection.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class DestinationConfigArgs:
    def __init__(__self__, *,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input['DestinationArgs']]]] = None,
                 key: Optional[pulumi.Input[str]] = None):
        """
        Define the Connectors target endpoint.
        :param pulumi.Input[Sequence[pulumi.Input['DestinationArgs']]] destinations: The destinations for the key.
        :param pulumi.Input[str] key: The key is the destination identifier that is supported by the Connector.
        """
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DestinationArgs']]]]:
        """
        The destinations for the key.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DestinationArgs']]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The key is the destination identifier that is supported by the Connector.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)


@pulumi.input_type
class DestinationArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 service_attachment: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host: For publicly routable host.
        :param pulumi.Input[int] port: The port is the target port number that is accepted by the destination.
        :param pulumi.Input[str] service_attachment: PSC service attachments. Format: projects/*/regions/*/serviceAttachments/*
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if service_attachment is not None:
            pulumi.set(__self__, "service_attachment", service_attachment)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        For publicly routable host.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port is the target port number that is accepted by the destination.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="serviceAttachment")
    def service_attachment(self) -> Optional[pulumi.Input[str]]:
        """
        PSC service attachments. Format: projects/*/regions/*/serviceAttachments/*
        """
        return pulumi.get(self, "service_attachment")

    @service_attachment.setter
    def service_attachment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_attachment", value)


@pulumi.input_type
class EncryptionKeyArgs:
    def __init__(__self__, *,
                 kms_key_name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input['EncryptionKeyType']] = None):
        """
        Encryption Key value.
        :param pulumi.Input[str] kms_key_name: The [KMS key name] with which the content of the Operation is encrypted. The expected format: `projects/*/locations/*/keyRings/*/cryptoKeys/*`. Will be empty string if google managed.
        :param pulumi.Input['EncryptionKeyType'] type: Type.
        """
        if kms_key_name is not None:
            pulumi.set(__self__, "kms_key_name", kms_key_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> Optional[pulumi.Input[str]]:
        """
        The [KMS key name] with which the content of the Operation is encrypted. The expected format: `projects/*/locations/*/keyRings/*/cryptoKeys/*`. Will be empty string if google managed.
        """
        return pulumi.get(self, "kms_key_name")

    @kms_key_name.setter
    def kms_key_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['EncryptionKeyType']]:
        """
        Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['EncryptionKeyType']]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class EndPointArgs:
    def __init__(__self__, *,
                 endpoint_uri: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['HeaderArgs']]]] = None):
        """
        Endpoint message includes details of the Destination endpoint.
        :param pulumi.Input[str] endpoint_uri: The URI of the Endpoint.
        :param pulumi.Input[Sequence[pulumi.Input['HeaderArgs']]] headers: List of Header to be added to the Endpoint.
        """
        if endpoint_uri is not None:
            pulumi.set(__self__, "endpoint_uri", endpoint_uri)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter(name="endpointUri")
    def endpoint_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The URI of the Endpoint.
        """
        return pulumi.get(self, "endpoint_uri")

    @endpoint_uri.setter
    def endpoint_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_uri", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HeaderArgs']]]]:
        """
        List of Header to be added to the Endpoint.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HeaderArgs']]]]):
        pulumi.set(self, "headers", value)


@pulumi.input_type
class EventSubscriptionDestinationArgs:
    def __init__(__self__, *,
                 endpoint: Optional[pulumi.Input['EndPointArgs']] = None,
                 service_account: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input['EventSubscriptionDestinationType']] = None):
        """
        Message for EventSubscription Destination to act on receiving an event
        :param pulumi.Input['EndPointArgs'] endpoint: OPTION 1: Hit an endpoint when we receive an event.
        :param pulumi.Input[str] service_account: Service account needed for runtime plane to trigger IP workflow.
        :param pulumi.Input['EventSubscriptionDestinationType'] type: type of the destination
        """
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input['EndPointArgs']]:
        """
        OPTION 1: Hit an endpoint when we receive an event.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input['EndPointArgs']]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input[str]]:
        """
        Service account needed for runtime plane to trigger IP workflow.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['EventSubscriptionDestinationType']]:
        """
        type of the destination
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['EventSubscriptionDestinationType']]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class EventingConfigArgs:
    def __init__(__self__, *,
                 additional_variables: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigVariableArgs']]]] = None,
                 auth_config: Optional[pulumi.Input['AuthConfigArgs']] = None,
                 enrichment_enabled: Optional[pulumi.Input[bool]] = None,
                 events_listener_ingress_endpoint: Optional[pulumi.Input[str]] = None,
                 listener_auth_config: Optional[pulumi.Input['AuthConfigArgs']] = None,
                 private_connectivity_enabled: Optional[pulumi.Input[bool]] = None,
                 registration_destination_config: Optional[pulumi.Input['DestinationConfigArgs']] = None):
        """
        Eventing Configuration of a connection
        :param pulumi.Input[Sequence[pulumi.Input['ConfigVariableArgs']]] additional_variables: Additional eventing related field values
        :param pulumi.Input['AuthConfigArgs'] auth_config: Auth details for the webhook adapter.
        :param pulumi.Input[bool] enrichment_enabled: Enrichment Enabled.
        :param pulumi.Input[str] events_listener_ingress_endpoint: Optional. Ingress endpoint of the event listener. This is used only when private connectivity is enabled.
        :param pulumi.Input['AuthConfigArgs'] listener_auth_config: Optional. Auth details for the event listener.
        :param pulumi.Input[bool] private_connectivity_enabled: Optional. Private Connectivity Enabled.
        :param pulumi.Input['DestinationConfigArgs'] registration_destination_config: Registration endpoint for auto registration.
        """
        if additional_variables is not None:
            pulumi.set(__self__, "additional_variables", additional_variables)
        if auth_config is not None:
            pulumi.set(__self__, "auth_config", auth_config)
        if enrichment_enabled is not None:
            pulumi.set(__self__, "enrichment_enabled", enrichment_enabled)
        if events_listener_ingress_endpoint is not None:
            pulumi.set(__self__, "events_listener_ingress_endpoint", events_listener_ingress_endpoint)
        if listener_auth_config is not None:
            pulumi.set(__self__, "listener_auth_config", listener_auth_config)
        if private_connectivity_enabled is not None:
            pulumi.set(__self__, "private_connectivity_enabled", private_connectivity_enabled)
        if registration_destination_config is not None:
            pulumi.set(__self__, "registration_destination_config", registration_destination_config)

    @property
    @pulumi.getter(name="additionalVariables")
    def additional_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfigVariableArgs']]]]:
        """
        Additional eventing related field values
        """
        return pulumi.get(self, "additional_variables")

    @additional_variables.setter
    def additional_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigVariableArgs']]]]):
        pulumi.set(self, "additional_variables", value)

    @property
    @pulumi.getter(name="authConfig")
    def auth_config(self) -> Optional[pulumi.Input['AuthConfigArgs']]:
        """
        Auth details for the webhook adapter.
        """
        return pulumi.get(self, "auth_config")

    @auth_config.setter
    def auth_config(self, value: Optional[pulumi.Input['AuthConfigArgs']]):
        pulumi.set(self, "auth_config", value)

    @property
    @pulumi.getter(name="enrichmentEnabled")
    def enrichment_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enrichment Enabled.
        """
        return pulumi.get(self, "enrichment_enabled")

    @enrichment_enabled.setter
    def enrichment_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enrichment_enabled", value)

    @property
    @pulumi.getter(name="eventsListenerIngressEndpoint")
    def events_listener_ingress_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Ingress endpoint of the event listener. This is used only when private connectivity is enabled.
        """
        return pulumi.get(self, "events_listener_ingress_endpoint")

    @events_listener_ingress_endpoint.setter
    def events_listener_ingress_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "events_listener_ingress_endpoint", value)

    @property
    @pulumi.getter(name="listenerAuthConfig")
    def listener_auth_config(self) -> Optional[pulumi.Input['AuthConfigArgs']]:
        """
        Optional. Auth details for the event listener.
        """
        return pulumi.get(self, "listener_auth_config")

    @listener_auth_config.setter
    def listener_auth_config(self, value: Optional[pulumi.Input['AuthConfigArgs']]):
        pulumi.set(self, "listener_auth_config", value)

    @property
    @pulumi.getter(name="privateConnectivityEnabled")
    def private_connectivity_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. Private Connectivity Enabled.
        """
        return pulumi.get(self, "private_connectivity_enabled")

    @private_connectivity_enabled.setter
    def private_connectivity_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "private_connectivity_enabled", value)

    @property
    @pulumi.getter(name="registrationDestinationConfig")
    def registration_destination_config(self) -> Optional[pulumi.Input['DestinationConfigArgs']]:
        """
        Registration endpoint for auto registration.
        """
        return pulumi.get(self, "registration_destination_config")

    @registration_destination_config.setter
    def registration_destination_config(self, value: Optional[pulumi.Input['DestinationConfigArgs']]):
        pulumi.set(self, "registration_destination_config", value)


@pulumi.input_type
class ExprArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
        :param pulumi.Input[str] description: Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        :param pulumi.Input[str] expression: Textual representation of an expression in Common Expression Language syntax.
        :param pulumi.Input[str] location: Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
        :param pulumi.Input[str] title: Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class HeaderArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        Header details for a given header to be added to Endpoint.
        :param pulumi.Input[str] key: Key of Header.
        :param pulumi.Input[str] value: Value of Header.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key of Header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of Header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class JMSArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input['JMSType']] = None):
        """
        JMS message denotes the source of the event
        :param pulumi.Input[str] name: Optional. Name of the JMS source. i.e. queueName or topicName
        :param pulumi.Input['JMSType'] type: Optional. Type of the JMS Source. i.e. Queue or Topic
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Name of the JMS source. i.e. queueName or topicName
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['JMSType']]:
        """
        Optional. Type of the JMS Source. i.e. Queue or Topic
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['JMSType']]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class JwtClaimsArgs:
    def __init__(__self__, *,
                 audience: Optional[pulumi.Input[str]] = None,
                 issuer: Optional[pulumi.Input[str]] = None,
                 subject: Optional[pulumi.Input[str]] = None):
        """
        JWT claims used for the jwt-bearer authorization grant.
        :param pulumi.Input[str] audience: Value for the "aud" claim.
        :param pulumi.Input[str] issuer: Value for the "iss" claim.
        :param pulumi.Input[str] subject: Value for the "sub" claim.
        """
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter
    def audience(self) -> Optional[pulumi.Input[str]]:
        """
        Value for the "aud" claim.
        """
        return pulumi.get(self, "audience")

    @audience.setter
    def audience(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audience", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[str]]:
        """
        Value for the "iss" claim.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        """
        Value for the "sub" claim.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)


@pulumi.input_type
class LockConfigArgs:
    def __init__(__self__, *,
                 locked: Optional[pulumi.Input[bool]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        Determines whether or no a connection is locked. If locked, a reason must be specified.
        :param pulumi.Input[bool] locked: Indicates whether or not the connection is locked.
        :param pulumi.Input[str] reason: Describes why a connection is locked.
        """
        if locked is not None:
            pulumi.set(__self__, "locked", locked)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def locked(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether or not the connection is locked.
        """
        return pulumi.get(self, "locked")

    @locked.setter
    def locked(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "locked", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        Describes why a connection is locked.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


@pulumi.input_type
class NodeConfigArgs:
    def __init__(__self__, *,
                 max_node_count: Optional[pulumi.Input[int]] = None,
                 min_node_count: Optional[pulumi.Input[int]] = None):
        """
        Node configuration for the connection.
        :param pulumi.Input[int] max_node_count: Maximum number of nodes in the runtime nodes.
        :param pulumi.Input[int] min_node_count: Minimum number of nodes in the runtime nodes.
        """
        if max_node_count is not None:
            pulumi.set(__self__, "max_node_count", max_node_count)
        if min_node_count is not None:
            pulumi.set(__self__, "min_node_count", min_node_count)

    @property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of nodes in the runtime nodes.
        """
        return pulumi.get(self, "max_node_count")

    @max_node_count.setter
    def max_node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_node_count", value)

    @property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of nodes in the runtime nodes.
        """
        return pulumi.get(self, "min_node_count")

    @min_node_count.setter
    def min_node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_node_count", value)


@pulumi.input_type
class Oauth2AuthCodeFlowArgs:
    def __init__(__self__, *,
                 auth_code: Optional[pulumi.Input[str]] = None,
                 auth_uri: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input['SecretArgs']] = None,
                 enable_pkce: Optional[pulumi.Input[bool]] = None,
                 pkce_verifier: Optional[pulumi.Input[str]] = None,
                 redirect_uri: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Parameters to support Oauth 2.0 Auth Code Grant Authentication. See https://www.rfc-editor.org/rfc/rfc6749#section-1.3.1 for more details.
        :param pulumi.Input[str] auth_code: Authorization code to be exchanged for access and refresh tokens.
        :param pulumi.Input[str] auth_uri: Auth URL for Authorization Code Flow
        :param pulumi.Input[str] client_id: Client ID for user-provided OAuth app.
        :param pulumi.Input['SecretArgs'] client_secret: Client secret for user-provided OAuth app.
        :param pulumi.Input[bool] enable_pkce: Whether to enable PKCE when the user performs the auth code flow.
        :param pulumi.Input[str] pkce_verifier: PKCE verifier to be used during the auth code exchange.
        :param pulumi.Input[str] redirect_uri: Redirect URI to be provided during the auth code exchange.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: Scopes the connection will request when the user performs the auth code flow.
        """
        if auth_code is not None:
            pulumi.set(__self__, "auth_code", auth_code)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if enable_pkce is not None:
            pulumi.set(__self__, "enable_pkce", enable_pkce)
        if pkce_verifier is not None:
            pulumi.set(__self__, "pkce_verifier", pkce_verifier)
        if redirect_uri is not None:
            pulumi.set(__self__, "redirect_uri", redirect_uri)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter(name="authCode")
    def auth_code(self) -> Optional[pulumi.Input[str]]:
        """
        Authorization code to be exchanged for access and refresh tokens.
        """
        return pulumi.get(self, "auth_code")

    @auth_code.setter
    def auth_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_code", value)

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Auth URL for Authorization Code Flow
        """
        return pulumi.get(self, "auth_uri")

    @auth_uri.setter
    def auth_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_uri", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Client ID for user-provided OAuth app.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input['SecretArgs']]:
        """
        Client secret for user-provided OAuth app.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input['SecretArgs']]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="enablePkce")
    def enable_pkce(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable PKCE when the user performs the auth code flow.
        """
        return pulumi.get(self, "enable_pkce")

    @enable_pkce.setter
    def enable_pkce(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_pkce", value)

    @property
    @pulumi.getter(name="pkceVerifier")
    def pkce_verifier(self) -> Optional[pulumi.Input[str]]:
        """
        PKCE verifier to be used during the auth code exchange.
        """
        return pulumi.get(self, "pkce_verifier")

    @pkce_verifier.setter
    def pkce_verifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pkce_verifier", value)

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Redirect URI to be provided during the auth code exchange.
        """
        return pulumi.get(self, "redirect_uri")

    @redirect_uri.setter
    def redirect_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redirect_uri", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Scopes the connection will request when the user performs the auth code flow.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)


@pulumi.input_type
class Oauth2ClientCredentialsArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input['SecretArgs']] = None):
        """
        Parameters to support Oauth 2.0 Client Credentials Grant Authentication. See https://tools.ietf.org/html/rfc6749#section-1.3.4 for more details.
        :param pulumi.Input[str] client_id: The client identifier.
        :param pulumi.Input['SecretArgs'] client_secret: Secret version reference containing the client secret.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The client identifier.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input['SecretArgs']]:
        """
        Secret version reference containing the client secret.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input['SecretArgs']]):
        pulumi.set(self, "client_secret", value)


@pulumi.input_type
class Oauth2JwtBearerArgs:
    def __init__(__self__, *,
                 client_key: Optional[pulumi.Input['SecretArgs']] = None,
                 jwt_claims: Optional[pulumi.Input['JwtClaimsArgs']] = None):
        """
        Parameters to support JSON Web Token (JWT) Profile for Oauth 2.0 Authorization Grant based authentication. See https://tools.ietf.org/html/rfc7523 for more details.
        :param pulumi.Input['SecretArgs'] client_key: Secret version reference containing a PKCS#8 PEM-encoded private key associated with the Client Certificate. This private key will be used to sign JWTs used for the jwt-bearer authorization grant. Specified in the form as: `projects/*/secrets/*/versions/*`.
        :param pulumi.Input['JwtClaimsArgs'] jwt_claims: JwtClaims providers fields to generate the token.
        """
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if jwt_claims is not None:
            pulumi.set(__self__, "jwt_claims", jwt_claims)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input['SecretArgs']]:
        """
        Secret version reference containing a PKCS#8 PEM-encoded private key associated with the Client Certificate. This private key will be used to sign JWTs used for the jwt-bearer authorization grant. Specified in the form as: `projects/*/secrets/*/versions/*`.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input['SecretArgs']]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="jwtClaims")
    def jwt_claims(self) -> Optional[pulumi.Input['JwtClaimsArgs']]:
        """
        JwtClaims providers fields to generate the token.
        """
        return pulumi.get(self, "jwt_claims")

    @jwt_claims.setter
    def jwt_claims(self, value: Optional[pulumi.Input['JwtClaimsArgs']]):
        pulumi.set(self, "jwt_claims", value)


@pulumi.input_type
class SecretArgs:
    def __init__(__self__, *,
                 secret_version: Optional[pulumi.Input[str]] = None):
        """
        Secret provides a reference to entries in Secret Manager.
        :param pulumi.Input[str] secret_version: The resource name of the secret version in the format, format as: `projects/*/secrets/*/versions/*`.
        """
        if secret_version is not None:
            pulumi.set(__self__, "secret_version", secret_version)

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[pulumi.Input[str]]:
        """
        The resource name of the secret version in the format, format as: `projects/*/secrets/*/versions/*`.
        """
        return pulumi.get(self, "secret_version")

    @secret_version.setter
    def secret_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_version", value)


@pulumi.input_type
class SshPublicKeyArgs:
    def __init__(__self__, *,
                 cert_type: Optional[pulumi.Input[str]] = None,
                 ssh_client_cert: Optional[pulumi.Input['SecretArgs']] = None,
                 ssh_client_cert_pass: Optional[pulumi.Input['SecretArgs']] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        Parameters to support Ssh public key Authentication.
        :param pulumi.Input[str] cert_type: Format of SSH Client cert.
        :param pulumi.Input['SecretArgs'] ssh_client_cert: SSH Client Cert. It should contain both public and private key.
        :param pulumi.Input['SecretArgs'] ssh_client_cert_pass: Password (passphrase) for ssh client certificate if it has one.
        :param pulumi.Input[str] username: The user account used to authenticate.
        """
        if cert_type is not None:
            pulumi.set(__self__, "cert_type", cert_type)
        if ssh_client_cert is not None:
            pulumi.set(__self__, "ssh_client_cert", ssh_client_cert)
        if ssh_client_cert_pass is not None:
            pulumi.set(__self__, "ssh_client_cert_pass", ssh_client_cert_pass)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="certType")
    def cert_type(self) -> Optional[pulumi.Input[str]]:
        """
        Format of SSH Client cert.
        """
        return pulumi.get(self, "cert_type")

    @cert_type.setter
    def cert_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cert_type", value)

    @property
    @pulumi.getter(name="sshClientCert")
    def ssh_client_cert(self) -> Optional[pulumi.Input['SecretArgs']]:
        """
        SSH Client Cert. It should contain both public and private key.
        """
        return pulumi.get(self, "ssh_client_cert")

    @ssh_client_cert.setter
    def ssh_client_cert(self, value: Optional[pulumi.Input['SecretArgs']]):
        pulumi.set(self, "ssh_client_cert", value)

    @property
    @pulumi.getter(name="sshClientCertPass")
    def ssh_client_cert_pass(self) -> Optional[pulumi.Input['SecretArgs']]:
        """
        Password (passphrase) for ssh client certificate if it has one.
        """
        return pulumi.get(self, "ssh_client_cert_pass")

    @ssh_client_cert_pass.setter
    def ssh_client_cert_pass(self, value: Optional[pulumi.Input['SecretArgs']]):
        pulumi.set(self, "ssh_client_cert_pass", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The user account used to authenticate.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class SslConfigArgs:
    def __init__(__self__, *,
                 additional_variables: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigVariableArgs']]]] = None,
                 client_cert_type: Optional[pulumi.Input['SslConfigClientCertType']] = None,
                 client_certificate: Optional[pulumi.Input['SecretArgs']] = None,
                 client_private_key: Optional[pulumi.Input['SecretArgs']] = None,
                 client_private_key_pass: Optional[pulumi.Input['SecretArgs']] = None,
                 private_server_certificate: Optional[pulumi.Input['SecretArgs']] = None,
                 server_cert_type: Optional[pulumi.Input['SslConfigServerCertType']] = None,
                 trust_model: Optional[pulumi.Input['SslConfigTrustModel']] = None,
                 type: Optional[pulumi.Input['SslConfigType']] = None,
                 use_ssl: Optional[pulumi.Input[bool]] = None):
        """
        SSL Configuration of a connection
        :param pulumi.Input[Sequence[pulumi.Input['ConfigVariableArgs']]] additional_variables: Additional SSL related field values
        :param pulumi.Input['SslConfigClientCertType'] client_cert_type: Type of Client Cert (PEM/JKS/.. etc.)
        :param pulumi.Input['SecretArgs'] client_certificate: Client Certificate
        :param pulumi.Input['SecretArgs'] client_private_key: Client Private Key
        :param pulumi.Input['SecretArgs'] client_private_key_pass: Secret containing the passphrase protecting the Client Private Key
        :param pulumi.Input['SecretArgs'] private_server_certificate: Private Server Certificate. Needs to be specified if trust model is `PRIVATE`.
        :param pulumi.Input['SslConfigServerCertType'] server_cert_type: Type of Server Cert (PEM/JKS/.. etc.)
        :param pulumi.Input['SslConfigTrustModel'] trust_model: Trust Model of the SSL connection
        :param pulumi.Input['SslConfigType'] type: Controls the ssl type for the given connector version.
        :param pulumi.Input[bool] use_ssl: Bool for enabling SSL
        """
        if additional_variables is not None:
            pulumi.set(__self__, "additional_variables", additional_variables)
        if client_cert_type is not None:
            pulumi.set(__self__, "client_cert_type", client_cert_type)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_private_key is not None:
            pulumi.set(__self__, "client_private_key", client_private_key)
        if client_private_key_pass is not None:
            pulumi.set(__self__, "client_private_key_pass", client_private_key_pass)
        if private_server_certificate is not None:
            pulumi.set(__self__, "private_server_certificate", private_server_certificate)
        if server_cert_type is not None:
            pulumi.set(__self__, "server_cert_type", server_cert_type)
        if trust_model is not None:
            pulumi.set(__self__, "trust_model", trust_model)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_ssl is not None:
            pulumi.set(__self__, "use_ssl", use_ssl)

    @property
    @pulumi.getter(name="additionalVariables")
    def additional_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfigVariableArgs']]]]:
        """
        Additional SSL related field values
        """
        return pulumi.get(self, "additional_variables")

    @additional_variables.setter
    def additional_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigVariableArgs']]]]):
        pulumi.set(self, "additional_variables", value)

    @property
    @pulumi.getter(name="clientCertType")
    def client_cert_type(self) -> Optional[pulumi.Input['SslConfigClientCertType']]:
        """
        Type of Client Cert (PEM/JKS/.. etc.)
        """
        return pulumi.get(self, "client_cert_type")

    @client_cert_type.setter
    def client_cert_type(self, value: Optional[pulumi.Input['SslConfigClientCertType']]):
        pulumi.set(self, "client_cert_type", value)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input['SecretArgs']]:
        """
        Client Certificate
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input['SecretArgs']]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="clientPrivateKey")
    def client_private_key(self) -> Optional[pulumi.Input['SecretArgs']]:
        """
        Client Private Key
        """
        return pulumi.get(self, "client_private_key")

    @client_private_key.setter
    def client_private_key(self, value: Optional[pulumi.Input['SecretArgs']]):
        pulumi.set(self, "client_private_key", value)

    @property
    @pulumi.getter(name="clientPrivateKeyPass")
    def client_private_key_pass(self) -> Optional[pulumi.Input['SecretArgs']]:
        """
        Secret containing the passphrase protecting the Client Private Key
        """
        return pulumi.get(self, "client_private_key_pass")

    @client_private_key_pass.setter
    def client_private_key_pass(self, value: Optional[pulumi.Input['SecretArgs']]):
        pulumi.set(self, "client_private_key_pass", value)

    @property
    @pulumi.getter(name="privateServerCertificate")
    def private_server_certificate(self) -> Optional[pulumi.Input['SecretArgs']]:
        """
        Private Server Certificate. Needs to be specified if trust model is `PRIVATE`.
        """
        return pulumi.get(self, "private_server_certificate")

    @private_server_certificate.setter
    def private_server_certificate(self, value: Optional[pulumi.Input['SecretArgs']]):
        pulumi.set(self, "private_server_certificate", value)

    @property
    @pulumi.getter(name="serverCertType")
    def server_cert_type(self) -> Optional[pulumi.Input['SslConfigServerCertType']]:
        """
        Type of Server Cert (PEM/JKS/.. etc.)
        """
        return pulumi.get(self, "server_cert_type")

    @server_cert_type.setter
    def server_cert_type(self, value: Optional[pulumi.Input['SslConfigServerCertType']]):
        pulumi.set(self, "server_cert_type", value)

    @property
    @pulumi.getter(name="trustModel")
    def trust_model(self) -> Optional[pulumi.Input['SslConfigTrustModel']]:
        """
        Trust Model of the SSL connection
        """
        return pulumi.get(self, "trust_model")

    @trust_model.setter
    def trust_model(self, value: Optional[pulumi.Input['SslConfigTrustModel']]):
        pulumi.set(self, "trust_model", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['SslConfigType']]:
        """
        Controls the ssl type for the given connector version.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['SslConfigType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="useSsl")
    def use_ssl(self) -> Optional[pulumi.Input[bool]]:
        """
        Bool for enabling SSL
        """
        return pulumi.get(self, "use_ssl")

    @use_ssl.setter
    def use_ssl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_ssl", value)


@pulumi.input_type
class UserPasswordArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input['SecretArgs']] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        Parameters to support Username and Password Authentication.
        :param pulumi.Input['SecretArgs'] password: Secret version reference containing the password.
        :param pulumi.Input[str] username: Username.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input['SecretArgs']]:
        """
        Secret version reference containing the password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input['SecretArgs']]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


