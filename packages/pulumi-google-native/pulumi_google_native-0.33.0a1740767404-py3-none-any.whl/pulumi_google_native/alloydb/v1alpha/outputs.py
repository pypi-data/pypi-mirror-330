# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AutomatedBackupPolicyResponse',
    'BackupSourceResponse',
    'ClientConnectionConfigResponse',
    'ContinuousBackupConfigResponse',
    'ContinuousBackupInfoResponse',
    'EncryptionConfigResponse',
    'EncryptionInfoResponse',
    'GoogleTypeTimeOfDayResponse',
    'MachineConfigResponse',
    'MigrationSourceResponse',
    'NetworkConfigResponse',
    'NodeResponse',
    'PrimaryConfigResponse',
    'PscConfigResponse',
    'QuantityBasedExpiryResponse',
    'QuantityBasedRetentionResponse',
    'QueryInsightsInstanceConfigResponse',
    'ReadPoolConfigResponse',
    'SecondaryConfigResponse',
    'SslConfigResponse',
    'TimeBasedRetentionResponse',
    'UpdatePolicyResponse',
    'UserPasswordResponse',
    'WeeklyScheduleResponse',
]

@pulumi.output_type
class AutomatedBackupPolicyResponse(dict):
    """
    Message describing the user-specified automated backup policy. All fields in the automated backup policy are optional. Defaults for each field are provided if they are not set.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupWindow":
            suggest = "backup_window"
        elif key == "encryptionConfig":
            suggest = "encryption_config"
        elif key == "quantityBasedRetention":
            suggest = "quantity_based_retention"
        elif key == "timeBasedRetention":
            suggest = "time_based_retention"
        elif key == "weeklySchedule":
            suggest = "weekly_schedule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomatedBackupPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomatedBackupPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomatedBackupPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_window: str,
                 enabled: bool,
                 encryption_config: 'outputs.EncryptionConfigResponse',
                 labels: Mapping[str, str],
                 location: str,
                 quantity_based_retention: 'outputs.QuantityBasedRetentionResponse',
                 time_based_retention: 'outputs.TimeBasedRetentionResponse',
                 weekly_schedule: 'outputs.WeeklyScheduleResponse'):
        """
        Message describing the user-specified automated backup policy. All fields in the automated backup policy are optional. Defaults for each field are provided if they are not set.
        :param str backup_window: The length of the time window during which a backup can be taken. If a backup does not succeed within this time window, it will be canceled and considered failed. The backup window must be at least 5 minutes long. There is no upper bound on the window. If not set, it defaults to 1 hour.
        :param bool enabled: Whether automated automated backups are enabled. If not set, defaults to true.
        :param 'EncryptionConfigResponse' encryption_config: Optional. The encryption config can be specified to encrypt the backups with a customer-managed encryption key (CMEK). When this field is not specified, the backup will then use default encryption scheme to protect the user data.
        :param Mapping[str, str] labels: Labels to apply to backups created using this configuration.
        :param str location: The location where the backup will be stored. Currently, the only supported option is to store the backup in the same region as the cluster. If empty, defaults to the region of the cluster.
        :param 'QuantityBasedRetentionResponse' quantity_based_retention: Quantity-based Backup retention policy to retain recent backups.
        :param 'TimeBasedRetentionResponse' time_based_retention: Time-based Backup retention policy.
        :param 'WeeklyScheduleResponse' weekly_schedule: Weekly schedule for the Backup.
        """
        pulumi.set(__self__, "backup_window", backup_window)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "encryption_config", encryption_config)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "quantity_based_retention", quantity_based_retention)
        pulumi.set(__self__, "time_based_retention", time_based_retention)
        pulumi.set(__self__, "weekly_schedule", weekly_schedule)

    @property
    @pulumi.getter(name="backupWindow")
    def backup_window(self) -> str:
        """
        The length of the time window during which a backup can be taken. If a backup does not succeed within this time window, it will be canceled and considered failed. The backup window must be at least 5 minutes long. There is no upper bound on the window. If not set, it defaults to 1 hour.
        """
        return pulumi.get(self, "backup_window")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether automated automated backups are enabled. If not set, defaults to true.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="encryptionConfig")
    def encryption_config(self) -> 'outputs.EncryptionConfigResponse':
        """
        Optional. The encryption config can be specified to encrypt the backups with a customer-managed encryption key (CMEK). When this field is not specified, the backup will then use default encryption scheme to protect the user data.
        """
        return pulumi.get(self, "encryption_config")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Labels to apply to backups created using this configuration.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The location where the backup will be stored. Currently, the only supported option is to store the backup in the same region as the cluster. If empty, defaults to the region of the cluster.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="quantityBasedRetention")
    def quantity_based_retention(self) -> 'outputs.QuantityBasedRetentionResponse':
        """
        Quantity-based Backup retention policy to retain recent backups.
        """
        return pulumi.get(self, "quantity_based_retention")

    @property
    @pulumi.getter(name="timeBasedRetention")
    def time_based_retention(self) -> 'outputs.TimeBasedRetentionResponse':
        """
        Time-based Backup retention policy.
        """
        return pulumi.get(self, "time_based_retention")

    @property
    @pulumi.getter(name="weeklySchedule")
    def weekly_schedule(self) -> 'outputs.WeeklyScheduleResponse':
        """
        Weekly schedule for the Backup.
        """
        return pulumi.get(self, "weekly_schedule")


@pulumi.output_type
class BackupSourceResponse(dict):
    """
    Message describing a BackupSource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupName":
            suggest = "backup_name"
        elif key == "backupUid":
            suggest = "backup_uid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_name: str,
                 backup_uid: str):
        """
        Message describing a BackupSource.
        :param str backup_name: The name of the backup resource with the format: * projects/{project}/locations/{region}/backups/{backup_id}
        :param str backup_uid: The system-generated UID of the backup which was used to create this resource. The UID is generated when the backup is created, and it is retained until the backup is deleted.
        """
        pulumi.set(__self__, "backup_name", backup_name)
        pulumi.set(__self__, "backup_uid", backup_uid)

    @property
    @pulumi.getter(name="backupName")
    def backup_name(self) -> str:
        """
        The name of the backup resource with the format: * projects/{project}/locations/{region}/backups/{backup_id}
        """
        return pulumi.get(self, "backup_name")

    @property
    @pulumi.getter(name="backupUid")
    def backup_uid(self) -> str:
        """
        The system-generated UID of the backup which was used to create this resource. The UID is generated when the backup is created, and it is retained until the backup is deleted.
        """
        return pulumi.get(self, "backup_uid")


@pulumi.output_type
class ClientConnectionConfigResponse(dict):
    """
    Client connection configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requireConnectors":
            suggest = "require_connectors"
        elif key == "sslConfig":
            suggest = "ssl_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientConnectionConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientConnectionConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientConnectionConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 require_connectors: bool,
                 ssl_config: 'outputs.SslConfigResponse'):
        """
        Client connection configuration
        :param bool require_connectors: Optional. Configuration to enforce connectors only (ex: AuthProxy) connections to the database.
        :param 'SslConfigResponse' ssl_config: Optional. SSL config option for this instance.
        """
        pulumi.set(__self__, "require_connectors", require_connectors)
        pulumi.set(__self__, "ssl_config", ssl_config)

    @property
    @pulumi.getter(name="requireConnectors")
    def require_connectors(self) -> bool:
        """
        Optional. Configuration to enforce connectors only (ex: AuthProxy) connections to the database.
        """
        return pulumi.get(self, "require_connectors")

    @property
    @pulumi.getter(name="sslConfig")
    def ssl_config(self) -> 'outputs.SslConfigResponse':
        """
        Optional. SSL config option for this instance.
        """
        return pulumi.get(self, "ssl_config")


@pulumi.output_type
class ContinuousBackupConfigResponse(dict):
    """
    ContinuousBackupConfig describes the continuous backups recovery configurations of a cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionConfig":
            suggest = "encryption_config"
        elif key == "recoveryWindowDays":
            suggest = "recovery_window_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContinuousBackupConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContinuousBackupConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContinuousBackupConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 encryption_config: 'outputs.EncryptionConfigResponse',
                 recovery_window_days: int):
        """
        ContinuousBackupConfig describes the continuous backups recovery configurations of a cluster.
        :param bool enabled: Whether ContinuousBackup is enabled.
        :param 'EncryptionConfigResponse' encryption_config: The encryption config can be specified to encrypt the backups with a customer-managed encryption key (CMEK). When this field is not specified, the backup will then use default encryption scheme to protect the user data.
        :param int recovery_window_days: The number of days that are eligible to restore from using PITR. To support the entire recovery window, backups and logs are retained for one day more than the recovery window. If not set, defaults to 14 days.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "encryption_config", encryption_config)
        pulumi.set(__self__, "recovery_window_days", recovery_window_days)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether ContinuousBackup is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="encryptionConfig")
    def encryption_config(self) -> 'outputs.EncryptionConfigResponse':
        """
        The encryption config can be specified to encrypt the backups with a customer-managed encryption key (CMEK). When this field is not specified, the backup will then use default encryption scheme to protect the user data.
        """
        return pulumi.get(self, "encryption_config")

    @property
    @pulumi.getter(name="recoveryWindowDays")
    def recovery_window_days(self) -> int:
        """
        The number of days that are eligible to restore from using PITR. To support the entire recovery window, backups and logs are retained for one day more than the recovery window. If not set, defaults to 14 days.
        """
        return pulumi.get(self, "recovery_window_days")


@pulumi.output_type
class ContinuousBackupInfoResponse(dict):
    """
    ContinuousBackupInfo describes the continuous backup properties of a cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "earliestRestorableTime":
            suggest = "earliest_restorable_time"
        elif key == "enabledTime":
            suggest = "enabled_time"
        elif key == "encryptionInfo":
            suggest = "encryption_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContinuousBackupInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContinuousBackupInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContinuousBackupInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 earliest_restorable_time: str,
                 enabled_time: str,
                 encryption_info: 'outputs.EncryptionInfoResponse',
                 schedule: Sequence[str]):
        """
        ContinuousBackupInfo describes the continuous backup properties of a cluster.
        :param str earliest_restorable_time: The earliest restorable time that can be restored to. Output only field.
        :param str enabled_time: When ContinuousBackup was most recently enabled. Set to null if ContinuousBackup is not enabled.
        :param 'EncryptionInfoResponse' encryption_info: The encryption information for the WALs and backups required for ContinuousBackup.
        :param Sequence[str] schedule: Days of the week on which a continuous backup is taken. Output only field. Ignored if passed into the request.
        """
        pulumi.set(__self__, "earliest_restorable_time", earliest_restorable_time)
        pulumi.set(__self__, "enabled_time", enabled_time)
        pulumi.set(__self__, "encryption_info", encryption_info)
        pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter(name="earliestRestorableTime")
    def earliest_restorable_time(self) -> str:
        """
        The earliest restorable time that can be restored to. Output only field.
        """
        return pulumi.get(self, "earliest_restorable_time")

    @property
    @pulumi.getter(name="enabledTime")
    def enabled_time(self) -> str:
        """
        When ContinuousBackup was most recently enabled. Set to null if ContinuousBackup is not enabled.
        """
        return pulumi.get(self, "enabled_time")

    @property
    @pulumi.getter(name="encryptionInfo")
    def encryption_info(self) -> 'outputs.EncryptionInfoResponse':
        """
        The encryption information for the WALs and backups required for ContinuousBackup.
        """
        return pulumi.get(self, "encryption_info")

    @property
    @pulumi.getter
    def schedule(self) -> Sequence[str]:
        """
        Days of the week on which a continuous backup is taken. Output only field. Ignored if passed into the request.
        """
        return pulumi.get(self, "schedule")


@pulumi.output_type
class EncryptionConfigResponse(dict):
    """
    EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyName":
            suggest = "kms_key_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_name: str):
        """
        EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
        :param str kms_key_name: The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME]
        """
        pulumi.set(__self__, "kms_key_name", kms_key_name)

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> str:
        """
        The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME]
        """
        return pulumi.get(self, "kms_key_name")


@pulumi.output_type
class EncryptionInfoResponse(dict):
    """
    EncryptionInfo describes the encryption information of a cluster or a backup.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKeyVersions":
            suggest = "kms_key_versions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_type: str,
                 kms_key_versions: Sequence[str]):
        """
        EncryptionInfo describes the encryption information of a cluster or a backup.
        :param str encryption_type: Type of encryption.
        :param Sequence[str] kms_key_versions: Cloud KMS key versions that are being used to protect the database or the backup.
        """
        pulumi.set(__self__, "encryption_type", encryption_type)
        pulumi.set(__self__, "kms_key_versions", kms_key_versions)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> str:
        """
        Type of encryption.
        """
        return pulumi.get(self, "encryption_type")

    @property
    @pulumi.getter(name="kmsKeyVersions")
    def kms_key_versions(self) -> Sequence[str]:
        """
        Cloud KMS key versions that are being used to protect the database or the backup.
        """
        return pulumi.get(self, "kms_key_versions")


@pulumi.output_type
class GoogleTypeTimeOfDayResponse(dict):
    """
    Represents a time of day. The date and time zone are either not significant or are specified elsewhere. An API may choose to allow leap seconds. Related types are google.type.Date and `google.protobuf.Timestamp`.
    """
    def __init__(__self__, *,
                 hours: int,
                 minutes: int,
                 nanos: int,
                 seconds: int):
        """
        Represents a time of day. The date and time zone are either not significant or are specified elsewhere. An API may choose to allow leap seconds. Related types are google.type.Date and `google.protobuf.Timestamp`.
        :param int hours: Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param int minutes: Minutes of hour of day. Must be from 0 to 59.
        :param int nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param int seconds: Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> int:
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> int:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @property
    @pulumi.getter
    def nanos(self) -> int:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @property
    @pulumi.getter
    def seconds(self) -> int:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class MachineConfigResponse(dict):
    """
    MachineConfig describes the configuration of a machine.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuCount":
            suggest = "cpu_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_count: int):
        """
        MachineConfig describes the configuration of a machine.
        :param int cpu_count: The number of CPU's in the VM instance.
        """
        pulumi.set(__self__, "cpu_count", cpu_count)

    @property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> int:
        """
        The number of CPU's in the VM instance.
        """
        return pulumi.get(self, "cpu_count")


@pulumi.output_type
class MigrationSourceResponse(dict):
    """
    Subset of the source instance configuration that is available when reading the cluster resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostPort":
            suggest = "host_port"
        elif key == "referenceId":
            suggest = "reference_id"
        elif key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrationSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrationSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrationSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_port: str,
                 reference_id: str,
                 source_type: str):
        """
        Subset of the source instance configuration that is available when reading the cluster resource.
        :param str host_port: The host and port of the on-premises instance in host:port format
        :param str reference_id: Place holder for the external source identifier(e.g DMS job name) that created the cluster.
        :param str source_type: Type of migration source.
        """
        pulumi.set(__self__, "host_port", host_port)
        pulumi.set(__self__, "reference_id", reference_id)
        pulumi.set(__self__, "source_type", source_type)

    @property
    @pulumi.getter(name="hostPort")
    def host_port(self) -> str:
        """
        The host and port of the on-premises instance in host:port format
        """
        return pulumi.get(self, "host_port")

    @property
    @pulumi.getter(name="referenceId")
    def reference_id(self) -> str:
        """
        Place holder for the external source identifier(e.g DMS job name) that created the cluster.
        """
        return pulumi.get(self, "reference_id")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        Type of migration source.
        """
        return pulumi.get(self, "source_type")


@pulumi.output_type
class NetworkConfigResponse(dict):
    """
    Metadata related to network configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocatedIpRange":
            suggest = "allocated_ip_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocated_ip_range: str,
                 network: str):
        """
        Metadata related to network configuration.
        :param str allocated_ip_range: Optional. Name of the allocated IP range for the private IP AlloyDB cluster, for example: "google-managed-services-default". If set, the instance IPs for this cluster will be created in the allocated range. The range name must comply with RFC 1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`. Field name is intended to be consistent with Cloud SQL.
        :param str network: Optional. The resource link for the VPC network in which cluster resources are created and from which they are accessible via Private IP. The network must belong to the same project as the cluster. It is specified in the form: "projects/{project_number}/global/networks/{network_id}". This is required to create a cluster.
        """
        pulumi.set(__self__, "allocated_ip_range", allocated_ip_range)
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter(name="allocatedIpRange")
    def allocated_ip_range(self) -> str:
        """
        Optional. Name of the allocated IP range for the private IP AlloyDB cluster, for example: "google-managed-services-default". If set, the instance IPs for this cluster will be created in the allocated range. The range name must comply with RFC 1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`. Field name is intended to be consistent with Cloud SQL.
        """
        return pulumi.get(self, "allocated_ip_range")

    @property
    @pulumi.getter
    def network(self) -> str:
        """
        Optional. The resource link for the VPC network in which cluster resources are created and from which they are accessible via Private IP. The network must belong to the same project as the cluster. It is specified in the form: "projects/{project_number}/global/networks/{network_id}". This is required to create a cluster.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class NodeResponse(dict):
    """
    Details of a single node in the instance. Nodes in an AlloyDB instance are ephemereal, they can change during update, failover, autohealing and resize operations.
    """
    def __init__(__self__, *,
                 ip: str,
                 state: str,
                 zone: str):
        """
        Details of a single node in the instance. Nodes in an AlloyDB instance are ephemereal, they can change during update, failover, autohealing and resize operations.
        :param str ip: The private IP address of the VM e.g. "10.57.0.34".
        :param str state: Determined by state of the compute VM and postgres-service health. Compute VM state can have values listed in https://cloud.google.com/compute/docs/instances/instance-life-cycle and postgres-service health can have values: HEALTHY and UNHEALTHY.
        :param str zone: The Compute Engine zone of the VM e.g. "us-central1-b".
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The private IP address of the VM e.g. "10.57.0.34".
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Determined by state of the compute VM and postgres-service health. Compute VM state can have values listed in https://cloud.google.com/compute/docs/instances/instance-life-cycle and postgres-service health can have values: HEALTHY and UNHEALTHY.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The Compute Engine zone of the VM e.g. "us-central1-b".
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class PrimaryConfigResponse(dict):
    """
    Configuration for the primary cluster. It has the list of clusters that are replicating from this cluster. This should be set if and only if the cluster is of type PRIMARY.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secondaryClusterNames":
            suggest = "secondary_cluster_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrimaryConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrimaryConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrimaryConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secondary_cluster_names: Sequence[str]):
        """
        Configuration for the primary cluster. It has the list of clusters that are replicating from this cluster. This should be set if and only if the cluster is of type PRIMARY.
        :param Sequence[str] secondary_cluster_names: Names of the clusters that are replicating from this cluster.
        """
        pulumi.set(__self__, "secondary_cluster_names", secondary_cluster_names)

    @property
    @pulumi.getter(name="secondaryClusterNames")
    def secondary_cluster_names(self) -> Sequence[str]:
        """
        Names of the clusters that are replicating from this cluster.
        """
        return pulumi.get(self, "secondary_cluster_names")


@pulumi.output_type
class PscConfigResponse(dict):
    """
    PscConfig contains PSC related configuration at a cluster level. NEXT ID: 2
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pscEnabled":
            suggest = "psc_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PscConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PscConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PscConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 psc_enabled: bool):
        """
        PscConfig contains PSC related configuration at a cluster level. NEXT ID: 2
        :param bool psc_enabled: Optional. Create an instance that allows connections from Private Service Connect endpoints to the instance.
        """
        pulumi.set(__self__, "psc_enabled", psc_enabled)

    @property
    @pulumi.getter(name="pscEnabled")
    def psc_enabled(self) -> bool:
        """
        Optional. Create an instance that allows connections from Private Service Connect endpoints to the instance.
        """
        return pulumi.get(self, "psc_enabled")


@pulumi.output_type
class QuantityBasedExpiryResponse(dict):
    """
    A backup's position in a quantity-based retention queue, of backups with the same source cluster and type, with length, retention, specified by the backup's retention policy. Once the position is greater than the retention, the backup is eligible to be garbage collected. Example: 5 backups from the same source cluster and type with a quantity-based retention of 3 and denoted by backup_id (position, retention). Safe: backup_5 (1, 3), backup_4, (2, 3), backup_3 (3, 3). Awaiting garbage collection: backup_2 (4, 3), backup_1 (5, 3)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionCount":
            suggest = "retention_count"
        elif key == "totalRetentionCount":
            suggest = "total_retention_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QuantityBasedExpiryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QuantityBasedExpiryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QuantityBasedExpiryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_count: int,
                 total_retention_count: int):
        """
        A backup's position in a quantity-based retention queue, of backups with the same source cluster and type, with length, retention, specified by the backup's retention policy. Once the position is greater than the retention, the backup is eligible to be garbage collected. Example: 5 backups from the same source cluster and type with a quantity-based retention of 3 and denoted by backup_id (position, retention). Safe: backup_5 (1, 3), backup_4, (2, 3), backup_3 (3, 3). Awaiting garbage collection: backup_2 (4, 3), backup_1 (5, 3)
        :param int retention_count: The backup's position among its backups with the same source cluster and type, by descending chronological order create time(i.e. newest first).
        :param int total_retention_count: The length of the quantity-based queue, specified by the backup's retention policy.
        """
        pulumi.set(__self__, "retention_count", retention_count)
        pulumi.set(__self__, "total_retention_count", total_retention_count)

    @property
    @pulumi.getter(name="retentionCount")
    def retention_count(self) -> int:
        """
        The backup's position among its backups with the same source cluster and type, by descending chronological order create time(i.e. newest first).
        """
        return pulumi.get(self, "retention_count")

    @property
    @pulumi.getter(name="totalRetentionCount")
    def total_retention_count(self) -> int:
        """
        The length of the quantity-based queue, specified by the backup's retention policy.
        """
        return pulumi.get(self, "total_retention_count")


@pulumi.output_type
class QuantityBasedRetentionResponse(dict):
    """
    A quantity based policy specifies that a certain number of the most recent successful backups should be retained.
    """
    def __init__(__self__, *,
                 count: int):
        """
        A quantity based policy specifies that a certain number of the most recent successful backups should be retained.
        :param int count: The number of backups to retain.
        """
        pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of backups to retain.
        """
        return pulumi.get(self, "count")


@pulumi.output_type
class QueryInsightsInstanceConfigResponse(dict):
    """
    QueryInsights Instance specific configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryPlansPerMinute":
            suggest = "query_plans_per_minute"
        elif key == "queryStringLength":
            suggest = "query_string_length"
        elif key == "recordApplicationTags":
            suggest = "record_application_tags"
        elif key == "recordClientAddress":
            suggest = "record_client_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueryInsightsInstanceConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueryInsightsInstanceConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueryInsightsInstanceConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_plans_per_minute: int,
                 query_string_length: int,
                 record_application_tags: bool,
                 record_client_address: bool):
        """
        QueryInsights Instance specific configuration.
        :param int query_plans_per_minute: Number of query execution plans captured by Insights per minute for all queries combined. The default value is 5. Any integer between 0 and 20 is considered valid.
        :param int query_string_length: Query string length. The default value is 1024. Any integer between 256 and 4500 is considered valid.
        :param bool record_application_tags: Record application tags for an instance. This flag is turned "on" by default.
        :param bool record_client_address: Record client address for an instance. Client address is PII information. This flag is turned "on" by default.
        """
        pulumi.set(__self__, "query_plans_per_minute", query_plans_per_minute)
        pulumi.set(__self__, "query_string_length", query_string_length)
        pulumi.set(__self__, "record_application_tags", record_application_tags)
        pulumi.set(__self__, "record_client_address", record_client_address)

    @property
    @pulumi.getter(name="queryPlansPerMinute")
    def query_plans_per_minute(self) -> int:
        """
        Number of query execution plans captured by Insights per minute for all queries combined. The default value is 5. Any integer between 0 and 20 is considered valid.
        """
        return pulumi.get(self, "query_plans_per_minute")

    @property
    @pulumi.getter(name="queryStringLength")
    def query_string_length(self) -> int:
        """
        Query string length. The default value is 1024. Any integer between 256 and 4500 is considered valid.
        """
        return pulumi.get(self, "query_string_length")

    @property
    @pulumi.getter(name="recordApplicationTags")
    def record_application_tags(self) -> bool:
        """
        Record application tags for an instance. This flag is turned "on" by default.
        """
        return pulumi.get(self, "record_application_tags")

    @property
    @pulumi.getter(name="recordClientAddress")
    def record_client_address(self) -> bool:
        """
        Record client address for an instance. Client address is PII information. This flag is turned "on" by default.
        """
        return pulumi.get(self, "record_client_address")


@pulumi.output_type
class ReadPoolConfigResponse(dict):
    """
    Configuration for a read pool instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeCount":
            suggest = "node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReadPoolConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReadPoolConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReadPoolConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_count: int):
        """
        Configuration for a read pool instance.
        :param int node_count: Read capacity, i.e. number of nodes in a read pool instance.
        """
        pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> int:
        """
        Read capacity, i.e. number of nodes in a read pool instance.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class SecondaryConfigResponse(dict):
    """
    Configuration information for the secondary cluster. This should be set if and only if the cluster is of type SECONDARY.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryClusterName":
            suggest = "primary_cluster_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecondaryConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecondaryConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecondaryConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary_cluster_name: str):
        """
        Configuration information for the secondary cluster. This should be set if and only if the cluster is of type SECONDARY.
        :param str primary_cluster_name: The name of the primary cluster name with the format: * projects/{project}/locations/{region}/clusters/{cluster_id}
        """
        pulumi.set(__self__, "primary_cluster_name", primary_cluster_name)

    @property
    @pulumi.getter(name="primaryClusterName")
    def primary_cluster_name(self) -> str:
        """
        The name of the primary cluster name with the format: * projects/{project}/locations/{region}/clusters/{cluster_id}
        """
        return pulumi.get(self, "primary_cluster_name")


@pulumi.output_type
class SslConfigResponse(dict):
    """
    SSL configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caSource":
            suggest = "ca_source"
        elif key == "sslMode":
            suggest = "ssl_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SslConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SslConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SslConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_source: str,
                 ssl_mode: str):
        """
        SSL configuration.
        :param str ca_source: Optional. Certificate Authority (CA) source. Only CA_SOURCE_MANAGED is supported currently, and is the default value.
        :param str ssl_mode: Optional. SSL mode. Specifies client-server SSL/TLS connection behavior.
        """
        pulumi.set(__self__, "ca_source", ca_source)
        pulumi.set(__self__, "ssl_mode", ssl_mode)

    @property
    @pulumi.getter(name="caSource")
    def ca_source(self) -> str:
        """
        Optional. Certificate Authority (CA) source. Only CA_SOURCE_MANAGED is supported currently, and is the default value.
        """
        return pulumi.get(self, "ca_source")

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> str:
        """
        Optional. SSL mode. Specifies client-server SSL/TLS connection behavior.
        """
        return pulumi.get(self, "ssl_mode")


@pulumi.output_type
class TimeBasedRetentionResponse(dict):
    """
    A time based retention policy specifies that all backups within a certain time period should be retained.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionPeriod":
            suggest = "retention_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TimeBasedRetentionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TimeBasedRetentionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TimeBasedRetentionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_period: str):
        """
        A time based retention policy specifies that all backups within a certain time period should be retained.
        :param str retention_period: The retention period.
        """
        pulumi.set(__self__, "retention_period", retention_period)

    @property
    @pulumi.getter(name="retentionPeriod")
    def retention_period(self) -> str:
        """
        The retention period.
        """
        return pulumi.get(self, "retention_period")


@pulumi.output_type
class UpdatePolicyResponse(dict):
    """
    Policy to be used while updating the instance.
    """
    def __init__(__self__, *,
                 mode: str):
        """
        Policy to be used while updating the instance.
        :param str mode: Mode for updating the instance.
        """
        pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Mode for updating the instance.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class UserPasswordResponse(dict):
    """
    The username/password for a database user. Used for specifying initial users at cluster creation time.
    """
    def __init__(__self__, *,
                 password: str,
                 user: str):
        """
        The username/password for a database user. Used for specifying initial users at cluster creation time.
        :param str password: The initial password for the user.
        :param str user: The database username.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The initial password for the user.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def user(self) -> str:
        """
        The database username.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class WeeklyScheduleResponse(dict):
    """
    A weekly schedule starts a backup at prescribed start times within a day, for the specified days of the week. The weekly schedule message is flexible and can be used to create many types of schedules. For example, to have a daily backup that starts at 22:00, configure the `start_times` field to have one element "22:00" and the `days_of_week` field to have all seven days of the week.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfWeek":
            suggest = "days_of_week"
        elif key == "startTimes":
            suggest = "start_times"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WeeklyScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WeeklyScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WeeklyScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_week: Sequence[str],
                 start_times: Sequence['outputs.GoogleTypeTimeOfDayResponse']):
        """
        A weekly schedule starts a backup at prescribed start times within a day, for the specified days of the week. The weekly schedule message is flexible and can be used to create many types of schedules. For example, to have a daily backup that starts at 22:00, configure the `start_times` field to have one element "22:00" and the `days_of_week` field to have all seven days of the week.
        :param Sequence[str] days_of_week: The days of the week to perform a backup. If this field is left empty, the default of every day of the week is used.
        :param Sequence['GoogleTypeTimeOfDayResponse'] start_times: The times during the day to start a backup. The start times are assumed to be in UTC and to be an exact hour (e.g., 04:00:00). If no start times are provided, a single fixed start time is chosen arbitrarily.
        """
        pulumi.set(__self__, "days_of_week", days_of_week)
        pulumi.set(__self__, "start_times", start_times)

    @property
    @pulumi.getter(name="daysOfWeek")
    def days_of_week(self) -> Sequence[str]:
        """
        The days of the week to perform a backup. If this field is left empty, the default of every day of the week is used.
        """
        return pulumi.get(self, "days_of_week")

    @property
    @pulumi.getter(name="startTimes")
    def start_times(self) -> Sequence['outputs.GoogleTypeTimeOfDayResponse']:
        """
        The times during the day to start a backup. The start times are assumed to be in UTC and to be an exact hour (e.g., 04:00:00). If no start times are provided, a single fixed start time is chosen arbitrarily.
        """
        return pulumi.get(self, "start_times")


