# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AcceleratorResponse',
    'ActionConditionResponse',
    'AllocationPolicyResponse',
    'AttachedDiskResponse',
    'BarrierResponse',
    'CloudLoggingOptionResponse',
    'ComputeResourceResponse',
    'ContainerResponse',
    'DiskResponse',
    'EnvironmentResponse',
    'GCSResponse',
    'InstancePolicyOrTemplateResponse',
    'InstancePolicyResponse',
    'InstanceStatusResponse',
    'JobNotificationResponse',
    'JobStatusResponse',
    'KMSEnvMapResponse',
    'LifecyclePolicyResponse',
    'LocationPolicyResponse',
    'LogsPolicyResponse',
    'MessageResponse',
    'NFSResponse',
    'NetworkInterfaceResponse',
    'NetworkPolicyResponse',
    'PlacementPolicyResponse',
    'RunnableResponse',
    'ScriptResponse',
    'ServiceAccountResponse',
    'StatusEventResponse',
    'TaskExecutionResponse',
    'TaskGroupResponse',
    'TaskGroupStatusResponse',
    'TaskSpecResponse',
    'VolumeResponse',
]

@pulumi.output_type
class AcceleratorResponse(dict):
    """
    Accelerator describes Compute Engine accelerators to be attached to the VM.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "driverVersion":
            suggest = "driver_version"
        elif key == "installGpuDrivers":
            suggest = "install_gpu_drivers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AcceleratorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AcceleratorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AcceleratorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: str,
                 driver_version: str,
                 install_gpu_drivers: bool,
                 type: str):
        """
        Accelerator describes Compute Engine accelerators to be attached to the VM.
        :param str count: The number of accelerators of this type.
        :param str driver_version: Optional. The NVIDIA GPU driver version that should be installed for this type. You can define the specific driver version such as "470.103.01", following the driver version requirements in https://cloud.google.com/compute/docs/gpus/install-drivers-gpu#minimum-driver. Batch will install the specific accelerator driver if qualified.
        :param bool install_gpu_drivers: Deprecated: please use instances[0].install_gpu_drivers instead.
        :param str type: The accelerator type. For example, "nvidia-tesla-t4". See `gcloud compute accelerator-types list`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "driver_version", driver_version)
        pulumi.set(__self__, "install_gpu_drivers", install_gpu_drivers)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def count(self) -> str:
        """
        The number of accelerators of this type.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="driverVersion")
    def driver_version(self) -> str:
        """
        Optional. The NVIDIA GPU driver version that should be installed for this type. You can define the specific driver version such as "470.103.01", following the driver version requirements in https://cloud.google.com/compute/docs/gpus/install-drivers-gpu#minimum-driver. Batch will install the specific accelerator driver if qualified.
        """
        return pulumi.get(self, "driver_version")

    @property
    @pulumi.getter(name="installGpuDrivers")
    @_utilities.deprecated("""Deprecated: please use instances[0].install_gpu_drivers instead.""")
    def install_gpu_drivers(self) -> bool:
        """
        Deprecated: please use instances[0].install_gpu_drivers instead.
        """
        return pulumi.get(self, "install_gpu_drivers")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The accelerator type. For example, "nvidia-tesla-t4". See `gcloud compute accelerator-types list`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ActionConditionResponse(dict):
    """
    Conditions for actions to deal with task failures.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exitCodes":
            suggest = "exit_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exit_codes: Sequence[int]):
        """
        Conditions for actions to deal with task failures.
        :param Sequence[int] exit_codes: Exit codes of a task execution. If there are more than 1 exit codes, when task executes with any of the exit code in the list, the condition is met and the action will be executed.
        """
        pulumi.set(__self__, "exit_codes", exit_codes)

    @property
    @pulumi.getter(name="exitCodes")
    def exit_codes(self) -> Sequence[int]:
        """
        Exit codes of a task execution. If there are more than 1 exit codes, when task executes with any of the exit code in the list, the condition is met and the action will be executed.
        """
        return pulumi.get(self, "exit_codes")


@pulumi.output_type
class AllocationPolicyResponse(dict):
    """
    A Job's resource allocation policy describes when, where, and how compute resources should be allocated for the Job.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccount":
            suggest = "service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AllocationPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AllocationPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AllocationPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instances: Sequence['outputs.InstancePolicyOrTemplateResponse'],
                 labels: Mapping[str, str],
                 location: 'outputs.LocationPolicyResponse',
                 network: 'outputs.NetworkPolicyResponse',
                 placement: 'outputs.PlacementPolicyResponse',
                 service_account: 'outputs.ServiceAccountResponse'):
        """
        A Job's resource allocation policy describes when, where, and how compute resources should be allocated for the Job.
        :param Sequence['InstancePolicyOrTemplateResponse'] instances: Describe instances that can be created by this AllocationPolicy. Only instances[0] is supported now.
        :param Mapping[str, str] labels: Labels applied to all VM instances and other resources created by AllocationPolicy. Labels could be user provided or system generated. You can assign up to 64 labels. [Google Compute Engine label restrictions](https://cloud.google.com/compute/docs/labeling-resources#restrictions) apply. Label names that start with "goog-" or "google-" are reserved.
        :param 'LocationPolicyResponse' location: Location where compute resources should be allocated for the Job.
        :param 'NetworkPolicyResponse' network: The network policy. If you define an instance template in the InstancePolicyOrTemplate field, Batch will use the network settings in the instance template instead of this field.
        :param 'PlacementPolicyResponse' placement: The placement policy.
        :param 'ServiceAccountResponse' service_account: Service account that VMs will run as.
        """
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "placement", placement)
        pulumi.set(__self__, "service_account", service_account)

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.InstancePolicyOrTemplateResponse']:
        """
        Describe instances that can be created by this AllocationPolicy. Only instances[0] is supported now.
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Labels applied to all VM instances and other resources created by AllocationPolicy. Labels could be user provided or system generated. You can assign up to 64 labels. [Google Compute Engine label restrictions](https://cloud.google.com/compute/docs/labeling-resources#restrictions) apply. Label names that start with "goog-" or "google-" are reserved.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def location(self) -> 'outputs.LocationPolicyResponse':
        """
        Location where compute resources should be allocated for the Job.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def network(self) -> 'outputs.NetworkPolicyResponse':
        """
        The network policy. If you define an instance template in the InstancePolicyOrTemplate field, Batch will use the network settings in the instance template instead of this field.
        """
        return pulumi.get(self, "network")

    @property
    @pulumi.getter
    def placement(self) -> 'outputs.PlacementPolicyResponse':
        """
        The placement policy.
        """
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> 'outputs.ServiceAccountResponse':
        """
        Service account that VMs will run as.
        """
        return pulumi.get(self, "service_account")


@pulumi.output_type
class AttachedDiskResponse(dict):
    """
    A new or an existing persistent disk (PD) or a local ssd attached to a VM instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "existingDisk":
            suggest = "existing_disk"
        elif key == "newDisk":
            suggest = "new_disk"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AttachedDiskResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AttachedDiskResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AttachedDiskResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: str,
                 existing_disk: str,
                 new_disk: 'outputs.DiskResponse'):
        """
        A new or an existing persistent disk (PD) or a local ssd attached to a VM instance.
        :param str device_name: Device name that the guest operating system will see. It is used by Runnable.volumes field to mount disks. So please specify the device_name if you want Batch to help mount the disk, and it should match the device_name field in volumes.
        :param str existing_disk: Name of an existing PD.
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "existing_disk", existing_disk)
        pulumi.set(__self__, "new_disk", new_disk)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        Device name that the guest operating system will see. It is used by Runnable.volumes field to mount disks. So please specify the device_name if you want Batch to help mount the disk, and it should match the device_name field in volumes.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="existingDisk")
    def existing_disk(self) -> str:
        """
        Name of an existing PD.
        """
        return pulumi.get(self, "existing_disk")

    @property
    @pulumi.getter(name="newDisk")
    def new_disk(self) -> 'outputs.DiskResponse':
        return pulumi.get(self, "new_disk")


@pulumi.output_type
class BarrierResponse(dict):
    """
    Barrier runnable blocks until all tasks in a taskgroup reach it.
    """
    def __init__(__self__, *,
                 name: str):
        """
        Barrier runnable blocks until all tasks in a taskgroup reach it.
        :param str name: Barriers are identified by their index in runnable list. Names are not required, but if present should be an identifier.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Barriers are identified by their index in runnable list. Names are not required, but if present should be an identifier.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CloudLoggingOptionResponse(dict):
    """
    CloudLoggingOption contains additional settings for cloud logging generated by Batch job.
    """
    def __init__(__self__):
        """
        CloudLoggingOption contains additional settings for cloud logging generated by Batch job.
        """
        pass


@pulumi.output_type
class ComputeResourceResponse(dict):
    """
    Compute resource requirements. ComputeResource defines the amount of resources required for each task. Make sure your tasks have enough resources to successfully run. If you also define the types of resources for a job to use with the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure both fields are compatible with each other.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDiskMib":
            suggest = "boot_disk_mib"
        elif key == "cpuMilli":
            suggest = "cpu_milli"
        elif key == "memoryMib":
            suggest = "memory_mib"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeResourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeResourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeResourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boot_disk_mib: str,
                 cpu_milli: str,
                 memory_mib: str):
        """
        Compute resource requirements. ComputeResource defines the amount of resources required for each task. Make sure your tasks have enough resources to successfully run. If you also define the types of resources for a job to use with the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure both fields are compatible with each other.
        :param str boot_disk_mib: Extra boot disk size in MiB for each task.
        :param str cpu_milli: The milliCPU count. `cpuMilli` defines the amount of CPU resources per task in milliCPU units. For example, `1000` corresponds to 1 vCPU per task. If undefined, the default value is `2000`. If you also define the VM's machine type using the `machineType` in [InstancePolicy](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy) field or inside the `instanceTemplate` in the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure the CPU resources for both fields are compatible with each other and with how many tasks you want to allow to run on the same VM at the same time. For example, if you specify the `n2-standard-2` machine type, which has 2 vCPUs each, you are recommended to set `cpuMilli` no more than `2000`, or you are recommended to run two tasks on the same VM if you set `cpuMilli` to `1000` or less.
        :param str memory_mib: Memory in MiB. `memoryMib` defines the amount of memory per task in MiB units. If undefined, the default value is `2000`. If you also define the VM's machine type using the `machineType` in [InstancePolicy](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy) field or inside the `instanceTemplate` in the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure the memory resources for both fields are compatible with each other and with how many tasks you want to allow to run on the same VM at the same time. For example, if you specify the `n2-standard-2` machine type, which has 8 GiB each, you are recommended to set `memoryMib` to no more than `8192`, or you are recommended to run two tasks on the same VM if you set `memoryMib` to `4096` or less.
        """
        pulumi.set(__self__, "boot_disk_mib", boot_disk_mib)
        pulumi.set(__self__, "cpu_milli", cpu_milli)
        pulumi.set(__self__, "memory_mib", memory_mib)

    @property
    @pulumi.getter(name="bootDiskMib")
    def boot_disk_mib(self) -> str:
        """
        Extra boot disk size in MiB for each task.
        """
        return pulumi.get(self, "boot_disk_mib")

    @property
    @pulumi.getter(name="cpuMilli")
    def cpu_milli(self) -> str:
        """
        The milliCPU count. `cpuMilli` defines the amount of CPU resources per task in milliCPU units. For example, `1000` corresponds to 1 vCPU per task. If undefined, the default value is `2000`. If you also define the VM's machine type using the `machineType` in [InstancePolicy](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy) field or inside the `instanceTemplate` in the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure the CPU resources for both fields are compatible with each other and with how many tasks you want to allow to run on the same VM at the same time. For example, if you specify the `n2-standard-2` machine type, which has 2 vCPUs each, you are recommended to set `cpuMilli` no more than `2000`, or you are recommended to run two tasks on the same VM if you set `cpuMilli` to `1000` or less.
        """
        return pulumi.get(self, "cpu_milli")

    @property
    @pulumi.getter(name="memoryMib")
    def memory_mib(self) -> str:
        """
        Memory in MiB. `memoryMib` defines the amount of memory per task in MiB units. If undefined, the default value is `2000`. If you also define the VM's machine type using the `machineType` in [InstancePolicy](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy) field or inside the `instanceTemplate` in the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure the memory resources for both fields are compatible with each other and with how many tasks you want to allow to run on the same VM at the same time. For example, if you specify the `n2-standard-2` machine type, which has 8 GiB each, you are recommended to set `memoryMib` to no more than `8192`, or you are recommended to run two tasks on the same VM if you set `memoryMib` to `4096` or less.
        """
        return pulumi.get(self, "memory_mib")


@pulumi.output_type
class ContainerResponse(dict):
    """
    Container runnable.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockExternalNetwork":
            suggest = "block_external_network"
        elif key == "imageUri":
            suggest = "image_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_external_network: bool,
                 commands: Sequence[str],
                 entrypoint: str,
                 image_uri: str,
                 options: str,
                 password: str,
                 username: str,
                 volumes: Sequence[str]):
        """
        Container runnable.
        :param bool block_external_network: If set to true, external network access to and from container will be blocked, containers that are with block_external_network as true can still communicate with each other, network cannot be specified in the `container.options` field.
        :param Sequence[str] commands: Overrides the `CMD` specified in the container. If there is an ENTRYPOINT (either in the container image or with the entrypoint field below) then commands are appended as arguments to the ENTRYPOINT.
        :param str entrypoint: Overrides the `ENTRYPOINT` specified in the container.
        :param str image_uri: The URI to pull the container image from.
        :param str options: Arbitrary additional options to include in the "docker run" command when running this container, e.g. "--network host".
        :param str password: Optional password for logging in to a docker registry. If password matches `projects/*/secrets/*/versions/*` then Batch will read the password from the Secret Manager;
        :param str username: Optional username for logging in to a docker registry. If username matches `projects/*/secrets/*/versions/*` then Batch will read the username from the Secret Manager.
        :param Sequence[str] volumes: Volumes to mount (bind mount) from the host machine files or directories into the container, formatted to match docker run's --volume option, e.g. /foo:/bar, or /foo:/bar:ro If the `TaskSpec.Volumes` field is specified but this field is not, Batch will mount each volume from the host machine to the container with the same mount path by default. In this case, the default mount option for containers will be read-only (ro) for existing persistent disks and read-write (rw) for other volume types, regardless of the original mount options specified in `TaskSpec.Volumes`. If you need different mount settings, you can explicitly configure them in this field.
        """
        pulumi.set(__self__, "block_external_network", block_external_network)
        pulumi.set(__self__, "commands", commands)
        pulumi.set(__self__, "entrypoint", entrypoint)
        pulumi.set(__self__, "image_uri", image_uri)
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter(name="blockExternalNetwork")
    def block_external_network(self) -> bool:
        """
        If set to true, external network access to and from container will be blocked, containers that are with block_external_network as true can still communicate with each other, network cannot be specified in the `container.options` field.
        """
        return pulumi.get(self, "block_external_network")

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        """
        Overrides the `CMD` specified in the container. If there is an ENTRYPOINT (either in the container image or with the entrypoint field below) then commands are appended as arguments to the ENTRYPOINT.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def entrypoint(self) -> str:
        """
        Overrides the `ENTRYPOINT` specified in the container.
        """
        return pulumi.get(self, "entrypoint")

    @property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> str:
        """
        The URI to pull the container image from.
        """
        return pulumi.get(self, "image_uri")

    @property
    @pulumi.getter
    def options(self) -> str:
        """
        Arbitrary additional options to include in the "docker run" command when running this container, e.g. "--network host".
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Optional password for logging in to a docker registry. If password matches `projects/*/secrets/*/versions/*` then Batch will read the password from the Secret Manager;
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Optional username for logging in to a docker registry. If username matches `projects/*/secrets/*/versions/*` then Batch will read the username from the Secret Manager.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def volumes(self) -> Sequence[str]:
        """
        Volumes to mount (bind mount) from the host machine files or directories into the container, formatted to match docker run's --volume option, e.g. /foo:/bar, or /foo:/bar:ro If the `TaskSpec.Volumes` field is specified but this field is not, Batch will mount each volume from the host machine to the container with the same mount path by default. In this case, the default mount option for containers will be read-only (ro) for existing persistent disks and read-write (rw) for other volume types, regardless of the original mount options specified in `TaskSpec.Volumes`. If you need different mount settings, you can explicitly configure them in this field.
        """
        return pulumi.get(self, "volumes")


@pulumi.output_type
class DiskResponse(dict):
    """
    A new persistent disk or a local ssd. A VM can only have one local SSD setting but multiple local SSD partitions. See https://cloud.google.com/compute/docs/disks#pdspecs and https://cloud.google.com/compute/docs/disks#localssds.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskInterface":
            suggest = "disk_interface"
        elif key == "sizeGb":
            suggest = "size_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_interface: str,
                 image: str,
                 size_gb: str,
                 snapshot: str,
                 type: str):
        """
        A new persistent disk or a local ssd. A VM can only have one local SSD setting but multiple local SSD partitions. See https://cloud.google.com/compute/docs/disks#pdspecs and https://cloud.google.com/compute/docs/disks#localssds.
        :param str disk_interface: Local SSDs are available through both "SCSI" and "NVMe" interfaces. If not indicated, "NVMe" will be the default one for local ssds. This field is ignored for persistent disks as the interface is chosen automatically. See https://cloud.google.com/compute/docs/disks/persistent-disks#choose_an_interface.
        :param str image: URL for a VM image to use as the data source for this disk. For example, the following are all valid URLs: * Specify the image by its family name: projects/{project}/global/images/family/{image_family} * Specify the image version: projects/{project}/global/images/{image_version} You can also use Batch customized image in short names. The following image values are supported for a boot disk: * `batch-debian`: use Batch Debian images. * `batch-centos`: use Batch CentOS images. * `batch-cos`: use Batch Container-Optimized images. * `batch-hpc-centos`: use Batch HPC CentOS images. * `batch-hpc-rocky`: use Batch HPC Rocky Linux images.
        :param str size_gb: Disk size in GB. **Non-Boot Disk**: If the `type` specifies a persistent disk, this field is ignored if `data_source` is set as `image` or `snapshot`. If the `type` specifies a local SSD, this field should be a multiple of 375 GB, otherwise, the final size will be the next greater multiple of 375 GB. **Boot Disk**: Batch will calculate the boot disk size based on source image and task requirements if you do not speicify the size. If both this field and the `boot_disk_mib` field in task spec's `compute_resource` are defined, Batch will only honor this field. Also, this field should be no smaller than the source disk's size when the `data_source` is set as `snapshot` or `image`. For example, if you set an image as the `data_source` field and the image's default disk size 30 GB, you can only use this field to make the disk larger or equal to 30 GB.
        :param str snapshot: Name of a snapshot used as the data source. Snapshot is not supported as boot disk now.
        :param str type: Disk type as shown in `gcloud compute disk-types list`. For example, local SSD uses type "local-ssd". Persistent disks and boot disks use "pd-balanced", "pd-extreme", "pd-ssd" or "pd-standard".
        """
        pulumi.set(__self__, "disk_interface", disk_interface)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "size_gb", size_gb)
        pulumi.set(__self__, "snapshot", snapshot)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="diskInterface")
    def disk_interface(self) -> str:
        """
        Local SSDs are available through both "SCSI" and "NVMe" interfaces. If not indicated, "NVMe" will be the default one for local ssds. This field is ignored for persistent disks as the interface is chosen automatically. See https://cloud.google.com/compute/docs/disks/persistent-disks#choose_an_interface.
        """
        return pulumi.get(self, "disk_interface")

    @property
    @pulumi.getter
    def image(self) -> str:
        """
        URL for a VM image to use as the data source for this disk. For example, the following are all valid URLs: * Specify the image by its family name: projects/{project}/global/images/family/{image_family} * Specify the image version: projects/{project}/global/images/{image_version} You can also use Batch customized image in short names. The following image values are supported for a boot disk: * `batch-debian`: use Batch Debian images. * `batch-centos`: use Batch CentOS images. * `batch-cos`: use Batch Container-Optimized images. * `batch-hpc-centos`: use Batch HPC CentOS images. * `batch-hpc-rocky`: use Batch HPC Rocky Linux images.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> str:
        """
        Disk size in GB. **Non-Boot Disk**: If the `type` specifies a persistent disk, this field is ignored if `data_source` is set as `image` or `snapshot`. If the `type` specifies a local SSD, this field should be a multiple of 375 GB, otherwise, the final size will be the next greater multiple of 375 GB. **Boot Disk**: Batch will calculate the boot disk size based on source image and task requirements if you do not speicify the size. If both this field and the `boot_disk_mib` field in task spec's `compute_resource` are defined, Batch will only honor this field. Also, this field should be no smaller than the source disk's size when the `data_source` is set as `snapshot` or `image`. For example, if you set an image as the `data_source` field and the image's default disk size 30 GB, you can only use this field to make the disk larger or equal to 30 GB.
        """
        return pulumi.get(self, "size_gb")

    @property
    @pulumi.getter
    def snapshot(self) -> str:
        """
        Name of a snapshot used as the data source. Snapshot is not supported as boot disk now.
        """
        return pulumi.get(self, "snapshot")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Disk type as shown in `gcloud compute disk-types list`. For example, local SSD uses type "local-ssd". Persistent disks and boot disks use "pd-balanced", "pd-extreme", "pd-ssd" or "pd-standard".
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EnvironmentResponse(dict):
    """
    An Environment describes a collection of environment variables to set when executing Tasks.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptedVariables":
            suggest = "encrypted_variables"
        elif key == "secretVariables":
            suggest = "secret_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encrypted_variables: 'outputs.KMSEnvMapResponse',
                 secret_variables: Mapping[str, str],
                 variables: Mapping[str, str]):
        """
        An Environment describes a collection of environment variables to set when executing Tasks.
        :param 'KMSEnvMapResponse' encrypted_variables: An encrypted JSON dictionary where the key/value pairs correspond to environment variable names and their values.
        :param Mapping[str, str] secret_variables: A map of environment variable names to Secret Manager secret names. The VM will access the named secrets to set the value of each environment variable.
        :param Mapping[str, str] variables: A map of environment variable names to values.
        """
        pulumi.set(__self__, "encrypted_variables", encrypted_variables)
        pulumi.set(__self__, "secret_variables", secret_variables)
        pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter(name="encryptedVariables")
    def encrypted_variables(self) -> 'outputs.KMSEnvMapResponse':
        """
        An encrypted JSON dictionary where the key/value pairs correspond to environment variable names and their values.
        """
        return pulumi.get(self, "encrypted_variables")

    @property
    @pulumi.getter(name="secretVariables")
    def secret_variables(self) -> Mapping[str, str]:
        """
        A map of environment variable names to Secret Manager secret names. The VM will access the named secrets to set the value of each environment variable.
        """
        return pulumi.get(self, "secret_variables")

    @property
    @pulumi.getter
    def variables(self) -> Mapping[str, str]:
        """
        A map of environment variable names to values.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class GCSResponse(dict):
    """
    Represents a Google Cloud Storage volume.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "remotePath":
            suggest = "remote_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GCSResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GCSResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GCSResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 remote_path: str):
        """
        Represents a Google Cloud Storage volume.
        :param str remote_path: Remote path, either a bucket name or a subdirectory of a bucket, e.g.: bucket_name, bucket_name/subdirectory/
        """
        pulumi.set(__self__, "remote_path", remote_path)

    @property
    @pulumi.getter(name="remotePath")
    def remote_path(self) -> str:
        """
        Remote path, either a bucket name or a subdirectory of a bucket, e.g.: bucket_name, bucket_name/subdirectory/
        """
        return pulumi.get(self, "remote_path")


@pulumi.output_type
class InstancePolicyOrTemplateResponse(dict):
    """
    InstancePolicyOrTemplate lets you define the type of resources to use for this job either with an InstancePolicy or an instance template. If undefined, Batch picks the type of VM to use and doesn't include optional VM resources such as GPUs and extra disks.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "installGpuDrivers":
            suggest = "install_gpu_drivers"
        elif key == "instanceTemplate":
            suggest = "instance_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePolicyOrTemplateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePolicyOrTemplateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePolicyOrTemplateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 install_gpu_drivers: bool,
                 instance_template: str,
                 policy: 'outputs.InstancePolicyResponse'):
        """
        InstancePolicyOrTemplate lets you define the type of resources to use for this job either with an InstancePolicy or an instance template. If undefined, Batch picks the type of VM to use and doesn't include optional VM resources such as GPUs and extra disks.
        :param bool install_gpu_drivers: Set this field true if users want Batch to help fetch drivers from a third party location and install them for GPUs specified in policy.accelerators or instance_template on their behalf. Default is false. For Container-Optimized Image cases, Batch will install the accelerator driver following milestones of https://cloud.google.com/container-optimized-os/docs/release-notes. For non Container-Optimized Image cases, following https://github.com/GoogleCloudPlatform/compute-gpu-installation/blob/main/linux/install_gpu_driver.py.
        :param str instance_template: Name of an instance template used to create VMs. Named the field as 'instance_template' instead of 'template' to avoid c++ keyword conflict.
        :param 'InstancePolicyResponse' policy: InstancePolicy.
        """
        pulumi.set(__self__, "install_gpu_drivers", install_gpu_drivers)
        pulumi.set(__self__, "instance_template", instance_template)
        pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter(name="installGpuDrivers")
    def install_gpu_drivers(self) -> bool:
        """
        Set this field true if users want Batch to help fetch drivers from a third party location and install them for GPUs specified in policy.accelerators or instance_template on their behalf. Default is false. For Container-Optimized Image cases, Batch will install the accelerator driver following milestones of https://cloud.google.com/container-optimized-os/docs/release-notes. For non Container-Optimized Image cases, following https://github.com/GoogleCloudPlatform/compute-gpu-installation/blob/main/linux/install_gpu_driver.py.
        """
        return pulumi.get(self, "install_gpu_drivers")

    @property
    @pulumi.getter(name="instanceTemplate")
    def instance_template(self) -> str:
        """
        Name of an instance template used to create VMs. Named the field as 'instance_template' instead of 'template' to avoid c++ keyword conflict.
        """
        return pulumi.get(self, "instance_template")

    @property
    @pulumi.getter
    def policy(self) -> 'outputs.InstancePolicyResponse':
        """
        InstancePolicy.
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class InstancePolicyResponse(dict):
    """
    InstancePolicy describes an instance type and resources attached to each VM created by this InstancePolicy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDisk":
            suggest = "boot_disk"
        elif key == "machineType":
            suggest = "machine_type"
        elif key == "minCpuPlatform":
            suggest = "min_cpu_platform"
        elif key == "provisioningModel":
            suggest = "provisioning_model"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerators: Sequence['outputs.AcceleratorResponse'],
                 boot_disk: 'outputs.DiskResponse',
                 disks: Sequence['outputs.AttachedDiskResponse'],
                 machine_type: str,
                 min_cpu_platform: str,
                 provisioning_model: str,
                 reservation: str):
        """
        InstancePolicy describes an instance type and resources attached to each VM created by this InstancePolicy.
        :param Sequence['AcceleratorResponse'] accelerators: The accelerators attached to each VM instance.
        :param 'DiskResponse' boot_disk: Boot disk to be created and attached to each VM by this InstancePolicy. Boot disk will be deleted when the VM is deleted. Batch API now only supports booting from image.
        :param Sequence['AttachedDiskResponse'] disks: Non-boot disks to be attached for each VM created by this InstancePolicy. New disks will be deleted when the VM is deleted. A non-boot disk is a disk that can be of a device with a file system or a raw storage drive that is not ready for data storage and accessing.
        :param str machine_type: The Compute Engine machine type.
        :param str min_cpu_platform: The minimum CPU platform. See https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform.
        :param str provisioning_model: The provisioning model.
        :param str reservation: Optional. If specified, VMs will consume only the specified reservation. If not specified (default), VMs will consume any applicable reservation.
        """
        pulumi.set(__self__, "accelerators", accelerators)
        pulumi.set(__self__, "boot_disk", boot_disk)
        pulumi.set(__self__, "disks", disks)
        pulumi.set(__self__, "machine_type", machine_type)
        pulumi.set(__self__, "min_cpu_platform", min_cpu_platform)
        pulumi.set(__self__, "provisioning_model", provisioning_model)
        pulumi.set(__self__, "reservation", reservation)

    @property
    @pulumi.getter
    def accelerators(self) -> Sequence['outputs.AcceleratorResponse']:
        """
        The accelerators attached to each VM instance.
        """
        return pulumi.get(self, "accelerators")

    @property
    @pulumi.getter(name="bootDisk")
    def boot_disk(self) -> 'outputs.DiskResponse':
        """
        Boot disk to be created and attached to each VM by this InstancePolicy. Boot disk will be deleted when the VM is deleted. Batch API now only supports booting from image.
        """
        return pulumi.get(self, "boot_disk")

    @property
    @pulumi.getter
    def disks(self) -> Sequence['outputs.AttachedDiskResponse']:
        """
        Non-boot disks to be attached for each VM created by this InstancePolicy. New disks will be deleted when the VM is deleted. A non-boot disk is a disk that can be of a device with a file system or a raw storage drive that is not ready for data storage and accessing.
        """
        return pulumi.get(self, "disks")

    @property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> str:
        """
        The Compute Engine machine type.
        """
        return pulumi.get(self, "machine_type")

    @property
    @pulumi.getter(name="minCpuPlatform")
    def min_cpu_platform(self) -> str:
        """
        The minimum CPU platform. See https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform.
        """
        return pulumi.get(self, "min_cpu_platform")

    @property
    @pulumi.getter(name="provisioningModel")
    def provisioning_model(self) -> str:
        """
        The provisioning model.
        """
        return pulumi.get(self, "provisioning_model")

    @property
    @pulumi.getter
    def reservation(self) -> str:
        """
        Optional. If specified, VMs will consume only the specified reservation. If not specified (default), VMs will consume any applicable reservation.
        """
        return pulumi.get(self, "reservation")


@pulumi.output_type
class InstanceStatusResponse(dict):
    """
    VM instance status.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDisk":
            suggest = "boot_disk"
        elif key == "machineType":
            suggest = "machine_type"
        elif key == "provisioningModel":
            suggest = "provisioning_model"
        elif key == "taskPack":
            suggest = "task_pack"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boot_disk: 'outputs.DiskResponse',
                 machine_type: str,
                 provisioning_model: str,
                 task_pack: str):
        """
        VM instance status.
        :param 'DiskResponse' boot_disk: The VM boot disk.
        :param str machine_type: The Compute Engine machine type.
        :param str provisioning_model: The VM instance provisioning model.
        :param str task_pack: The max number of tasks can be assigned to this instance type.
        """
        pulumi.set(__self__, "boot_disk", boot_disk)
        pulumi.set(__self__, "machine_type", machine_type)
        pulumi.set(__self__, "provisioning_model", provisioning_model)
        pulumi.set(__self__, "task_pack", task_pack)

    @property
    @pulumi.getter(name="bootDisk")
    def boot_disk(self) -> 'outputs.DiskResponse':
        """
        The VM boot disk.
        """
        return pulumi.get(self, "boot_disk")

    @property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> str:
        """
        The Compute Engine machine type.
        """
        return pulumi.get(self, "machine_type")

    @property
    @pulumi.getter(name="provisioningModel")
    def provisioning_model(self) -> str:
        """
        The VM instance provisioning model.
        """
        return pulumi.get(self, "provisioning_model")

    @property
    @pulumi.getter(name="taskPack")
    def task_pack(self) -> str:
        """
        The max number of tasks can be assigned to this instance type.
        """
        return pulumi.get(self, "task_pack")


@pulumi.output_type
class JobNotificationResponse(dict):
    """
    Notification configurations.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pubsubTopic":
            suggest = "pubsub_topic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNotificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNotificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNotificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message: 'outputs.MessageResponse',
                 pubsub_topic: str):
        """
        Notification configurations.
        :param 'MessageResponse' message: The attribute requirements of messages to be sent to this Pub/Sub topic. Without this field, no message will be sent.
        :param str pubsub_topic: The Pub/Sub topic where notifications like the job state changes will be published. The topic must exist in the same project as the job and billings will be charged to this project. If not specified, no Pub/Sub messages will be sent. Topic format: `projects/{project}/topics/{topic}`.
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "pubsub_topic", pubsub_topic)

    @property
    @pulumi.getter
    def message(self) -> 'outputs.MessageResponse':
        """
        The attribute requirements of messages to be sent to this Pub/Sub topic. Without this field, no message will be sent.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="pubsubTopic")
    def pubsub_topic(self) -> str:
        """
        The Pub/Sub topic where notifications like the job state changes will be published. The topic must exist in the same project as the job and billings will be charged to this project. If not specified, no Pub/Sub messages will be sent. Topic format: `projects/{project}/topics/{topic}`.
        """
        return pulumi.get(self, "pubsub_topic")


@pulumi.output_type
class JobStatusResponse(dict):
    """
    Job status.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "runDuration":
            suggest = "run_duration"
        elif key == "statusEvents":
            suggest = "status_events"
        elif key == "taskGroups":
            suggest = "task_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 run_duration: str,
                 state: str,
                 status_events: Sequence['outputs.StatusEventResponse'],
                 task_groups: Mapping[str, 'outputs.TaskGroupStatusResponse']):
        """
        Job status.
        :param str run_duration: The duration of time that the Job spent in status RUNNING.
        :param str state: Job state
        :param Sequence['StatusEventResponse'] status_events: Job status events
        :param Mapping[str, 'TaskGroupStatusResponse'] task_groups: Aggregated task status for each TaskGroup in the Job. The map key is TaskGroup ID.
        """
        pulumi.set(__self__, "run_duration", run_duration)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "status_events", status_events)
        pulumi.set(__self__, "task_groups", task_groups)

    @property
    @pulumi.getter(name="runDuration")
    def run_duration(self) -> str:
        """
        The duration of time that the Job spent in status RUNNING.
        """
        return pulumi.get(self, "run_duration")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Job state
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="statusEvents")
    def status_events(self) -> Sequence['outputs.StatusEventResponse']:
        """
        Job status events
        """
        return pulumi.get(self, "status_events")

    @property
    @pulumi.getter(name="taskGroups")
    def task_groups(self) -> Mapping[str, 'outputs.TaskGroupStatusResponse']:
        """
        Aggregated task status for each TaskGroup in the Job. The map key is TaskGroup ID.
        """
        return pulumi.get(self, "task_groups")


@pulumi.output_type
class KMSEnvMapResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cipherText":
            suggest = "cipher_text"
        elif key == "keyName":
            suggest = "key_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KMSEnvMapResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KMSEnvMapResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KMSEnvMapResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cipher_text: str,
                 key_name: str):
        """
        :param str cipher_text: The value of the cipherText response from the `encrypt` method.
        :param str key_name: The name of the KMS key that will be used to decrypt the cipher text.
        """
        pulumi.set(__self__, "cipher_text", cipher_text)
        pulumi.set(__self__, "key_name", key_name)

    @property
    @pulumi.getter(name="cipherText")
    def cipher_text(self) -> str:
        """
        The value of the cipherText response from the `encrypt` method.
        """
        return pulumi.get(self, "cipher_text")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> str:
        """
        The name of the KMS key that will be used to decrypt the cipher text.
        """
        return pulumi.get(self, "key_name")


@pulumi.output_type
class LifecyclePolicyResponse(dict):
    """
    LifecyclePolicy describes how to deal with task failures based on different conditions.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionCondition":
            suggest = "action_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LifecyclePolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LifecyclePolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LifecyclePolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 action_condition: 'outputs.ActionConditionResponse'):
        """
        LifecyclePolicy describes how to deal with task failures based on different conditions.
        :param str action: Action to execute when ActionCondition is true. When RETRY_TASK is specified, we will retry failed tasks if we notice any exit code match and fail tasks if no match is found. Likewise, when FAIL_TASK is specified, we will fail tasks if we notice any exit code match and retry tasks if no match is found.
        :param 'ActionConditionResponse' action_condition: Conditions that decide why a task failure is dealt with a specific action.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "action_condition", action_condition)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action to execute when ActionCondition is true. When RETRY_TASK is specified, we will retry failed tasks if we notice any exit code match and fail tasks if no match is found. Likewise, when FAIL_TASK is specified, we will fail tasks if we notice any exit code match and retry tasks if no match is found.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="actionCondition")
    def action_condition(self) -> 'outputs.ActionConditionResponse':
        """
        Conditions that decide why a task failure is dealt with a specific action.
        """
        return pulumi.get(self, "action_condition")


@pulumi.output_type
class LocationPolicyResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedLocations":
            suggest = "allowed_locations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LocationPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LocationPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LocationPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_locations: Sequence[str]):
        """
        :param Sequence[str] allowed_locations: A list of allowed location names represented by internal URLs. Each location can be a region or a zone. Only one region or multiple zones in one region is supported now. For example, ["regions/us-central1"] allow VMs in any zones in region us-central1. ["zones/us-central1-a", "zones/us-central1-c"] only allow VMs in zones us-central1-a and us-central1-c. All locations end up in different regions would cause errors. For example, ["regions/us-central1", "zones/us-central1-a", "zones/us-central1-b", "zones/us-west1-a"] contains 2 regions "us-central1" and "us-west1". An error is expected in this case.
        """
        pulumi.set(__self__, "allowed_locations", allowed_locations)

    @property
    @pulumi.getter(name="allowedLocations")
    def allowed_locations(self) -> Sequence[str]:
        """
        A list of allowed location names represented by internal URLs. Each location can be a region or a zone. Only one region or multiple zones in one region is supported now. For example, ["regions/us-central1"] allow VMs in any zones in region us-central1. ["zones/us-central1-a", "zones/us-central1-c"] only allow VMs in zones us-central1-a and us-central1-c. All locations end up in different regions would cause errors. For example, ["regions/us-central1", "zones/us-central1-a", "zones/us-central1-b", "zones/us-west1-a"] contains 2 regions "us-central1" and "us-west1". An error is expected in this case.
        """
        return pulumi.get(self, "allowed_locations")


@pulumi.output_type
class LogsPolicyResponse(dict):
    """
    LogsPolicy describes how outputs from a Job's Tasks (stdout/stderr) will be preserved.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudLoggingOption":
            suggest = "cloud_logging_option"
        elif key == "logsPath":
            suggest = "logs_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_logging_option: 'outputs.CloudLoggingOptionResponse',
                 destination: str,
                 logs_path: str):
        """
        LogsPolicy describes how outputs from a Job's Tasks (stdout/stderr) will be preserved.
        :param 'CloudLoggingOptionResponse' cloud_logging_option: Optional. Additional settings for Cloud Logging. It will only take effect when the destination of LogsPolicy is set to CLOUD_LOGGING.
        :param str destination: Where logs should be saved.
        :param str logs_path: The path to which logs are saved when the destination = PATH. This can be a local file path on the VM, or under the mount point of a Persistent Disk or Filestore, or a Cloud Storage path.
        """
        pulumi.set(__self__, "cloud_logging_option", cloud_logging_option)
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "logs_path", logs_path)

    @property
    @pulumi.getter(name="cloudLoggingOption")
    def cloud_logging_option(self) -> 'outputs.CloudLoggingOptionResponse':
        """
        Optional. Additional settings for Cloud Logging. It will only take effect when the destination of LogsPolicy is set to CLOUD_LOGGING.
        """
        return pulumi.get(self, "cloud_logging_option")

    @property
    @pulumi.getter
    def destination(self) -> str:
        """
        Where logs should be saved.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="logsPath")
    def logs_path(self) -> str:
        """
        The path to which logs are saved when the destination = PATH. This can be a local file path on the VM, or under the mount point of a Persistent Disk or Filestore, or a Cloud Storage path.
        """
        return pulumi.get(self, "logs_path")


@pulumi.output_type
class MessageResponse(dict):
    """
    Message details. Describe the conditions under which messages will be sent. If no attribute is defined, no message will be sent by default. One message should specify either the job or the task level attributes, but not both. For example, job level: JOB_STATE_CHANGED and/or a specified new_job_state; task level: TASK_STATE_CHANGED and/or a specified new_task_state.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "newJobState":
            suggest = "new_job_state"
        elif key == "newTaskState":
            suggest = "new_task_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MessageResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MessageResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MessageResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 new_job_state: str,
                 new_task_state: str,
                 type: str):
        """
        Message details. Describe the conditions under which messages will be sent. If no attribute is defined, no message will be sent by default. One message should specify either the job or the task level attributes, but not both. For example, job level: JOB_STATE_CHANGED and/or a specified new_job_state; task level: TASK_STATE_CHANGED and/or a specified new_task_state.
        :param str new_job_state: The new job state.
        :param str new_task_state: The new task state.
        :param str type: The message type.
        """
        pulumi.set(__self__, "new_job_state", new_job_state)
        pulumi.set(__self__, "new_task_state", new_task_state)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="newJobState")
    def new_job_state(self) -> str:
        """
        The new job state.
        """
        return pulumi.get(self, "new_job_state")

    @property
    @pulumi.getter(name="newTaskState")
    def new_task_state(self) -> str:
        """
        The new task state.
        """
        return pulumi.get(self, "new_task_state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The message type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NFSResponse(dict):
    """
    Represents an NFS volume.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "remotePath":
            suggest = "remote_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NFSResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NFSResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NFSResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 remote_path: str,
                 server: str):
        """
        Represents an NFS volume.
        :param str remote_path: Remote source path exported from the NFS, e.g., "/share".
        :param str server: The IP address of the NFS.
        """
        pulumi.set(__self__, "remote_path", remote_path)
        pulumi.set(__self__, "server", server)

    @property
    @pulumi.getter(name="remotePath")
    def remote_path(self) -> str:
        """
        Remote source path exported from the NFS, e.g., "/share".
        """
        return pulumi.get(self, "remote_path")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        The IP address of the NFS.
        """
        return pulumi.get(self, "server")


@pulumi.output_type
class NetworkInterfaceResponse(dict):
    """
    A network interface.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noExternalIpAddress":
            suggest = "no_external_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network: str,
                 no_external_ip_address: bool,
                 subnetwork: str):
        """
        A network interface.
        :param str network: The URL of an existing network resource. You can specify the network as a full or partial URL. For example, the following are all valid URLs: * https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network} * projects/{project}/global/networks/{network} * global/networks/{network}
        :param bool no_external_ip_address: Default is false (with an external IP address). Required if no external public IP address is attached to the VM. If no external public IP address, additional configuration is required to allow the VM to access Google Services. See https://cloud.google.com/vpc/docs/configure-private-google-access and https://cloud.google.com/nat/docs/gce-example#create-nat for more information.
        :param str subnetwork: The URL of an existing subnetwork resource in the network. You can specify the subnetwork as a full or partial URL. For example, the following are all valid URLs: * https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/subnetworks/{subnetwork} * projects/{project}/regions/{region}/subnetworks/{subnetwork} * regions/{region}/subnetworks/{subnetwork}
        """
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "no_external_ip_address", no_external_ip_address)
        pulumi.set(__self__, "subnetwork", subnetwork)

    @property
    @pulumi.getter
    def network(self) -> str:
        """
        The URL of an existing network resource. You can specify the network as a full or partial URL. For example, the following are all valid URLs: * https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network} * projects/{project}/global/networks/{network} * global/networks/{network}
        """
        return pulumi.get(self, "network")

    @property
    @pulumi.getter(name="noExternalIpAddress")
    def no_external_ip_address(self) -> bool:
        """
        Default is false (with an external IP address). Required if no external public IP address is attached to the VM. If no external public IP address, additional configuration is required to allow the VM to access Google Services. See https://cloud.google.com/vpc/docs/configure-private-google-access and https://cloud.google.com/nat/docs/gce-example#create-nat for more information.
        """
        return pulumi.get(self, "no_external_ip_address")

    @property
    @pulumi.getter
    def subnetwork(self) -> str:
        """
        The URL of an existing subnetwork resource in the network. You can specify the subnetwork as a full or partial URL. For example, the following are all valid URLs: * https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/subnetworks/{subnetwork} * projects/{project}/regions/{region}/subnetworks/{subnetwork} * regions/{region}/subnetworks/{subnetwork}
        """
        return pulumi.get(self, "subnetwork")


@pulumi.output_type
class NetworkPolicyResponse(dict):
    """
    NetworkPolicy describes VM instance network configurations.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkInterfaces":
            suggest = "network_interfaces"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_interfaces: Sequence['outputs.NetworkInterfaceResponse']):
        """
        NetworkPolicy describes VM instance network configurations.
        :param Sequence['NetworkInterfaceResponse'] network_interfaces: Network configurations.
        """
        pulumi.set(__self__, "network_interfaces", network_interfaces)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.NetworkInterfaceResponse']:
        """
        Network configurations.
        """
        return pulumi.get(self, "network_interfaces")


@pulumi.output_type
class PlacementPolicyResponse(dict):
    """
    PlacementPolicy describes a group placement policy for the VMs controlled by this AllocationPolicy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxDistance":
            suggest = "max_distance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlacementPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlacementPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlacementPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collocation: str,
                 max_distance: str):
        """
        PlacementPolicy describes a group placement policy for the VMs controlled by this AllocationPolicy.
        :param str collocation: UNSPECIFIED vs. COLLOCATED (default UNSPECIFIED). Use COLLOCATED when you want VMs to be located close to each other for low network latency between the VMs. No placement policy will be generated when collocation is UNSPECIFIED.
        :param str max_distance: When specified, causes the job to fail if more than max_distance logical switches are required between VMs. Batch uses the most compact possible placement of VMs even when max_distance is not specified. An explicit max_distance makes that level of compactness a strict requirement. Not yet implemented
        """
        pulumi.set(__self__, "collocation", collocation)
        pulumi.set(__self__, "max_distance", max_distance)

    @property
    @pulumi.getter
    def collocation(self) -> str:
        """
        UNSPECIFIED vs. COLLOCATED (default UNSPECIFIED). Use COLLOCATED when you want VMs to be located close to each other for low network latency between the VMs. No placement policy will be generated when collocation is UNSPECIFIED.
        """
        return pulumi.get(self, "collocation")

    @property
    @pulumi.getter(name="maxDistance")
    def max_distance(self) -> str:
        """
        When specified, causes the job to fail if more than max_distance logical switches are required between VMs. Batch uses the most compact possible placement of VMs even when max_distance is not specified. An explicit max_distance makes that level of compactness a strict requirement. Not yet implemented
        """
        return pulumi.get(self, "max_distance")


@pulumi.output_type
class RunnableResponse(dict):
    """
    Runnable describes instructions for executing a specific script or container as part of a Task.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysRun":
            suggest = "always_run"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "ignoreExitStatus":
            suggest = "ignore_exit_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RunnableResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RunnableResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RunnableResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_run: bool,
                 background: bool,
                 barrier: 'outputs.BarrierResponse',
                 container: 'outputs.ContainerResponse',
                 display_name: str,
                 environment: 'outputs.EnvironmentResponse',
                 ignore_exit_status: bool,
                 labels: Mapping[str, str],
                 script: 'outputs.ScriptResponse',
                 timeout: str):
        """
        Runnable describes instructions for executing a specific script or container as part of a Task.
        :param bool always_run: By default, after a Runnable fails, no further Runnable are executed. This flag indicates that this Runnable must be run even if the Task has already failed. This is useful for Runnables that copy output files off of the VM or for debugging. The always_run flag does not override the Task's overall max_run_duration. If the max_run_duration has expired then no further Runnables will execute, not even always_run Runnables.
        :param bool background: This flag allows a Runnable to continue running in the background while the Task executes subsequent Runnables. This is useful to provide services to other Runnables (or to provide debugging support tools like SSH servers).
        :param 'BarrierResponse' barrier: Barrier runnable.
        :param 'ContainerResponse' container: Container runnable.
        :param str display_name: Optional. DisplayName is an optional field that can be provided by the caller. If provided, it will be used in logs and other outputs to identify the script, making it easier for users to understand the logs. If not provided the index of the runnable will be used for outputs.
        :param 'EnvironmentResponse' environment: Environment variables for this Runnable (overrides variables set for the whole Task or TaskGroup).
        :param bool ignore_exit_status: Normally, a non-zero exit status causes the Task to fail. This flag allows execution of other Runnables to continue instead.
        :param Mapping[str, str] labels: Labels for this Runnable.
        :param 'ScriptResponse' script: Script runnable.
        :param str timeout: Timeout for this Runnable.
        """
        pulumi.set(__self__, "always_run", always_run)
        pulumi.set(__self__, "background", background)
        pulumi.set(__self__, "barrier", barrier)
        pulumi.set(__self__, "container", container)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "ignore_exit_status", ignore_exit_status)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "script", script)
        pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="alwaysRun")
    def always_run(self) -> bool:
        """
        By default, after a Runnable fails, no further Runnable are executed. This flag indicates that this Runnable must be run even if the Task has already failed. This is useful for Runnables that copy output files off of the VM or for debugging. The always_run flag does not override the Task's overall max_run_duration. If the max_run_duration has expired then no further Runnables will execute, not even always_run Runnables.
        """
        return pulumi.get(self, "always_run")

    @property
    @pulumi.getter
    def background(self) -> bool:
        """
        This flag allows a Runnable to continue running in the background while the Task executes subsequent Runnables. This is useful to provide services to other Runnables (or to provide debugging support tools like SSH servers).
        """
        return pulumi.get(self, "background")

    @property
    @pulumi.getter
    def barrier(self) -> 'outputs.BarrierResponse':
        """
        Barrier runnable.
        """
        return pulumi.get(self, "barrier")

    @property
    @pulumi.getter
    def container(self) -> 'outputs.ContainerResponse':
        """
        Container runnable.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        Optional. DisplayName is an optional field that can be provided by the caller. If provided, it will be used in logs and other outputs to identify the script, making it easier for users to understand the logs. If not provided the index of the runnable will be used for outputs.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def environment(self) -> 'outputs.EnvironmentResponse':
        """
        Environment variables for this Runnable (overrides variables set for the whole Task or TaskGroup).
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="ignoreExitStatus")
    def ignore_exit_status(self) -> bool:
        """
        Normally, a non-zero exit status causes the Task to fail. This flag allows execution of other Runnables to continue instead.
        """
        return pulumi.get(self, "ignore_exit_status")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Labels for this Runnable.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def script(self) -> 'outputs.ScriptResponse':
        """
        Script runnable.
        """
        return pulumi.get(self, "script")

    @property
    @pulumi.getter
    def timeout(self) -> str:
        """
        Timeout for this Runnable.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ScriptResponse(dict):
    """
    Script runnable.
    """
    def __init__(__self__, *,
                 path: str,
                 text: str):
        """
        Script runnable.
        :param str path: Script file path on the host VM. To specify an interpreter, please add a `#!`(also known as [shebang line](https://en.wikipedia.org/wiki/Shebang_(Unix))) as the first line of the file.(For example, to execute the script using bash, `#!/bin/bash` should be the first line of the file. To execute the script using`Python3`, `#!/usr/bin/env python3` should be the first line of the file.) Otherwise, the file will by default be excuted by `/bin/sh`.
        :param str text: Shell script text. To specify an interpreter, please add a `#!\\n` at the beginning of the text.(For example, to execute the script using bash, `#!/bin/bash\\n` should be added. To execute the script using`Python3`, `#!/usr/bin/env python3\\n` should be added.) Otherwise, the script will by default be excuted by `/bin/sh`.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Script file path on the host VM. To specify an interpreter, please add a `#!`(also known as [shebang line](https://en.wikipedia.org/wiki/Shebang_(Unix))) as the first line of the file.(For example, to execute the script using bash, `#!/bin/bash` should be the first line of the file. To execute the script using`Python3`, `#!/usr/bin/env python3` should be the first line of the file.) Otherwise, the file will by default be excuted by `/bin/sh`.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def text(self) -> str:
        """
        Shell script text. To specify an interpreter, please add a `#!\\n` at the beginning of the text.(For example, to execute the script using bash, `#!/bin/bash\\n` should be added. To execute the script using`Python3`, `#!/usr/bin/env python3\\n` should be added.) Otherwise, the script will by default be excuted by `/bin/sh`.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ServiceAccountResponse(dict):
    """
    Carries information about a Google Cloud service account.
    """
    def __init__(__self__, *,
                 email: str,
                 scopes: Sequence[str]):
        """
        Carries information about a Google Cloud service account.
        :param str email: Email address of the service account. If not specified, the default Compute Engine service account for the project will be used. If instance template is being used, the service account has to be specified in the instance template and it has to match the email field here.
        :param Sequence[str] scopes: List of scopes to be enabled for this service account on the VM, in addition to the cloud-platform API scope that will be added by default.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        Email address of the service account. If not specified, the default Compute Engine service account for the project will be used. If instance template is being used, the service account has to be specified in the instance template and it has to match the email field here.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        List of scopes to be enabled for this service account on the VM, in addition to the cloud-platform API scope that will be added by default.
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class StatusEventResponse(dict):
    """
    Status event
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventTime":
            suggest = "event_time"
        elif key == "taskExecution":
            suggest = "task_execution"
        elif key == "taskState":
            suggest = "task_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatusEventResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatusEventResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatusEventResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 event_time: str,
                 task_execution: 'outputs.TaskExecutionResponse',
                 task_state: str,
                 type: str):
        """
        Status event
        :param str description: Description of the event.
        :param str event_time: The time this event occurred.
        :param 'TaskExecutionResponse' task_execution: Task Execution
        :param str task_state: Task State
        :param str type: Type of the event.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "event_time", event_time)
        pulumi.set(__self__, "task_execution", task_execution)
        pulumi.set(__self__, "task_state", task_state)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the event.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="eventTime")
    def event_time(self) -> str:
        """
        The time this event occurred.
        """
        return pulumi.get(self, "event_time")

    @property
    @pulumi.getter(name="taskExecution")
    def task_execution(self) -> 'outputs.TaskExecutionResponse':
        """
        Task Execution
        """
        return pulumi.get(self, "task_execution")

    @property
    @pulumi.getter(name="taskState")
    def task_state(self) -> str:
        """
        Task State
        """
        return pulumi.get(self, "task_state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the event.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class TaskExecutionResponse(dict):
    """
    This Task Execution field includes detail information for task execution procedures, based on StatusEvent types.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exitCode":
            suggest = "exit_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskExecutionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskExecutionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskExecutionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exit_code: int):
        """
        This Task Execution field includes detail information for task execution procedures, based on StatusEvent types.
        :param int exit_code: When task is completed as the status of FAILED or SUCCEEDED, exit code is for one task execution result, default is 0 as success.
        """
        pulumi.set(__self__, "exit_code", exit_code)

    @property
    @pulumi.getter(name="exitCode")
    def exit_code(self) -> int:
        """
        When task is completed as the status of FAILED or SUCCEEDED, exit code is for one task execution result, default is 0 as success.
        """
        return pulumi.get(self, "exit_code")


@pulumi.output_type
class TaskGroupResponse(dict):
    """
    A TaskGroup defines one or more Tasks that all share the same TaskSpec.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "permissiveSsh":
            suggest = "permissive_ssh"
        elif key == "requireHostsFile":
            suggest = "require_hosts_file"
        elif key == "schedulingPolicy":
            suggest = "scheduling_policy"
        elif key == "taskCount":
            suggest = "task_count"
        elif key == "taskCountPerNode":
            suggest = "task_count_per_node"
        elif key == "taskEnvironments":
            suggest = "task_environments"
        elif key == "taskSpec":
            suggest = "task_spec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskGroupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskGroupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskGroupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 parallelism: str,
                 permissive_ssh: bool,
                 require_hosts_file: bool,
                 scheduling_policy: str,
                 task_count: str,
                 task_count_per_node: str,
                 task_environments: Sequence['outputs.EnvironmentResponse'],
                 task_spec: 'outputs.TaskSpecResponse'):
        """
        A TaskGroup defines one or more Tasks that all share the same TaskSpec.
        :param str name: TaskGroup name. The system generates this field based on parent Job name. For example: "projects/123456/locations/us-west1/jobs/job01/taskGroups/group01".
        :param str parallelism: Max number of tasks that can run in parallel. Default to min(task_count, parallel tasks per job limit). See: [Job Limits](https://cloud.google.com/batch/quotas#job_limits). Field parallelism must be 1 if the scheduling_policy is IN_ORDER.
        :param bool permissive_ssh: When true, Batch will configure SSH to allow passwordless login between VMs running the Batch tasks in the same TaskGroup.
        :param bool require_hosts_file: When true, Batch will populate a file with a list of all VMs assigned to the TaskGroup and set the BATCH_HOSTS_FILE environment variable to the path of that file. Defaults to false.
        :param str scheduling_policy: Scheduling policy for Tasks in the TaskGroup. The default value is AS_SOON_AS_POSSIBLE.
        :param str task_count: Number of Tasks in the TaskGroup. Default is 1.
        :param str task_count_per_node: Max number of tasks that can be run on a VM at the same time. If not specified, the system will decide a value based on available compute resources on a VM and task requirements.
        :param Sequence['EnvironmentResponse'] task_environments: An array of environment variable mappings, which are passed to Tasks with matching indices. If task_environments is used then task_count should not be specified in the request (and will be ignored). Task count will be the length of task_environments. Tasks get a BATCH_TASK_INDEX and BATCH_TASK_COUNT environment variable, in addition to any environment variables set in task_environments, specifying the number of Tasks in the Task's parent TaskGroup, and the specific Task's index in the TaskGroup (0 through BATCH_TASK_COUNT - 1).
        :param 'TaskSpecResponse' task_spec: Tasks in the group share the same task spec.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parallelism", parallelism)
        pulumi.set(__self__, "permissive_ssh", permissive_ssh)
        pulumi.set(__self__, "require_hosts_file", require_hosts_file)
        pulumi.set(__self__, "scheduling_policy", scheduling_policy)
        pulumi.set(__self__, "task_count", task_count)
        pulumi.set(__self__, "task_count_per_node", task_count_per_node)
        pulumi.set(__self__, "task_environments", task_environments)
        pulumi.set(__self__, "task_spec", task_spec)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        TaskGroup name. The system generates this field based on parent Job name. For example: "projects/123456/locations/us-west1/jobs/job01/taskGroups/group01".
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parallelism(self) -> str:
        """
        Max number of tasks that can run in parallel. Default to min(task_count, parallel tasks per job limit). See: [Job Limits](https://cloud.google.com/batch/quotas#job_limits). Field parallelism must be 1 if the scheduling_policy is IN_ORDER.
        """
        return pulumi.get(self, "parallelism")

    @property
    @pulumi.getter(name="permissiveSsh")
    def permissive_ssh(self) -> bool:
        """
        When true, Batch will configure SSH to allow passwordless login between VMs running the Batch tasks in the same TaskGroup.
        """
        return pulumi.get(self, "permissive_ssh")

    @property
    @pulumi.getter(name="requireHostsFile")
    def require_hosts_file(self) -> bool:
        """
        When true, Batch will populate a file with a list of all VMs assigned to the TaskGroup and set the BATCH_HOSTS_FILE environment variable to the path of that file. Defaults to false.
        """
        return pulumi.get(self, "require_hosts_file")

    @property
    @pulumi.getter(name="schedulingPolicy")
    def scheduling_policy(self) -> str:
        """
        Scheduling policy for Tasks in the TaskGroup. The default value is AS_SOON_AS_POSSIBLE.
        """
        return pulumi.get(self, "scheduling_policy")

    @property
    @pulumi.getter(name="taskCount")
    def task_count(self) -> str:
        """
        Number of Tasks in the TaskGroup. Default is 1.
        """
        return pulumi.get(self, "task_count")

    @property
    @pulumi.getter(name="taskCountPerNode")
    def task_count_per_node(self) -> str:
        """
        Max number of tasks that can be run on a VM at the same time. If not specified, the system will decide a value based on available compute resources on a VM and task requirements.
        """
        return pulumi.get(self, "task_count_per_node")

    @property
    @pulumi.getter(name="taskEnvironments")
    def task_environments(self) -> Sequence['outputs.EnvironmentResponse']:
        """
        An array of environment variable mappings, which are passed to Tasks with matching indices. If task_environments is used then task_count should not be specified in the request (and will be ignored). Task count will be the length of task_environments. Tasks get a BATCH_TASK_INDEX and BATCH_TASK_COUNT environment variable, in addition to any environment variables set in task_environments, specifying the number of Tasks in the Task's parent TaskGroup, and the specific Task's index in the TaskGroup (0 through BATCH_TASK_COUNT - 1).
        """
        return pulumi.get(self, "task_environments")

    @property
    @pulumi.getter(name="taskSpec")
    def task_spec(self) -> 'outputs.TaskSpecResponse':
        """
        Tasks in the group share the same task spec.
        """
        return pulumi.get(self, "task_spec")


@pulumi.output_type
class TaskGroupStatusResponse(dict):
    """
    Aggregated task status for a TaskGroup.
    """
    def __init__(__self__, *,
                 counts: Mapping[str, str],
                 instances: Sequence['outputs.InstanceStatusResponse']):
        """
        Aggregated task status for a TaskGroup.
        :param Mapping[str, str] counts: Count of task in each state in the TaskGroup. The map key is task state name.
        :param Sequence['InstanceStatusResponse'] instances: Status of instances allocated for the TaskGroup.
        """
        pulumi.set(__self__, "counts", counts)
        pulumi.set(__self__, "instances", instances)

    @property
    @pulumi.getter
    def counts(self) -> Mapping[str, str]:
        """
        Count of task in each state in the TaskGroup. The map key is task state name.
        """
        return pulumi.get(self, "counts")

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.InstanceStatusResponse']:
        """
        Status of instances allocated for the TaskGroup.
        """
        return pulumi.get(self, "instances")


@pulumi.output_type
class TaskSpecResponse(dict):
    """
    Spec of a task
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeResource":
            suggest = "compute_resource"
        elif key == "lifecyclePolicies":
            suggest = "lifecycle_policies"
        elif key == "maxRetryCount":
            suggest = "max_retry_count"
        elif key == "maxRunDuration":
            suggest = "max_run_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaskSpecResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaskSpecResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaskSpecResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_resource: 'outputs.ComputeResourceResponse',
                 environment: 'outputs.EnvironmentResponse',
                 environments: Mapping[str, str],
                 lifecycle_policies: Sequence['outputs.LifecyclePolicyResponse'],
                 max_retry_count: int,
                 max_run_duration: str,
                 runnables: Sequence['outputs.RunnableResponse'],
                 volumes: Sequence['outputs.VolumeResponse']):
        """
        Spec of a task
        :param 'ComputeResourceResponse' compute_resource: ComputeResource requirements.
        :param 'EnvironmentResponse' environment: Environment variables to set before running the Task.
        :param Mapping[str, str] environments: Deprecated: please use environment(non-plural) instead.
        :param Sequence['LifecyclePolicyResponse'] lifecycle_policies: Lifecycle management schema when any task in a task group is failed. Currently we only support one lifecycle policy. When the lifecycle policy condition is met, the action in the policy will execute. If task execution result does not meet with the defined lifecycle policy, we consider it as the default policy. Default policy means if the exit code is 0, exit task. If task ends with non-zero exit code, retry the task with max_retry_count.
        :param int max_retry_count: Maximum number of retries on failures. The default, 0, which means never retry. The valid value range is [0, 10].
        :param str max_run_duration: Maximum duration the task should run. The task will be killed and marked as FAILED if over this limit.
        :param Sequence['RunnableResponse'] runnables: The sequence of scripts or containers to run for this Task. Each Task using this TaskSpec executes its list of runnables in order. The Task succeeds if all of its runnables either exit with a zero status or any that exit with a non-zero status have the ignore_exit_status flag. Background runnables are killed automatically (if they have not already exited) a short time after all foreground runnables have completed. Even though this is likely to result in a non-zero exit status for the background runnable, these automatic kills are not treated as Task failures.
        :param Sequence['VolumeResponse'] volumes: Volumes to mount before running Tasks using this TaskSpec.
        """
        pulumi.set(__self__, "compute_resource", compute_resource)
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "environments", environments)
        pulumi.set(__self__, "lifecycle_policies", lifecycle_policies)
        pulumi.set(__self__, "max_retry_count", max_retry_count)
        pulumi.set(__self__, "max_run_duration", max_run_duration)
        pulumi.set(__self__, "runnables", runnables)
        pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter(name="computeResource")
    def compute_resource(self) -> 'outputs.ComputeResourceResponse':
        """
        ComputeResource requirements.
        """
        return pulumi.get(self, "compute_resource")

    @property
    @pulumi.getter
    def environment(self) -> 'outputs.EnvironmentResponse':
        """
        Environment variables to set before running the Task.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    @_utilities.deprecated("""Deprecated: please use environment(non-plural) instead.""")
    def environments(self) -> Mapping[str, str]:
        """
        Deprecated: please use environment(non-plural) instead.
        """
        return pulumi.get(self, "environments")

    @property
    @pulumi.getter(name="lifecyclePolicies")
    def lifecycle_policies(self) -> Sequence['outputs.LifecyclePolicyResponse']:
        """
        Lifecycle management schema when any task in a task group is failed. Currently we only support one lifecycle policy. When the lifecycle policy condition is met, the action in the policy will execute. If task execution result does not meet with the defined lifecycle policy, we consider it as the default policy. Default policy means if the exit code is 0, exit task. If task ends with non-zero exit code, retry the task with max_retry_count.
        """
        return pulumi.get(self, "lifecycle_policies")

    @property
    @pulumi.getter(name="maxRetryCount")
    def max_retry_count(self) -> int:
        """
        Maximum number of retries on failures. The default, 0, which means never retry. The valid value range is [0, 10].
        """
        return pulumi.get(self, "max_retry_count")

    @property
    @pulumi.getter(name="maxRunDuration")
    def max_run_duration(self) -> str:
        """
        Maximum duration the task should run. The task will be killed and marked as FAILED if over this limit.
        """
        return pulumi.get(self, "max_run_duration")

    @property
    @pulumi.getter
    def runnables(self) -> Sequence['outputs.RunnableResponse']:
        """
        The sequence of scripts or containers to run for this Task. Each Task using this TaskSpec executes its list of runnables in order. The Task succeeds if all of its runnables either exit with a zero status or any that exit with a non-zero status have the ignore_exit_status flag. Background runnables are killed automatically (if they have not already exited) a short time after all foreground runnables have completed. Even though this is likely to result in a non-zero exit status for the background runnable, these automatic kills are not treated as Task failures.
        """
        return pulumi.get(self, "runnables")

    @property
    @pulumi.getter
    def volumes(self) -> Sequence['outputs.VolumeResponse']:
        """
        Volumes to mount before running Tasks using this TaskSpec.
        """
        return pulumi.get(self, "volumes")


@pulumi.output_type
class VolumeResponse(dict):
    """
    Volume describes a volume and parameters for it to be mounted to a VM.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "mountOptions":
            suggest = "mount_options"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: str,
                 gcs: 'outputs.GCSResponse',
                 mount_options: Sequence[str],
                 mount_path: str,
                 nfs: 'outputs.NFSResponse'):
        """
        Volume describes a volume and parameters for it to be mounted to a VM.
        :param str device_name: Device name of an attached disk volume, which should align with a device_name specified by job.allocation_policy.instances[0].policy.disks[i].device_name or defined by the given instance template in job.allocation_policy.instances[0].instance_template.
        :param 'GCSResponse' gcs: A Google Cloud Storage (GCS) volume.
        :param Sequence[str] mount_options: For Google Cloud Storage (GCS), mount options are the options supported by the gcsfuse tool (https://github.com/GoogleCloudPlatform/gcsfuse). For existing persistent disks, mount options provided by the mount command (https://man7.org/linux/man-pages/man8/mount.8.html) except writing are supported. This is due to restrictions of multi-writer mode (https://cloud.google.com/compute/docs/disks/sharing-disks-between-vms). For other attached disks and Network File System (NFS), mount options are these supported by the mount command (https://man7.org/linux/man-pages/man8/mount.8.html).
        :param str mount_path: The mount path for the volume, e.g. /mnt/disks/share.
        :param 'NFSResponse' nfs: A Network File System (NFS) volume. For example, a Filestore file share.
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "gcs", gcs)
        pulumi.set(__self__, "mount_options", mount_options)
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "nfs", nfs)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        Device name of an attached disk volume, which should align with a device_name specified by job.allocation_policy.instances[0].policy.disks[i].device_name or defined by the given instance template in job.allocation_policy.instances[0].instance_template.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def gcs(self) -> 'outputs.GCSResponse':
        """
        A Google Cloud Storage (GCS) volume.
        """
        return pulumi.get(self, "gcs")

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Sequence[str]:
        """
        For Google Cloud Storage (GCS), mount options are the options supported by the gcsfuse tool (https://github.com/GoogleCloudPlatform/gcsfuse). For existing persistent disks, mount options provided by the mount command (https://man7.org/linux/man-pages/man8/mount.8.html) except writing are supported. This is due to restrictions of multi-writer mode (https://cloud.google.com/compute/docs/disks/sharing-disks-between-vms). For other attached disks and Network File System (NFS), mount options are these supported by the mount command (https://man7.org/linux/man-pages/man8/mount.8.html).
        """
        return pulumi.get(self, "mount_options")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> str:
        """
        The mount path for the volume, e.g. /mnt/disks/share.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter
    def nfs(self) -> 'outputs.NFSResponse':
        """
        A Network File System (NFS) volume. For example, a Filestore file share.
        """
        return pulumi.get(self, "nfs")


