# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from ._enums import *

__all__ = [
    'AttestationAuthenticatorArgs',
    'AttestationSourceArgs',
    'AttestorPublicKeyArgs',
    'BindingArgs',
    'CheckSetArgs',
    'CheckArgs',
    'ExprArgs',
    'GkePolicyArgs',
    'ImageAllowlistArgs',
    'ImageFreshnessCheckArgs',
    'PkixPublicKeySetArgs',
    'PkixPublicKeyArgs',
    'ScopeArgs',
    'SimpleSigningAttestationCheckArgs',
    'SlsaCheckArgs',
    'TrustedDirectoryCheckArgs',
    'UserOwnedGrafeasNoteArgs',
    'VerificationRuleArgs',
    'VulnerabilityCheckArgs',
]

@pulumi.input_type
class AttestationAuthenticatorArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 pkix_public_key_set: Optional[pulumi.Input['PkixPublicKeySetArgs']] = None):
        """
        An attestation authenticator that will be used to verify attestations. Typically this is just a set of public keys. Conceptually, an authenticator can be treated as always returning either "authenticated" or "not authenticated" when presented with a signed attestation (almost always assumed to be a [DSSE](https://github.com/secure-systems-lab/dsse) attestation). The details of how an authenticator makes this decision are specific to the type of 'authenticator' that this message wraps.
        :param pulumi.Input[str] display_name: Optional. A user-provided name for this `AttestationAuthenticator`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
        :param pulumi.Input['PkixPublicKeySetArgs'] pkix_public_key_set: Optional. A set of raw PKIX SubjectPublicKeyInfo format public keys. If any public key in the set validates the attestation signature, then the signature is considered authenticated (i.e. any one key is sufficient to authenticate).
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if pkix_public_key_set is not None:
            pulumi.set(__self__, "pkix_public_key_set", pkix_public_key_set)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. A user-provided name for this `AttestationAuthenticator`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="pkixPublicKeySet")
    def pkix_public_key_set(self) -> Optional[pulumi.Input['PkixPublicKeySetArgs']]:
        """
        Optional. A set of raw PKIX SubjectPublicKeyInfo format public keys. If any public key in the set validates the attestation signature, then the signature is considered authenticated (i.e. any one key is sufficient to authenticate).
        """
        return pulumi.get(self, "pkix_public_key_set")

    @pkix_public_key_set.setter
    def pkix_public_key_set(self, value: Optional[pulumi.Input['PkixPublicKeySetArgs']]):
        pulumi.set(self, "pkix_public_key_set", value)


@pulumi.input_type
class AttestationSourceArgs:
    def __init__(__self__, *,
                 container_analysis_attestation_projects: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Specifies the locations for fetching the provenance attestations.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] container_analysis_attestation_projects: The IDs of the GCP projects storing the SLSA attestations as Container Analysis Occurrences.
        """
        if container_analysis_attestation_projects is not None:
            pulumi.set(__self__, "container_analysis_attestation_projects", container_analysis_attestation_projects)

    @property
    @pulumi.getter(name="containerAnalysisAttestationProjects")
    def container_analysis_attestation_projects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The IDs of the GCP projects storing the SLSA attestations as Container Analysis Occurrences.
        """
        return pulumi.get(self, "container_analysis_attestation_projects")

    @container_analysis_attestation_projects.setter
    def container_analysis_attestation_projects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "container_analysis_attestation_projects", value)


@pulumi.input_type
class AttestorPublicKeyArgs:
    def __init__(__self__, *,
                 ascii_armored_pgp_public_key: Optional[pulumi.Input[str]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 pkix_public_key: Optional[pulumi.Input['PkixPublicKeyArgs']] = None):
        """
        An attestor public key that will be used to verify attestations signed by this attestor.
        :param pulumi.Input[str] ascii_armored_pgp_public_key: ASCII-armored representation of a PGP public key, as the entire output by the command `gpg --export --armor foo@example.com` (either LF or CRLF line endings). When using this field, `id` should be left blank. The Binary Authorization API handlers will calculate the ID and fill it in automatically. Binary Authorization computes this ID as the OpenPGP RFC4880 V4 fingerprint, represented as upper-case hex. If `id` is provided by the caller, it will be overwritten by the API-calculated ID.
        :param pulumi.Input[str] comment: Optional. A descriptive comment. This field may be updated.
        :param pulumi.Input[str] id: The ID of this public key. Signatures verified by Binary Authorization must include the ID of the public key that can be used to verify them, and that ID must match the contents of this field exactly. Additional restrictions on this field can be imposed based on which public key type is encapsulated. See the documentation on `public_key` cases below for details.
        :param pulumi.Input['PkixPublicKeyArgs'] pkix_public_key: A raw PKIX SubjectPublicKeyInfo format public key. NOTE: `id` may be explicitly provided by the caller when using this type of public key, but it MUST be a valid RFC3986 URI. If `id` is left blank, a default one will be computed based on the digest of the DER encoding of the public key.
        """
        if ascii_armored_pgp_public_key is not None:
            pulumi.set(__self__, "ascii_armored_pgp_public_key", ascii_armored_pgp_public_key)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if pkix_public_key is not None:
            pulumi.set(__self__, "pkix_public_key", pkix_public_key)

    @property
    @pulumi.getter(name="asciiArmoredPgpPublicKey")
    def ascii_armored_pgp_public_key(self) -> Optional[pulumi.Input[str]]:
        """
        ASCII-armored representation of a PGP public key, as the entire output by the command `gpg --export --armor foo@example.com` (either LF or CRLF line endings). When using this field, `id` should be left blank. The Binary Authorization API handlers will calculate the ID and fill it in automatically. Binary Authorization computes this ID as the OpenPGP RFC4880 V4 fingerprint, represented as upper-case hex. If `id` is provided by the caller, it will be overwritten by the API-calculated ID.
        """
        return pulumi.get(self, "ascii_armored_pgp_public_key")

    @ascii_armored_pgp_public_key.setter
    def ascii_armored_pgp_public_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ascii_armored_pgp_public_key", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. A descriptive comment. This field may be updated.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of this public key. Signatures verified by Binary Authorization must include the ID of the public key that can be used to verify them, and that ID must match the contents of this field exactly. Additional restrictions on this field can be imposed based on which public key type is encapsulated. See the documentation on `public_key` cases below for details.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="pkixPublicKey")
    def pkix_public_key(self) -> Optional[pulumi.Input['PkixPublicKeyArgs']]:
        """
        A raw PKIX SubjectPublicKeyInfo format public key. NOTE: `id` may be explicitly provided by the caller when using this type of public key, but it MUST be a valid RFC3986 URI. If `id` is left blank, a default one will be computed based on the digest of the DER encoding of the public key.
        """
        return pulumi.get(self, "pkix_public_key")

    @pkix_public_key.setter
    def pkix_public_key(self, value: Optional[pulumi.Input['PkixPublicKeyArgs']]):
        pulumi.set(self, "pkix_public_key", value)


@pulumi.input_type
class BindingArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input['ExprArgs']] = None,
                 members: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 role: Optional[pulumi.Input[str]] = None):
        """
        Associates `members`, or principals, with a `role`.
        :param pulumi.Input['ExprArgs'] condition: The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] members: Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
        :param pulumi.Input[str] role: Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if members is not None:
            pulumi.set(__self__, "members", members)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['ExprArgs']]:
        """
        The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['ExprArgs']]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def members(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
        """
        return pulumi.get(self, "members")

    @members.setter
    def members(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "members", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)


@pulumi.input_type
class CheckSetArgs:
    def __init__(__self__, *,
                 checks: Optional[pulumi.Input[Sequence[pulumi.Input['CheckArgs']]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 image_allowlist: Optional[pulumi.Input['ImageAllowlistArgs']] = None,
                 scope: Optional[pulumi.Input['ScopeArgs']] = None):
        """
        A conjunction of policy checks, scoped to a particular namespace or Kubernetes service account. In order for evaluation of a `CheckSet` to return "allowed" for a given image in a given Pod, one of the following conditions must be satisfied: * The image is explicitly exempted by an entry in `image_allowlist`, OR * ALL of the `checks` evaluate to "allowed".
        :param pulumi.Input[Sequence[pulumi.Input['CheckArgs']]] checks: Optional. The checks to apply. The ultimate result of evaluating the check set will be "allow" if and only if every check in `checks` evaluates to "allow". If `checks` is empty, the default behavior is "always allow".
        :param pulumi.Input[str] display_name: Optional. A user-provided name for this `CheckSet`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
        :param pulumi.Input['ImageAllowlistArgs'] image_allowlist: Optional. Images exempted from this `CheckSet`. If any of the patterns match the image being evaluated, no checks in the `CheckSet` will be evaluated.
        :param pulumi.Input['ScopeArgs'] scope: Optional. The scope to which this `CheckSet` applies. If unset or an empty string (the default), applies to all namespaces and service accounts. See the `Scope` message documentation for details on scoping rules.
        """
        if checks is not None:
            pulumi.set(__self__, "checks", checks)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if image_allowlist is not None:
            pulumi.set(__self__, "image_allowlist", image_allowlist)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def checks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CheckArgs']]]]:
        """
        Optional. The checks to apply. The ultimate result of evaluating the check set will be "allow" if and only if every check in `checks` evaluates to "allow". If `checks` is empty, the default behavior is "always allow".
        """
        return pulumi.get(self, "checks")

    @checks.setter
    def checks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CheckArgs']]]]):
        pulumi.set(self, "checks", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. A user-provided name for this `CheckSet`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="imageAllowlist")
    def image_allowlist(self) -> Optional[pulumi.Input['ImageAllowlistArgs']]:
        """
        Optional. Images exempted from this `CheckSet`. If any of the patterns match the image being evaluated, no checks in the `CheckSet` will be evaluated.
        """
        return pulumi.get(self, "image_allowlist")

    @image_allowlist.setter
    def image_allowlist(self, value: Optional[pulumi.Input['ImageAllowlistArgs']]):
        pulumi.set(self, "image_allowlist", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input['ScopeArgs']]:
        """
        Optional. The scope to which this `CheckSet` applies. If unset or an empty string (the default), applies to all namespaces and service accounts. See the `Scope` message documentation for details on scoping rules.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input['ScopeArgs']]):
        pulumi.set(self, "scope", value)


@pulumi.input_type
class CheckArgs:
    def __init__(__self__, *,
                 always_deny: Optional[pulumi.Input[bool]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 image_allowlist: Optional[pulumi.Input['ImageAllowlistArgs']] = None,
                 image_freshness_check: Optional[pulumi.Input['ImageFreshnessCheckArgs']] = None,
                 simple_signing_attestation_check: Optional[pulumi.Input['SimpleSigningAttestationCheckArgs']] = None,
                 slsa_check: Optional[pulumi.Input['SlsaCheckArgs']] = None,
                 trusted_directory_check: Optional[pulumi.Input['TrustedDirectoryCheckArgs']] = None,
                 vulnerability_check: Optional[pulumi.Input['VulnerabilityCheckArgs']] = None):
        """
        A single check to perform against a Pod. Checks are grouped into `CheckSet` objects, which are defined by the top-level policy.
        :param pulumi.Input[bool] always_deny: Optional. A special-case check that always denies. Note that this still only applies when the scope of the `CheckSet` applies and the image isn't exempted by an image allowlist. This check is primarily useful for testing, or to set the default behavior for all unmatched scopes to "deny".
        :param pulumi.Input[str] display_name: Optional. A user-provided name for this check. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
        :param pulumi.Input['ImageAllowlistArgs'] image_allowlist: Optional. Images exempted from this check. If any of the patterns match the image url, the check will not be evaluated.
        :param pulumi.Input['ImageFreshnessCheckArgs'] image_freshness_check: Optional. Require that an image is no older than a configured expiration time. Image age is determined by its upload time.
        :param pulumi.Input['SimpleSigningAttestationCheckArgs'] simple_signing_attestation_check: Optional. Require a SimpleSigning-type attestation for every image in the deployment.
        :param pulumi.Input['SlsaCheckArgs'] slsa_check: Optional. Require that an image was built by a trusted builder (such as Google Cloud Build), meets requirements for Supply chain Levels for Software Artifacts (SLSA), and was built from a trusted source code repostitory.
        :param pulumi.Input['TrustedDirectoryCheckArgs'] trusted_directory_check: Optional. Require that an image lives in a trusted directory.
        :param pulumi.Input['VulnerabilityCheckArgs'] vulnerability_check: Optional. Require that an image does not contain vulnerabilities that violate the configured rules, such as based on severity levels.
        """
        if always_deny is not None:
            pulumi.set(__self__, "always_deny", always_deny)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if image_allowlist is not None:
            pulumi.set(__self__, "image_allowlist", image_allowlist)
        if image_freshness_check is not None:
            pulumi.set(__self__, "image_freshness_check", image_freshness_check)
        if simple_signing_attestation_check is not None:
            pulumi.set(__self__, "simple_signing_attestation_check", simple_signing_attestation_check)
        if slsa_check is not None:
            pulumi.set(__self__, "slsa_check", slsa_check)
        if trusted_directory_check is not None:
            pulumi.set(__self__, "trusted_directory_check", trusted_directory_check)
        if vulnerability_check is not None:
            pulumi.set(__self__, "vulnerability_check", vulnerability_check)

    @property
    @pulumi.getter(name="alwaysDeny")
    def always_deny(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. A special-case check that always denies. Note that this still only applies when the scope of the `CheckSet` applies and the image isn't exempted by an image allowlist. This check is primarily useful for testing, or to set the default behavior for all unmatched scopes to "deny".
        """
        return pulumi.get(self, "always_deny")

    @always_deny.setter
    def always_deny(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_deny", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. A user-provided name for this check. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="imageAllowlist")
    def image_allowlist(self) -> Optional[pulumi.Input['ImageAllowlistArgs']]:
        """
        Optional. Images exempted from this check. If any of the patterns match the image url, the check will not be evaluated.
        """
        return pulumi.get(self, "image_allowlist")

    @image_allowlist.setter
    def image_allowlist(self, value: Optional[pulumi.Input['ImageAllowlistArgs']]):
        pulumi.set(self, "image_allowlist", value)

    @property
    @pulumi.getter(name="imageFreshnessCheck")
    def image_freshness_check(self) -> Optional[pulumi.Input['ImageFreshnessCheckArgs']]:
        """
        Optional. Require that an image is no older than a configured expiration time. Image age is determined by its upload time.
        """
        return pulumi.get(self, "image_freshness_check")

    @image_freshness_check.setter
    def image_freshness_check(self, value: Optional[pulumi.Input['ImageFreshnessCheckArgs']]):
        pulumi.set(self, "image_freshness_check", value)

    @property
    @pulumi.getter(name="simpleSigningAttestationCheck")
    def simple_signing_attestation_check(self) -> Optional[pulumi.Input['SimpleSigningAttestationCheckArgs']]:
        """
        Optional. Require a SimpleSigning-type attestation for every image in the deployment.
        """
        return pulumi.get(self, "simple_signing_attestation_check")

    @simple_signing_attestation_check.setter
    def simple_signing_attestation_check(self, value: Optional[pulumi.Input['SimpleSigningAttestationCheckArgs']]):
        pulumi.set(self, "simple_signing_attestation_check", value)

    @property
    @pulumi.getter(name="slsaCheck")
    def slsa_check(self) -> Optional[pulumi.Input['SlsaCheckArgs']]:
        """
        Optional. Require that an image was built by a trusted builder (such as Google Cloud Build), meets requirements for Supply chain Levels for Software Artifacts (SLSA), and was built from a trusted source code repostitory.
        """
        return pulumi.get(self, "slsa_check")

    @slsa_check.setter
    def slsa_check(self, value: Optional[pulumi.Input['SlsaCheckArgs']]):
        pulumi.set(self, "slsa_check", value)

    @property
    @pulumi.getter(name="trustedDirectoryCheck")
    def trusted_directory_check(self) -> Optional[pulumi.Input['TrustedDirectoryCheckArgs']]:
        """
        Optional. Require that an image lives in a trusted directory.
        """
        return pulumi.get(self, "trusted_directory_check")

    @trusted_directory_check.setter
    def trusted_directory_check(self, value: Optional[pulumi.Input['TrustedDirectoryCheckArgs']]):
        pulumi.set(self, "trusted_directory_check", value)

    @property
    @pulumi.getter(name="vulnerabilityCheck")
    def vulnerability_check(self) -> Optional[pulumi.Input['VulnerabilityCheckArgs']]:
        """
        Optional. Require that an image does not contain vulnerabilities that violate the configured rules, such as based on severity levels.
        """
        return pulumi.get(self, "vulnerability_check")

    @vulnerability_check.setter
    def vulnerability_check(self, value: Optional[pulumi.Input['VulnerabilityCheckArgs']]):
        pulumi.set(self, "vulnerability_check", value)


@pulumi.input_type
class ExprArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
        :param pulumi.Input[str] description: Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        :param pulumi.Input[str] expression: Textual representation of an expression in Common Expression Language syntax.
        :param pulumi.Input[str] location: Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
        :param pulumi.Input[str] title: Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class GkePolicyArgs:
    def __init__(__self__, *,
                 check_sets: Optional[pulumi.Input[Sequence[pulumi.Input['CheckSetArgs']]]] = None,
                 image_allowlist: Optional[pulumi.Input['ImageAllowlistArgs']] = None):
        """
        A Binary Authorization policy for a GKE cluster. This is one type of policy that can occur as a `PlatformPolicy`.
        :param pulumi.Input[Sequence[pulumi.Input['CheckSetArgs']]] check_sets: Optional. The `CheckSet` objects to apply, scoped by namespace or namespace and service account. Exactly one `CheckSet` will be evaluated for a given Pod (unless the list is empty, in which case the behavior is "always allow"). If multiple `CheckSet` objects have scopes that match the namespace and service account of the Pod being evaluated, only the `CheckSet` with the MOST SPECIFIC scope will match. `CheckSet` objects must be listed in order of decreasing specificity, i.e. if a scope matches a given service account (which must include the namespace), it must come before a `CheckSet` with a scope matching just that namespace. This property is enforced by server-side validation. The purpose of this restriction is to ensure that if more than one `CheckSet` matches a given Pod, the `CheckSet` that will be evaluated will always be the first in the list to match (because if any other matches, it must be less specific). If `check_sets` is empty, the default behavior is to allow all images. If `check_sets` is non-empty, the last `check_sets` entry must always be a `CheckSet` with no scope set, i.e. a catchall to handle any situation not caught by the preceding `CheckSet` objects.
        :param pulumi.Input['ImageAllowlistArgs'] image_allowlist: Optional. Images exempted from this policy. If any of the patterns match the image being evaluated, the rest of the policy will not be evaluated.
        """
        if check_sets is not None:
            pulumi.set(__self__, "check_sets", check_sets)
        if image_allowlist is not None:
            pulumi.set(__self__, "image_allowlist", image_allowlist)

    @property
    @pulumi.getter(name="checkSets")
    def check_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CheckSetArgs']]]]:
        """
        Optional. The `CheckSet` objects to apply, scoped by namespace or namespace and service account. Exactly one `CheckSet` will be evaluated for a given Pod (unless the list is empty, in which case the behavior is "always allow"). If multiple `CheckSet` objects have scopes that match the namespace and service account of the Pod being evaluated, only the `CheckSet` with the MOST SPECIFIC scope will match. `CheckSet` objects must be listed in order of decreasing specificity, i.e. if a scope matches a given service account (which must include the namespace), it must come before a `CheckSet` with a scope matching just that namespace. This property is enforced by server-side validation. The purpose of this restriction is to ensure that if more than one `CheckSet` matches a given Pod, the `CheckSet` that will be evaluated will always be the first in the list to match (because if any other matches, it must be less specific). If `check_sets` is empty, the default behavior is to allow all images. If `check_sets` is non-empty, the last `check_sets` entry must always be a `CheckSet` with no scope set, i.e. a catchall to handle any situation not caught by the preceding `CheckSet` objects.
        """
        return pulumi.get(self, "check_sets")

    @check_sets.setter
    def check_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CheckSetArgs']]]]):
        pulumi.set(self, "check_sets", value)

    @property
    @pulumi.getter(name="imageAllowlist")
    def image_allowlist(self) -> Optional[pulumi.Input['ImageAllowlistArgs']]:
        """
        Optional. Images exempted from this policy. If any of the patterns match the image being evaluated, the rest of the policy will not be evaluated.
        """
        return pulumi.get(self, "image_allowlist")

    @image_allowlist.setter
    def image_allowlist(self, value: Optional[pulumi.Input['ImageAllowlistArgs']]):
        pulumi.set(self, "image_allowlist", value)


@pulumi.input_type
class ImageAllowlistArgs:
    def __init__(__self__, *,
                 allow_pattern: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Images that are exempted from normal checks based on name pattern only.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_pattern: A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
        """
        pulumi.set(__self__, "allow_pattern", allow_pattern)

    @property
    @pulumi.getter(name="allowPattern")
    def allow_pattern(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
        """
        return pulumi.get(self, "allow_pattern")

    @allow_pattern.setter
    def allow_pattern(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allow_pattern", value)


@pulumi.input_type
class ImageFreshnessCheckArgs:
    def __init__(__self__, *,
                 max_upload_age_days: pulumi.Input[int]):
        """
        An image freshness check, which rejects images that were uploaded before the set number of days ago to the supported repositories.
        :param pulumi.Input[int] max_upload_age_days: The max number of days that is allowed since the image was uploaded. Must be greater than zero.
        """
        pulumi.set(__self__, "max_upload_age_days", max_upload_age_days)

    @property
    @pulumi.getter(name="maxUploadAgeDays")
    def max_upload_age_days(self) -> pulumi.Input[int]:
        """
        The max number of days that is allowed since the image was uploaded. Must be greater than zero.
        """
        return pulumi.get(self, "max_upload_age_days")

    @max_upload_age_days.setter
    def max_upload_age_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_upload_age_days", value)


@pulumi.input_type
class PkixPublicKeySetArgs:
    def __init__(__self__, *,
                 pkix_public_keys: pulumi.Input[Sequence[pulumi.Input['PkixPublicKeyArgs']]]):
        """
        A bundle of PKIX public keys, used to authenticate attestation signatures. Generally, a signature is considered to be authenticated by a `PkixPublicKeySet` if any of the public keys verify it (i.e. it is an "OR" of the keys).
        :param pulumi.Input[Sequence[pulumi.Input['PkixPublicKeyArgs']]] pkix_public_keys: `pkix_public_keys` must have at least one entry.
        """
        pulumi.set(__self__, "pkix_public_keys", pkix_public_keys)

    @property
    @pulumi.getter(name="pkixPublicKeys")
    def pkix_public_keys(self) -> pulumi.Input[Sequence[pulumi.Input['PkixPublicKeyArgs']]]:
        """
        `pkix_public_keys` must have at least one entry.
        """
        return pulumi.get(self, "pkix_public_keys")

    @pkix_public_keys.setter
    def pkix_public_keys(self, value: pulumi.Input[Sequence[pulumi.Input['PkixPublicKeyArgs']]]):
        pulumi.set(self, "pkix_public_keys", value)


@pulumi.input_type
class PkixPublicKeyArgs:
    def __init__(__self__, *,
                 key_id: Optional[pulumi.Input[str]] = None,
                 public_key_pem: Optional[pulumi.Input[str]] = None,
                 signature_algorithm: Optional[pulumi.Input['PkixPublicKeySignatureAlgorithm']] = None):
        """
        A public key in the PkixPublicKey [format](https://tools.ietf.org/html/rfc5280#section-4.1.2.7). Public keys of this type are typically textually encoded using the PEM format.
        :param pulumi.Input[str] key_id: Optional. The ID of this public key. Signatures verified by Binary Authorization must include the ID of the public key that can be used to verify them, and that ID must match the contents of this field exactly. This may be explicitly provided by the caller, but it MUST be a valid RFC3986 URI. If `key_id` is left blank and this `PkixPublicKey` is not used in the context of a wrapper (see next paragraph), a default key ID will be computed based on the digest of the DER encoding of the public key. If this `PkixPublicKey` is used in the context of a wrapper that has its own notion of key ID (e.g. `AttestorPublicKey`), then this field can either: * Match that value exactly. * Or be left blank, in which case it behaves exactly as though it is equal to that wrapper value.
        :param pulumi.Input[str] public_key_pem: A PEM-encoded public key, as described in https://tools.ietf.org/html/rfc7468#section-13
        :param pulumi.Input['PkixPublicKeySignatureAlgorithm'] signature_algorithm: The signature algorithm used to verify a message against a signature using this key. These signature algorithm must match the structure and any object identifiers encoded in `public_key_pem` (i.e. this algorithm must match that of the public key).
        """
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if public_key_pem is not None:
            pulumi.set(__self__, "public_key_pem", public_key_pem)
        if signature_algorithm is not None:
            pulumi.set(__self__, "signature_algorithm", signature_algorithm)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The ID of this public key. Signatures verified by Binary Authorization must include the ID of the public key that can be used to verify them, and that ID must match the contents of this field exactly. This may be explicitly provided by the caller, but it MUST be a valid RFC3986 URI. If `key_id` is left blank and this `PkixPublicKey` is not used in the context of a wrapper (see next paragraph), a default key ID will be computed based on the digest of the DER encoding of the public key. If this `PkixPublicKey` is used in the context of a wrapper that has its own notion of key ID (e.g. `AttestorPublicKey`), then this field can either: * Match that value exactly. * Or be left blank, in which case it behaves exactly as though it is equal to that wrapper value.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_id", value)

    @property
    @pulumi.getter(name="publicKeyPem")
    def public_key_pem(self) -> Optional[pulumi.Input[str]]:
        """
        A PEM-encoded public key, as described in https://tools.ietf.org/html/rfc7468#section-13
        """
        return pulumi.get(self, "public_key_pem")

    @public_key_pem.setter
    def public_key_pem(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_key_pem", value)

    @property
    @pulumi.getter(name="signatureAlgorithm")
    def signature_algorithm(self) -> Optional[pulumi.Input['PkixPublicKeySignatureAlgorithm']]:
        """
        The signature algorithm used to verify a message against a signature using this key. These signature algorithm must match the structure and any object identifiers encoded in `public_key_pem` (i.e. this algorithm must match that of the public key).
        """
        return pulumi.get(self, "signature_algorithm")

    @signature_algorithm.setter
    def signature_algorithm(self, value: Optional[pulumi.Input['PkixPublicKeySignatureAlgorithm']]):
        pulumi.set(self, "signature_algorithm", value)


@pulumi.input_type
class ScopeArgs:
    def __init__(__self__, *,
                 kubernetes_namespace: Optional[pulumi.Input[str]] = None,
                 kubernetes_service_account: Optional[pulumi.Input[str]] = None):
        """
        A scope specifier for `CheckSet` objects.
        :param pulumi.Input[str] kubernetes_namespace: Optional. Matches all Kubernetes service accounts in the provided namespace, unless a more specific `kubernetes_service_account` scope already matched.
        :param pulumi.Input[str] kubernetes_service_account: Optional. Matches a single Kubernetes service account, e.g. `my-namespace:my-service-account`. `kubernetes_service_account` scope is always more specific than `kubernetes_namespace` scope for the same namespace.
        """
        if kubernetes_namespace is not None:
            pulumi.set(__self__, "kubernetes_namespace", kubernetes_namespace)
        if kubernetes_service_account is not None:
            pulumi.set(__self__, "kubernetes_service_account", kubernetes_service_account)

    @property
    @pulumi.getter(name="kubernetesNamespace")
    def kubernetes_namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Matches all Kubernetes service accounts in the provided namespace, unless a more specific `kubernetes_service_account` scope already matched.
        """
        return pulumi.get(self, "kubernetes_namespace")

    @kubernetes_namespace.setter
    def kubernetes_namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kubernetes_namespace", value)

    @property
    @pulumi.getter(name="kubernetesServiceAccount")
    def kubernetes_service_account(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Matches a single Kubernetes service account, e.g. `my-namespace:my-service-account`. `kubernetes_service_account` scope is always more specific than `kubernetes_namespace` scope for the same namespace.
        """
        return pulumi.get(self, "kubernetes_service_account")

    @kubernetes_service_account.setter
    def kubernetes_service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kubernetes_service_account", value)


@pulumi.input_type
class SimpleSigningAttestationCheckArgs:
    def __init__(__self__, *,
                 attestation_authenticators: pulumi.Input[Sequence[pulumi.Input['AttestationAuthenticatorArgs']]],
                 container_analysis_attestation_projects: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Require a signed [DSSE](https://github.com/secure-systems-lab/dsse) attestation with type SimpleSigning.
        :param pulumi.Input[Sequence[pulumi.Input['AttestationAuthenticatorArgs']]] attestation_authenticators: The authenticators required by this check to verify an attestation. Typically this is one or more PKIX public keys for signature verification. Only one authenticator needs to consider an attestation verified in order for an attestation to be considered fully authenticated. In otherwords, this list of authenticators is an "OR" of the authenticator results. At least one authenticator is required.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] container_analysis_attestation_projects: Optional. The projects where attestations are stored as Container Analysis Occurrences. Only one attestation needs to successfully verify an image for this check to pass, so a single verified attestation found in any of `container_analysis_attestation_projects` is sufficient for the check to pass. When fetching Occurrences from Container Analysis, only 'AttestationOccurrence' kinds are considered. In the future, additional Occurrence kinds may be added to the query.
        """
        pulumi.set(__self__, "attestation_authenticators", attestation_authenticators)
        if container_analysis_attestation_projects is not None:
            pulumi.set(__self__, "container_analysis_attestation_projects", container_analysis_attestation_projects)

    @property
    @pulumi.getter(name="attestationAuthenticators")
    def attestation_authenticators(self) -> pulumi.Input[Sequence[pulumi.Input['AttestationAuthenticatorArgs']]]:
        """
        The authenticators required by this check to verify an attestation. Typically this is one or more PKIX public keys for signature verification. Only one authenticator needs to consider an attestation verified in order for an attestation to be considered fully authenticated. In otherwords, this list of authenticators is an "OR" of the authenticator results. At least one authenticator is required.
        """
        return pulumi.get(self, "attestation_authenticators")

    @attestation_authenticators.setter
    def attestation_authenticators(self, value: pulumi.Input[Sequence[pulumi.Input['AttestationAuthenticatorArgs']]]):
        pulumi.set(self, "attestation_authenticators", value)

    @property
    @pulumi.getter(name="containerAnalysisAttestationProjects")
    def container_analysis_attestation_projects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. The projects where attestations are stored as Container Analysis Occurrences. Only one attestation needs to successfully verify an image for this check to pass, so a single verified attestation found in any of `container_analysis_attestation_projects` is sufficient for the check to pass. When fetching Occurrences from Container Analysis, only 'AttestationOccurrence' kinds are considered. In the future, additional Occurrence kinds may be added to the query.
        """
        return pulumi.get(self, "container_analysis_attestation_projects")

    @container_analysis_attestation_projects.setter
    def container_analysis_attestation_projects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "container_analysis_attestation_projects", value)


@pulumi.input_type
class SlsaCheckArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['VerificationRuleArgs']]]] = None):
        """
        A SLSA provenance attestation check, which ensures that images are built by a trusted builder using source code from its trusted repositories only.
        :param pulumi.Input[Sequence[pulumi.Input['VerificationRuleArgs']]] rules: Specifies a list of verification rules for the SLSA attestations. An image is considered compliant with the SlsaCheck if any of the rules are satisfied.
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VerificationRuleArgs']]]]:
        """
        Specifies a list of verification rules for the SLSA attestations. An image is considered compliant with the SlsaCheck if any of the rules are satisfied.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VerificationRuleArgs']]]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class TrustedDirectoryCheckArgs:
    def __init__(__self__, *,
                 trusted_dir_patterns: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        A trusted directory check, which rejects images that do not come from the set of user-configured trusted directories.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] trusted_dir_patterns: List of trusted directory patterns. A pattern is in the form "registry/path/to/directory". The registry domain part is defined as two or more dot-separated words, e.g., `us.pkg.dev`, or `gcr.io`. Additionally, `*` can be used in three ways as wildcards: 1. leading `*` to match varying prefixes in registry subdomain (useful for location prefixes); 2. trailing `*` after registry/ to match varying endings; 3. trailing `**` after registry/ to match "/" as well. For example: -- `gcr.io/my-project/my-repo` is valid to match a single directory -- `*-docker.pkg.dev/my-project/my-repo` or `*.gcr.io/my-project` are valid to match varying prefixes -- `gcr.io/my-project/*` will match all direct directories in `my-project` -- `gcr.io/my-project/**` would match all directories in `my-project` -- `gcr.i*` is not allowed since the registry is not completely specified -- `sub*domain.gcr.io/nginx` is not valid because only leading `*` or trailing `*` are allowed. -- `*pkg.dev/my-project/my-repo` is not valid because leading `*` can only match subdomain -- `**-docker.pkg.dev` is not valid because one leading `*` is allowed, and that it cannot match `/`
        """
        pulumi.set(__self__, "trusted_dir_patterns", trusted_dir_patterns)

    @property
    @pulumi.getter(name="trustedDirPatterns")
    def trusted_dir_patterns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of trusted directory patterns. A pattern is in the form "registry/path/to/directory". The registry domain part is defined as two or more dot-separated words, e.g., `us.pkg.dev`, or `gcr.io`. Additionally, `*` can be used in three ways as wildcards: 1. leading `*` to match varying prefixes in registry subdomain (useful for location prefixes); 2. trailing `*` after registry/ to match varying endings; 3. trailing `**` after registry/ to match "/" as well. For example: -- `gcr.io/my-project/my-repo` is valid to match a single directory -- `*-docker.pkg.dev/my-project/my-repo` or `*.gcr.io/my-project` are valid to match varying prefixes -- `gcr.io/my-project/*` will match all direct directories in `my-project` -- `gcr.io/my-project/**` would match all directories in `my-project` -- `gcr.i*` is not allowed since the registry is not completely specified -- `sub*domain.gcr.io/nginx` is not valid because only leading `*` or trailing `*` are allowed. -- `*pkg.dev/my-project/my-repo` is not valid because leading `*` can only match subdomain -- `**-docker.pkg.dev` is not valid because one leading `*` is allowed, and that it cannot match `/`
        """
        return pulumi.get(self, "trusted_dir_patterns")

    @trusted_dir_patterns.setter
    def trusted_dir_patterns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "trusted_dir_patterns", value)


@pulumi.input_type
class UserOwnedGrafeasNoteArgs:
    def __init__(__self__, *,
                 note_reference: pulumi.Input[str],
                 public_keys: Optional[pulumi.Input[Sequence[pulumi.Input['AttestorPublicKeyArgs']]]] = None):
        """
        An user owned Grafeas note references a Grafeas Attestation.Authority Note created by the user.
        :param pulumi.Input[str] note_reference: The Grafeas resource name of a Attestation.Authority Note, created by the user, in the format: `projects/*/notes/*`. This field may not be updated. An attestation by this attestor is stored as a Grafeas Attestation.Authority Occurrence that names a container image and that links to this Note. Grafeas is an external dependency.
        :param pulumi.Input[Sequence[pulumi.Input['AttestorPublicKeyArgs']]] public_keys: Optional. Public keys that verify attestations signed by this attestor. This field may be updated. If this field is non-empty, one of the specified public keys must verify that an attestation was signed by this attestor for the image specified in the admission request. If this field is empty, this attestor always returns that no valid attestations exist.
        """
        pulumi.set(__self__, "note_reference", note_reference)
        if public_keys is not None:
            pulumi.set(__self__, "public_keys", public_keys)

    @property
    @pulumi.getter(name="noteReference")
    def note_reference(self) -> pulumi.Input[str]:
        """
        The Grafeas resource name of a Attestation.Authority Note, created by the user, in the format: `projects/*/notes/*`. This field may not be updated. An attestation by this attestor is stored as a Grafeas Attestation.Authority Occurrence that names a container image and that links to this Note. Grafeas is an external dependency.
        """
        return pulumi.get(self, "note_reference")

    @note_reference.setter
    def note_reference(self, value: pulumi.Input[str]):
        pulumi.set(self, "note_reference", value)

    @property
    @pulumi.getter(name="publicKeys")
    def public_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AttestorPublicKeyArgs']]]]:
        """
        Optional. Public keys that verify attestations signed by this attestor. This field may be updated. If this field is non-empty, one of the specified public keys must verify that an attestation was signed by this attestor for the image specified in the admission request. If this field is empty, this attestor always returns that no valid attestations exist.
        """
        return pulumi.get(self, "public_keys")

    @public_keys.setter
    def public_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AttestorPublicKeyArgs']]]]):
        pulumi.set(self, "public_keys", value)


@pulumi.input_type
class VerificationRuleArgs:
    def __init__(__self__, *,
                 attestation_source: Optional[pulumi.Input['AttestationSourceArgs']] = None,
                 config_based_build_required: Optional[pulumi.Input[bool]] = None,
                 trusted_builder: Optional[pulumi.Input['VerificationRuleTrustedBuilder']] = None,
                 trusted_source_repo_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Specifies verification rules for evaluating the SLSA attestations including: which builders to trust, where to fetch the SLSA attestations generated by those builders, and other builder-specific evaluation rules such as which source repositories are trusted. An image is considered verified by the rule if any of the fetched SLSA attestations is verified.
        :param pulumi.Input['AttestationSourceArgs'] attestation_source: Specifies where to fetch the provenances attestations generated by the builder (group).
        :param pulumi.Input[bool] config_based_build_required: If true, require the image to be built from a top-level configuration. `trusted_source_repo_patterns` specifies the repositories containing this configuration.
        :param pulumi.Input['VerificationRuleTrustedBuilder'] trusted_builder: Each verification rule is used for evaluation against provenances generated by a specific builder (group). For some of the builders, such as the Google Cloud Build, users don't need to explicitly specify their roots of trust in the policy since the evaluation service can automatically fetch them based on the builder (group).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] trusted_source_repo_patterns: List of trusted source code repository URL patterns. These patterns match the full repository URL without its scheme (e.g. `https://`). The patterns must not include schemes. For example, the pattern `source.cloud.google.com/my-project/my-repo-name` matches the following URLs: - `source.cloud.google.com/my-project/my-repo-name` - `git+ssh://source.cloud.google.com/my-project/my-repo-name` - `https://source.cloud.google.com/my-project/my-repo-name` A pattern matches a URL either exactly or with `*` wildcards. `*` can be used in only two ways: 1. trailing `*` after hosturi/ to match varying endings; 2. trailing `**` after hosturi/ to match `/` as well. `*` and `**` can only be used as wildcards and can only occur at the end of the pattern after a `/`. (So it's not possible to match a URL that contains literal `*`.) For example: - `github.com/my-project/my-repo` is valid to match a single repo - `github.com/my-project/*` will match all direct repos in `my-project` - `github.com/**` matches all repos in GitHub
        """
        if attestation_source is not None:
            pulumi.set(__self__, "attestation_source", attestation_source)
        if config_based_build_required is not None:
            pulumi.set(__self__, "config_based_build_required", config_based_build_required)
        if trusted_builder is not None:
            pulumi.set(__self__, "trusted_builder", trusted_builder)
        if trusted_source_repo_patterns is not None:
            pulumi.set(__self__, "trusted_source_repo_patterns", trusted_source_repo_patterns)

    @property
    @pulumi.getter(name="attestationSource")
    def attestation_source(self) -> Optional[pulumi.Input['AttestationSourceArgs']]:
        """
        Specifies where to fetch the provenances attestations generated by the builder (group).
        """
        return pulumi.get(self, "attestation_source")

    @attestation_source.setter
    def attestation_source(self, value: Optional[pulumi.Input['AttestationSourceArgs']]):
        pulumi.set(self, "attestation_source", value)

    @property
    @pulumi.getter(name="configBasedBuildRequired")
    def config_based_build_required(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, require the image to be built from a top-level configuration. `trusted_source_repo_patterns` specifies the repositories containing this configuration.
        """
        return pulumi.get(self, "config_based_build_required")

    @config_based_build_required.setter
    def config_based_build_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "config_based_build_required", value)

    @property
    @pulumi.getter(name="trustedBuilder")
    def trusted_builder(self) -> Optional[pulumi.Input['VerificationRuleTrustedBuilder']]:
        """
        Each verification rule is used for evaluation against provenances generated by a specific builder (group). For some of the builders, such as the Google Cloud Build, users don't need to explicitly specify their roots of trust in the policy since the evaluation service can automatically fetch them based on the builder (group).
        """
        return pulumi.get(self, "trusted_builder")

    @trusted_builder.setter
    def trusted_builder(self, value: Optional[pulumi.Input['VerificationRuleTrustedBuilder']]):
        pulumi.set(self, "trusted_builder", value)

    @property
    @pulumi.getter(name="trustedSourceRepoPatterns")
    def trusted_source_repo_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of trusted source code repository URL patterns. These patterns match the full repository URL without its scheme (e.g. `https://`). The patterns must not include schemes. For example, the pattern `source.cloud.google.com/my-project/my-repo-name` matches the following URLs: - `source.cloud.google.com/my-project/my-repo-name` - `git+ssh://source.cloud.google.com/my-project/my-repo-name` - `https://source.cloud.google.com/my-project/my-repo-name` A pattern matches a URL either exactly or with `*` wildcards. `*` can be used in only two ways: 1. trailing `*` after hosturi/ to match varying endings; 2. trailing `**` after hosturi/ to match `/` as well. `*` and `**` can only be used as wildcards and can only occur at the end of the pattern after a `/`. (So it's not possible to match a URL that contains literal `*`.) For example: - `github.com/my-project/my-repo` is valid to match a single repo - `github.com/my-project/*` will match all direct repos in `my-project` - `github.com/**` matches all repos in GitHub
        """
        return pulumi.get(self, "trusted_source_repo_patterns")

    @trusted_source_repo_patterns.setter
    def trusted_source_repo_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "trusted_source_repo_patterns", value)


@pulumi.input_type
class VulnerabilityCheckArgs:
    def __init__(__self__, *,
                 maximum_fixable_severity: pulumi.Input['VulnerabilityCheckMaximumFixableSeverity'],
                 maximum_unfixable_severity: pulumi.Input['VulnerabilityCheckMaximumUnfixableSeverity'],
                 allowed_cves: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 blocked_cves: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 container_analysis_vulnerability_projects: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        An image vulnerability check, which rejects images that violate the configured vulnerability rules.
        :param pulumi.Input['VulnerabilityCheckMaximumFixableSeverity'] maximum_fixable_severity: The threshold for severity for which a fix is currently available. This field is required and must be set.
        :param pulumi.Input['VulnerabilityCheckMaximumUnfixableSeverity'] maximum_unfixable_severity: The threshold for severity for which a fix isn't currently available. This field is required and must be set.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_cves: Optional. A list of specific CVEs to ignore even if the vulnerability level violates `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will allow vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] blocked_cves: Optional. A list of specific CVEs to always raise warnings about even if the vulnerability level meets `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will block vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] container_analysis_vulnerability_projects: Optional. The projects where vulnerabilities are stored as Container Analysis Occurrences. Each project is expressed in the resource format of `projects/[PROJECT_ID]`, e.g., `projects/my-gcp-project`. An attempt will be made for each project to fetch vulnerabilities, and all valid vulnerabilities will be used to check against the vulnerability policy. If no valid scan is found in all projects configured here, an error will be returned for the check.
        """
        pulumi.set(__self__, "maximum_fixable_severity", maximum_fixable_severity)
        pulumi.set(__self__, "maximum_unfixable_severity", maximum_unfixable_severity)
        if allowed_cves is not None:
            pulumi.set(__self__, "allowed_cves", allowed_cves)
        if blocked_cves is not None:
            pulumi.set(__self__, "blocked_cves", blocked_cves)
        if container_analysis_vulnerability_projects is not None:
            pulumi.set(__self__, "container_analysis_vulnerability_projects", container_analysis_vulnerability_projects)

    @property
    @pulumi.getter(name="maximumFixableSeverity")
    def maximum_fixable_severity(self) -> pulumi.Input['VulnerabilityCheckMaximumFixableSeverity']:
        """
        The threshold for severity for which a fix is currently available. This field is required and must be set.
        """
        return pulumi.get(self, "maximum_fixable_severity")

    @maximum_fixable_severity.setter
    def maximum_fixable_severity(self, value: pulumi.Input['VulnerabilityCheckMaximumFixableSeverity']):
        pulumi.set(self, "maximum_fixable_severity", value)

    @property
    @pulumi.getter(name="maximumUnfixableSeverity")
    def maximum_unfixable_severity(self) -> pulumi.Input['VulnerabilityCheckMaximumUnfixableSeverity']:
        """
        The threshold for severity for which a fix isn't currently available. This field is required and must be set.
        """
        return pulumi.get(self, "maximum_unfixable_severity")

    @maximum_unfixable_severity.setter
    def maximum_unfixable_severity(self, value: pulumi.Input['VulnerabilityCheckMaximumUnfixableSeverity']):
        pulumi.set(self, "maximum_unfixable_severity", value)

    @property
    @pulumi.getter(name="allowedCves")
    def allowed_cves(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. A list of specific CVEs to ignore even if the vulnerability level violates `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will allow vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
        """
        return pulumi.get(self, "allowed_cves")

    @allowed_cves.setter
    def allowed_cves(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_cves", value)

    @property
    @pulumi.getter(name="blockedCves")
    def blocked_cves(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. A list of specific CVEs to always raise warnings about even if the vulnerability level meets `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will block vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
        """
        return pulumi.get(self, "blocked_cves")

    @blocked_cves.setter
    def blocked_cves(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "blocked_cves", value)

    @property
    @pulumi.getter(name="containerAnalysisVulnerabilityProjects")
    def container_analysis_vulnerability_projects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. The projects where vulnerabilities are stored as Container Analysis Occurrences. Each project is expressed in the resource format of `projects/[PROJECT_ID]`, e.g., `projects/my-gcp-project`. An attempt will be made for each project to fetch vulnerabilities, and all valid vulnerabilities will be used to check against the vulnerability policy. If no valid scan is found in all projects configured here, an error will be returned for the check.
        """
        return pulumi.get(self, "container_analysis_vulnerability_projects")

    @container_analysis_vulnerability_projects.setter
    def container_analysis_vulnerability_projects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "container_analysis_vulnerability_projects", value)


