# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ActingUserResponse',
    'CertDnsChallengeResponse',
    'CertHttpChallengeResponse',
    'CertVerificationResponse',
    'CertificateResponse',
    'CloudRunRewriteResponse',
    'DnsRecordResponse',
    'DnsRecordSetResponse',
    'DnsUpdatesResponse',
    'DomainProvisioningResponse',
    'DomainRedirectResponse',
    'HeaderResponse',
    'HttpUpdateResponse',
    'I18nConfigResponse',
    'RedirectResponse',
    'ReleaseResponse',
    'RewriteResponse',
    'ServingConfigResponse',
    'StatusResponse',
    'VersionResponse',
]

@pulumi.output_type
class ActingUserResponse(dict):
    """
    Contains metadata about the user who performed an action, such as creating a release or finalizing a version.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActingUserResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActingUserResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActingUserResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: str,
                 image_url: str):
        """
        Contains metadata about the user who performed an action, such as creating a release or finalizing a version.
        :param str email: The email address of the user when the user performed the action.
        :param str image_url: A profile image URL for the user. May not be present if the user has changed their email address or deleted their account.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "image_url", image_url)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email address of the user when the user performed the action.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> str:
        """
        A profile image URL for the user. May not be present if the user has changed their email address or deleted their account.
        """
        return pulumi.get(self, "image_url")


@pulumi.output_type
class CertDnsChallengeResponse(dict):
    """
    Represents a DNS certificate challenge.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainName":
            suggest = "domain_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertDnsChallengeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertDnsChallengeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertDnsChallengeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name: str,
                 token: str):
        """
        Represents a DNS certificate challenge.
        :param str domain_name: The domain name upon which the DNS challenge must be satisfied.
        :param str token: The value that must be present as a TXT record on the domain name to satisfy the challenge.
        """
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        The domain name upon which the DNS challenge must be satisfied.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        The value that must be present as a TXT record on the domain name to satisfy the challenge.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class CertHttpChallengeResponse(dict):
    """
    Represents an HTTP certificate challenge.
    """
    def __init__(__self__, *,
                 path: str,
                 token: str):
        """
        Represents an HTTP certificate challenge.
        :param str path: The URL path on which to serve the specified token to satisfy the certificate challenge.
        :param str token: The token to serve at the specified URL path to satisfy the certificate challenge.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The URL path on which to serve the specified token to satisfy the certificate challenge.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        The token to serve at the specified URL path to satisfy the certificate challenge.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class CertVerificationResponse(dict):
    """
    A set of ACME challenges you can use to allow Hosting to create an SSL certificate for your domain name before directing traffic to Hosting servers. Use either the DNS or HTTP challenge; it's not necessary to provide both.
    """
    def __init__(__self__, *,
                 dns: 'outputs.DnsUpdatesResponse',
                 http: 'outputs.HttpUpdateResponse'):
        """
        A set of ACME challenges you can use to allow Hosting to create an SSL certificate for your domain name before directing traffic to Hosting servers. Use either the DNS or HTTP challenge; it's not necessary to provide both.
        :param 'DnsUpdatesResponse' dns: A `TXT` record to add to your DNS records that confirms your intent to let Hosting create an SSL cert for your domain name.
        :param 'HttpUpdateResponse' http: A file to add to your existing, non-Hosting hosting service that confirms your intent to let Hosting create an SSL cert for your domain name.
        """
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "http", http)

    @property
    @pulumi.getter
    def dns(self) -> 'outputs.DnsUpdatesResponse':
        """
        A `TXT` record to add to your DNS records that confirms your intent to let Hosting create an SSL cert for your domain name.
        """
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter
    def http(self) -> 'outputs.HttpUpdateResponse':
        """
        A file to add to your existing, non-Hosting hosting service that confirms your intent to let Hosting create an SSL cert for your domain name.
        """
        return pulumi.get(self, "http")


@pulumi.output_type
class CertificateResponse(dict):
    """
    An SSL certificate used to provide end-to-end encryption for requests against your domain name. A `Certificate` can be an actual SSL certificate or, for newly-created custom domains, Hosting's intent to create one.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createTime":
            suggest = "create_time"
        elif key == "expireTime":
            suggest = "expire_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_time: str,
                 expire_time: str,
                 issues: Sequence['outputs.StatusResponse'],
                 state: str,
                 type: str,
                 verification: 'outputs.CertVerificationResponse'):
        """
        An SSL certificate used to provide end-to-end encryption for requests against your domain name. A `Certificate` can be an actual SSL certificate or, for newly-created custom domains, Hosting's intent to create one.
        :param str create_time: The certificate's creation time. For `TEMPORARY` certs this is the time Hosting first generated challenges for your domain name. For all other cert types, it's the time the actual cert was created.
        :param str expire_time: The certificate's expiration time. After this time, the cert can no longer be used to provide secure communication between Hosting and your site's visitors.
        :param Sequence['StatusResponse'] issues: A set of errors Hosting encountered when attempting to create a cert for your domain name. Resolve these issues to ensure Hosting is able to provide secure communication with your site's visitors.
        :param str state: The state of the certificate. Only the `CERT_ACTIVE` and `CERT_EXPIRING_SOON` states provide SSL coverage for a domain name. If the state is `PROPAGATING` and Hosting had an active cert for the domain name before, that formerly-active cert provides SSL coverage for the domain name until the current cert propagates.
        :param str type: The certificate's type.
        :param 'CertVerificationResponse' verification: A set of ACME challenges you can add to your DNS records or existing, non-Hosting hosting provider to allow Hosting to create an SSL certificate for your domain name before you point traffic toward hosting. You can use thse challenges as part of a zero downtime transition from your old provider to Hosting.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "expire_time", expire_time)
        pulumi.set(__self__, "issues", issues)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "verification", verification)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The certificate's creation time. For `TEMPORARY` certs this is the time Hosting first generated challenges for your domain name. For all other cert types, it's the time the actual cert was created.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> str:
        """
        The certificate's expiration time. After this time, the cert can no longer be used to provide secure communication between Hosting and your site's visitors.
        """
        return pulumi.get(self, "expire_time")

    @property
    @pulumi.getter
    def issues(self) -> Sequence['outputs.StatusResponse']:
        """
        A set of errors Hosting encountered when attempting to create a cert for your domain name. Resolve these issues to ensure Hosting is able to provide secure communication with your site's visitors.
        """
        return pulumi.get(self, "issues")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the certificate. Only the `CERT_ACTIVE` and `CERT_EXPIRING_SOON` states provide SSL coverage for a domain name. If the state is `PROPAGATING` and Hosting had an active cert for the domain name before, that formerly-active cert provides SSL coverage for the domain name until the current cert propagates.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The certificate's type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def verification(self) -> 'outputs.CertVerificationResponse':
        """
        A set of ACME challenges you can add to your DNS records or existing, non-Hosting hosting provider to allow Hosting to create an SSL certificate for your domain name before you point traffic toward hosting. You can use thse challenges as part of a zero downtime transition from your old provider to Hosting.
        """
        return pulumi.get(self, "verification")


@pulumi.output_type
class CloudRunRewriteResponse(dict):
    """
    A configured rewrite that directs requests to a Cloud Run service. If the Cloud Run service does not exist when setting or updating your Firebase Hosting configuration, then the request fails. Any errors from the Cloud Run service are passed to the end user (for example, if you delete a service, any requests directed to that service receive a `404` error).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceId":
            suggest = "service_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudRunRewriteResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudRunRewriteResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudRunRewriteResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region: str,
                 service_id: str,
                 tag: str):
        """
        A configured rewrite that directs requests to a Cloud Run service. If the Cloud Run service does not exist when setting or updating your Firebase Hosting configuration, then the request fails. Any errors from the Cloud Run service are passed to the end user (for example, if you delete a service, any requests directed to that service receive a `404` error).
        :param str region: Optional. User-provided region where the Cloud Run service is hosted. Defaults to `us-central1` if not supplied.
        :param str service_id: User-defined ID of the Cloud Run service.
        :param str tag: Optional. User-provided TrafficConfig tag to send traffic to. When omitted, traffic is sent to the service-wide URI
        """
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "service_id", service_id)
        pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Optional. User-provided region where the Cloud Run service is hosted. Defaults to `us-central1` if not supplied.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> str:
        """
        User-defined ID of the Cloud Run service.
        """
        return pulumi.get(self, "service_id")

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        Optional. User-provided TrafficConfig tag to send traffic to. When omitted, traffic is sent to the service-wide URI
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class DnsRecordResponse(dict):
    """
    DNS records are resource records that define how systems and services should behave when handling requests for a domain name. For example, when you add `A` records to your domain name's DNS records, you're informing other systems (such as your users' web browsers) to contact those IPv4 addresses to retrieve resources relevant to your domain name (such as your Hosting site files).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainName":
            suggest = "domain_name"
        elif key == "requiredAction":
            suggest = "required_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DnsRecordResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DnsRecordResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DnsRecordResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name: str,
                 rdata: str,
                 required_action: str,
                 type: str):
        """
        DNS records are resource records that define how systems and services should behave when handling requests for a domain name. For example, when you add `A` records to your domain name's DNS records, you're informing other systems (such as your users' web browsers) to contact those IPv4 addresses to retrieve resources relevant to your domain name (such as your Hosting site files).
        :param str domain_name: The domain name the record pertains to, e.g. `foo.bar.com.`.
        :param str rdata: The data of the record. The meaning of the value depends on record type: - A and AAAA: IP addresses for the domain name. - CNAME: Another domain to check for records. - TXT: Arbitrary text strings associated with the domain name. Hosting uses TXT records to determine which Firebase projects have permission to act on the domain name's behalf. - CAA: The record's flags, tag, and value, e.g. `0 issue "pki.goog"`.
        :param str required_action: An enum that indicates the a required action for this record.
        :param str type: The record's type, which determines what data the record contains.
        """
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "rdata", rdata)
        pulumi.set(__self__, "required_action", required_action)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        The domain name the record pertains to, e.g. `foo.bar.com.`.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter
    def rdata(self) -> str:
        """
        The data of the record. The meaning of the value depends on record type: - A and AAAA: IP addresses for the domain name. - CNAME: Another domain to check for records. - TXT: Arbitrary text strings associated with the domain name. Hosting uses TXT records to determine which Firebase projects have permission to act on the domain name's behalf. - CAA: The record's flags, tag, and value, e.g. `0 issue "pki.goog"`.
        """
        return pulumi.get(self, "rdata")

    @property
    @pulumi.getter(name="requiredAction")
    def required_action(self) -> str:
        """
        An enum that indicates the a required action for this record.
        """
        return pulumi.get(self, "required_action")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The record's type, which determines what data the record contains.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DnsRecordSetResponse(dict):
    """
    A set of DNS records relevant to the setup and maintenance of a custom domain in Firebase Hosting.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkError":
            suggest = "check_error"
        elif key == "domainName":
            suggest = "domain_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DnsRecordSetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DnsRecordSetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DnsRecordSetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_error: 'outputs.StatusResponse',
                 domain_name: str,
                 records: Sequence['outputs.DnsRecordResponse']):
        """
        A set of DNS records relevant to the setup and maintenance of a custom domain in Firebase Hosting.
        :param 'StatusResponse' check_error: An error Hosting services encountered when querying your domain name's DNS records. Note: Hosting ignores `NXDOMAIN` errors, as those generally just mean that a domain name hasn't been set up yet.
        :param str domain_name: The domain name the record set pertains to.
        :param Sequence['DnsRecordResponse'] records: Records on the domain.
        """
        pulumi.set(__self__, "check_error", check_error)
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "records", records)

    @property
    @pulumi.getter(name="checkError")
    def check_error(self) -> 'outputs.StatusResponse':
        """
        An error Hosting services encountered when querying your domain name's DNS records. Note: Hosting ignores `NXDOMAIN` errors, as those generally just mean that a domain name hasn't been set up yet.
        """
        return pulumi.get(self, "check_error")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        The domain name the record set pertains to.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter
    def records(self) -> Sequence['outputs.DnsRecordResponse']:
        """
        Records on the domain.
        """
        return pulumi.get(self, "records")


@pulumi.output_type
class DnsUpdatesResponse(dict):
    """
    A set of DNS record updates that you should make to allow Hosting to serve secure content in response to requests against your domain name. These updates present the current state of your domain name's DNS records when Hosting last queried them, and the desired set of records that Hosting needs to see before your custom domain can be fully active.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkTime":
            suggest = "check_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DnsUpdatesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DnsUpdatesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DnsUpdatesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_time: str,
                 desired: Sequence['outputs.DnsRecordSetResponse'],
                 discovered: Sequence['outputs.DnsRecordSetResponse']):
        """
        A set of DNS record updates that you should make to allow Hosting to serve secure content in response to requests against your domain name. These updates present the current state of your domain name's DNS records when Hosting last queried them, and the desired set of records that Hosting needs to see before your custom domain can be fully active.
        :param str check_time: The last time Hosting checked your custom domain's DNS records.
        :param Sequence['DnsRecordSetResponse'] desired: The set of DNS records Hosting needs to serve secure content on the domain.
        :param Sequence['DnsRecordSetResponse'] discovered: The set of DNS records Hosting discovered when inspecting a domain.
        """
        pulumi.set(__self__, "check_time", check_time)
        pulumi.set(__self__, "desired", desired)
        pulumi.set(__self__, "discovered", discovered)

    @property
    @pulumi.getter(name="checkTime")
    def check_time(self) -> str:
        """
        The last time Hosting checked your custom domain's DNS records.
        """
        return pulumi.get(self, "check_time")

    @property
    @pulumi.getter
    def desired(self) -> Sequence['outputs.DnsRecordSetResponse']:
        """
        The set of DNS records Hosting needs to serve secure content on the domain.
        """
        return pulumi.get(self, "desired")

    @property
    @pulumi.getter
    def discovered(self) -> Sequence['outputs.DnsRecordSetResponse']:
        """
        The set of DNS records Hosting discovered when inspecting a domain.
        """
        return pulumi.get(self, "discovered")


@pulumi.output_type
class DomainProvisioningResponse(dict):
    """
    The current certificate provisioning status information for a domain.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certChallengeDiscoveredTxt":
            suggest = "cert_challenge_discovered_txt"
        elif key == "certChallengeDns":
            suggest = "cert_challenge_dns"
        elif key == "certChallengeHttp":
            suggest = "cert_challenge_http"
        elif key == "certStatus":
            suggest = "cert_status"
        elif key == "discoveredIps":
            suggest = "discovered_ips"
        elif key == "dnsFetchTime":
            suggest = "dns_fetch_time"
        elif key == "dnsStatus":
            suggest = "dns_status"
        elif key == "expectedIps":
            suggest = "expected_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainProvisioningResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainProvisioningResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainProvisioningResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert_challenge_discovered_txt: Sequence[str],
                 cert_challenge_dns: 'outputs.CertDnsChallengeResponse',
                 cert_challenge_http: 'outputs.CertHttpChallengeResponse',
                 cert_status: str,
                 discovered_ips: Sequence[str],
                 dns_fetch_time: str,
                 dns_status: str,
                 expected_ips: Sequence[str]):
        """
        The current certificate provisioning status information for a domain.
        :param Sequence[str] cert_challenge_discovered_txt: The TXT records (for the certificate challenge) that were found at the last DNS fetch.
        :param 'CertDnsChallengeResponse' cert_challenge_dns: The DNS challenge for generating a certificate.
        :param 'CertHttpChallengeResponse' cert_challenge_http: The HTTP challenge for generating a certificate.
        :param str cert_status: The certificate provisioning status; updated when Firebase Hosting provisions an SSL certificate for the domain.
        :param Sequence[str] discovered_ips: The IPs found at the last DNS fetch.
        :param str dns_fetch_time: The time at which the last DNS fetch occurred.
        :param str dns_status: The DNS record match status as of the last DNS fetch.
        :param Sequence[str] expected_ips: The list of IPs to which the domain is expected to resolve.
        """
        pulumi.set(__self__, "cert_challenge_discovered_txt", cert_challenge_discovered_txt)
        pulumi.set(__self__, "cert_challenge_dns", cert_challenge_dns)
        pulumi.set(__self__, "cert_challenge_http", cert_challenge_http)
        pulumi.set(__self__, "cert_status", cert_status)
        pulumi.set(__self__, "discovered_ips", discovered_ips)
        pulumi.set(__self__, "dns_fetch_time", dns_fetch_time)
        pulumi.set(__self__, "dns_status", dns_status)
        pulumi.set(__self__, "expected_ips", expected_ips)

    @property
    @pulumi.getter(name="certChallengeDiscoveredTxt")
    def cert_challenge_discovered_txt(self) -> Sequence[str]:
        """
        The TXT records (for the certificate challenge) that were found at the last DNS fetch.
        """
        return pulumi.get(self, "cert_challenge_discovered_txt")

    @property
    @pulumi.getter(name="certChallengeDns")
    def cert_challenge_dns(self) -> 'outputs.CertDnsChallengeResponse':
        """
        The DNS challenge for generating a certificate.
        """
        return pulumi.get(self, "cert_challenge_dns")

    @property
    @pulumi.getter(name="certChallengeHttp")
    def cert_challenge_http(self) -> 'outputs.CertHttpChallengeResponse':
        """
        The HTTP challenge for generating a certificate.
        """
        return pulumi.get(self, "cert_challenge_http")

    @property
    @pulumi.getter(name="certStatus")
    def cert_status(self) -> str:
        """
        The certificate provisioning status; updated when Firebase Hosting provisions an SSL certificate for the domain.
        """
        return pulumi.get(self, "cert_status")

    @property
    @pulumi.getter(name="discoveredIps")
    def discovered_ips(self) -> Sequence[str]:
        """
        The IPs found at the last DNS fetch.
        """
        return pulumi.get(self, "discovered_ips")

    @property
    @pulumi.getter(name="dnsFetchTime")
    def dns_fetch_time(self) -> str:
        """
        The time at which the last DNS fetch occurred.
        """
        return pulumi.get(self, "dns_fetch_time")

    @property
    @pulumi.getter(name="dnsStatus")
    def dns_status(self) -> str:
        """
        The DNS record match status as of the last DNS fetch.
        """
        return pulumi.get(self, "dns_status")

    @property
    @pulumi.getter(name="expectedIps")
    def expected_ips(self) -> Sequence[str]:
        """
        The list of IPs to which the domain is expected to resolve.
        """
        return pulumi.get(self, "expected_ips")


@pulumi.output_type
class DomainRedirectResponse(dict):
    """
    Defines the behavior of a domain-level redirect. Domain redirects preserve the path of the redirect but replace the requested domain with the one specified in the redirect configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainName":
            suggest = "domain_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainRedirectResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainRedirectResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainRedirectResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name: str,
                 type: str):
        """
        Defines the behavior of a domain-level redirect. Domain redirects preserve the path of the redirect but replace the requested domain with the one specified in the redirect configuration.
        :param str domain_name: The domain name to redirect to.
        :param str type: The redirect status code.
        """
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        The domain name to redirect to.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The redirect status code.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class HeaderResponse(dict):
    """
    A [`Header`](https://firebase.google.com/docs/hosting/full-config#headers) specifies a URL pattern that, if matched to the request URL path, triggers Hosting to apply the specified custom response headers.
    """
    def __init__(__self__, *,
                 glob: str,
                 headers: Mapping[str, str],
                 regex: str):
        """
        A [`Header`](https://firebase.google.com/docs/hosting/full-config#headers) specifies a URL pattern that, if matched to the request URL path, triggers Hosting to apply the specified custom response headers.
        :param str glob: The user-supplied [glob](https://firebase.google.com/docs/hosting/full-config#glob_pattern_matching) to match against the request URL path.
        :param Mapping[str, str] headers: The additional headers to add to the response.
        :param str regex: The user-supplied RE2 regular expression to match against the request URL path.
        """
        pulumi.set(__self__, "glob", glob)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def glob(self) -> str:
        """
        The user-supplied [glob](https://firebase.google.com/docs/hosting/full-config#glob_pattern_matching) to match against the request URL path.
        """
        return pulumi.get(self, "glob")

    @property
    @pulumi.getter
    def headers(self) -> Mapping[str, str]:
        """
        The additional headers to add to the response.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def regex(self) -> str:
        """
        The user-supplied RE2 regular expression to match against the request URL path.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class HttpUpdateResponse(dict):
    """
    A file you can add to your existing, non-Hosting hosting service that confirms your intent to allow Hosting's Certificate Authorities to create an SSL certificate for your domain.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkError":
            suggest = "check_error"
        elif key == "lastCheckTime":
            suggest = "last_check_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpUpdateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpUpdateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpUpdateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_error: 'outputs.StatusResponse',
                 desired: str,
                 discovered: str,
                 last_check_time: str,
                 path: str):
        """
        A file you can add to your existing, non-Hosting hosting service that confirms your intent to allow Hosting's Certificate Authorities to create an SSL certificate for your domain.
        :param 'StatusResponse' check_error: An error encountered during the last contents check. If null, the check completed successfully.
        :param str desired: A text string to serve at the path.
        :param str discovered: Whether Hosting was able to find the required file contents on the specified path during its last check.
        :param str last_check_time: The last time Hosting systems checked for the file contents.
        :param str path: The path to the file.
        """
        pulumi.set(__self__, "check_error", check_error)
        pulumi.set(__self__, "desired", desired)
        pulumi.set(__self__, "discovered", discovered)
        pulumi.set(__self__, "last_check_time", last_check_time)
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="checkError")
    def check_error(self) -> 'outputs.StatusResponse':
        """
        An error encountered during the last contents check. If null, the check completed successfully.
        """
        return pulumi.get(self, "check_error")

    @property
    @pulumi.getter
    def desired(self) -> str:
        """
        A text string to serve at the path.
        """
        return pulumi.get(self, "desired")

    @property
    @pulumi.getter
    def discovered(self) -> str:
        """
        Whether Hosting was able to find the required file contents on the specified path during its last check.
        """
        return pulumi.get(self, "discovered")

    @property
    @pulumi.getter(name="lastCheckTime")
    def last_check_time(self) -> str:
        """
        The last time Hosting systems checked for the file contents.
        """
        return pulumi.get(self, "last_check_time")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path to the file.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class I18nConfigResponse(dict):
    """
    If provided, i18n rewrites are enabled.
    """
    def __init__(__self__, *,
                 root: str):
        """
        If provided, i18n rewrites are enabled.
        :param str root: The user-supplied path where country and language specific content will be looked for within the public directory.
        """
        pulumi.set(__self__, "root", root)

    @property
    @pulumi.getter
    def root(self) -> str:
        """
        The user-supplied path where country and language specific content will be looked for within the public directory.
        """
        return pulumi.get(self, "root")


@pulumi.output_type
class RedirectResponse(dict):
    """
    A [`Redirect`](https://firebase.google.com/docs/hosting/full-config#redirects) specifies a URL pattern that, if matched to the request URL path, triggers Hosting to respond with a redirect to the specified destination path.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RedirectResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RedirectResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RedirectResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 glob: str,
                 location: str,
                 regex: str,
                 status_code: int):
        """
        A [`Redirect`](https://firebase.google.com/docs/hosting/full-config#redirects) specifies a URL pattern that, if matched to the request URL path, triggers Hosting to respond with a redirect to the specified destination path.
        :param str glob: The user-supplied [glob](https://firebase.google.com/docs/hosting/full-config#glob_pattern_matching) to match against the request URL path.
        :param str location: The value to put in the HTTP location header of the response. The location can contain capture group values from the pattern using a `:` prefix to identify the segment and an optional `*` to capture the rest of the URL. For example: "glob": "/:capture*", "statusCode": 301, "location": "https://example.com/foo/:capture"
        :param str regex: The user-supplied RE2 regular expression to match against the request URL path.
        :param int status_code: The status HTTP code to return in the response. It must be a valid 3xx status code.
        """
        pulumi.set(__self__, "glob", glob)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "regex", regex)
        pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def glob(self) -> str:
        """
        The user-supplied [glob](https://firebase.google.com/docs/hosting/full-config#glob_pattern_matching) to match against the request URL path.
        """
        return pulumi.get(self, "glob")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The value to put in the HTTP location header of the response. The location can contain capture group values from the pattern using a `:` prefix to identify the segment and an optional `*` to capture the rest of the URL. For example: "glob": "/:capture*", "statusCode": 301, "location": "https://example.com/foo/:capture"
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def regex(self) -> str:
        """
        The user-supplied RE2 regular expression to match against the request URL path.
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> int:
        """
        The status HTTP code to return in the response. It must be a valid 3xx status code.
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class ReleaseResponse(dict):
    """
     A `Release` is a particular [collection of configurations and files](sites.versions) that is set to be public at a particular time.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseTime":
            suggest = "release_time"
        elif key == "releaseUser":
            suggest = "release_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message: str,
                 name: str,
                 release_time: str,
                 release_user: 'outputs.ActingUserResponse',
                 type: str,
                 version: 'outputs.VersionResponse'):
        """
         A `Release` is a particular [collection of configurations and files](sites.versions) that is set to be public at a particular time.
        :param str message: The deploy description when the release was created. The value can be up to 512 characters.
        :param str name: The unique identifier for the release, in either of the following formats: - sites/SITE_ID/releases/RELEASE_ID - sites/SITE_ID/channels/CHANNEL_ID/releases/RELEASE_ID This name is provided in the response body when you call [`releases.create`](sites.releases/create) or [`channels.releases.create`](sites.channels.releases/create).
        :param str release_time: The time at which the version is set to be public.
        :param 'ActingUserResponse' release_user: Identifies the user who created the release.
        :param str type: Explains the reason for the release. Specify a value for this field only when creating a `SITE_DISABLE` type release.
        :param 'VersionResponse' version: The configuration and content that was released.
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "release_time", release_time)
        pulumi.set(__self__, "release_user", release_user)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        The deploy description when the release was created. The value can be up to 512 characters.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The unique identifier for the release, in either of the following formats: - sites/SITE_ID/releases/RELEASE_ID - sites/SITE_ID/channels/CHANNEL_ID/releases/RELEASE_ID This name is provided in the response body when you call [`releases.create`](sites.releases/create) or [`channels.releases.create`](sites.channels.releases/create).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="releaseTime")
    def release_time(self) -> str:
        """
        The time at which the version is set to be public.
        """
        return pulumi.get(self, "release_time")

    @property
    @pulumi.getter(name="releaseUser")
    def release_user(self) -> 'outputs.ActingUserResponse':
        """
        Identifies the user who created the release.
        """
        return pulumi.get(self, "release_user")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Explains the reason for the release. Specify a value for this field only when creating a `SITE_DISABLE` type release.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def version(self) -> 'outputs.VersionResponse':
        """
        The configuration and content that was released.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class RewriteResponse(dict):
    """
    A [`Rewrite`](https://firebase.google.com/docs/hosting/full-config#rewrites) specifies a URL pattern that, if matched to the request URL path, triggers Hosting to respond as if the service were given the specified destination URL.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicLinks":
            suggest = "dynamic_links"
        elif key == "functionRegion":
            suggest = "function_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RewriteResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RewriteResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RewriteResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dynamic_links: bool,
                 function: str,
                 function_region: str,
                 glob: str,
                 path: str,
                 regex: str,
                 run: 'outputs.CloudRunRewriteResponse'):
        """
        A [`Rewrite`](https://firebase.google.com/docs/hosting/full-config#rewrites) specifies a URL pattern that, if matched to the request URL path, triggers Hosting to respond as if the service were given the specified destination URL.
        :param bool dynamic_links: The request will be forwarded to Firebase Dynamic Links.
        :param str function: The function to proxy requests to. Must match the exported function name exactly.
        :param str function_region: Optional. Specify a Cloud region for rewritten Functions invocations. If not provided, defaults to us-central1.
        :param str glob: The user-supplied [glob](https://firebase.google.com/docs/hosting/full-config#glob_pattern_matching) to match against the request URL path.
        :param str path: The URL path to rewrite the request to.
        :param str regex: The user-supplied RE2 regular expression to match against the request URL path.
        :param 'CloudRunRewriteResponse' run: The request will be forwarded to Cloud Run.
        """
        pulumi.set(__self__, "dynamic_links", dynamic_links)
        pulumi.set(__self__, "function", function)
        pulumi.set(__self__, "function_region", function_region)
        pulumi.set(__self__, "glob", glob)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "regex", regex)
        pulumi.set(__self__, "run", run)

    @property
    @pulumi.getter(name="dynamicLinks")
    def dynamic_links(self) -> bool:
        """
        The request will be forwarded to Firebase Dynamic Links.
        """
        return pulumi.get(self, "dynamic_links")

    @property
    @pulumi.getter
    def function(self) -> str:
        """
        The function to proxy requests to. Must match the exported function name exactly.
        """
        return pulumi.get(self, "function")

    @property
    @pulumi.getter(name="functionRegion")
    def function_region(self) -> str:
        """
        Optional. Specify a Cloud region for rewritten Functions invocations. If not provided, defaults to us-central1.
        """
        return pulumi.get(self, "function_region")

    @property
    @pulumi.getter
    def glob(self) -> str:
        """
        The user-supplied [glob](https://firebase.google.com/docs/hosting/full-config#glob_pattern_matching) to match against the request URL path.
        """
        return pulumi.get(self, "glob")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The URL path to rewrite the request to.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def regex(self) -> str:
        """
        The user-supplied RE2 regular expression to match against the request URL path.
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def run(self) -> 'outputs.CloudRunRewriteResponse':
        """
        The request will be forwarded to Cloud Run.
        """
        return pulumi.get(self, "run")


@pulumi.output_type
class ServingConfigResponse(dict):
    """
    The configuration for how incoming requests to a site should be routed and processed before serving content. The URL request paths are matched against the specified URL patterns in the configuration, then Hosting applies the applicable configuration according to a specific [priority order](https://firebase.google.com/docs/hosting/full-config#hosting_priority_order).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appAssociation":
            suggest = "app_association"
        elif key == "cleanUrls":
            suggest = "clean_urls"
        elif key == "trailingSlashBehavior":
            suggest = "trailing_slash_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServingConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServingConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServingConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_association: str,
                 clean_urls: bool,
                 headers: Sequence['outputs.HeaderResponse'],
                 i18n: 'outputs.I18nConfigResponse',
                 redirects: Sequence['outputs.RedirectResponse'],
                 rewrites: Sequence['outputs.RewriteResponse'],
                 trailing_slash_behavior: str):
        """
        The configuration for how incoming requests to a site should be routed and processed before serving content. The URL request paths are matched against the specified URL patterns in the configuration, then Hosting applies the applicable configuration according to a specific [priority order](https://firebase.google.com/docs/hosting/full-config#hosting_priority_order).
        :param str app_association: How to handle well known App Association files.
        :param bool clean_urls: Defines whether to drop the file extension from uploaded files.
        :param Sequence['HeaderResponse'] headers: An array of objects, where each object specifies a URL pattern that, if matched to the request URL path, triggers Hosting to apply the specified custom response headers.
        :param 'I18nConfigResponse' i18n: Optional. Defines i18n rewrite behavior.
        :param Sequence['RedirectResponse'] redirects: An array of objects (called redirect rules), where each rule specifies a URL pattern that, if matched to the request URL path, triggers Hosting to respond with a redirect to the specified destination path.
        :param Sequence['RewriteResponse'] rewrites: An array of objects (called rewrite rules), where each rule specifies a URL pattern that, if matched to the request URL path, triggers Hosting to respond as if the service were given the specified destination URL.
        :param str trailing_slash_behavior: Defines how to handle a trailing slash in the URL path.
        """
        pulumi.set(__self__, "app_association", app_association)
        pulumi.set(__self__, "clean_urls", clean_urls)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "i18n", i18n)
        pulumi.set(__self__, "redirects", redirects)
        pulumi.set(__self__, "rewrites", rewrites)
        pulumi.set(__self__, "trailing_slash_behavior", trailing_slash_behavior)

    @property
    @pulumi.getter(name="appAssociation")
    def app_association(self) -> str:
        """
        How to handle well known App Association files.
        """
        return pulumi.get(self, "app_association")

    @property
    @pulumi.getter(name="cleanUrls")
    def clean_urls(self) -> bool:
        """
        Defines whether to drop the file extension from uploaded files.
        """
        return pulumi.get(self, "clean_urls")

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.HeaderResponse']:
        """
        An array of objects, where each object specifies a URL pattern that, if matched to the request URL path, triggers Hosting to apply the specified custom response headers.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def i18n(self) -> 'outputs.I18nConfigResponse':
        """
        Optional. Defines i18n rewrite behavior.
        """
        return pulumi.get(self, "i18n")

    @property
    @pulumi.getter
    def redirects(self) -> Sequence['outputs.RedirectResponse']:
        """
        An array of objects (called redirect rules), where each rule specifies a URL pattern that, if matched to the request URL path, triggers Hosting to respond with a redirect to the specified destination path.
        """
        return pulumi.get(self, "redirects")

    @property
    @pulumi.getter
    def rewrites(self) -> Sequence['outputs.RewriteResponse']:
        """
        An array of objects (called rewrite rules), where each rule specifies a URL pattern that, if matched to the request URL path, triggers Hosting to respond as if the service were given the specified destination URL.
        """
        return pulumi.get(self, "rewrites")

    @property
    @pulumi.getter(name="trailingSlashBehavior")
    def trailing_slash_behavior(self) -> str:
        """
        Defines how to handle a trailing slash in the URL path.
        """
        return pulumi.get(self, "trailing_slash_behavior")


@pulumi.output_type
class StatusResponse(dict):
    """
    The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
    """
    def __init__(__self__, *,
                 code: int,
                 details: Sequence[Mapping[str, Any]],
                 message: str):
        """
        The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
        :param int code: The status code, which should be an enum value of google.rpc.Code.
        :param Sequence[Mapping[str, Any]] details: A list of messages that carry the error details. There is a common set of message types for APIs to use.
        :param str message: A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> int:
        """
        The status code, which should be an enum value of google.rpc.Code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def details(self) -> Sequence[Mapping[str, Any]]:
        """
        A list of messages that carry the error details. There is a common set of message types for APIs to use.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class VersionResponse(dict):
    """
    A `Version` is a configuration and a collection of static files which determine how a site is displayed.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createTime":
            suggest = "create_time"
        elif key == "createUser":
            suggest = "create_user"
        elif key == "deleteTime":
            suggest = "delete_time"
        elif key == "deleteUser":
            suggest = "delete_user"
        elif key == "fileCount":
            suggest = "file_count"
        elif key == "finalizeTime":
            suggest = "finalize_time"
        elif key == "finalizeUser":
            suggest = "finalize_user"
        elif key == "versionBytes":
            suggest = "version_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config: 'outputs.ServingConfigResponse',
                 create_time: str,
                 create_user: 'outputs.ActingUserResponse',
                 delete_time: str,
                 delete_user: 'outputs.ActingUserResponse',
                 file_count: str,
                 finalize_time: str,
                 finalize_user: 'outputs.ActingUserResponse',
                 labels: Mapping[str, str],
                 name: str,
                 status: str,
                 version_bytes: str):
        """
        A `Version` is a configuration and a collection of static files which determine how a site is displayed.
        :param 'ServingConfigResponse' config: The configuration for the behavior of the site. This configuration exists in the [`firebase.json`](https://firebase.google.com/docs/cli/#the_firebasejson_file) file.
        :param str create_time: The time at which the version was created.
        :param 'ActingUserResponse' create_user: Identifies the user who created the version.
        :param str delete_time: The time at which the version was `DELETED`.
        :param 'ActingUserResponse' delete_user: Identifies the user who `DELETED` the version.
        :param str file_count: The total number of files associated with the version. This value is calculated after a version is `FINALIZED`.
        :param str finalize_time: The time at which the version was `FINALIZED`.
        :param 'ActingUserResponse' finalize_user: Identifies the user who `FINALIZED` the version.
        :param Mapping[str, str] labels: The labels used for extra metadata and/or filtering.
        :param str name: The fully-qualified resource name for the version, in the format: sites/ SITE_ID/versions/VERSION_ID This name is provided in the response body when you call [`CreateVersion`](sites.versions/create).
        :param str status: The deploy status of the version. For a successful deploy, call [`CreateVersion`](sites.versions/create) to make a new version (`CREATED` status), [upload all desired files](sites.versions/populateFiles) to the version, then [update](sites.versions/patch) the version to the `FINALIZED` status. Note that if you leave the version in the `CREATED` state for more than 12 hours, the system will automatically mark the version as `ABANDONED`. You can also change the status of a version to `DELETED` by calling [`DeleteVersion`](sites.versions/delete).
        :param str version_bytes: The total stored bytesize of the version. This value is calculated after a version is `FINALIZED`.
        """
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "create_user", create_user)
        pulumi.set(__self__, "delete_time", delete_time)
        pulumi.set(__self__, "delete_user", delete_user)
        pulumi.set(__self__, "file_count", file_count)
        pulumi.set(__self__, "finalize_time", finalize_time)
        pulumi.set(__self__, "finalize_user", finalize_user)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "version_bytes", version_bytes)

    @property
    @pulumi.getter
    def config(self) -> 'outputs.ServingConfigResponse':
        """
        The configuration for the behavior of the site. This configuration exists in the [`firebase.json`](https://firebase.google.com/docs/cli/#the_firebasejson_file) file.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> str:
        """
        The time at which the version was created.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="createUser")
    def create_user(self) -> 'outputs.ActingUserResponse':
        """
        Identifies the user who created the version.
        """
        return pulumi.get(self, "create_user")

    @property
    @pulumi.getter(name="deleteTime")
    def delete_time(self) -> str:
        """
        The time at which the version was `DELETED`.
        """
        return pulumi.get(self, "delete_time")

    @property
    @pulumi.getter(name="deleteUser")
    def delete_user(self) -> 'outputs.ActingUserResponse':
        """
        Identifies the user who `DELETED` the version.
        """
        return pulumi.get(self, "delete_user")

    @property
    @pulumi.getter(name="fileCount")
    def file_count(self) -> str:
        """
        The total number of files associated with the version. This value is calculated after a version is `FINALIZED`.
        """
        return pulumi.get(self, "file_count")

    @property
    @pulumi.getter(name="finalizeTime")
    def finalize_time(self) -> str:
        """
        The time at which the version was `FINALIZED`.
        """
        return pulumi.get(self, "finalize_time")

    @property
    @pulumi.getter(name="finalizeUser")
    def finalize_user(self) -> 'outputs.ActingUserResponse':
        """
        Identifies the user who `FINALIZED` the version.
        """
        return pulumi.get(self, "finalize_user")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        The labels used for extra metadata and/or filtering.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The fully-qualified resource name for the version, in the format: sites/ SITE_ID/versions/VERSION_ID This name is provided in the response body when you call [`CreateVersion`](sites.versions/create).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The deploy status of the version. For a successful deploy, call [`CreateVersion`](sites.versions/create) to make a new version (`CREATED` status), [upload all desired files](sites.versions/populateFiles) to the version, then [update](sites.versions/patch) the version to the `FINALIZED` status. Note that if you leave the version in the `CREATED` state for more than 12 hours, the system will automatically mark the version as `ABANDONED`. You can also change the status of a version to `DELETED` by calling [`DeleteVersion`](sites.versions/delete).
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="versionBytes")
    def version_bytes(self) -> str:
        """
        The total stored bytesize of the version. This value is calculated after a version is `FINALIZED`.
        """
        return pulumi.get(self, "version_bytes")


