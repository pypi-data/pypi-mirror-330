#!/usr/bin/env python
# coding=utf-8

# -------------------------------------------------------------------------------
#
#  ███████╗██████╗ ██╗ ██████╗███████╗██╗     ██╗██████╗
#  ██╔════╝██╔══██╗██║██╔════╝██╔════╝██║     ██║██╔══██╗
#  ███████╗██████╔╝██║██║     █████╗  ██║     ██║██████╔╝
#  ╚════██║██╔═══╝ ██║██║     ██╔══╝  ██║     ██║██╔══██╗
#  ███████║██║     ██║╚██████╗███████╗███████╗██║██████╔╝
#  ╚══════╝╚═╝     ╚═╝ ╚═════╝╚══════╝╚══════╝╚═╝╚═════╝
#
# Name:        raw_write.py
# Purpose:     Create RAW Files
#
# Author:      Nuno Brum (nuno.brum@gmail.com)
#
# Created:     16-10-2021
# Licence:     refer to the LICENSE file
# -------------------------------------------------------------------------------

"""
This module generates RAW Files from user data.
It can be used to combine RAW files generated by different Simulation Runs
"""
from pathlib import Path
from time import strftime
from typing import Any, Callable, List, Optional, Sequence, Tuple, Union

from numpy import array, float32, ndarray, zeros

from .raw_classes import DataSet
from .raw_read import RawRead


class Trace(DataSet):
    """Helper class representing a trace in a RAW file.

    This class extends DataSet and represents a single trace or signal in a RAW file.
    It doesn't support STEPPED data as it's designed for write operations.

    Args:
        name (str): Name of the trace being created
        data (Union[Sequence[Union[float, complex]], ndarray]): Data points for the trace
        whattype (str, optional): Type of trace data - "time", "frequency", "voltage" or "current". Defaults to "voltage".
        numerical_type (str, optional): Numerical representation - "real", "complex", or "double". If empty,
                                        will be inferred from the data. Defaults to "".

    Raises:
        AssertionError: If the trace is a frequency trace but no numerical_type is specified
        NotImplementedError: If the data type cannot be inferred

    Note:
        The first trace in a RAW file is typically an axis trace (time or frequency).
        For frequency traces, numerical_type must be explicitly specified ('complex' for AC analysis or
        'double' for NOISE analysis).
    """

    def __init__(
        self,
        name: str,
        data: Union[Sequence[Union[float, complex]], ndarray],
        whattype: str = "voltage",
        numerical_type: str = "",
    ) -> None:
        if name == "time":
            whattype = "time"
        elif name == "frequency":
            whattype = "frequency"
        if numerical_type == "":
            if name == "time":
                numerical_type = "double"
            elif name == "frequency":
                raise AssertionError(
                    "For frequency plots, please specify the numerical_type:\n"
                    "Use:\n"
                    "   * numerical_type='complex' for .AC analysis\n"
                    "   * numerical_type='double' for .NOISE analysys"
                )
            # Use type() instead of isinstance() for parameterized types
            elif type(data[0]) in (float32, float):
                numerical_type = "real"
            elif type(data[0]) is complex:
                numerical_type = "complex"
            else:
                raise NotImplementedError("Unsupported data type for Trace")

        DataSet.__init__(self, name, whattype, len(data), numerical_type=numerical_type)
        if isinstance(data, (list, tuple)):
            self.data = array(data, dtype=self.data.dtype)
        else:
            self.data[:] = data[:]  # This way the dtype is kept


class RawWrite:
    """
    Represents a RAW data file being generated for SPICE simulation output.

    This class allows creation and manipulation of RAW files for SPICE simulation data.
    Unlike RawRead, this class doesn't support stepped data.

    Args:
        plot_name (Optional[str], optional): Name of the plot. If None, will be inferred from first trace. Defaults to None.
        fastacces (bool, optional): Whether to use fast access format. Defaults to True.
        numtype (str, optional): Numerical type for the file. Use "auto" to infer from first trace. Defaults to "auto".
        encoding (str, optional): Character encoding for the file. Defaults to "utf_16_le".
    """

    def __init__(
        self,
        plot_name: Optional[str] = None,
        fastacces: bool = True,
        numtype: str = "auto",
        encoding: str = "utf_16_le",
    ) -> None:
        self._traces: List[Trace] = list()
        self.flag_numtype: str = numtype
        self.flag_forward: bool = False
        self.flag_log: bool = False
        self.flag_stepped: bool = False
        self.flag_fastaccess: bool = fastacces
        self.plot_name: Optional[str] = plot_name
        self.offset: float = 0.0
        self.encoding: str = encoding
        self._imported_data: List[Any] = []
        self._new_axis: Optional[List[float]] = None

    def _str_flags(self) -> str:
        """
        Generate a string representation of the RAW file flags.

        Returns:
            str: Space-separated string of enabled flags
        """
        flags = [self.flag_numtype]
        if self.flag_forward:
            flags.append("forward")
        if self.flag_log:
            flags.append("log")
        if self.flag_stepped:
            flags.append("stepped")
        if self.flag_fastaccess:
            flags.append("fastaccess")
        return " ".join(flags)

    def add_trace(self, trace: Trace) -> None:
        """
        Add a trace to the RAW file.

        The trace must have the same size as trace 0 ('time', 'frequency', etc.).
        The first trace added defines the X-Axis and the type of RAW file being generated.
        If no plot name was defined, it will automatically assign a name based on the first trace.

        Args:
            trace (Trace): The trace to add. Must be a Trace instance.

        Raises:
            AssertionError: If trace is not a Trace instance
            ValueError: If the first trace does not have a recognized whattype
            IndexError: If the trace size doesn't match the first trace
        """
        assert isinstance(trace, Trace), "The trace needs to be of the type Trace"
        if len(self._traces) == 0:
            if trace.whattype == "time":
                self.plot_name = self.plot_name or "Transient Analysis"
                flag_numtype = "real"
            elif trace.whattype == "frequency":
                if (
                    trace.numerical_type != "complex" and self.flag_numtype != "complex"
                ) or "Noise" in str(self.plot_name):
                    self.plot_name = (
                        self.plot_name or "Noise Spectral Density - (V/Hz½ or A/Hz½)"
                    )
                    flag_numtype = "real"
                else:
                    self.plot_name = self.plot_name or "AC Analysis"
                    flag_numtype = "complex"
            elif trace.whattype in ("voltage", "current"):
                self.plot_name = self.plot_name or "DC transfer characteristic"
                flag_numtype = "real"
            elif trace.whattype == "param":
                self.plot_name = self.plot_name or "Operating Point"
                flag_numtype = "real"
            else:
                raise ValueError(
                    "First Trace needs to be either 'time', 'frequency', 'param', 'voltage' or '...'"
                )

            if self.flag_numtype == "auto":
                self.flag_numtype = flag_numtype
        else:
            if len(self._traces[0]) != len(trace):
                raise IndexError("The trace needs to be the same size as trace 0")
        self._traces.append(trace)

    def save(self, filename: Union[str, Path]) -> None:
        """
        Save the RAW file to disk.

        The file format is always binary. Text-based RAW output format is not supported
        in this version.

        Args:
            filename (Union[str, Path]): Path where the RAW file will be written.
                                         The extension should be .RAW

        Note:
            If there are any imported data that need to be consolidated, this will happen
            automatically before saving.
        """
        if len(self._imported_data):
            self._consolidate()
        f = open(filename, "wb")
        f.write("Title: * kupicelib RawWrite\n".encode(self.encoding))
        f.write(
            "Date: {}\n".format(strftime("%a %b %d %H:%M:%S %Y")).encode(self.encoding)
        )
        f.write("Plotname: {}\n".format(self.plot_name).encode(self.encoding))
        f.write("Flags: {}\n".format(self._str_flags()).encode(self.encoding))
        f.write("No. Variables: {}\n".format(len(self._traces)).encode(self.encoding))
        f.write(
            "No. Points: {:12}\n".format(len(self._traces[0])).encode(self.encoding)
        )
        f.write("Offset:   {:.16e}\n".format(self.offset).encode(self.encoding))
        f.write(
            "Command: Linear Technology Corporation LTspice XVII\n".encode(
                self.encoding
            )
        )
        # f.write("Backannotation: \n".encode(self.encoding))
        f.write("Variables:\n".encode(self.encoding))
        for i, trace in enumerate(self._traces):
            f.write(
                "\t{0}\t{1}\t{2}\n".format(i, trace.name, trace.whattype).encode(
                    self.encoding
                )
            )
        total_bytes = 0
        f.write("Binary:\n".encode(self.encoding))
        if (
            self.flag_fastaccess and self.flag_numtype != "complex"
        ):  # Don't know why, but complex RAW files aren't
            # converted to FastAccess
            for trace in self._traces:
                f.write(trace.data.tobytes())
        else:
            fmts = {trace: tobytes_for_trace(trace) for trace in self._traces}
            for i in range(len(self._traces[0])):
                for trace in self._traces:
                    total_bytes += f.write(fmts[trace](trace.data[i]))
        f.close()

    @staticmethod
    def _rename_netlabel(name: str, **kwargs) -> str:
        """
        Rename a trace name while preserving V() or I() containers.

        Args:
            name (str): The original trace name
            **kwargs: Keyword arguments including potential rename_format

        Returns:
            str: The renamed trace name

        Note:
            If rename_format is provided in kwargs, it will be used to format the name.
            For voltage/current signals (V(...) or I(...)), only the content inside the
            parentheses is formatted.
        """
        # Make the rename as requested
        if "rename_format" in kwargs:
            if name.endswith(")") and (name.startswith("V(") or name.startswith("I(")):
                new_name = (
                    name[:2]
                    + kwargs["rename_format"].format(name[2:-1], **kwargs)
                    + name[-1]
                )
            else:
                new_name = kwargs["rename_format"].format(name, **kwargs)
            return new_name
        else:
            return name

    def _name_exists(self, name: str) -> bool:
        """
        Check if a trace name already exists in the collection.

        Args:
            name (str): The trace name to check

        Returns:
            bool: True if the name exists, False otherwise
        """
        # first check whether it is a duplicate
        for trace in self._traces:
            if trace.name == name:
                return True
        return False

    def add_traces_from_raw(
        self,
        other: RawRead,
        trace_filter: Union[List[str], Tuple[str, ...], str],
        **kwargs,
    ) -> None:
        """
        Merge traces from a RawRead instance into this RawWrite instance.

        This method allows combining data from multiple RAW files. It can handle
        different axis alignments and provides options for renaming traces.

        Args:
            other (RawRead): The source RawRead instance to copy traces from
            trace_filter (Union[List[str], Tuple[str, ...], str]): Traces to import - either
                                a list of trace names or a single trace name as string
            **kwargs: Optional keyword arguments:
                - force_axis_alignment (bool): Try to sync axes if they don't match
                - admissible_error (float): Maximum allowed error when syncing axes
                - rename_format (str): Format string for renaming traces
                - step (int): Which step to import from multi-step source (default: 0)
                - minimum_timestep (float): Minimum time increment to preserve

        Raises:
            ValueError: If the source and destination types or axis types don't match
            NotImplementedError: For certain unimplemented features

        Note:
            This feature is partially implemented and may not work in all cases.
        """
        force_axis_alignment = kwargs.get("force_axis_alignment", False)
        admissible_error = kwargs.get("admissible_error", 1e-11)
        from_step = kwargs.get("step", 0)
        minimum_timestep = kwargs.get("minimum_timestep", 0.0)
        if isinstance(trace_filter, str):
            trace_filter = [trace_filter]

        other_flags = other.get_raw_property("Flags").split(" ")
        for flag in other_flags:
            if flag in ("real", "complex"):
                other_flag_num_type = flag
                break
        else:
            other_flag_num_type = "real"

        if len(self._traces):  # there are already traces
            if self.flag_numtype != other_flag_num_type:
                raise ValueError(
                    "The two instances should have the same type:\n"
                    f"Source is {other_flag_num_type} and Destination is {self.flag_numtype}"
                )
            if self._traces[0].whattype != other.get_trace(0).whattype:
                raise ValueError(
                    "The two instances should have the same axis type:\n"
                    f"Source is {other.get_trace(0).whattype} and Destination is {self._traces[0].whattype}"
                )
            if len(trace_filter) == 0:
                return  # There is nothing to add stop here

        else:  # No traces are present
            # if no X axis is present, copy from the first one
            self.flag_numtype = other_flag_num_type
            self.flag_log = "log" in other_flags
            self.flag_forward = "forward" in other_flags
            self.plot_name = other.get_raw_property("Plotname")
            oaxis = other.get_trace(0)
            new_axis = Trace(
                oaxis.name,
                other.get_axis(from_step),
                oaxis.whattype,
                oaxis.numerical_type,
            )
            self._traces.append(new_axis)
            force_axis_alignment = False

        if force_axis_alignment or minimum_timestep > 0.0:
            if self._new_axis:
                my_axis = self._new_axis
            else:
                # Convert ndarray to list[float] to maintain type consistency
                my_axis = self._traces[0].get_wave().tolist()
            other_axis = other.get_axis(from_step)
            new_axis_list: List[float] = []
            if minimum_timestep > 0.0:
                raise NotImplementedError(
                    "minimum_timestep feature is not yet implemented"
                )
            else:
                i = 0  # incomming data counter
                e = 0  # existing data counter

                while e < len(my_axis) - 1 and i < len(other_axis) - 1:
                    error = other_axis[i] - my_axis[e]
                    if abs(error) < admissible_error:
                        new_axis_list.append(float(my_axis[e]))
                        i += 1
                        e += 1
                    elif error < 0:
                        # Other axis is smaller
                        new_axis_list.append(float(other_axis[i]))
                        i += 1
                    else:
                        new_axis_list.append(float(my_axis[e]))
                        e += 1
                # Creating the New Axis
                self._new_axis = new_axis_list

                for trace_name in trace_filter:
                    imported_trace = other.get_trace(trace_name)
                    new_name = self._rename_netlabel(trace_name, **kwargs)
                    imported_trace.name = new_name
                    self._imported_data.append(imported_trace)
        else:
            assert len(self._traces[0]) == len(
                other.get_axis(from_step)
            ), "The two instances should have the same size. To avoid this use force_axis_alignment=True option"
            for trace_name in trace_filter:
                trace = other.get_trace(trace_name)
                new_name = self._rename_netlabel(trace_name, **kwargs)
                data = trace.get_wave(from_step)
                self._traces.append(
                    Trace(
                        new_name,
                        data,
                        trace.whattype,
                        numerical_type=trace.numerical_type,
                    )
                )

    @staticmethod
    def _interpolate(
        trace_data: ndarray, trace_axis: ndarray, new_axis: Sequence[float]
    ) -> ndarray:
        """
        Interpolate trace data to align with a new axis.

        Args:
            trace_data (ndarray): The original data values
            trace_axis (ndarray): The original axis values
            new_axis (Sequence[float]): The new axis values to interpolate to

        Returns:
            ndarray: Interpolated data aligned with the new axis

        Note:
            Uses linear interpolation between data points.
        """
        new_data = zeros(len(new_axis), dtype=trace_data.dtype)
        new_data[0] = trace_data[0]

        slope = (trace_data[1] - trace_data[0]) / (trace_axis[1] - trace_axis[0])
        i = 1
        for j, t in enumerate(new_axis):
            while i < len(trace_axis) and trace_axis[i] < t:
                i += 1
                if i < len(trace_axis):
                    slope = (trace_data[i] - trace_data[i - 1]) / (
                        trace_axis[i] - trace_axis[i - 1]
                    )
            new_data[j] = trace_data[i - 1] + slope * (t - trace_axis[i - 1])
        return new_data

    def _consolidate(self) -> None:
        """
        Consolidate imported data by interpolating to align with a common axis.

        This internal method is called before saving to ensure all traces are aligned
        to the same axis. Traces are interpolated as needed to match the new axis.
        """
        if self._new_axis and self._imported_data:
            new_axis = self._new_axis
            axis_length = len(new_axis)
            old_axis = self._traces[0]
            if axis_length != len(old_axis):
                my_axis = old_axis.data
                for trace in self._traces[1:]:
                    trace.data = self._interpolate(trace.data, my_axis, new_axis)
            for imported_trace in self._imported_data:
                new_trace = Trace(
                    imported_trace.name,
                    self._interpolate(
                        imported_trace.get_wave(),
                        imported_trace.axis.get_wave(),
                        new_axis,
                    ),
                    imported_trace.whattype,
                    imported_trace.numerical_type,
                )
                self._traces.append(new_trace)
            self._traces[0] = Trace(
                old_axis.name, new_axis, old_axis.whattype, old_axis.numerical_type
            )  # Replaces with the new axis
            self._new_axis = None
            self._imported_data.clear()

    def get_trace(self, trace_ref: Union[str, int]) -> Trace:
        """
        Retrieve a trace by name or index.

        Args:
            trace_ref (Union[str, int]): Either the trace name as string or the trace index

        Returns:
            Trace: The requested trace

        Raises:
            IndexError: If the trace doesn't exist
        """
        if isinstance(trace_ref, str):
            for trace in self._traces:
                if trace_ref == trace.name:
                    return trace
            raise IndexError(
                f'{self} doesn\'t contain trace "{trace_ref}"\n'
                f"Valid traces are {[trc.name for trc in self._traces]}"
            )
        else:
            return self._traces[trace_ref]

    def __getitem__(self, item: Union[str, int]) -> Trace:
        """
        Access traces using the [ ] operator.

        Args:
            item (Union[str, int]): Either the trace name or index

        Returns:
            Trace: The requested trace

        Raises:
            IndexError: If the trace doesn't exist
        """
        return self.get_trace(item)


def tobytes_for_trace(trace: Trace) -> Callable[[Any], bytes]:
    """
    Create a function that converts trace data values to bytes.

    This is a higher-order function that returns a specialized function for
    converting values from a specific trace to bytes.

    Args:
        trace (Trace): The trace for which to create a conversion function

    Returns:
        Callable[[Any], bytes]: A function that converts a value to bytes
    """

    def tobytes(value: Any) -> bytes:
        """Convert a trace value to bytes."""
        return value.tobytes()

    return tobytes
