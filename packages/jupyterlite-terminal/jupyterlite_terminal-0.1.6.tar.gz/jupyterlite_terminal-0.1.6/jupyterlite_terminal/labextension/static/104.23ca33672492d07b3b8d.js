"use strict";(self.webpackChunk_jupyterlite_terminal=self.webpackChunk_jupyterlite_terminal||[]).push([[104],{9104:(e,s,t)=>{t.r(s),t.d(s,{default:()=>u});var i=t(5310),n=t(4602),o=t(155),r=t(5199);class a extends r.BaseShell{constructor(e){super(e)}initWorker(e){return console.log("Terminal create webworker"),new Worker(new URL(t.p+t.u(671),t.b),{type:void 0})}}class l{constructor(e){this.options=e,this._disposed=new n.Signal(this),this._isDisposed=!1,this._running=!1,this._shell=new a({mountpoint:"/drive",driveFsBaseUrl:e.baseUrl,wasmBaseUrl:e.baseUrl+"extensions/@jupyterlite/terminal/static/wasm/",outputCallback:this._outputCallback.bind(this)}),this._shell.disposed.connect((()=>this.dispose()))}_outputCallback(e){if(this._socket){const s=JSON.stringify(["stdout",e]);this._socket.send(s)}}dispose(){this._isDisposed||(console.log("Terminal.dispose"),this._isDisposed=!0,void 0!==this._socket&&(this._socket.send(JSON.stringify(["disconnect"])),this._socket.close(),this._socket=void 0),void 0!==this._server&&(this._server.close(),this._server=void 0),this._shell.dispose(),this._disposed.emit())}get disposed(){return this._disposed}get isDisposed(){return this._isDisposed}get name(){return this.options.name}async wsConnect(e){console.log("Terminal wsConnect",e),this._server=new o.Server(e),this._server.on("connection",(async e=>{console.log("Terminal server connection"),void 0!==this._socket&&(this._socket.send(JSON.stringify(["disconnect"])),this._socket.close(),this._socket=void 0),this._socket=e,e.on("message",(async e=>{const s=JSON.parse(e),t=s[0],i=s.slice(1);if("stdin"===t)await this._shell.input(i[0]);else if("set_size"===t){const e=i[0],s=i[1];await this._shell.setSize(e,s)}})),e.on("close",(()=>{console.log("Terminal socket close")})),e.on("error",(()=>{console.log("Terminal socket error")}));const s=JSON.stringify(["setup"]);console.log("Terminal returning handshake via socket"),e.send(s),this._running||(this._running=!0,await this._shell.start())}))}}class c{constructor(e){this._terminals=new Map,this._wsUrl=e,console.log("==> TerminalManager.constructor",this._wsUrl)}has(e){return this._terminals.has(e)}async listRunning(){return[...this._terminals.values()].map((e=>({name:e.name})))}async shutdownTerminal(e){const s=this._terminals.get(e);void 0!==s&&(console.log("==> TerminalManager.shutdownTerminal",e),this._terminals.delete(e),s.dispose())}async startNew(){const e=this._nextAvailableName();console.log("==> TerminalManager.startNew",e);const s=i.PageConfig.getBaseUrl(),t=new l({name:e,baseUrl:s});this._terminals.set(e,t),t.disposed.connect((()=>this.shutdownTerminal(e)));const n=`${this._wsUrl}terminals/websocket/${e}`;return await t.wsConnect(n),{name:e}}_nextAvailableName(){for(let e=1;;++e){const s=`${e}`;if(!this._terminals.has(s))return s}}}const h=new(t(7262).Token)("@jupyterlite/terminal:ITerminalManager"),u=[{id:"@jupyterlite/terminal:plugin",description:"A terminal for JupyterLite",autoStart:!0,provides:h,activate:async e=>{console.log("JupyterLite extension @jupyterlite/terminal:plugin is activated!");const{serviceManager:s}=e,{serverSettings:t,terminals:i}=s;return console.log("terminals available:",i.isAvailable()),console.log("terminals ready:",i.isReady),console.log("terminals active:",i.isActive),await i.ready,console.log("terminals ready after await:",i.isReady),new c(t.wsUrl)}},{id:"@jupyterlite/terminal:routes-plugin",autoStart:!0,requires:[h],activate:(e,s)=>{console.log("JupyterLite extension @jupyterlite/terminal:routes-plugin is activated!",s),e.router.get("/api/terminals",(async e=>{const t=await s.listRunning();return new Response(JSON.stringify(t))})),e.router.post("/api/terminals",(async e=>{const t=await s.startNew();return new Response(JSON.stringify(t))})),e.router.delete("/api/terminals/(.+)",(async(e,t)=>{const i=s.has(t);if(i)await s.shutdownTerminal(t);else{const e=`The terminal session "${t}"" does not exist`;console.warn(e)}return new Response(null,{status:i?204:404})}))}}]}}]);