import asyncio
import logging
from typing import Any, Mapping, Sequence

from autogen_agentchat.base import TaskResult, Team
from autogen_agentchat.messages import (
    AgentEvent,
    HandoffMessage,
    MultiModalMessage,
    StopMessage,
    TextMessage,
    ToolCallExecutionEvent,
    ToolCallRequestEvent,
)
from autogen_core import (
    EVENT_LOGGER_NAME,
    AgentId,
    CancellationToken,
    ComponentBase,
    SingleThreadedAgentRuntime,
    Subscription,
    TopicId,
)
from autogen_core.logging import LLMCallEvent
from autogenstudio.datamodel import LLMCallEventMessage
from loguru import logger
from mtmai.agents.hf_space_agent import HfSpaceAgent
from mtmai.agents.tenant_agent.tenant_agent import MsgResetTenant, TenantAgent
from mtmai.clients.rest.api_client import ApiClient
from mtmai.clients.rest.configuration import Configuration
from mtmai.clients.rest.models.ag_state_upsert import AgStateUpsert
from mtmai.clients.rest.models.agent_run_input import AgentRunInput
from mtmai.clients.rest.models.chat_message import ChatMessage
from mtmai.clients.rest.models.chat_message_upsert import ChatMessageUpsert
from mtmai.clients.rest.models.mt_component import MtComponent
from mtmai.context.context import get_tenant_id, set_backend_url, set_tenant_id
from mtmai.core.config import settings
from mtmai.mtlibs.id import generate_uuid

# from mtmai.mtm.sppb.ag_pb2 import MsgGetTeamComponent
from pydantic import BaseModel
from typing_extensions import Self


class WorkerAgentConfig(BaseModel):
    name: str
    # model_client: ComponentModel
    # tools: List[ComponentModel] | None
    # handoffs: List[HandoffBase | str] | None = None
    # model_context: ComponentModel | None = None
    # memory: List[ComponentModel] | None = None
    description: str
    system_message: str | None = None
    model_client_stream: bool = False
    reflect_on_tool_use: bool
    tool_call_summary_format: str


class RunEventLogger(logging.Handler):
    """Event logger that queues LLMCallEvents for streaming"""

    def __init__(self):
        super().__init__()
        self.events = asyncio.Queue()

    def emit(self, record: logging.LogRecord):
        if isinstance(record.msg, LLMCallEvent):
            self.events.put_nowait(LLMCallEventMessage(content=str(record.msg)))


class WorkerAgent(Team, ComponentBase[WorkerAgentConfig]):
    """
    参考 autogen 的 BaseGroupChat 的实现方式
    """

    component_type = "worker"

    def __init__(self):
        self.backend_url = settings.GOMTM_URL
        if not self.backend_url:
            raise ValueError("backend_url is not set")
        self.worker = None
        self.autogen_host = None
        self.wfapp = None
        self.api_client = ApiClient(
            configuration=Configuration(
                host=self.backend_url,
            )
        )
        set_backend_url(self.backend_url)
        self._initialized = False
        self._is_running = False

        # Create a runtime for the team.
        # TODO: The runtime should be created by a managed context.
        # self._create_runtime()
        # Constants for the closure agent to collect the output messages.
        self._stop_reason: str | None = None
        self._output_message_queue: asyncio.Queue[AgentEvent | ChatMessage | None] = (
            asyncio.Queue()
        )

    async def _create_runtime(self):
        # 使用本地runtime
        # self._runtime = SingleThreadedAgentRuntime()

        # 使用远程gomtm runtime
        from worker._worker_runtime import MtmWorkerRuntime

        grpc_runtime = MtmWorkerRuntime()
        self._runtime = grpc_runtime
        # for serializer_type in attrs(serializer_types):
        # self._runtime.add_message_serializer(
        #     try_get_known_serializers_for_type(MsgGetTeamComponent)
        # )
        await self._runtime.start()
        logger.info("mtm(grpc) runtime 启动完成")
        await self._runtime.add_subscription(
            subscription=Subscription(
                topic_id=TopicId(type="tenant_agent", key="default"),
                callback=self.tenant_agent.handle_message,
            )
        )

    async def _init(self) -> None:
        # await self.start_autogen_host()
        await self._create_runtime()
        self.tenant_agent_id = AgentId("tenant_agent", "default")
        self.tenant_agent = await TenantAgent.register(
            runtime=self._runtime,
            type=self.tenant_agent_id.type,
            factory=lambda: TenantAgent(
                description=self.tenant_agent_id.type,
                wfapp=self.wfapp,
            ),
        )

        hf_space_agent_id = AgentId("hf_space_agent", "default")

        await HfSpaceAgent.register(
            runtime=self._runtime,
            type=hf_space_agent_id.type,
            factory=lambda: HfSpaceAgent(
                description=hf_space_agent_id.type,
                wfapp=self.wfapp,
            ),
        )
        self._initialized = True

    async def run(
        self,
        *,
        task: str | ChatMessage | Sequence[ChatMessage] | None = None,
        cancellation_token: CancellationToken | None = None,
    ) -> TaskResult:
        result: TaskResult | None = None
        if not self._initialized:
            await self._init()
        # self._runtime.start()

        # await self._init_ingestor()
        # logger.info("worker agent 结束")

    # @message_handler
    async def handle_message(self, message: AgentRunInput) -> TaskResult:
        # Setup logger correctly
        logger = logging.getLogger(EVENT_LOGGER_NAME)
        logger.setLevel(logging.INFO)
        llm_event_logger = RunEventLogger()
        logger.handlers = [llm_event_logger]  # Replace all handlers

        tenant_id: str | None = message.tenant_id
        if not tenant_id:
            tenant_id = get_tenant_id()
        if not tenant_id:
            raise ValueError("tenant_id is required")
        set_tenant_id(tenant_id)
        run_id = message.run_id
        if not run_id:
            raise ValueError("run_id is required")

        user_input = message.content
        if user_input.startswith("/tenant/seed"):
            logger.info(f"通知 TanantAgent 初始化(或重置)租户信息: {message}")
            result = await self._runtime.send_message(
                MsgResetTenant(tenant_id=tenant_id),
                self.tenant_agent_id,
            )
            return

        team_comp_data: MtComponent = None
        if not message.team_id:
            team_id = "fake_team_id"
            # result = await self._runtime.send_message(
            #     MsgGetTeamComponent(tenant_id=message.tenant_id, component_id=team_id),
            #     self.tenant_agent_id,
            # )
            # logger.info(f"get team component: {result}")
            # assistant_team_builder = assisant_team_builder.AssistantTeamBuilder()
            # team_comp_data = await self.get_or_create_default_team(
            #     tenant_id=message.tenant_id,
            #     label=assistant_team_builder.name,
            # )
            # message.team_id = team_comp_data.metadata.id

        # else:
        #     # 直接通过 grpc 获取团队组件
        #     data2 = await self._runtime.send_message(
        #         MsgGetTeamComponent(
        #             tenant_id=message.tenant_id, component_id=message.team_id
        #         ),
        #         self.tenant_agent_id,
        #     )

        # team_comp_data = await self.mtm_client.ag.GetComponent(
        #     request=MsgGetTeamComponent(
        #         tenant_id=message.tenant_id, component_id=message.team_id
        #     )
        # )
        team = Team.load_component(team_comp_data.component)
        team_id = message.team_id
        if not team_id:
            team_id = generate_uuid()

        thread_id = message.session_id
        if not thread_id:
            thread_id = generate_uuid()
        else:
            logger.info(f"现有session: {thread_id}")
            # 加载团队状态
            # await self.load_state(thread_id)
            ...

        task_result: TaskResult | None = None

        try:
            async for event in team.run_stream(
                task=message.content,
                # cancellation_token=ctx.cancellation_token,
            ):
                # if ctx.cancellation_token and ctx.cancellation_token.is_cancelled():
                #     break

                if isinstance(event, TaskResult):
                    logger.info(f"Worker Agent 收到任务结果: {event}")
                    task_result = event
                elif isinstance(
                    event,
                    (
                        TextMessage,
                        MultiModalMessage,
                        StopMessage,
                        HandoffMessage,
                        ToolCallRequestEvent,
                        ToolCallExecutionEvent,
                        LLMCallEventMessage,
                    ),
                ):
                    if event.content:
                        await self.handle_message_create(
                            ChatMessageUpsert(
                                content=event.content,
                                tenant_id=message.tenant_id,
                                component_id=message.team_id,
                                threadId=thread_id,
                                role=event.source,
                                runId=run_id,
                                stepRunId=message.step_run_id,
                            ),
                        )
                        self.wfapp.event.stream(
                            "hello1await111111111111", step_run_id=message.step_run_id
                        )
                    else:
                        logger.warn(f"worker Agent 消息没有content: {event}")
                else:
                    logger.info(f"worker Agent 收到(未知类型)消息: {event}")
        finally:
            await self.save_team_state(
                team=team,
                team_id=team_id,
                tenant_id=tenant_id,
                run_id=run_id,
            )
        return task_result

    # async def start_autogen_host(self):
    #     from autogen_ext.runtimes.grpc import GrpcWorkerAgentRuntimeHost

    #     self.autogen_host = GrpcWorkerAgentRuntimeHost(address=settings.AG_HOST_ADDRESS)
    #     self.autogen_host.start()

    async def handle_message_create(self, message: ChatMessageUpsert) -> None:
        await self.gomtmapi.chat_api.chat_message_upsert(
            tenant=message.tenant_id,
            chat_message_upsert=message.model_dump(),
        )

    async def stop(self):
        if self.worker:
            await self.worker.async_stop()
            if self.autogen_host:
                await self.autogen_host.stop()
            if self.runtime:
                await self.runtime.stop()
            logger.warning("worker and autogen host stopped")

    async def reset(self) -> None:
        if not self._initialized:
            raise RuntimeError(
                "The group chat has not been initialized. It must be run before it can be reset."
            )

        if self._is_running:
            raise RuntimeError(
                "The group chat is currently running. It must be stopped before it can be reset."
            )
        self._is_running = True
        self._runtime.start()

        try:
            self._runtime = SingleThreadedAgentRuntime()
            # for serializer_type in serializer_types:
            #     self._runtime.add_message_serializer(
            #         try_get_known_serializers_for_type(serializer_type)
            #     )

        finally:
            # Stop the runtime.
            await self._runtime.stop_when_idle()

            # Reset the output message queue.
            self._stop_reason = None
            while not self._output_message_queue.empty():
                self._output_message_queue.get_nowait()

            # Indicate that the team is no longer running.
            self._is_running = False

    async def save_state(self) -> Mapping[str, Any]:
        """Save the state of the group chat team."""
        if not self._initialized:
            raise RuntimeError(
                "The group chat has not been initialized. It must be run before it can be saved."
            )

        if self._is_running:
            raise RuntimeError("The team cannot be saved while it is running.")
        self._is_running = True

        try:
            # Save the state of the runtime. This will save the state of the participants and the group chat manager.
            agent_states = await self._runtime.save_state()
            # return TeamState(agent_states=agent_states, team_id=self._team_id).model_dump()

        finally:
            # Indicate that the team is no longer running.
            self._is_running = False

    async def load_state(self, state: Mapping[str, Any]) -> None:
        """Load the state of the group chat team."""
        if not self._initialized:
            await self._init(self._runtime)

        if self._is_running:
            raise RuntimeError("The team cannot be loaded while it is running.")
        self._is_running = True

        try:
            # Load the state of the runtime. This will load the state of the participants and the group chat manager.
            # team_state = TeamState.model_validate(state)
            # self._team_id = team_state.team_id
            # await self._runtime.load_state(team_state.agent_states)
            pass
        finally:
            # Indicate that the team is no longer running.
            self._is_running = False

    def _to_config(self) -> WorkerAgentConfig:
        participants = [
            participant.dump_component() for participant in self._participants
        ]
        termination_condition = (
            self._termination_condition.dump_component()
            if self._termination_condition
            else None
        )
        return WorkerAgentConfig(
            participants=participants,
            termination_condition=termination_condition,
            max_turns=self._max_turns,
        )

    @classmethod
    def _from_config(cls, config: WorkerAgentConfig) -> Self:
        # participants = [ChatAgent.load_component(participant) for participant in config.participants]
        # termination_condition = (
        #     TerminationCondition.load_component(config.termination_condition) if config.termination_condition else None
        # )
        return cls(max_turns=config.max_turns)

    async def save_team_state(
        self, team: Team, team_id: str, tenant_id: str, run_id: str
    ) -> None:
        """保存团队状态"""
        logger.info("保存团队状态")
        # 确保停止团队的内部 agents
        if team and hasattr(team, "_participants"):
            for agent in team._participants:
                if hasattr(agent, "close"):
                    await agent.close()
        state = await team.save_state()
        await self.gomtmapi.ag_state_api.ag_state_upsert(
            tenant=tenant_id,
            ag_state_upsert=AgStateUpsert(
                componentId=team_id,
                runId=run_id,
                state=state,
            ).model_dump(),
        )
