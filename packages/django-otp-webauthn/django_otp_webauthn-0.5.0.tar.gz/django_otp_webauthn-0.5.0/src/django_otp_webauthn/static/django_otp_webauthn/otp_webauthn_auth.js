(()=>{"use strict";var b;(function(e){e.UNKNOWN_ERROR="unknown-error",e.STATE_ERROR="state-error",e.SECURITY_ERROR="security-error",e.GET_OPTIONS_FAILED="get-options-failed",e.ABORTED="aborted",e.NOT_ALLOWED_OR_ABORTED="not-allowed-or-aborted",e.SERVER_ERROR="server-error",e.SUCCESS="success",e.BUSY="busy"})(b||(b={}));async function L(){let e=null;const t=document.getElementById("otp_webauthn_config");if(t)return e=JSON.parse(t.innerText),Object.freeze(e);throw new Error("otp_webauthn_config element not found")}function v(){return V.stubThis(globalThis?.PublicKeyCredential!==void 0&&typeof globalThis.PublicKeyCredential=="function")}const V={stubThis:e=>e};class _ extends Error{constructor({message:t,code:o,cause:l,name:s}){super(t,{cause:l}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=s??l.name,this.code=o}}function M({error:e,options:t}){const{publicKey:o}=t;if(!o)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new WebAuthnError({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else if(e.name==="ConstraintError"){if(o.authenticatorSelection?.requireResidentKey===!0)return new WebAuthnError({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:e});if(t.mediation==="conditional"&&o.authenticatorSelection?.userVerification==="required")return new WebAuthnError({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:e});if(o.authenticatorSelection?.userVerification==="required")return new WebAuthnError({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:e})}else{if(e.name==="InvalidStateError")return new WebAuthnError({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:e});if(e.name==="NotAllowedError")return new WebAuthnError({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="NotSupportedError")return o.pubKeyCredParams.filter(s=>s.type==="public-key").length===0?new WebAuthnError({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:e}):new WebAuthnError({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:e});if(e.name==="SecurityError"){const l=globalThis.location.hostname;if(isValidDomain(l)){if(o.rp.id!==l)return new WebAuthnError({message:`The RP ID "${o.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new WebAuthnError({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="TypeError"){if(o.user.id.byteLength<1||o.user.id.byteLength>64)return new WebAuthnError({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:e})}else if(e.name==="UnknownError")return new WebAuthnError({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}class B{constructor(){Object.defineProperty(this,"controller",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}createNewAbortSignal(){if(this.controller){const o=new Error("Cancelling existing WebAuthn API call for new one");o.name="AbortError",this.controller.abort(o)}const t=new AbortController;return this.controller=t,t.signal}cancelCeremony(){if(this.controller){const t=new Error("Manually cancelling existing WebAuthn API call");t.name="AbortError",this.controller.abort(t),this.controller=void 0}}}const k=new B;async function J(e){!e.optionsJSON&&e.challenge&&(console.warn("startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),e={optionsJSON:e});const{optionsJSON:t,useAutoRegister:o=!1}=e;if(!browserSupportsWebAuthn())throw new Error("WebAuthn is not supported in this browser");const l={...t,challenge:base64URLStringToBuffer(t.challenge),user:{...t.user,id:base64URLStringToBuffer(t.user.id)},excludeCredentials:t.excludeCredentials?.map(toPublicKeyCredentialDescriptor)},s={};o&&(s.mediation="conditional"),s.publicKey=l,s.signal=WebAuthnAbortService.createNewAbortSignal();let f;try{f=await navigator.credentials.create(s)}catch(n){throw identifyRegistrationError({error:n,options:s})}if(!f)throw new Error("Registration was not completed");const{id:h,rawId:u,response:i,type:I}=f;let E;typeof i.getTransports=="function"&&(E=i.getTransports());let c;if(typeof i.getPublicKeyAlgorithm=="function")try{c=i.getPublicKeyAlgorithm()}catch(n){C("getPublicKeyAlgorithm()",n)}let g;if(typeof i.getPublicKey=="function")try{const n=i.getPublicKey();n!==null&&(g=bufferToBase64URLString(n))}catch(n){C("getPublicKey()",n)}let w;if(typeof i.getAuthenticatorData=="function")try{w=bufferToBase64URLString(i.getAuthenticatorData())}catch(n){C("getAuthenticatorData()",n)}return{id:h,rawId:bufferToBase64URLString(u),response:{attestationObject:bufferToBase64URLString(i.attestationObject),clientDataJSON:bufferToBase64URLString(i.clientDataJSON),transports:E,publicKeyAlgorithm:c,publicKey:g,authenticatorData:w},type:I,clientExtensionResults:f.getClientExtensionResults(),authenticatorAttachment:toAuthenticatorAttachment(f.authenticatorAttachment)}}function C(e,t){console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${e}. You should report this error to them.
`,t)}function O(e){const t=new Uint8Array(e);let o="";for(const s of t)o+=String.fromCharCode(s);return btoa(o).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function P(e){const t=e.replace(/-/g,"+").replace(/_/g,"/"),o=(4-t.length%4)%4,l=t.padEnd(t.length+o,"="),s=atob(l),f=new ArrayBuffer(s.length),h=new Uint8Array(f);for(let u=0;u<s.length;u++)h[u]=s.charCodeAt(u);return f}function D(){if(!v())return N.stubThis(new Promise(t=>t(!1)));const e=globalThis.PublicKeyCredential;return e?.isConditionalMediationAvailable===void 0?N.stubThis(new Promise(t=>t(!1))):N.stubThis(e.isConditionalMediationAvailable())}const N={stubThis:e=>e};function K(e){const{id:t}=e;return{...e,id:P(t),transports:e.transports}}function x(e){return e==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}function W({error:e,options:t}){const{publicKey:o}=t;if(!o)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new _({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else{if(e.name==="NotAllowedError")return new _({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="SecurityError"){const l=globalThis.location.hostname;if(x(l)){if(o.rpId!==l)return new _({message:`The RP ID "${o.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new _({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="UnknownError")return new _({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}const F=["cross-platform","platform"];function q(e){if(e&&!(F.indexOf(e)<0))return e}async function U(e){!e.optionsJSON&&e.challenge&&(console.warn("startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),e={optionsJSON:e});const{optionsJSON:t,useBrowserAutofill:o=!1,verifyBrowserAutofillInput:l=!0}=e;if(!v())throw new Error("WebAuthn is not supported in this browser");let s;t.allowCredentials?.length!==0&&(s=t.allowCredentials?.map(K));const f={...t,challenge:P(t.challenge),allowCredentials:s},h={};if(o){if(!await D())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete$='webauthn']").length<1&&l)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');h.mediation="conditional",f.allowCredentials=[]}h.publicKey=f,h.signal=k.createNewAbortSignal();let u;try{u=await navigator.credentials.get(h)}catch(w){throw W({error:w,options:h})}if(!u)throw new Error("Authentication was not completed");const{id:i,rawId:I,response:E,type:c}=u;let g;return E.userHandle&&(g=O(E.userHandle)),{id:i,rawId:O(I),response:{authenticatorData:O(E.authenticatorData),clientDataJSON:O(E.clientDataJSON),signature:O(E.signature),userHandle:g},type:c,clientExtensionResults:u.getClientExtensionResults(),authenticatorAttachment:q(u.authenticatorAttachment)}}function j(){return browserSupportsWebAuthn()?PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable():new Promise(e=>e(!1))}(async function(){const e="passkey-verification-button",t="passkey-verification-status-message",o="visible",l="passkey-verification-placeholder",s="passkey-verification-unavailable-template",f="passkey-verification-available-template",h="otp_webauthn.verification_start",u="otp_webauthn.verification_complete",i="otp_webauthn.verification_failed";async function I(n){if(!n.autocompleteLoginFieldSelector)return;const r=document.querySelector(n.autocompleteLoginFieldSelector);if(!r){console.error(`Could not find login field with selector ${n.autocompleteLoginFieldSelector}. WebAuthn autofill cannot continue.`);return}const a=r.getAttribute("autocomplete")||"";r.setAttribute("autocomplete",a+" webauthn"),r.dispatchEvent(new CustomEvent(h,{detail:{fromAutofill:!0},bubbles:!0}));const y=await fetch(n.beginAuthenticationUrl,{method:"POST",credentials:"same-origin",headers:{"X-CSRFToken":n.csrfToken,Accept:"application/json"}});if(!y.ok){console.error("Unable to fetch options from server. Will not attempt autofill."),r.dispatchEvent(new CustomEvent(i,{detail:{fromAutofill:!0,response:y},bubbles:!0}));return}let A;try{A=await U({optionsJSON:await y.json(),useBrowserAutofill:!0})}catch(p){console.error("Got error during the webauthn credential autofill call",p),r.dispatchEvent(new CustomEvent(i,{detail:{fromAutofill:!0,error:p},bubbles:!0}));return}const T=document.querySelector("input[name='next']");let S=n.completeAuthenticationUrl;T&&T.value&&(S+=`?next=${encodeURIComponent(T.value)}`);const m=await fetch(S,{method:"POST",headers:{"Content-Type":"application/json","X-CSRFToken":n.csrfToken},credentials:"same-origin",body:JSON.stringify(A)});if(!m.headers.get("content-type")?.includes("application/json")){r.dispatchEvent(new CustomEvent(i,{detail:{fromAutofill:!0,response:m},bubbles:!0})),alert(gettext("Verification failed. A server error occurred."));return}const d=await m.json();if(!m.ok&&"detail"in d){r.dispatchEvent(new CustomEvent(i,{detail:{fromAutofill:!0,response:m},bubbles:!0})),alert(d.detail);return}if(d&&d.id)r.dispatchEvent(new CustomEvent(u,{detail:{fromAutofill:!0,response:m},bubbles:!0})),d.redirect_url&&(window.location.href=d.redirect_url);else{r.dispatchEvent(new CustomEvent(i,{detail:{fromAutofill:!0,response:m},bubbles:!0}));const p=d.error||gettext("An error occurred during verification.");alert(p)}}async function E(n){const r=document.getElementById(e);if(!r)return;const a=r.textContent||gettext("Verify with Passkey");r.addEventListener("click",async y=>{r.dispatchEvent(new CustomEvent(h,{detail:{fromAutofill:!1},bubbles:!0})),await c({buttonDisabled:!0,statusEnum:b.BUSY,buttonLabel:gettext("Verifying...")});const A=await fetch(n.beginAuthenticationUrl,{method:"POST",credentials:"same-origin",headers:{"X-CSRFToken":n.csrfToken,Accept:"application/json"}});if(!A.ok){await c({buttonDisabled:!1,buttonLabel:a,requestFocus:!0,statusEnum:b.GET_OPTIONS_FAILED,status:gettext("Verification failed. Could not retrieve parameters from the server.")}),r.dispatchEvent(new CustomEvent(i,{detail:{fromAutofill:!1,response:A},bubbles:!0}));return}let T;try{T=await U({optionsJSON:await A.json(),useBrowserAutofill:!1})}catch(R){if(R instanceof Error||R instanceof _){switch(console.error(R),R.name){case"AbortError":await c({buttonDisabled:!1,buttonLabel:a,requestFocus:!0,statusEnum:b.ABORTED,status:gettext("Verification aborted.")});break;case"NotAllowedError":await c({buttonDisabled:!1,buttonLabel:a,requestFocus:!0,statusEnum:b.NOT_ALLOWED_OR_ABORTED,status:gettext("Verification canceled or not allowed.")});break;default:throw await c({buttonDisabled:!1,buttonLabel:a,requestFocus:!0,statusEnum:b.UNKNOWN_ERROR,status:gettext("Verification failed. An unknown error occurred.")}),R}r.dispatchEvent(new CustomEvent(i,{detail:{fromAutofill:!1,error:R},bubbles:!0}));return}}await c({buttonDisabled:!0,statusEnum:b.BUSY,buttonLabel:gettext("Finishing verification...")});const S=document.querySelector("input[name='next']");let m=n.completeAuthenticationUrl;S&&S.value&&(m+=`?next=${encodeURIComponent(S.value)}`);const d=await fetch(m,{method:"POST",headers:{"Content-Type":"application/json","X-CSRFToken":n.csrfToken},credentials:"same-origin",body:JSON.stringify(T)});if(!d.headers.get("content-type")?.includes("application/json")){await c({buttonDisabled:!1,buttonLabel:a,requestFocus:!0,statusEnum:b.SERVER_ERROR,status:gettext("Verification failed. An unknown server error occurred.")}),r.dispatchEvent(new CustomEvent(i,{detail:{fromAutofill:!1,response:d},bubbles:!0}));return}const p=await d.json();if(!d.ok){const R=p.detail||gettext("Verification failed. An unknown error occurred.");await c({buttonDisabled:!1,buttonLabel:a,statusEnum:b.SERVER_ERROR,requestFocus:!0,status:R}),r.dispatchEvent(new CustomEvent(i,{detail:{fromAutofill:!1,response:d},bubbles:!0}));return}if(p&&p.id)await c({buttonDisabled:!1,buttonLabel:a,statusEnum:b.SUCCESS,status:gettext("Verification successful!")}),r.dispatchEvent(new CustomEvent(u,{detail:{fromAutofill:!1,response:d,id:p.id},bubbles:!0})),p.redirect_url&&(window.location.href=p.redirect_url);else{const R=p.error||gettext("An error occurred during verification.");await c({buttonDisabled:!1,buttonLabel:a,statusEnum:b.SERVER_ERROR,requestFocus:!0,status:R})}})}async function c(n){const r=document.getElementById(e);if(!r)return;const a=document.getElementById(t);r.disabled=n.buttonDisabled,r.textContent=n.buttonLabel,n.statusEnum?a.setAttribute("data-status-enum",n.statusEnum):a.removeAttribute("data-status-enum"),a&&(n.status?(r.setAttribute("aria-describedby",t),a.classList.add(o),a.textContent=n.status,a.setAttribute("aria-live","assertive"),n.requestFocus&&r.focus()):(r.removeAttribute("aria-describedby"),a.removeAttribute("aria-live"),a.classList.remove(o)))}async function g(n){const r=document.getElementById(l),a=document.getElementById(f),y=document.getElementById(s);if(!r)throw new Error("Placeholder element not found");if(!a)throw new Error("Available template not found");if(n){const A=a.content.cloneNode(!0);r.replaceWith(A)}else if(y){const A=y.content.cloneNode(!0);r.replaceWith(A)}else r.remove()}const w=await L();w.autocompleteLoginFieldSelector&&await D()&&I(w),v()?(await g(!0),E(w)):await g(!1)})()})();

//# sourceMappingURL=otp_webauthn_auth.js.map