# Generated by cloudcoil-model-codegen v0.5.6
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    Union,
    cast,
    overload,
)

from pydantic import Field, RootModel

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseBuilder,
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class SourceMatch(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SourceMatch"]:
            return SourceMatch

        def build(self) -> "SourceMatch":
            return SourceMatch(**self._attrs)

        def match_type(self, value: Optional[Literal["!=", "=", "=~", "!~"]], /) -> Self:
            """
            Match operation available with AlertManager >= v0.22.0 and
            takes precedence over Regex (deprecated) if non-empty.
            """
            return self._set("match_type", value)

        def name(self, value: str, /) -> Self:
            """
            Label to match.
            """
            return self._set("name", value)

        def regex(self, value: Optional[bool], /) -> Self:
            """
            Whether to match on equality (false) or regular-expression (true).
            Deprecated: for AlertManager >= v0.22.0, `matchType` should be used instead.
            """
            return self._set("regex", value)

        def value(self, value: Optional[str], /) -> Self:
            """
            Label value to match.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["SourceMatch.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SourceMatch.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SourceMatch."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SourceMatch", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SourceMatch.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_type: Annotated[Optional[Literal["!=", "=", "=~", "!~"]], Field(alias="matchType")] = None
    """
    Match operation available with AlertManager >= v0.22.0 and
    takes precedence over Regex (deprecated) if non-empty.
    """
    name: Annotated[str, Field(min_length=1)]
    """
    Label to match.
    """
    regex: Optional[bool] = None
    """
    Whether to match on equality (false) or regular-expression (true).
    Deprecated: for AlertManager >= v0.22.0, `matchType` should be used instead.
    """
    value: Optional[str] = None
    """
    Label value to match.
    """


class TargetMatch(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TargetMatch"]:
            return TargetMatch

        def build(self) -> "TargetMatch":
            return TargetMatch(**self._attrs)

        def match_type(self, value: Optional[Literal["!=", "=", "=~", "!~"]], /) -> Self:
            """
            Match operation available with AlertManager >= v0.22.0 and
            takes precedence over Regex (deprecated) if non-empty.
            """
            return self._set("match_type", value)

        def name(self, value: str, /) -> Self:
            """
            Label to match.
            """
            return self._set("name", value)

        def regex(self, value: Optional[bool], /) -> Self:
            """
            Whether to match on equality (false) or regular-expression (true).
            Deprecated: for AlertManager >= v0.22.0, `matchType` should be used instead.
            """
            return self._set("regex", value)

        def value(self, value: Optional[str], /) -> Self:
            """
            Label value to match.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["TargetMatch.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TargetMatch.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TargetMatch."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TargetMatch", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TargetMatch.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_type: Annotated[Optional[Literal["!=", "=", "=~", "!~"]], Field(alias="matchType")] = None
    """
    Match operation available with AlertManager >= v0.22.0 and
    takes precedence over Regex (deprecated) if non-empty.
    """
    name: Annotated[str, Field(min_length=1)]
    """
    Label to match.
    """
    regex: Optional[bool] = None
    """
    Whether to match on equality (false) or regular-expression (true).
    Deprecated: for AlertManager >= v0.22.0, `matchType` should be used instead.
    """
    value: Optional[str] = None
    """
    Label value to match.
    """


class InhibitRule(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InhibitRule"]:
            return InhibitRule

        def build(self) -> "InhibitRule":
            return InhibitRule(**self._attrs)

        def equal(self, value: Optional[List[str]], /) -> Self:
            """
            Labels that must have an equal value in the source and target alert for
            the inhibition to take effect.
            """
            return self._set("equal", value)

        @overload
        def source_match(
            self, value_or_callback: List[SourceMatch], /
        ) -> "InhibitRule.Builder": ...

        @overload
        def source_match(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[SourceMatch, SourceMatch.Builder]],
                GenericListBuilder[SourceMatch, SourceMatch.Builder] | List[SourceMatch],
            ],
            /,
        ) -> "InhibitRule.Builder": ...

        @overload
        def source_match(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[SourceMatch.Builder]: ...

        def source_match(self, value_or_callback=None, /):
            """
            Matchers for which one or more alerts have to exist for the inhibition
            to take effect. The operator enforces that the alert matches the
            resource's namespace.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[SourceMatch.Builder]()
                context._parent_builder = self
                context._field_name = "source_match"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SourceMatch.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("source_match", value)

        @overload
        def target_match(
            self, value_or_callback: List[TargetMatch], /
        ) -> "InhibitRule.Builder": ...

        @overload
        def target_match(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[TargetMatch, TargetMatch.Builder]],
                GenericListBuilder[TargetMatch, TargetMatch.Builder] | List[TargetMatch],
            ],
            /,
        ) -> "InhibitRule.Builder": ...

        @overload
        def target_match(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[TargetMatch.Builder]: ...

        def target_match(self, value_or_callback=None, /):
            """
            Matchers that have to be fulfilled in the alerts to be muted. The
            operator enforces that the alert matches the resource's namespace.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[TargetMatch.Builder]()
                context._parent_builder = self
                context._field_name = "target_match"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TargetMatch.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("target_match", value)

    class BuilderContext(BuilderContextBase["InhibitRule.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InhibitRule.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InhibitRule."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InhibitRule", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InhibitRule.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    equal: Optional[List[str]] = None
    """
    Labels that must have an equal value in the source and target alert for
    the inhibition to take effect.
    """
    source_match: Annotated[Optional[List[SourceMatch]], Field(alias="sourceMatch")] = None
    """
    Matchers for which one or more alerts have to exist for the inhibition
    to take effect. The operator enforces that the alert matches the
    resource's namespace.
    """
    target_match: Annotated[Optional[List[TargetMatch]], Field(alias="targetMatch")] = None
    """
    Matchers that have to be fulfilled in the alerts to be muted. The
    operator enforces that the alert matches the resource's namespace.
    """


class DaysOfMonth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DaysOfMonth"]:
            return DaysOfMonth

        def build(self) -> "DaysOfMonth":
            return DaysOfMonth(**self._attrs)

        def end(self, value: Optional[int], /) -> Self:
            """
            End of the inclusive range
            """
            return self._set("end", value)

        def start(self, value: Optional[int], /) -> Self:
            """
            Start of the inclusive range
            """
            return self._set("start", value)

    class BuilderContext(BuilderContextBase["DaysOfMonth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DaysOfMonth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DaysOfMonth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DaysOfMonth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DaysOfMonth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    end: Annotated[Optional[int], Field(ge=-31, le=31)] = None
    """
    End of the inclusive range
    """
    start: Annotated[Optional[int], Field(ge=-31, le=31)] = None
    """
    Start of the inclusive range
    """


class Month(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            MonthRange is an inclusive range of months of the year beginning in January
            Months can be specified by name (e.g 'January') by numerical month (e.g '1') or as an inclusive range (e.g 'January:March', '1:3', '1:March')
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            MonthRange is an inclusive range of months of the year beginning in January
            Months can be specified by name (e.g 'January') by numerical month (e.g '1') or as an inclusive range (e.g 'January:March', '1:3', '1:March')
            """
            self._value = value
            return self

        def build(self) -> "Month":
            value = cast(str, self._value)
            return Month(value)

    root: Annotated[
        str,
        Field(
            pattern="^((?i)january|february|march|april|may|june|july|august|september|october|november|december|1[0-2]|[1-9])(?:((:((?i)january|february|march|april|may|june|july|august|september|october|november|december|1[0-2]|[1-9]))$)|$)"
        ),
    ]
    """
    MonthRange is an inclusive range of months of the year beginning in January
    Months can be specified by name (e.g 'January') by numerical month (e.g '1') or as an inclusive range (e.g 'January:March', '1:3', '1:March')
    """

    class BuilderContext(BuilderContextBase["Month.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Month.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Month."""
        return cls.BuilderContext()


class Time(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Time"]:
            return Time

        def build(self) -> "Time":
            return Time(**self._attrs)

        def end_time(self, value: Optional[str], /) -> Self:
            """
            EndTime is the end time in 24hr format.
            """
            return self._set("end_time", value)

        def start_time(self, value: Optional[str], /) -> Self:
            """
            StartTime is the start time in 24hr format.
            """
            return self._set("start_time", value)

    class BuilderContext(BuilderContextBase["Time.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Time.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Time."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Time", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Time.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    end_time: Annotated[
        Optional[str],
        Field(alias="endTime", pattern="^((([01][0-9])|(2[0-3])):[0-5][0-9])$|(^24:00$)"),
    ] = None
    """
    EndTime is the end time in 24hr format.
    """
    start_time: Annotated[
        Optional[str],
        Field(alias="startTime", pattern="^((([01][0-9])|(2[0-3])):[0-5][0-9])$|(^24:00$)"),
    ] = None
    """
    StartTime is the start time in 24hr format.
    """


class Weekday(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            WeekdayRange is an inclusive range of days of the week beginning on Sunday
            Days can be specified by name (e.g 'Sunday') or as an inclusive range (e.g 'Monday:Friday')
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            WeekdayRange is an inclusive range of days of the week beginning on Sunday
            Days can be specified by name (e.g 'Sunday') or as an inclusive range (e.g 'Monday:Friday')
            """
            self._value = value
            return self

        def build(self) -> "Weekday":
            value = cast(str, self._value)
            return Weekday(value)

    root: Annotated[
        str,
        Field(
            pattern="^((?i)sun|mon|tues|wednes|thurs|fri|satur)day(?:((:(sun|mon|tues|wednes|thurs|fri|satur)day)$)|$)"
        ),
    ]
    """
    WeekdayRange is an inclusive range of days of the week beginning on Sunday
    Days can be specified by name (e.g 'Sunday') or as an inclusive range (e.g 'Monday:Friday')
    """

    class BuilderContext(BuilderContextBase["Weekday.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Weekday.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Weekday."""
        return cls.BuilderContext()


class Year(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            YearRange is an inclusive range of years
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            YearRange is an inclusive range of years
            """
            self._value = value
            return self

        def build(self) -> "Year":
            value = cast(str, self._value)
            return Year(value)

    root: Annotated[str, Field(pattern="^2\\d{3}(?::2\\d{3}|$)")]
    """
    YearRange is an inclusive range of years
    """

    class BuilderContext(BuilderContextBase["Year.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Year.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Year."""
        return cls.BuilderContext()


class TimeInterval(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TimeInterval"]:
            return TimeInterval

        def build(self) -> "TimeInterval":
            return TimeInterval(**self._attrs)

        @overload
        def days_of_month(
            self, value_or_callback: List[DaysOfMonth], /
        ) -> "TimeInterval.Builder": ...

        @overload
        def days_of_month(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[DaysOfMonth, DaysOfMonth.Builder]],
                GenericListBuilder[DaysOfMonth, DaysOfMonth.Builder] | List[DaysOfMonth],
            ],
            /,
        ) -> "TimeInterval.Builder": ...

        @overload
        def days_of_month(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[DaysOfMonth.Builder]: ...

        def days_of_month(self, value_or_callback=None, /):
            """
            DaysOfMonth is a list of DayOfMonthRange
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[DaysOfMonth.Builder]()
                context._parent_builder = self
                context._field_name = "days_of_month"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DaysOfMonth.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("days_of_month", value)

        @overload
        def months(self, value_or_callback: List[Month], /) -> "TimeInterval.Builder": ...

        @overload
        def months(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Month, Month.Builder]],
                GenericListBuilder[Month, Month.Builder] | List[Month],
            ],
            /,
        ) -> "TimeInterval.Builder": ...

        @overload
        def months(self, value_or_callback: Never = ...) -> ListBuilderContext[Month.Builder]: ...

        def months(self, value_or_callback=None, /):
            """
            Months is a list of MonthRange
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Month.Builder]()
                context._parent_builder = self
                context._field_name = "months"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Month.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("months", value)

        @overload
        def times(self, value_or_callback: List[Time], /) -> "TimeInterval.Builder": ...

        @overload
        def times(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Time, Time.Builder]],
                GenericListBuilder[Time, Time.Builder] | List[Time],
            ],
            /,
        ) -> "TimeInterval.Builder": ...

        @overload
        def times(self, value_or_callback: Never = ...) -> ListBuilderContext[Time.Builder]: ...

        def times(self, value_or_callback=None, /):
            """
            Times is a list of TimeRange
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Time.Builder]()
                context._parent_builder = self
                context._field_name = "times"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Time.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("times", value)

        @overload
        def weekdays(self, value_or_callback: List[Weekday], /) -> "TimeInterval.Builder": ...

        @overload
        def weekdays(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Weekday, Weekday.Builder]],
                GenericListBuilder[Weekday, Weekday.Builder] | List[Weekday],
            ],
            /,
        ) -> "TimeInterval.Builder": ...

        @overload
        def weekdays(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Weekday.Builder]: ...

        def weekdays(self, value_or_callback=None, /):
            """
            Weekdays is a list of WeekdayRange
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Weekday.Builder]()
                context._parent_builder = self
                context._field_name = "weekdays"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Weekday.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("weekdays", value)

        @overload
        def years(self, value_or_callback: List[Year], /) -> "TimeInterval.Builder": ...

        @overload
        def years(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Year, Year.Builder]],
                GenericListBuilder[Year, Year.Builder] | List[Year],
            ],
            /,
        ) -> "TimeInterval.Builder": ...

        @overload
        def years(self, value_or_callback: Never = ...) -> ListBuilderContext[Year.Builder]: ...

        def years(self, value_or_callback=None, /):
            """
            Years is a list of YearRange
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Year.Builder]()
                context._parent_builder = self
                context._field_name = "years"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Year.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("years", value)

    class BuilderContext(BuilderContextBase["TimeInterval.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TimeInterval.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TimeInterval."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TimeInterval", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TimeInterval.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    days_of_month: Annotated[Optional[List[DaysOfMonth]], Field(alias="daysOfMonth")] = None
    """
    DaysOfMonth is a list of DayOfMonthRange
    """
    months: Optional[List[Month]] = None
    """
    Months is a list of MonthRange
    """
    times: Optional[List[Time]] = None
    """
    Times is a list of TimeRange
    """
    weekdays: Optional[List[Weekday]] = None
    """
    Weekdays is a list of WeekdayRange
    """
    years: Optional[List[Year]] = None
    """
    Years is a list of YearRange
    """


class MuteTimeInterval(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MuteTimeInterval"]:
            return MuteTimeInterval

        def build(self) -> "MuteTimeInterval":
            return MuteTimeInterval(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the time interval
            """
            return self._set("name", value)

        @overload
        def time_intervals(
            self, value_or_callback: List[TimeInterval], /
        ) -> "MuteTimeInterval.Builder": ...

        @overload
        def time_intervals(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[TimeInterval, TimeInterval.Builder]],
                GenericListBuilder[TimeInterval, TimeInterval.Builder] | List[TimeInterval],
            ],
            /,
        ) -> "MuteTimeInterval.Builder": ...

        @overload
        def time_intervals(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[TimeInterval.Builder]: ...

        def time_intervals(self, value_or_callback=None, /):
            """
            TimeIntervals is a list of TimeInterval
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[TimeInterval.Builder]()
                context._parent_builder = self
                context._field_name = "time_intervals"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TimeInterval.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("time_intervals", value)

    class BuilderContext(BuilderContextBase["MuteTimeInterval.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MuteTimeInterval.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MuteTimeInterval."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MuteTimeInterval", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MuteTimeInterval.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the time interval
    """
    time_intervals: Annotated[Optional[List[TimeInterval]], Field(alias="timeIntervals")] = None
    """
    TimeIntervals is a list of TimeInterval
    """


class ApiUrl(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ApiUrl"]:
            return ApiUrl

        def build(self) -> "ApiUrl":
            return ApiUrl(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ApiUrl.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ApiUrl.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ApiUrl."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ApiUrl", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ApiUrl.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class Credentials(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Credentials"]:
            return Credentials

        def build(self) -> "Credentials":
            return Credentials(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["Credentials.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Credentials.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Credentials."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Credentials", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Credentials.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class Authorization(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Authorization"]:
            return Authorization

        def build(self) -> "Authorization":
            return Authorization(**self._attrs)

        @overload
        def credentials(
            self, value_or_callback: Optional[Credentials], /
        ) -> "Authorization.Builder": ...

        @overload
        def credentials(
            self,
            value_or_callback: Callable[[Credentials.Builder], Credentials.Builder | Credentials],
            /,
        ) -> "Authorization.Builder": ...

        @overload
        def credentials(self, value_or_callback: Never = ...) -> "Credentials.BuilderContext": ...

        def credentials(self, value_or_callback=None, /):
            """
            Selects a key of a Secret in the namespace that contains the credentials for authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Credentials.BuilderContext()
                context._parent_builder = self
                context._field_name = "credentials"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Credentials.builder())
                if isinstance(output, Credentials.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("credentials", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Defines the authentication type. The value is case-insensitive.

            "Basic" is not a supported value.

            Default: "Bearer"
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Authorization.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Authorization.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Authorization."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Authorization", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Authorization.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    credentials: Optional[Credentials] = None
    """
    Selects a key of a Secret in the namespace that contains the credentials for authentication.
    """
    type: Optional[str] = None
    """
    Defines the authentication type. The value is case-insensitive.

    "Basic" is not a supported value.

    Default: "Bearer"
    """


class Password(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Password"]:
            return Password

        def build(self) -> "Password":
            return Password(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["Password.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Password.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Password."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Password", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Password.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class Username(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Username"]:
            return Username

        def build(self) -> "Username":
            return Username(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["Username.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Username.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Username."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Username", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Username.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class BasicAuth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BasicAuth"]:
            return BasicAuth

        def build(self) -> "BasicAuth":
            return BasicAuth(**self._attrs)

        @overload
        def password(self, value_or_callback: Optional[Password], /) -> "BasicAuth.Builder": ...

        @overload
        def password(
            self,
            value_or_callback: Callable[[Password.Builder], Password.Builder | Password],
            /,
        ) -> "BasicAuth.Builder": ...

        @overload
        def password(self, value_or_callback: Never = ...) -> "Password.BuilderContext": ...

        def password(self, value_or_callback=None, /):
            """
            `password` specifies a key of a Secret containing the password for
            authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Password.BuilderContext()
                context._parent_builder = self
                context._field_name = "password"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Password.builder())
                if isinstance(output, Password.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("password", value)

        @overload
        def username(self, value_or_callback: Optional[Username], /) -> "BasicAuth.Builder": ...

        @overload
        def username(
            self,
            value_or_callback: Callable[[Username.Builder], Username.Builder | Username],
            /,
        ) -> "BasicAuth.Builder": ...

        @overload
        def username(self, value_or_callback: Never = ...) -> "Username.BuilderContext": ...

        def username(self, value_or_callback=None, /):
            """
            `username` specifies a key of a Secret containing the username for
            authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Username.BuilderContext()
                context._parent_builder = self
                context._field_name = "username"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Username.builder())
                if isinstance(output, Username.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("username", value)

    class BuilderContext(BuilderContextBase["BasicAuth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BasicAuth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BasicAuth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BasicAuth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BasicAuth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    password: Optional[Password] = None
    """
    `password` specifies a key of a Secret containing the password for
    authentication.
    """
    username: Optional[Username] = None
    """
    `username` specifies a key of a Secret containing the username for
    authentication.
    """


class BearerTokenSecret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BearerTokenSecret"]:
            return BearerTokenSecret

        def build(self) -> "BearerTokenSecret":
            return BearerTokenSecret(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["BearerTokenSecret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BearerTokenSecret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BearerTokenSecret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BearerTokenSecret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BearerTokenSecret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class ConfigMap(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMap"]:
            return ConfigMap

        def build(self) -> "ConfigMap":
            return ConfigMap(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key to select.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the ConfigMap or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMap.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMap.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMap."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMap", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMap.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key to select.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the ConfigMap or its key must be defined
    """


class Secret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Secret"]:
            return Secret

        def build(self) -> "Secret":
            return Secret(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["Secret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Secret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Secret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Secret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Secret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class ClientId(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClientId"]:
            return ClientId

        def build(self) -> "ClientId":
            return ClientId(**self._attrs)

        @overload
        def config_map(self, value_or_callback: Optional[ConfigMap], /) -> "ClientId.Builder": ...

        @overload
        def config_map(
            self,
            value_or_callback: Callable[[ConfigMap.Builder], ConfigMap.Builder | ConfigMap],
            /,
        ) -> "ClientId.Builder": ...

        @overload
        def config_map(self, value_or_callback: Never = ...) -> "ConfigMap.BuilderContext": ...

        def config_map(self, value_or_callback=None, /):
            """
            ConfigMap containing data to use for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMap.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMap.builder())
                if isinstance(output, ConfigMap.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map", value)

        @overload
        def secret(self, value_or_callback: Optional[Secret], /) -> "ClientId.Builder": ...

        @overload
        def secret(
            self,
            value_or_callback: Callable[[Secret.Builder], Secret.Builder | Secret],
            /,
        ) -> "ClientId.Builder": ...

        @overload
        def secret(self, value_or_callback: Never = ...) -> "Secret.BuilderContext": ...

        def secret(self, value_or_callback=None, /):
            """
            Secret containing data to use for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = Secret.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Secret.builder())
                if isinstance(output, Secret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret", value)

    class BuilderContext(BuilderContextBase["ClientId.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClientId.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClientId."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClientId", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClientId.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_map: Annotated[Optional[ConfigMap], Field(alias="configMap")] = None
    """
    ConfigMap containing data to use for the targets.
    """
    secret: Optional[Secret] = None
    """
    Secret containing data to use for the targets.
    """


class ClientSecret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClientSecret"]:
            return ClientSecret

        def build(self) -> "ClientSecret":
            return ClientSecret(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ClientSecret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClientSecret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClientSecret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClientSecret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClientSecret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class ProxyConnectHeader(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProxyConnectHeader"]:
            return ProxyConnectHeader

        def build(self) -> "ProxyConnectHeader":
            return ProxyConnectHeader(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ProxyConnectHeader.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProxyConnectHeader.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProxyConnectHeader."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProxyConnectHeader", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProxyConnectHeader.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class Ca(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ca"]:
            return Ca

        def build(self) -> "Ca":
            return Ca(**self._attrs)

        @overload
        def config_map(self, value_or_callback: Optional[ConfigMap], /) -> "Ca.Builder": ...

        @overload
        def config_map(
            self,
            value_or_callback: Callable[[ConfigMap.Builder], ConfigMap.Builder | ConfigMap],
            /,
        ) -> "Ca.Builder": ...

        @overload
        def config_map(self, value_or_callback: Never = ...) -> "ConfigMap.BuilderContext": ...

        def config_map(self, value_or_callback=None, /):
            """
            ConfigMap containing data to use for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMap.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMap.builder())
                if isinstance(output, ConfigMap.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map", value)

        @overload
        def secret(self, value_or_callback: Optional[Secret], /) -> "Ca.Builder": ...

        @overload
        def secret(
            self,
            value_or_callback: Callable[[Secret.Builder], Secret.Builder | Secret],
            /,
        ) -> "Ca.Builder": ...

        @overload
        def secret(self, value_or_callback: Never = ...) -> "Secret.BuilderContext": ...

        def secret(self, value_or_callback=None, /):
            """
            Secret containing data to use for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = Secret.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Secret.builder())
                if isinstance(output, Secret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret", value)

    class BuilderContext(BuilderContextBase["Ca.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ca.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ca."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ca", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ca.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_map: Annotated[Optional[ConfigMap], Field(alias="configMap")] = None
    """
    ConfigMap containing data to use for the targets.
    """
    secret: Optional[Secret] = None
    """
    Secret containing data to use for the targets.
    """


class Cert(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Cert"]:
            return Cert

        def build(self) -> "Cert":
            return Cert(**self._attrs)

        @overload
        def config_map(self, value_or_callback: Optional[ConfigMap], /) -> "Cert.Builder": ...

        @overload
        def config_map(
            self,
            value_or_callback: Callable[[ConfigMap.Builder], ConfigMap.Builder | ConfigMap],
            /,
        ) -> "Cert.Builder": ...

        @overload
        def config_map(self, value_or_callback: Never = ...) -> "ConfigMap.BuilderContext": ...

        def config_map(self, value_or_callback=None, /):
            """
            ConfigMap containing data to use for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMap.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMap.builder())
                if isinstance(output, ConfigMap.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map", value)

        @overload
        def secret(self, value_or_callback: Optional[Secret], /) -> "Cert.Builder": ...

        @overload
        def secret(
            self,
            value_or_callback: Callable[[Secret.Builder], Secret.Builder | Secret],
            /,
        ) -> "Cert.Builder": ...

        @overload
        def secret(self, value_or_callback: Never = ...) -> "Secret.BuilderContext": ...

        def secret(self, value_or_callback=None, /):
            """
            Secret containing data to use for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = Secret.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Secret.builder())
                if isinstance(output, Secret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret", value)

    class BuilderContext(BuilderContextBase["Cert.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Cert.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Cert."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Cert", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Cert.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_map: Annotated[Optional[ConfigMap], Field(alias="configMap")] = None
    """
    ConfigMap containing data to use for the targets.
    """
    secret: Optional[Secret] = None
    """
    Secret containing data to use for the targets.
    """


class KeySecret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["KeySecret"]:
            return KeySecret

        def build(self) -> "KeySecret":
            return KeySecret(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["KeySecret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = KeySecret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for KeySecret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["KeySecret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KeySecret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class TlsConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsConfig"]:
            return TlsConfig

        def build(self) -> "TlsConfig":
            return TlsConfig(**self._attrs)

        @overload
        def ca(self, value_or_callback: Optional[Ca], /) -> "TlsConfig.Builder": ...

        @overload
        def ca(
            self, value_or_callback: Callable[[Ca.Builder], Ca.Builder | Ca], /
        ) -> "TlsConfig.Builder": ...

        @overload
        def ca(self, value_or_callback: Never = ...) -> "Ca.BuilderContext": ...

        def ca(self, value_or_callback=None, /):
            """
            Certificate authority used when verifying server certificates.
            """
            if self._in_context and value_or_callback is None:
                context = Ca.BuilderContext()
                context._parent_builder = self
                context._field_name = "ca"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ca.builder())
                if isinstance(output, Ca.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ca", value)

        @overload
        def cert(self, value_or_callback: Optional[Cert], /) -> "TlsConfig.Builder": ...

        @overload
        def cert(
            self, value_or_callback: Callable[[Cert.Builder], Cert.Builder | Cert], /
        ) -> "TlsConfig.Builder": ...

        @overload
        def cert(self, value_or_callback: Never = ...) -> "Cert.BuilderContext": ...

        def cert(self, value_or_callback=None, /):
            """
            Client certificate to present when doing client-authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Cert.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cert.builder())
                if isinstance(output, Cert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert", value)

        def insecure_skip_verify(self, value: Optional[bool], /) -> Self:
            """
            Disable target certificate validation.
            """
            return self._set("insecure_skip_verify", value)

        @overload
        def key_secret(self, value_or_callback: Optional[KeySecret], /) -> "TlsConfig.Builder": ...

        @overload
        def key_secret(
            self,
            value_or_callback: Callable[[KeySecret.Builder], KeySecret.Builder | KeySecret],
            /,
        ) -> "TlsConfig.Builder": ...

        @overload
        def key_secret(self, value_or_callback: Never = ...) -> "KeySecret.BuilderContext": ...

        def key_secret(self, value_or_callback=None, /):
            """
            Secret containing the client key file for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = KeySecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "key_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KeySecret.builder())
                if isinstance(output, KeySecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("key_secret", value)

        def max_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Maximum acceptable TLS version.

            It requires Prometheus >= v2.41.0.
            """
            return self._set("max_version", value)

        def min_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Minimum acceptable TLS version.

            It requires Prometheus >= v2.35.0.
            """
            return self._set("min_version", value)

        def server_name(self, value: Optional[str], /) -> Self:
            """
            Used to verify the hostname for the targets.
            """
            return self._set("server_name", value)

    class BuilderContext(BuilderContextBase["TlsConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca: Optional[Ca] = None
    """
    Certificate authority used when verifying server certificates.
    """
    cert: Optional[Cert] = None
    """
    Client certificate to present when doing client-authentication.
    """
    insecure_skip_verify: Annotated[Optional[bool], Field(alias="insecureSkipVerify")] = None
    """
    Disable target certificate validation.
    """
    key_secret: Annotated[Optional[KeySecret], Field(alias="keySecret")] = None
    """
    Secret containing the client key file for the targets.
    """
    max_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="maxVersion")
    ] = None
    """
    Maximum acceptable TLS version.

    It requires Prometheus >= v2.41.0.
    """
    min_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="minVersion")
    ] = None
    """
    Minimum acceptable TLS version.

    It requires Prometheus >= v2.35.0.
    """
    server_name: Annotated[Optional[str], Field(alias="serverName")] = None
    """
    Used to verify the hostname for the targets.
    """


class Oauth2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Oauth2"]:
            return Oauth2

        def build(self) -> "Oauth2":
            return Oauth2(**self._attrs)

        @overload
        def client_id(self, value_or_callback: ClientId, /) -> "Oauth2.Builder": ...

        @overload
        def client_id(
            self,
            value_or_callback: Callable[[ClientId.Builder], ClientId.Builder | ClientId],
            /,
        ) -> "Oauth2.Builder": ...

        @overload
        def client_id(self, value_or_callback: Never = ...) -> "ClientId.BuilderContext": ...

        def client_id(self, value_or_callback=None, /):
            """
            `clientId` specifies a key of a Secret or ConfigMap containing the
            OAuth2 client's ID.
            """
            if self._in_context and value_or_callback is None:
                context = ClientId.BuilderContext()
                context._parent_builder = self
                context._field_name = "client_id"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClientId.builder())
                if isinstance(output, ClientId.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("client_id", value)

        @overload
        def client_secret(self, value_or_callback: ClientSecret, /) -> "Oauth2.Builder": ...

        @overload
        def client_secret(
            self,
            value_or_callback: Callable[
                [ClientSecret.Builder], ClientSecret.Builder | ClientSecret
            ],
            /,
        ) -> "Oauth2.Builder": ...

        @overload
        def client_secret(
            self, value_or_callback: Never = ...
        ) -> "ClientSecret.BuilderContext": ...

        def client_secret(self, value_or_callback=None, /):
            """
            `clientSecret` specifies a key of a Secret containing the OAuth2
            client's secret.
            """
            if self._in_context and value_or_callback is None:
                context = ClientSecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "client_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClientSecret.builder())
                if isinstance(output, ClientSecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("client_secret", value)

        def endpoint_params(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            `endpointParams` configures the HTTP parameters to append to the token
            URL.
            """
            return self._set("endpoint_params", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        def scopes(self, value: Optional[List[str]], /) -> Self:
            """
            `scopes` defines the OAuth2 scopes used for the token request.
            """
            return self._set("scopes", value)

        @overload
        def tls_config(self, value_or_callback: Optional[TlsConfig], /) -> "Oauth2.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[[TlsConfig.Builder], TlsConfig.Builder | TlsConfig],
            /,
        ) -> "Oauth2.Builder": ...

        @overload
        def tls_config(self, value_or_callback: Never = ...) -> "TlsConfig.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration to use when connecting to the OAuth2 server.
            It requires Prometheus >= v2.43.0.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfig.builder())
                if isinstance(output, TlsConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

        def token_url(self, value: str, /) -> Self:
            """
            `tokenURL` configures the URL to fetch the token from.
            """
            return self._set("token_url", value)

    class BuilderContext(BuilderContextBase["Oauth2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Oauth2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Oauth2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Oauth2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Oauth2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    client_id: Annotated[ClientId, Field(alias="clientId")]
    """
    `clientId` specifies a key of a Secret or ConfigMap containing the
    OAuth2 client's ID.
    """
    client_secret: Annotated[ClientSecret, Field(alias="clientSecret")]
    """
    `clientSecret` specifies a key of a Secret containing the OAuth2
    client's secret.
    """
    endpoint_params: Annotated[Optional[Dict[str, str]], Field(alias="endpointParams")] = None
    """
    `endpointParams` configures the HTTP parameters to append to the token
    URL.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    scopes: Optional[List[str]] = None
    """
    `scopes` defines the OAuth2 scopes used for the token request.
    """
    tls_config: Annotated[Optional[TlsConfig], Field(alias="tlsConfig")] = None
    """
    TLS configuration to use when connecting to the OAuth2 server.
    It requires Prometheus >= v2.43.0.
    """
    token_url: Annotated[str, Field(alias="tokenUrl", min_length=1)]
    """
    `tokenURL` configures the URL to fetch the token from.
    """


class HttpConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HttpConfig"]:
            return HttpConfig

        def build(self) -> "HttpConfig":
            return HttpConfig(**self._attrs)

        @overload
        def authorization(
            self, value_or_callback: Optional[Authorization], /
        ) -> "HttpConfig.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [Authorization.Builder], Authorization.Builder | Authorization
            ],
            /,
        ) -> "HttpConfig.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "Authorization.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization header configuration for the client.
            This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
            """
            if self._in_context and value_or_callback is None:
                context = Authorization.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Authorization.builder())
                if isinstance(output, Authorization.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def basic_auth(self, value_or_callback: Optional[BasicAuth], /) -> "HttpConfig.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "HttpConfig.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            BasicAuth for the client.
            This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        @overload
        def bearer_token_secret(
            self, value_or_callback: Optional[BearerTokenSecret], /
        ) -> "HttpConfig.Builder": ...

        @overload
        def bearer_token_secret(
            self,
            value_or_callback: Callable[
                [BearerTokenSecret.Builder],
                BearerTokenSecret.Builder | BearerTokenSecret,
            ],
            /,
        ) -> "HttpConfig.Builder": ...

        @overload
        def bearer_token_secret(
            self, value_or_callback: Never = ...
        ) -> "BearerTokenSecret.BuilderContext": ...

        def bearer_token_secret(self, value_or_callback=None, /):
            """
            The secret's key that contains the bearer token to be used by the client
            for authentication.
            The secret needs to be in the same namespace as the AlertmanagerConfig
            object and accessible by the Prometheus Operator.
            """
            if self._in_context and value_or_callback is None:
                context = BearerTokenSecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "bearer_token_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BearerTokenSecret.builder())
                if isinstance(output, BearerTokenSecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("bearer_token_secret", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
            """
            return self._set("follow_redirects", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        @overload
        def oauth2(self, value_or_callback: Optional[Oauth2], /) -> "HttpConfig.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "HttpConfig.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            OAuth2 client credentials used to fetch a token for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            Optional proxy URL.

            If defined, this field takes precedence over `proxyUrl`.
            """
            return self._set("proxy_url", value)

        def proxy_url_1(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url_1", value)

        @overload
        def tls_config(self, value_or_callback: Optional[TlsConfig], /) -> "HttpConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[[TlsConfig.Builder], TlsConfig.Builder | TlsConfig],
            /,
        ) -> "HttpConfig.Builder": ...

        @overload
        def tls_config(self, value_or_callback: Never = ...) -> "TlsConfig.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration for the client.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfig.builder())
                if isinstance(output, TlsConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["HttpConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HttpConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HttpConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HttpConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HttpConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authorization: Optional[Authorization] = None
    """
    Authorization header configuration for the client.
    This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    BasicAuth for the client.
    This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
    """
    bearer_token_secret: Annotated[
        Optional[BearerTokenSecret], Field(alias="bearerTokenSecret")
    ] = None
    """
    The secret's key that contains the bearer token to be used by the client
    for authentication.
    The secret needs to be in the same namespace as the AlertmanagerConfig
    object and accessible by the Prometheus Operator.
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    oauth2: Optional[Oauth2] = None
    """
    OAuth2 client credentials used to fetch a token for the targets.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyURL")] = None
    """
    Optional proxy URL.

    If defined, this field takes precedence over `proxyUrl`.
    """
    proxy_url_1: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    tls_config: Annotated[Optional[TlsConfig], Field(alias="tlsConfig")] = None
    """
    TLS configuration for the client.
    """


class DiscordConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DiscordConfig"]:
            return DiscordConfig

        def build(self) -> "DiscordConfig":
            return DiscordConfig(**self._attrs)

        @overload
        def api_url(self, value_or_callback: ApiUrl, /) -> "DiscordConfig.Builder": ...

        @overload
        def api_url(
            self,
            value_or_callback: Callable[[ApiUrl.Builder], ApiUrl.Builder | ApiUrl],
            /,
        ) -> "DiscordConfig.Builder": ...

        @overload
        def api_url(self, value_or_callback: Never = ...) -> "ApiUrl.BuilderContext": ...

        def api_url(self, value_or_callback=None, /):
            """
            The secret's key that contains the Discord webhook URL.
            The secret needs to be in the same namespace as the AlertmanagerConfig
            object and accessible by the Prometheus Operator.
            """
            if self._in_context and value_or_callback is None:
                context = ApiUrl.BuilderContext()
                context._parent_builder = self
                context._field_name = "api_url"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ApiUrl.builder())
                if isinstance(output, ApiUrl.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("api_url", value)

        @overload
        def http_config(
            self, value_or_callback: Optional[HttpConfig], /
        ) -> "DiscordConfig.Builder": ...

        @overload
        def http_config(
            self,
            value_or_callback: Callable[[HttpConfig.Builder], HttpConfig.Builder | HttpConfig],
            /,
        ) -> "DiscordConfig.Builder": ...

        @overload
        def http_config(self, value_or_callback: Never = ...) -> "HttpConfig.BuilderContext": ...

        def http_config(self, value_or_callback=None, /):
            """
            HTTP client configuration.
            """
            if self._in_context and value_or_callback is None:
                context = HttpConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpConfig.builder())
                if isinstance(output, HttpConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_config", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            The template of the message's body.
            """
            return self._set("message", value)

        def send_resolved(self, value: Optional[bool], /) -> Self:
            """
            Whether or not to notify about resolved alerts.
            """
            return self._set("send_resolved", value)

        def title(self, value: Optional[str], /) -> Self:
            """
            The template of the message's title.
            """
            return self._set("title", value)

    class BuilderContext(BuilderContextBase["DiscordConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DiscordConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DiscordConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DiscordConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DiscordConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_url: Annotated[ApiUrl, Field(alias="apiURL")]
    """
    The secret's key that contains the Discord webhook URL.
    The secret needs to be in the same namespace as the AlertmanagerConfig
    object and accessible by the Prometheus Operator.
    """
    http_config: Annotated[Optional[HttpConfig], Field(alias="httpConfig")] = None
    """
    HTTP client configuration.
    """
    message: Optional[str] = None
    """
    The template of the message's body.
    """
    send_resolved: Annotated[Optional[bool], Field(alias="sendResolved")] = None
    """
    Whether or not to notify about resolved alerts.
    """
    title: Optional[str] = None
    """
    The template of the message's title.
    """


class AuthPassword(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AuthPassword"]:
            return AuthPassword

        def build(self) -> "AuthPassword":
            return AuthPassword(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["AuthPassword.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AuthPassword.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AuthPassword."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AuthPassword", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AuthPassword.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class AuthSecret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AuthSecret"]:
            return AuthSecret

        def build(self) -> "AuthSecret":
            return AuthSecret(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["AuthSecret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AuthSecret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AuthSecret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AuthSecret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AuthSecret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class Header(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Header"]:
            return Header

        def build(self) -> "Header":
            return Header(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            Key of the tuple.
            """
            return self._set("key", value)

        def value(self, value: str, /) -> Self:
            """
            Value of the tuple.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["Header.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Header.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Header."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Header", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Header.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Annotated[str, Field(min_length=1)]
    """
    Key of the tuple.
    """
    value: str
    """
    Value of the tuple.
    """


class EmailConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["EmailConfig"]:
            return EmailConfig

        def build(self) -> "EmailConfig":
            return EmailConfig(**self._attrs)

        def auth_identity(self, value: Optional[str], /) -> Self:
            """
            The identity to use for authentication.
            """
            return self._set("auth_identity", value)

        @overload
        def auth_password(
            self, value_or_callback: Optional[AuthPassword], /
        ) -> "EmailConfig.Builder": ...

        @overload
        def auth_password(
            self,
            value_or_callback: Callable[
                [AuthPassword.Builder], AuthPassword.Builder | AuthPassword
            ],
            /,
        ) -> "EmailConfig.Builder": ...

        @overload
        def auth_password(
            self, value_or_callback: Never = ...
        ) -> "AuthPassword.BuilderContext": ...

        def auth_password(self, value_or_callback=None, /):
            """
            The secret's key that contains the password to use for authentication.
            The secret needs to be in the same namespace as the AlertmanagerConfig
            object and accessible by the Prometheus Operator.
            """
            if self._in_context and value_or_callback is None:
                context = AuthPassword.BuilderContext()
                context._parent_builder = self
                context._field_name = "auth_password"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthPassword.builder())
                if isinstance(output, AuthPassword.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("auth_password", value)

        @overload
        def auth_secret(
            self, value_or_callback: Optional[AuthSecret], /
        ) -> "EmailConfig.Builder": ...

        @overload
        def auth_secret(
            self,
            value_or_callback: Callable[[AuthSecret.Builder], AuthSecret.Builder | AuthSecret],
            /,
        ) -> "EmailConfig.Builder": ...

        @overload
        def auth_secret(self, value_or_callback: Never = ...) -> "AuthSecret.BuilderContext": ...

        def auth_secret(self, value_or_callback=None, /):
            """
            The secret's key that contains the CRAM-MD5 secret.
            The secret needs to be in the same namespace as the AlertmanagerConfig
            object and accessible by the Prometheus Operator.
            """
            if self._in_context and value_or_callback is None:
                context = AuthSecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "auth_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthSecret.builder())
                if isinstance(output, AuthSecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("auth_secret", value)

        def auth_username(self, value: Optional[str], /) -> Self:
            """
            The username to use for authentication.
            """
            return self._set("auth_username", value)

        def from_(self, value: Optional[str], /) -> Self:
            """
            The sender address.
            """
            return self._set("from_", value)

        @overload
        def headers(self, value_or_callback: List[Header], /) -> "EmailConfig.Builder": ...

        @overload
        def headers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Header, Header.Builder]],
                GenericListBuilder[Header, Header.Builder] | List[Header],
            ],
            /,
        ) -> "EmailConfig.Builder": ...

        @overload
        def headers(self, value_or_callback: Never = ...) -> ListBuilderContext[Header.Builder]: ...

        def headers(self, value_or_callback=None, /):
            """
            Further headers email header key/value pairs. Overrides any headers
            previously set by the notification implementation.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Header.Builder]()
                context._parent_builder = self
                context._field_name = "headers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Header.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("headers", value)

        def hello(self, value: Optional[str], /) -> Self:
            """
            The hostname to identify to the SMTP server.
            """
            return self._set("hello", value)

        def html(self, value: Optional[str], /) -> Self:
            """
            The HTML body of the email notification.
            """
            return self._set("html", value)

        def require_tls(self, value: Optional[bool], /) -> Self:
            """
            The SMTP TLS requirement.
            Note that Go does not support unencrypted connections to remote SMTP endpoints.
            """
            return self._set("require_tls", value)

        def send_resolved(self, value: Optional[bool], /) -> Self:
            """
            Whether or not to notify about resolved alerts.
            """
            return self._set("send_resolved", value)

        def smarthost(self, value: Optional[str], /) -> Self:
            """
            The SMTP host and port through which emails are sent. E.g. example.com:25
            """
            return self._set("smarthost", value)

        def text(self, value: Optional[str], /) -> Self:
            """
            The text body of the email notification.
            """
            return self._set("text", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfig], /
        ) -> "EmailConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[[TlsConfig.Builder], TlsConfig.Builder | TlsConfig],
            /,
        ) -> "EmailConfig.Builder": ...

        @overload
        def tls_config(self, value_or_callback: Never = ...) -> "TlsConfig.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfig.builder())
                if isinstance(output, TlsConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

        def to(self, value: Optional[str], /) -> Self:
            """
            The email address to send notifications to.
            """
            return self._set("to", value)

    class BuilderContext(BuilderContextBase["EmailConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = EmailConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for EmailConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["EmailConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use EmailConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    auth_identity: Annotated[Optional[str], Field(alias="authIdentity")] = None
    """
    The identity to use for authentication.
    """
    auth_password: Annotated[Optional[AuthPassword], Field(alias="authPassword")] = None
    """
    The secret's key that contains the password to use for authentication.
    The secret needs to be in the same namespace as the AlertmanagerConfig
    object and accessible by the Prometheus Operator.
    """
    auth_secret: Annotated[Optional[AuthSecret], Field(alias="authSecret")] = None
    """
    The secret's key that contains the CRAM-MD5 secret.
    The secret needs to be in the same namespace as the AlertmanagerConfig
    object and accessible by the Prometheus Operator.
    """
    auth_username: Annotated[Optional[str], Field(alias="authUsername")] = None
    """
    The username to use for authentication.
    """
    from_: Annotated[Optional[str], Field(alias="from")] = None
    """
    The sender address.
    """
    headers: Optional[List[Header]] = None
    """
    Further headers email header key/value pairs. Overrides any headers
    previously set by the notification implementation.
    """
    hello: Optional[str] = None
    """
    The hostname to identify to the SMTP server.
    """
    html: Optional[str] = None
    """
    The HTML body of the email notification.
    """
    require_tls: Annotated[Optional[bool], Field(alias="requireTLS")] = None
    """
    The SMTP TLS requirement.
    Note that Go does not support unencrypted connections to remote SMTP endpoints.
    """
    send_resolved: Annotated[Optional[bool], Field(alias="sendResolved")] = None
    """
    Whether or not to notify about resolved alerts.
    """
    smarthost: Optional[str] = None
    """
    The SMTP host and port through which emails are sent. E.g. example.com:25
    """
    text: Optional[str] = None
    """
    The text body of the email notification.
    """
    tls_config: Annotated[Optional[TlsConfig], Field(alias="tlsConfig")] = None
    """
    TLS configuration
    """
    to: Optional[str] = None
    """
    The email address to send notifications to.
    """


class WebhookUrl(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WebhookUrl"]:
            return WebhookUrl

        def build(self) -> "WebhookUrl":
            return WebhookUrl(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["WebhookUrl.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WebhookUrl.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WebhookUrl."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WebhookUrl", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WebhookUrl.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class MsteamsConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MsteamsConfig"]:
            return MsteamsConfig

        def build(self) -> "MsteamsConfig":
            return MsteamsConfig(**self._attrs)

        @overload
        def http_config(
            self, value_or_callback: Optional[HttpConfig], /
        ) -> "MsteamsConfig.Builder": ...

        @overload
        def http_config(
            self,
            value_or_callback: Callable[[HttpConfig.Builder], HttpConfig.Builder | HttpConfig],
            /,
        ) -> "MsteamsConfig.Builder": ...

        @overload
        def http_config(self, value_or_callback: Never = ...) -> "HttpConfig.BuilderContext": ...

        def http_config(self, value_or_callback=None, /):
            """
            HTTP client configuration.
            """
            if self._in_context and value_or_callback is None:
                context = HttpConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpConfig.builder())
                if isinstance(output, HttpConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_config", value)

        def send_resolved(self, value: Optional[bool], /) -> Self:
            """
            Whether to notify about resolved alerts.
            """
            return self._set("send_resolved", value)

        def summary(self, value: Optional[str], /) -> Self:
            """
            Message summary template.
            It requires Alertmanager >= 0.27.0.
            """
            return self._set("summary", value)

        def text(self, value: Optional[str], /) -> Self:
            """
            Message body template.
            """
            return self._set("text", value)

        def title(self, value: Optional[str], /) -> Self:
            """
            Message title template.
            """
            return self._set("title", value)

        @overload
        def webhook_url(self, value_or_callback: WebhookUrl, /) -> "MsteamsConfig.Builder": ...

        @overload
        def webhook_url(
            self,
            value_or_callback: Callable[[WebhookUrl.Builder], WebhookUrl.Builder | WebhookUrl],
            /,
        ) -> "MsteamsConfig.Builder": ...

        @overload
        def webhook_url(self, value_or_callback: Never = ...) -> "WebhookUrl.BuilderContext": ...

        def webhook_url(self, value_or_callback=None, /):
            """
            MSTeams webhook URL.
            """
            if self._in_context and value_or_callback is None:
                context = WebhookUrl.BuilderContext()
                context._parent_builder = self
                context._field_name = "webhook_url"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WebhookUrl.builder())
                if isinstance(output, WebhookUrl.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("webhook_url", value)

    class BuilderContext(BuilderContextBase["MsteamsConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MsteamsConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MsteamsConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MsteamsConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MsteamsConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    http_config: Annotated[Optional[HttpConfig], Field(alias="httpConfig")] = None
    """
    HTTP client configuration.
    """
    send_resolved: Annotated[Optional[bool], Field(alias="sendResolved")] = None
    """
    Whether to notify about resolved alerts.
    """
    summary: Optional[str] = None
    """
    Message summary template.
    It requires Alertmanager >= 0.27.0.
    """
    text: Optional[str] = None
    """
    Message body template.
    """
    title: Optional[str] = None
    """
    Message title template.
    """
    webhook_url: Annotated[WebhookUrl, Field(alias="webhookUrl")]
    """
    MSTeams webhook URL.
    """


class ApiKey(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ApiKey"]:
            return ApiKey

        def build(self) -> "ApiKey":
            return ApiKey(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ApiKey.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ApiKey.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ApiKey."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ApiKey", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ApiKey.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class Detail(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Detail"]:
            return Detail

        def build(self) -> "Detail":
            return Detail(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            Key of the tuple.
            """
            return self._set("key", value)

        def value(self, value: str, /) -> Self:
            """
            Value of the tuple.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["Detail.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Detail.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Detail."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Detail", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Detail.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Annotated[str, Field(min_length=1)]
    """
    Key of the tuple.
    """
    value: str
    """
    Value of the tuple.
    """


class Responder(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Responder"]:
            return Responder

        def build(self) -> "Responder":
            return Responder(**self._attrs)

        def id(self, value: Optional[str], /) -> Self:
            """
            ID of the responder.
            """
            return self._set("id", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the responder.
            """
            return self._set("name", value)

        def type(self, value: str, /) -> Self:
            """
            Type of responder.
            """
            return self._set("type", value)

        def username(self, value: Optional[str], /) -> Self:
            """
            Username of the responder.
            """
            return self._set("username", value)

    class BuilderContext(BuilderContextBase["Responder.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Responder.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Responder."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Responder", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Responder.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    id: Optional[str] = None
    """
    ID of the responder.
    """
    name: Optional[str] = None
    """
    Name of the responder.
    """
    type: Annotated[str, Field(min_length=1)]
    """
    Type of responder.
    """
    username: Optional[str] = None
    """
    Username of the responder.
    """


class OpsgenieConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["OpsgenieConfig"]:
            return OpsgenieConfig

        def build(self) -> "OpsgenieConfig":
            return OpsgenieConfig(**self._attrs)

        def actions(self, value: Optional[str], /) -> Self:
            """
            Comma separated list of actions that will be available for the alert.
            """
            return self._set("actions", value)

        @overload
        def api_key(self, value_or_callback: Optional[ApiKey], /) -> "OpsgenieConfig.Builder": ...

        @overload
        def api_key(
            self,
            value_or_callback: Callable[[ApiKey.Builder], ApiKey.Builder | ApiKey],
            /,
        ) -> "OpsgenieConfig.Builder": ...

        @overload
        def api_key(self, value_or_callback: Never = ...) -> "ApiKey.BuilderContext": ...

        def api_key(self, value_or_callback=None, /):
            """
            The secret's key that contains the OpsGenie API key.
            The secret needs to be in the same namespace as the AlertmanagerConfig
            object and accessible by the Prometheus Operator.
            """
            if self._in_context and value_or_callback is None:
                context = ApiKey.BuilderContext()
                context._parent_builder = self
                context._field_name = "api_key"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ApiKey.builder())
                if isinstance(output, ApiKey.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("api_key", value)

        def api_url(self, value: Optional[str], /) -> Self:
            """
            The URL to send OpsGenie API requests to.
            """
            return self._set("api_url", value)

        def description(self, value: Optional[str], /) -> Self:
            """
            Description of the incident.
            """
            return self._set("description", value)

        @overload
        def details(self, value_or_callback: List[Detail], /) -> "OpsgenieConfig.Builder": ...

        @overload
        def details(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Detail, Detail.Builder]],
                GenericListBuilder[Detail, Detail.Builder] | List[Detail],
            ],
            /,
        ) -> "OpsgenieConfig.Builder": ...

        @overload
        def details(self, value_or_callback: Never = ...) -> ListBuilderContext[Detail.Builder]: ...

        def details(self, value_or_callback=None, /):
            """
            A set of arbitrary key/value pairs that provide further detail about the incident.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Detail.Builder]()
                context._parent_builder = self
                context._field_name = "details"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Detail.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("details", value)

        def entity(self, value: Optional[str], /) -> Self:
            """
            Optional field that can be used to specify which domain alert is related to.
            """
            return self._set("entity", value)

        @overload
        def http_config(
            self, value_or_callback: Optional[HttpConfig], /
        ) -> "OpsgenieConfig.Builder": ...

        @overload
        def http_config(
            self,
            value_or_callback: Callable[[HttpConfig.Builder], HttpConfig.Builder | HttpConfig],
            /,
        ) -> "OpsgenieConfig.Builder": ...

        @overload
        def http_config(self, value_or_callback: Never = ...) -> "HttpConfig.BuilderContext": ...

        def http_config(self, value_or_callback=None, /):
            """
            HTTP client configuration.
            """
            if self._in_context and value_or_callback is None:
                context = HttpConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpConfig.builder())
                if isinstance(output, HttpConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_config", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Alert text limited to 130 characters.
            """
            return self._set("message", value)

        def note(self, value: Optional[str], /) -> Self:
            """
            Additional alert note.
            """
            return self._set("note", value)

        def priority(self, value: Optional[str], /) -> Self:
            """
            Priority level of alert. Possible values are P1, P2, P3, P4, and P5.
            """
            return self._set("priority", value)

        @overload
        def responders(self, value_or_callback: List[Responder], /) -> "OpsgenieConfig.Builder": ...

        @overload
        def responders(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Responder, Responder.Builder]],
                GenericListBuilder[Responder, Responder.Builder] | List[Responder],
            ],
            /,
        ) -> "OpsgenieConfig.Builder": ...

        @overload
        def responders(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Responder.Builder]: ...

        def responders(self, value_or_callback=None, /):
            """
            List of responders responsible for notifications.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Responder.Builder]()
                context._parent_builder = self
                context._field_name = "responders"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Responder.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("responders", value)

        def send_resolved(self, value: Optional[bool], /) -> Self:
            """
            Whether or not to notify about resolved alerts.
            """
            return self._set("send_resolved", value)

        def source(self, value: Optional[str], /) -> Self:
            """
            Backlink to the sender of the notification.
            """
            return self._set("source", value)

        def tags(self, value: Optional[str], /) -> Self:
            """
            Comma separated list of tags attached to the notifications.
            """
            return self._set("tags", value)

        def update_alerts(self, value: Optional[bool], /) -> Self:
            """
            Whether to update message and description of the alert in OpsGenie if it already exists
            By default, the alert is never updated in OpsGenie, the new message only appears in activity log.
            """
            return self._set("update_alerts", value)

    class BuilderContext(BuilderContextBase["OpsgenieConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = OpsgenieConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for OpsgenieConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["OpsgenieConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use OpsgenieConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    actions: Optional[str] = None
    """
    Comma separated list of actions that will be available for the alert.
    """
    api_key: Annotated[Optional[ApiKey], Field(alias="apiKey")] = None
    """
    The secret's key that contains the OpsGenie API key.
    The secret needs to be in the same namespace as the AlertmanagerConfig
    object and accessible by the Prometheus Operator.
    """
    api_url: Annotated[Optional[str], Field(alias="apiURL")] = None
    """
    The URL to send OpsGenie API requests to.
    """
    description: Optional[str] = None
    """
    Description of the incident.
    """
    details: Optional[List[Detail]] = None
    """
    A set of arbitrary key/value pairs that provide further detail about the incident.
    """
    entity: Optional[str] = None
    """
    Optional field that can be used to specify which domain alert is related to.
    """
    http_config: Annotated[Optional[HttpConfig], Field(alias="httpConfig")] = None
    """
    HTTP client configuration.
    """
    message: Optional[str] = None
    """
    Alert text limited to 130 characters.
    """
    note: Optional[str] = None
    """
    Additional alert note.
    """
    priority: Optional[str] = None
    """
    Priority level of alert. Possible values are P1, P2, P3, P4, and P5.
    """
    responders: Optional[List[Responder]] = None
    """
    List of responders responsible for notifications.
    """
    send_resolved: Annotated[Optional[bool], Field(alias="sendResolved")] = None
    """
    Whether or not to notify about resolved alerts.
    """
    source: Optional[str] = None
    """
    Backlink to the sender of the notification.
    """
    tags: Optional[str] = None
    """
    Comma separated list of tags attached to the notifications.
    """
    update_alerts: Annotated[Optional[bool], Field(alias="updateAlerts")] = None
    """
    Whether to update message and description of the alert in OpsGenie if it already exists
    By default, the alert is never updated in OpsGenie, the new message only appears in activity log.
    """


class PagerDutyImageConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PagerDutyImageConfig"]:
            return PagerDutyImageConfig

        def build(self) -> "PagerDutyImageConfig":
            return PagerDutyImageConfig(**self._attrs)

        def alt(self, value: Optional[str], /) -> Self:
            """
            Alt is the optional alternative text for the image.
            """
            return self._set("alt", value)

        def href(self, value: Optional[str], /) -> Self:
            """
            Optional URL; makes the image a clickable link.
            """
            return self._set("href", value)

        def src(self, value: Optional[str], /) -> Self:
            """
            Src of the image being attached to the incident
            """
            return self._set("src", value)

    class BuilderContext(BuilderContextBase["PagerDutyImageConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PagerDutyImageConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PagerDutyImageConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PagerDutyImageConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PagerDutyImageConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    alt: Optional[str] = None
    """
    Alt is the optional alternative text for the image.
    """
    href: Optional[str] = None
    """
    Optional URL; makes the image a clickable link.
    """
    src: Optional[str] = None
    """
    Src of the image being attached to the incident
    """


class PagerDutyLinkConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PagerDutyLinkConfig"]:
            return PagerDutyLinkConfig

        def build(self) -> "PagerDutyLinkConfig":
            return PagerDutyLinkConfig(**self._attrs)

        def alt(self, value: Optional[str], /) -> Self:
            """
            Text that describes the purpose of the link, and can be used as the link's text.
            """
            return self._set("alt", value)

        def href(self, value: Optional[str], /) -> Self:
            """
            Href is the URL of the link to be attached
            """
            return self._set("href", value)

    class BuilderContext(BuilderContextBase["PagerDutyLinkConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PagerDutyLinkConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PagerDutyLinkConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PagerDutyLinkConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PagerDutyLinkConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    alt: Optional[str] = None
    """
    Text that describes the purpose of the link, and can be used as the link's text.
    """
    href: Optional[str] = None
    """
    Href is the URL of the link to be attached
    """


class RoutingKey(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RoutingKey"]:
            return RoutingKey

        def build(self) -> "RoutingKey":
            return RoutingKey(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["RoutingKey.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RoutingKey.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RoutingKey."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RoutingKey", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RoutingKey.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class ServiceKey(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceKey"]:
            return ServiceKey

        def build(self) -> "ServiceKey":
            return ServiceKey(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ServiceKey.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceKey.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceKey."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceKey", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceKey.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class PagerdutyConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PagerdutyConfig"]:
            return PagerdutyConfig

        def build(self) -> "PagerdutyConfig":
            return PagerdutyConfig(**self._attrs)

        def class_(self, value: Optional[str], /) -> Self:
            """
            The class/type of the event.
            """
            return self._set("class_", value)

        def client(self, value: Optional[str], /) -> Self:
            """
            Client identification.
            """
            return self._set("client", value)

        def client_url(self, value: Optional[str], /) -> Self:
            """
            Backlink to the sender of notification.
            """
            return self._set("client_url", value)

        def component(self, value: Optional[str], /) -> Self:
            """
            The part or component of the affected system that is broken.
            """
            return self._set("component", value)

        def description(self, value: Optional[str], /) -> Self:
            """
            Description of the incident.
            """
            return self._set("description", value)

        @overload
        def details(self, value_or_callback: List[Detail], /) -> "PagerdutyConfig.Builder": ...

        @overload
        def details(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Detail, Detail.Builder]],
                GenericListBuilder[Detail, Detail.Builder] | List[Detail],
            ],
            /,
        ) -> "PagerdutyConfig.Builder": ...

        @overload
        def details(self, value_or_callback: Never = ...) -> ListBuilderContext[Detail.Builder]: ...

        def details(self, value_or_callback=None, /):
            """
            Arbitrary key/value pairs that provide further detail about the incident.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Detail.Builder]()
                context._parent_builder = self
                context._field_name = "details"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Detail.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("details", value)

        def group(self, value: Optional[str], /) -> Self:
            """
            A cluster or grouping of sources.
            """
            return self._set("group", value)

        @overload
        def http_config(
            self, value_or_callback: Optional[HttpConfig], /
        ) -> "PagerdutyConfig.Builder": ...

        @overload
        def http_config(
            self,
            value_or_callback: Callable[[HttpConfig.Builder], HttpConfig.Builder | HttpConfig],
            /,
        ) -> "PagerdutyConfig.Builder": ...

        @overload
        def http_config(self, value_or_callback: Never = ...) -> "HttpConfig.BuilderContext": ...

        def http_config(self, value_or_callback=None, /):
            """
            HTTP client configuration.
            """
            if self._in_context and value_or_callback is None:
                context = HttpConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpConfig.builder())
                if isinstance(output, HttpConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_config", value)

        @overload
        def pager_duty_image_configs(
            self, value_or_callback: List[PagerDutyImageConfig], /
        ) -> "PagerdutyConfig.Builder": ...

        @overload
        def pager_duty_image_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PagerDutyImageConfig, PagerDutyImageConfig.Builder]],
                GenericListBuilder[PagerDutyImageConfig, PagerDutyImageConfig.Builder]
                | List[PagerDutyImageConfig],
            ],
            /,
        ) -> "PagerdutyConfig.Builder": ...

        @overload
        def pager_duty_image_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PagerDutyImageConfig.Builder]: ...

        def pager_duty_image_configs(self, value_or_callback=None, /):
            """
            A list of image details to attach that provide further detail about an incident.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PagerDutyImageConfig.Builder]()
                context._parent_builder = self
                context._field_name = "pager_duty_image_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PagerDutyImageConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("pager_duty_image_configs", value)

        @overload
        def pager_duty_link_configs(
            self, value_or_callback: List[PagerDutyLinkConfig], /
        ) -> "PagerdutyConfig.Builder": ...

        @overload
        def pager_duty_link_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PagerDutyLinkConfig, PagerDutyLinkConfig.Builder]],
                GenericListBuilder[PagerDutyLinkConfig, PagerDutyLinkConfig.Builder]
                | List[PagerDutyLinkConfig],
            ],
            /,
        ) -> "PagerdutyConfig.Builder": ...

        @overload
        def pager_duty_link_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PagerDutyLinkConfig.Builder]: ...

        def pager_duty_link_configs(self, value_or_callback=None, /):
            """
            A list of link details to attach that provide further detail about an incident.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PagerDutyLinkConfig.Builder]()
                context._parent_builder = self
                context._field_name = "pager_duty_link_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PagerDutyLinkConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("pager_duty_link_configs", value)

        @overload
        def routing_key(
            self, value_or_callback: Optional[RoutingKey], /
        ) -> "PagerdutyConfig.Builder": ...

        @overload
        def routing_key(
            self,
            value_or_callback: Callable[[RoutingKey.Builder], RoutingKey.Builder | RoutingKey],
            /,
        ) -> "PagerdutyConfig.Builder": ...

        @overload
        def routing_key(self, value_or_callback: Never = ...) -> "RoutingKey.BuilderContext": ...

        def routing_key(self, value_or_callback=None, /):
            """
            The secret's key that contains the PagerDuty integration key (when using
            Events API v2). Either this field or `serviceKey` needs to be defined.
            The secret needs to be in the same namespace as the AlertmanagerConfig
            object and accessible by the Prometheus Operator.
            """
            if self._in_context and value_or_callback is None:
                context = RoutingKey.BuilderContext()
                context._parent_builder = self
                context._field_name = "routing_key"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RoutingKey.builder())
                if isinstance(output, RoutingKey.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("routing_key", value)

        def send_resolved(self, value: Optional[bool], /) -> Self:
            """
            Whether or not to notify about resolved alerts.
            """
            return self._set("send_resolved", value)

        @overload
        def service_key(
            self, value_or_callback: Optional[ServiceKey], /
        ) -> "PagerdutyConfig.Builder": ...

        @overload
        def service_key(
            self,
            value_or_callback: Callable[[ServiceKey.Builder], ServiceKey.Builder | ServiceKey],
            /,
        ) -> "PagerdutyConfig.Builder": ...

        @overload
        def service_key(self, value_or_callback: Never = ...) -> "ServiceKey.BuilderContext": ...

        def service_key(self, value_or_callback=None, /):
            """
            The secret's key that contains the PagerDuty service key (when using
            integration type "Prometheus"). Either this field or `routingKey` needs to
            be defined.
            The secret needs to be in the same namespace as the AlertmanagerConfig
            object and accessible by the Prometheus Operator.
            """
            if self._in_context and value_or_callback is None:
                context = ServiceKey.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_key"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceKey.builder())
                if isinstance(output, ServiceKey.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_key", value)

        def severity(self, value: Optional[str], /) -> Self:
            """
            Severity of the incident.
            """
            return self._set("severity", value)

        def source(self, value: Optional[str], /) -> Self:
            """
            Unique location of the affected system.
            """
            return self._set("source", value)

        def url(self, value: Optional[str], /) -> Self:
            """
            The URL to send requests to.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["PagerdutyConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PagerdutyConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PagerdutyConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PagerdutyConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PagerdutyConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    class_: Annotated[Optional[str], Field(alias="class")] = None
    """
    The class/type of the event.
    """
    client: Optional[str] = None
    """
    Client identification.
    """
    client_url: Annotated[Optional[str], Field(alias="clientURL")] = None
    """
    Backlink to the sender of notification.
    """
    component: Optional[str] = None
    """
    The part or component of the affected system that is broken.
    """
    description: Optional[str] = None
    """
    Description of the incident.
    """
    details: Optional[List[Detail]] = None
    """
    Arbitrary key/value pairs that provide further detail about the incident.
    """
    group: Optional[str] = None
    """
    A cluster or grouping of sources.
    """
    http_config: Annotated[Optional[HttpConfig], Field(alias="httpConfig")] = None
    """
    HTTP client configuration.
    """
    pager_duty_image_configs: Annotated[
        Optional[List[PagerDutyImageConfig]], Field(alias="pagerDutyImageConfigs")
    ] = None
    """
    A list of image details to attach that provide further detail about an incident.
    """
    pager_duty_link_configs: Annotated[
        Optional[List[PagerDutyLinkConfig]], Field(alias="pagerDutyLinkConfigs")
    ] = None
    """
    A list of link details to attach that provide further detail about an incident.
    """
    routing_key: Annotated[Optional[RoutingKey], Field(alias="routingKey")] = None
    """
    The secret's key that contains the PagerDuty integration key (when using
    Events API v2). Either this field or `serviceKey` needs to be defined.
    The secret needs to be in the same namespace as the AlertmanagerConfig
    object and accessible by the Prometheus Operator.
    """
    send_resolved: Annotated[Optional[bool], Field(alias="sendResolved")] = None
    """
    Whether or not to notify about resolved alerts.
    """
    service_key: Annotated[Optional[ServiceKey], Field(alias="serviceKey")] = None
    """
    The secret's key that contains the PagerDuty service key (when using
    integration type "Prometheus"). Either this field or `routingKey` needs to
    be defined.
    The secret needs to be in the same namespace as the AlertmanagerConfig
    object and accessible by the Prometheus Operator.
    """
    severity: Optional[str] = None
    """
    Severity of the incident.
    """
    source: Optional[str] = None
    """
    Unique location of the affected system.
    """
    url: Optional[str] = None
    """
    The URL to send requests to.
    """


class Token(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Token"]:
            return Token

        def build(self) -> "Token":
            return Token(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["Token.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Token.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Token."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Token", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Token.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class UserKey(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UserKey"]:
            return UserKey

        def build(self) -> "UserKey":
            return UserKey(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["UserKey.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UserKey.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UserKey."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UserKey", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UserKey.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class PushoverConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PushoverConfig"]:
            return PushoverConfig

        def build(self) -> "PushoverConfig":
            return PushoverConfig(**self._attrs)

        def device(self, value: Optional[str], /) -> Self:
            """
            The name of a device to send the notification to
            """
            return self._set("device", value)

        def expire(self, value: Optional[str], /) -> Self:
            """
            How long your notification will continue to be retried for, unless the user
            acknowledges the notification.
            """
            return self._set("expire", value)

        def html(self, value: Optional[bool], /) -> Self:
            """
            Whether notification message is HTML or plain text.
            """
            return self._set("html", value)

        @overload
        def http_config(
            self, value_or_callback: Optional[HttpConfig], /
        ) -> "PushoverConfig.Builder": ...

        @overload
        def http_config(
            self,
            value_or_callback: Callable[[HttpConfig.Builder], HttpConfig.Builder | HttpConfig],
            /,
        ) -> "PushoverConfig.Builder": ...

        @overload
        def http_config(self, value_or_callback: Never = ...) -> "HttpConfig.BuilderContext": ...

        def http_config(self, value_or_callback=None, /):
            """
            HTTP client configuration.
            """
            if self._in_context and value_or_callback is None:
                context = HttpConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpConfig.builder())
                if isinstance(output, HttpConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_config", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Notification message.
            """
            return self._set("message", value)

        def priority(self, value: Optional[str], /) -> Self:
            """
            Priority, see https://pushover.net/api#priority
            """
            return self._set("priority", value)

        def retry(self, value: Optional[str], /) -> Self:
            """
            How often the Pushover servers will send the same notification to the user.
            Must be at least 30 seconds.
            """
            return self._set("retry", value)

        def send_resolved(self, value: Optional[bool], /) -> Self:
            """
            Whether or not to notify about resolved alerts.
            """
            return self._set("send_resolved", value)

        def sound(self, value: Optional[str], /) -> Self:
            """
            The name of one of the sounds supported by device clients to override the user's default sound choice
            """
            return self._set("sound", value)

        def title(self, value: Optional[str], /) -> Self:
            """
            Notification title.
            """
            return self._set("title", value)

        @overload
        def token(self, value_or_callback: Optional[Token], /) -> "PushoverConfig.Builder": ...

        @overload
        def token(
            self, value_or_callback: Callable[[Token.Builder], Token.Builder | Token], /
        ) -> "PushoverConfig.Builder": ...

        @overload
        def token(self, value_or_callback: Never = ...) -> "Token.BuilderContext": ...

        def token(self, value_or_callback=None, /):
            """
            The secret's key that contains the registered application's API token, see https://pushover.net/apps.
            The secret needs to be in the same namespace as the AlertmanagerConfig
            object and accessible by the Prometheus Operator.
            Either `token` or `tokenFile` is required.
            """
            if self._in_context and value_or_callback is None:
                context = Token.BuilderContext()
                context._parent_builder = self
                context._field_name = "token"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Token.builder())
                if isinstance(output, Token.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("token", value)

        def token_file(self, value: Optional[str], /) -> Self:
            """
            The token file that contains the registered application's API token, see https://pushover.net/apps.
            Either `token` or `tokenFile` is required.
            It requires Alertmanager >= v0.26.0.
            """
            return self._set("token_file", value)

        def ttl(self, value: Optional[str], /) -> Self:
            """
            The time to live definition for the alert notification
            """
            return self._set("ttl", value)

        def url(self, value: Optional[str], /) -> Self:
            """
            A supplementary URL shown alongside the message.
            """
            return self._set("url", value)

        def url_title(self, value: Optional[str], /) -> Self:
            """
            A title for supplementary URL, otherwise just the URL is shown
            """
            return self._set("url_title", value)

        @overload
        def user_key(self, value_or_callback: Optional[UserKey], /) -> "PushoverConfig.Builder": ...

        @overload
        def user_key(
            self,
            value_or_callback: Callable[[UserKey.Builder], UserKey.Builder | UserKey],
            /,
        ) -> "PushoverConfig.Builder": ...

        @overload
        def user_key(self, value_or_callback: Never = ...) -> "UserKey.BuilderContext": ...

        def user_key(self, value_or_callback=None, /):
            """
            The secret's key that contains the recipient user's user key.
            The secret needs to be in the same namespace as the AlertmanagerConfig
            object and accessible by the Prometheus Operator.
            Either `userKey` or `userKeyFile` is required.
            """
            if self._in_context and value_or_callback is None:
                context = UserKey.BuilderContext()
                context._parent_builder = self
                context._field_name = "user_key"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UserKey.builder())
                if isinstance(output, UserKey.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("user_key", value)

        def user_key_file(self, value: Optional[str], /) -> Self:
            """
            The user key file that contains the recipient user's user key.
            Either `userKey` or `userKeyFile` is required.
            It requires Alertmanager >= v0.26.0.
            """
            return self._set("user_key_file", value)

    class BuilderContext(BuilderContextBase["PushoverConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PushoverConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PushoverConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PushoverConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PushoverConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    device: Optional[str] = None
    """
    The name of a device to send the notification to
    """
    expire: Annotated[
        Optional[str],
        Field(
            pattern="^(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?$"
        ),
    ] = None
    """
    How long your notification will continue to be retried for, unless the user
    acknowledges the notification.
    """
    html: Optional[bool] = None
    """
    Whether notification message is HTML or plain text.
    """
    http_config: Annotated[Optional[HttpConfig], Field(alias="httpConfig")] = None
    """
    HTTP client configuration.
    """
    message: Optional[str] = None
    """
    Notification message.
    """
    priority: Optional[str] = None
    """
    Priority, see https://pushover.net/api#priority
    """
    retry: Annotated[
        Optional[str],
        Field(
            pattern="^(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?$"
        ),
    ] = None
    """
    How often the Pushover servers will send the same notification to the user.
    Must be at least 30 seconds.
    """
    send_resolved: Annotated[Optional[bool], Field(alias="sendResolved")] = None
    """
    Whether or not to notify about resolved alerts.
    """
    sound: Optional[str] = None
    """
    The name of one of the sounds supported by device clients to override the user's default sound choice
    """
    title: Optional[str] = None
    """
    Notification title.
    """
    token: Optional[Token] = None
    """
    The secret's key that contains the registered application's API token, see https://pushover.net/apps.
    The secret needs to be in the same namespace as the AlertmanagerConfig
    object and accessible by the Prometheus Operator.
    Either `token` or `tokenFile` is required.
    """
    token_file: Annotated[Optional[str], Field(alias="tokenFile")] = None
    """
    The token file that contains the registered application's API token, see https://pushover.net/apps.
    Either `token` or `tokenFile` is required.
    It requires Alertmanager >= v0.26.0.
    """
    ttl: Annotated[
        Optional[str],
        Field(
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"
        ),
    ] = None
    """
    The time to live definition for the alert notification
    """
    url: Optional[str] = None
    """
    A supplementary URL shown alongside the message.
    """
    url_title: Annotated[Optional[str], Field(alias="urlTitle")] = None
    """
    A title for supplementary URL, otherwise just the URL is shown
    """
    user_key: Annotated[Optional[UserKey], Field(alias="userKey")] = None
    """
    The secret's key that contains the recipient user's user key.
    The secret needs to be in the same namespace as the AlertmanagerConfig
    object and accessible by the Prometheus Operator.
    Either `userKey` or `userKeyFile` is required.
    """
    user_key_file: Annotated[Optional[str], Field(alias="userKeyFile")] = None
    """
    The user key file that contains the recipient user's user key.
    Either `userKey` or `userKeyFile` is required.
    It requires Alertmanager >= v0.26.0.
    """


class Confirm(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Confirm"]:
            return Confirm

        def build(self) -> "Confirm":
            return Confirm(**self._attrs)

        def dismiss_text(self, value: Optional[str], /) -> Self:
            return self._set("dismiss_text", value)

        def ok_text(self, value: Optional[str], /) -> Self:
            return self._set("ok_text", value)

        def text(self, value: str, /) -> Self:
            return self._set("text", value)

        def title(self, value: Optional[str], /) -> Self:
            return self._set("title", value)

    class BuilderContext(BuilderContextBase["Confirm.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Confirm.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Confirm."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Confirm", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Confirm.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    dismiss_text: Annotated[Optional[str], Field(alias="dismissText")] = None
    ok_text: Annotated[Optional[str], Field(alias="okText")] = None
    text: Annotated[str, Field(min_length=1)]
    title: Optional[str] = None


class Action(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Action"]:
            return Action

        def build(self) -> "Action":
            return Action(**self._attrs)

        @overload
        def confirm(self, value_or_callback: Optional[Confirm], /) -> "Action.Builder": ...

        @overload
        def confirm(
            self,
            value_or_callback: Callable[[Confirm.Builder], Confirm.Builder | Confirm],
            /,
        ) -> "Action.Builder": ...

        @overload
        def confirm(self, value_or_callback: Never = ...) -> "Confirm.BuilderContext": ...

        def confirm(self, value_or_callback=None, /):
            """
            SlackConfirmationField protect users from destructive actions or
            particularly distinguished decisions by asking them to confirm their button
            click one more time.
            See https://api.slack.com/docs/interactive-message-field-guide#confirmation_fields
            for more information.
            """
            if self._in_context and value_or_callback is None:
                context = Confirm.BuilderContext()
                context._parent_builder = self
                context._field_name = "confirm"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Confirm.builder())
                if isinstance(output, Confirm.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("confirm", value)

        def name(self, value: Optional[str], /) -> Self:
            return self._set("name", value)

        def style(self, value: Optional[str], /) -> Self:
            return self._set("style", value)

        def text(self, value: str, /) -> Self:
            return self._set("text", value)

        def type(self, value: str, /) -> Self:
            return self._set("type", value)

        def url(self, value: Optional[str], /) -> Self:
            return self._set("url", value)

        def value(self, value: Optional[str], /) -> Self:
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["Action.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Action.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Action."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Action", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Action.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    confirm: Optional[Confirm] = None
    """
    SlackConfirmationField protect users from destructive actions or
    particularly distinguished decisions by asking them to confirm their button
    click one more time.
    See https://api.slack.com/docs/interactive-message-field-guide#confirmation_fields
    for more information.
    """
    name: Optional[str] = None
    style: Optional[str] = None
    text: Annotated[str, Field(min_length=1)]
    type: Annotated[str, Field(min_length=1)]
    url: Optional[str] = None
    value: Optional[str] = None


class FieldModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FieldModel"]:
            return FieldModel

        def build(self) -> "FieldModel":
            return FieldModel(**self._attrs)

        def short(self, value: Optional[bool], /) -> Self:
            return self._set("short", value)

        def title(self, value: str, /) -> Self:
            return self._set("title", value)

        def value(self, value: str, /) -> Self:
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["FieldModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FieldModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FieldModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FieldModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FieldModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    short: Optional[bool] = None
    title: Annotated[str, Field(min_length=1)]
    value: Annotated[str, Field(min_length=1)]


class SlackConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SlackConfig"]:
            return SlackConfig

        def build(self) -> "SlackConfig":
            return SlackConfig(**self._attrs)

        @overload
        def actions(self, value_or_callback: List[Action], /) -> "SlackConfig.Builder": ...

        @overload
        def actions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Action, Action.Builder]],
                GenericListBuilder[Action, Action.Builder] | List[Action],
            ],
            /,
        ) -> "SlackConfig.Builder": ...

        @overload
        def actions(self, value_or_callback: Never = ...) -> ListBuilderContext[Action.Builder]: ...

        def actions(self, value_or_callback=None, /):
            """
            A list of Slack actions that are sent with each notification.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Action.Builder]()
                context._parent_builder = self
                context._field_name = "actions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Action.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("actions", value)

        @overload
        def api_url(self, value_or_callback: Optional[ApiUrl], /) -> "SlackConfig.Builder": ...

        @overload
        def api_url(
            self,
            value_or_callback: Callable[[ApiUrl.Builder], ApiUrl.Builder | ApiUrl],
            /,
        ) -> "SlackConfig.Builder": ...

        @overload
        def api_url(self, value_or_callback: Never = ...) -> "ApiUrl.BuilderContext": ...

        def api_url(self, value_or_callback=None, /):
            """
            The secret's key that contains the Slack webhook URL.
            The secret needs to be in the same namespace as the AlertmanagerConfig
            object and accessible by the Prometheus Operator.
            """
            if self._in_context and value_or_callback is None:
                context = ApiUrl.BuilderContext()
                context._parent_builder = self
                context._field_name = "api_url"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ApiUrl.builder())
                if isinstance(output, ApiUrl.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("api_url", value)

        def callback_id(self, value: Optional[str], /) -> Self:
            return self._set("callback_id", value)

        def channel(self, value: Optional[str], /) -> Self:
            """
            The channel or user to send notifications to.
            """
            return self._set("channel", value)

        def color(self, value: Optional[str], /) -> Self:
            return self._set("color", value)

        def fallback(self, value: Optional[str], /) -> Self:
            return self._set("fallback", value)

        @overload
        def fields(self, value_or_callback: List[FieldModel], /) -> "SlackConfig.Builder": ...

        @overload
        def fields(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[FieldModel, FieldModel.Builder]],
                GenericListBuilder[FieldModel, FieldModel.Builder] | List[FieldModel],
            ],
            /,
        ) -> "SlackConfig.Builder": ...

        @overload
        def fields(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[FieldModel.Builder]: ...

        def fields(self, value_or_callback=None, /):
            """
            A list of Slack fields that are sent with each notification.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[FieldModel.Builder]()
                context._parent_builder = self
                context._field_name = "fields"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FieldModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("fields", value)

        def footer(self, value: Optional[str], /) -> Self:
            return self._set("footer", value)

        @overload
        def http_config(
            self, value_or_callback: Optional[HttpConfig], /
        ) -> "SlackConfig.Builder": ...

        @overload
        def http_config(
            self,
            value_or_callback: Callable[[HttpConfig.Builder], HttpConfig.Builder | HttpConfig],
            /,
        ) -> "SlackConfig.Builder": ...

        @overload
        def http_config(self, value_or_callback: Never = ...) -> "HttpConfig.BuilderContext": ...

        def http_config(self, value_or_callback=None, /):
            """
            HTTP client configuration.
            """
            if self._in_context and value_or_callback is None:
                context = HttpConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpConfig.builder())
                if isinstance(output, HttpConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_config", value)

        def icon_emoji(self, value: Optional[str], /) -> Self:
            return self._set("icon_emoji", value)

        def icon_url(self, value: Optional[str], /) -> Self:
            return self._set("icon_url", value)

        def image_url(self, value: Optional[str], /) -> Self:
            return self._set("image_url", value)

        def link_names(self, value: Optional[bool], /) -> Self:
            return self._set("link_names", value)

        def mrkdwn_in(self, value: Optional[List[str]], /) -> Self:
            return self._set("mrkdwn_in", value)

        def pretext(self, value: Optional[str], /) -> Self:
            return self._set("pretext", value)

        def send_resolved(self, value: Optional[bool], /) -> Self:
            """
            Whether or not to notify about resolved alerts.
            """
            return self._set("send_resolved", value)

        def short_fields(self, value: Optional[bool], /) -> Self:
            return self._set("short_fields", value)

        def text(self, value: Optional[str], /) -> Self:
            return self._set("text", value)

        def thumb_url(self, value: Optional[str], /) -> Self:
            return self._set("thumb_url", value)

        def title(self, value: Optional[str], /) -> Self:
            return self._set("title", value)

        def title_link(self, value: Optional[str], /) -> Self:
            return self._set("title_link", value)

        def username(self, value: Optional[str], /) -> Self:
            return self._set("username", value)

    class BuilderContext(BuilderContextBase["SlackConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SlackConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SlackConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SlackConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SlackConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    actions: Optional[List[Action]] = None
    """
    A list of Slack actions that are sent with each notification.
    """
    api_url: Annotated[Optional[ApiUrl], Field(alias="apiURL")] = None
    """
    The secret's key that contains the Slack webhook URL.
    The secret needs to be in the same namespace as the AlertmanagerConfig
    object and accessible by the Prometheus Operator.
    """
    callback_id: Annotated[Optional[str], Field(alias="callbackId")] = None
    channel: Optional[str] = None
    """
    The channel or user to send notifications to.
    """
    color: Optional[str] = None
    fallback: Optional[str] = None
    fields: Optional[List[FieldModel]] = None
    """
    A list of Slack fields that are sent with each notification.
    """
    footer: Optional[str] = None
    http_config: Annotated[Optional[HttpConfig], Field(alias="httpConfig")] = None
    """
    HTTP client configuration.
    """
    icon_emoji: Annotated[Optional[str], Field(alias="iconEmoji")] = None
    icon_url: Annotated[Optional[str], Field(alias="iconURL")] = None
    image_url: Annotated[Optional[str], Field(alias="imageURL")] = None
    link_names: Annotated[Optional[bool], Field(alias="linkNames")] = None
    mrkdwn_in: Annotated[Optional[List[str]], Field(alias="mrkdwnIn")] = None
    pretext: Optional[str] = None
    send_resolved: Annotated[Optional[bool], Field(alias="sendResolved")] = None
    """
    Whether or not to notify about resolved alerts.
    """
    short_fields: Annotated[Optional[bool], Field(alias="shortFields")] = None
    text: Optional[str] = None
    thumb_url: Annotated[Optional[str], Field(alias="thumbURL")] = None
    title: Optional[str] = None
    title_link: Annotated[Optional[str], Field(alias="titleLink")] = None
    username: Optional[str] = None


class AccessKey(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AccessKey"]:
            return AccessKey

        def build(self) -> "AccessKey":
            return AccessKey(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["AccessKey.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AccessKey.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AccessKey."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AccessKey", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AccessKey.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class SecretKey(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretKey"]:
            return SecretKey

        def build(self) -> "SecretKey":
            return SecretKey(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["SecretKey.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretKey.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretKey."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretKey", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretKey.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class Sigv4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Sigv4"]:
            return Sigv4

        def build(self) -> "Sigv4":
            return Sigv4(**self._attrs)

        @overload
        def access_key(self, value_or_callback: Optional[AccessKey], /) -> "Sigv4.Builder": ...

        @overload
        def access_key(
            self,
            value_or_callback: Callable[[AccessKey.Builder], AccessKey.Builder | AccessKey],
            /,
        ) -> "Sigv4.Builder": ...

        @overload
        def access_key(self, value_or_callback: Never = ...) -> "AccessKey.BuilderContext": ...

        def access_key(self, value_or_callback=None, /):
            """
            AccessKey is the AWS API key. If not specified, the environment variable
            `AWS_ACCESS_KEY_ID` is used.
            """
            if self._in_context and value_or_callback is None:
                context = AccessKey.BuilderContext()
                context._parent_builder = self
                context._field_name = "access_key"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AccessKey.builder())
                if isinstance(output, AccessKey.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("access_key", value)

        def profile(self, value: Optional[str], /) -> Self:
            """
            Profile is the named AWS profile used to authenticate.
            """
            return self._set("profile", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            Region is the AWS region. If blank, the region from the default credentials chain used.
            """
            return self._set("region", value)

        def role_arn(self, value: Optional[str], /) -> Self:
            """
            RoleArn is the named AWS profile used to authenticate.
            """
            return self._set("role_arn", value)

        @overload
        def secret_key(self, value_or_callback: Optional[SecretKey], /) -> "Sigv4.Builder": ...

        @overload
        def secret_key(
            self,
            value_or_callback: Callable[[SecretKey.Builder], SecretKey.Builder | SecretKey],
            /,
        ) -> "Sigv4.Builder": ...

        @overload
        def secret_key(self, value_or_callback: Never = ...) -> "SecretKey.BuilderContext": ...

        def secret_key(self, value_or_callback=None, /):
            """
            SecretKey is the AWS API secret. If not specified, the environment
            variable `AWS_SECRET_ACCESS_KEY` is used.
            """
            if self._in_context and value_or_callback is None:
                context = SecretKey.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_key"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretKey.builder())
                if isinstance(output, SecretKey.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_key", value)

    class BuilderContext(BuilderContextBase["Sigv4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Sigv4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Sigv4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Sigv4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Sigv4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_key: Annotated[Optional[AccessKey], Field(alias="accessKey")] = None
    """
    AccessKey is the AWS API key. If not specified, the environment variable
    `AWS_ACCESS_KEY_ID` is used.
    """
    profile: Optional[str] = None
    """
    Profile is the named AWS profile used to authenticate.
    """
    region: Optional[str] = None
    """
    Region is the AWS region. If blank, the region from the default credentials chain used.
    """
    role_arn: Annotated[Optional[str], Field(alias="roleArn")] = None
    """
    RoleArn is the named AWS profile used to authenticate.
    """
    secret_key: Annotated[Optional[SecretKey], Field(alias="secretKey")] = None
    """
    SecretKey is the AWS API secret. If not specified, the environment
    variable `AWS_SECRET_ACCESS_KEY` is used.
    """


class SnsConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SnsConfig"]:
            return SnsConfig

        def build(self) -> "SnsConfig":
            return SnsConfig(**self._attrs)

        def api_url(self, value: Optional[str], /) -> Self:
            """
            The SNS API URL i.e. https://sns.us-east-2.amazonaws.com.
            If not specified, the SNS API URL from the SNS SDK will be used.
            """
            return self._set("api_url", value)

        def attributes(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            SNS message attributes.
            """
            return self._set("attributes", value)

        @overload
        def http_config(
            self, value_or_callback: Optional[HttpConfig], /
        ) -> "SnsConfig.Builder": ...

        @overload
        def http_config(
            self,
            value_or_callback: Callable[[HttpConfig.Builder], HttpConfig.Builder | HttpConfig],
            /,
        ) -> "SnsConfig.Builder": ...

        @overload
        def http_config(self, value_or_callback: Never = ...) -> "HttpConfig.BuilderContext": ...

        def http_config(self, value_or_callback=None, /):
            """
            HTTP client configuration.
            """
            if self._in_context and value_or_callback is None:
                context = HttpConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpConfig.builder())
                if isinstance(output, HttpConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_config", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            The message content of the SNS notification.
            """
            return self._set("message", value)

        def phone_number(self, value: Optional[str], /) -> Self:
            """
            Phone number if message is delivered via SMS in E.164 format.
            If you don't specify this value, you must specify a value for the TopicARN or TargetARN.
            """
            return self._set("phone_number", value)

        def send_resolved(self, value: Optional[bool], /) -> Self:
            """
            Whether or not to notify about resolved alerts.
            """
            return self._set("send_resolved", value)

        @overload
        def sigv4(self, value_or_callback: Optional[Sigv4], /) -> "SnsConfig.Builder": ...

        @overload
        def sigv4(
            self, value_or_callback: Callable[[Sigv4.Builder], Sigv4.Builder | Sigv4], /
        ) -> "SnsConfig.Builder": ...

        @overload
        def sigv4(self, value_or_callback: Never = ...) -> "Sigv4.BuilderContext": ...

        def sigv4(self, value_or_callback=None, /):
            """
            Configures AWS's Signature Verification 4 signing process to sign requests.
            """
            if self._in_context and value_or_callback is None:
                context = Sigv4.BuilderContext()
                context._parent_builder = self
                context._field_name = "sigv4"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sigv4.builder())
                if isinstance(output, Sigv4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sigv4", value)

        def subject(self, value: Optional[str], /) -> Self:
            """
            Subject line when the message is delivered to email endpoints.
            """
            return self._set("subject", value)

        def target_arn(self, value: Optional[str], /) -> Self:
            """
            The  mobile platform endpoint ARN if message is delivered via mobile notifications.
            If you don't specify this value, you must specify a value for the topic_arn or PhoneNumber.
            """
            return self._set("target_arn", value)

        def topic_arn(self, value: Optional[str], /) -> Self:
            """
            SNS topic ARN, i.e. arn:aws:sns:us-east-2:698519295917:My-Topic
            If you don't specify this value, you must specify a value for the PhoneNumber or TargetARN.
            """
            return self._set("topic_arn", value)

    class BuilderContext(BuilderContextBase["SnsConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SnsConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SnsConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SnsConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SnsConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_url: Annotated[Optional[str], Field(alias="apiURL")] = None
    """
    The SNS API URL i.e. https://sns.us-east-2.amazonaws.com.
    If not specified, the SNS API URL from the SNS SDK will be used.
    """
    attributes: Optional[Dict[str, str]] = None
    """
    SNS message attributes.
    """
    http_config: Annotated[Optional[HttpConfig], Field(alias="httpConfig")] = None
    """
    HTTP client configuration.
    """
    message: Optional[str] = None
    """
    The message content of the SNS notification.
    """
    phone_number: Annotated[Optional[str], Field(alias="phoneNumber")] = None
    """
    Phone number if message is delivered via SMS in E.164 format.
    If you don't specify this value, you must specify a value for the TopicARN or TargetARN.
    """
    send_resolved: Annotated[Optional[bool], Field(alias="sendResolved")] = None
    """
    Whether or not to notify about resolved alerts.
    """
    sigv4: Optional[Sigv4] = None
    """
    Configures AWS's Signature Verification 4 signing process to sign requests.
    """
    subject: Optional[str] = None
    """
    Subject line when the message is delivered to email endpoints.
    """
    target_arn: Annotated[Optional[str], Field(alias="targetARN")] = None
    """
    The  mobile platform endpoint ARN if message is delivered via mobile notifications.
    If you don't specify this value, you must specify a value for the topic_arn or PhoneNumber.
    """
    topic_arn: Annotated[Optional[str], Field(alias="topicARN")] = None
    """
    SNS topic ARN, i.e. arn:aws:sns:us-east-2:698519295917:My-Topic
    If you don't specify this value, you must specify a value for the PhoneNumber or TargetARN.
    """


class BotToken(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BotToken"]:
            return BotToken

        def build(self) -> "BotToken":
            return BotToken(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["BotToken.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BotToken.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BotToken."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BotToken", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BotToken.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class TelegramConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TelegramConfig"]:
            return TelegramConfig

        def build(self) -> "TelegramConfig":
            return TelegramConfig(**self._attrs)

        def api_url(self, value: Optional[str], /) -> Self:
            """
            The Telegram API URL i.e. https://api.telegram.org.
            If not specified, default API URL will be used.
            """
            return self._set("api_url", value)

        @overload
        def bot_token(
            self, value_or_callback: Optional[BotToken], /
        ) -> "TelegramConfig.Builder": ...

        @overload
        def bot_token(
            self,
            value_or_callback: Callable[[BotToken.Builder], BotToken.Builder | BotToken],
            /,
        ) -> "TelegramConfig.Builder": ...

        @overload
        def bot_token(self, value_or_callback: Never = ...) -> "BotToken.BuilderContext": ...

        def bot_token(self, value_or_callback=None, /):
            """
            Telegram bot token. It is mutually exclusive with `botTokenFile`.
            The secret needs to be in the same namespace as the AlertmanagerConfig
            object and accessible by the Prometheus Operator.

            Either `botToken` or `botTokenFile` is required.
            """
            if self._in_context and value_or_callback is None:
                context = BotToken.BuilderContext()
                context._parent_builder = self
                context._field_name = "bot_token"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BotToken.builder())
                if isinstance(output, BotToken.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("bot_token", value)

        def bot_token_file(self, value: Optional[str], /) -> Self:
            """
            File to read the Telegram bot token from. It is mutually exclusive with `botToken`.
            Either `botToken` or `botTokenFile` is required.

            It requires Alertmanager >= v0.26.0.
            """
            return self._set("bot_token_file", value)

        def chat_id(self, value: int, /) -> Self:
            """
            The Telegram chat ID.
            """
            return self._set("chat_id", value)

        def disable_notifications(self, value: Optional[bool], /) -> Self:
            """
            Disable telegram notifications
            """
            return self._set("disable_notifications", value)

        @overload
        def http_config(
            self, value_or_callback: Optional[HttpConfig], /
        ) -> "TelegramConfig.Builder": ...

        @overload
        def http_config(
            self,
            value_or_callback: Callable[[HttpConfig.Builder], HttpConfig.Builder | HttpConfig],
            /,
        ) -> "TelegramConfig.Builder": ...

        @overload
        def http_config(self, value_or_callback: Never = ...) -> "HttpConfig.BuilderContext": ...

        def http_config(self, value_or_callback=None, /):
            """
            HTTP client configuration.
            """
            if self._in_context and value_or_callback is None:
                context = HttpConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpConfig.builder())
                if isinstance(output, HttpConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_config", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message template
            """
            return self._set("message", value)

        def message_thread_id(self, value: Optional[int], /) -> Self:
            """
            The Telegram Group Topic ID.
            It requires Alertmanager >= 0.26.0.
            """
            return self._set("message_thread_id", value)

        def parse_mode(self, value: Optional[Literal["MarkdownV2", "Markdown", "HTML"]], /) -> Self:
            """
            Parse mode for telegram message
            """
            return self._set("parse_mode", value)

        def send_resolved(self, value: Optional[bool], /) -> Self:
            """
            Whether to notify about resolved alerts.
            """
            return self._set("send_resolved", value)

    class BuilderContext(BuilderContextBase["TelegramConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TelegramConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TelegramConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TelegramConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TelegramConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_url: Annotated[Optional[str], Field(alias="apiURL")] = None
    """
    The Telegram API URL i.e. https://api.telegram.org.
    If not specified, default API URL will be used.
    """
    bot_token: Annotated[Optional[BotToken], Field(alias="botToken")] = None
    """
    Telegram bot token. It is mutually exclusive with `botTokenFile`.
    The secret needs to be in the same namespace as the AlertmanagerConfig
    object and accessible by the Prometheus Operator.

    Either `botToken` or `botTokenFile` is required.
    """
    bot_token_file: Annotated[Optional[str], Field(alias="botTokenFile")] = None
    """
    File to read the Telegram bot token from. It is mutually exclusive with `botToken`.
    Either `botToken` or `botTokenFile` is required.

    It requires Alertmanager >= v0.26.0.
    """
    chat_id: Annotated[int, Field(alias="chatID")]
    """
    The Telegram chat ID.
    """
    disable_notifications: Annotated[Optional[bool], Field(alias="disableNotifications")] = None
    """
    Disable telegram notifications
    """
    http_config: Annotated[Optional[HttpConfig], Field(alias="httpConfig")] = None
    """
    HTTP client configuration.
    """
    message: Optional[str] = None
    """
    Message template
    """
    message_thread_id: Annotated[Optional[int], Field(alias="messageThreadID")] = None
    """
    The Telegram Group Topic ID.
    It requires Alertmanager >= 0.26.0.
    """
    parse_mode: Annotated[
        Optional[Literal["MarkdownV2", "Markdown", "HTML"]], Field(alias="parseMode")
    ] = None
    """
    Parse mode for telegram message
    """
    send_resolved: Annotated[Optional[bool], Field(alias="sendResolved")] = None
    """
    Whether to notify about resolved alerts.
    """


class CustomField(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CustomField"]:
            return CustomField

        def build(self) -> "CustomField":
            return CustomField(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            Key of the tuple.
            """
            return self._set("key", value)

        def value(self, value: str, /) -> Self:
            """
            Value of the tuple.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["CustomField.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CustomField.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CustomField."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CustomField", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CustomField.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Annotated[str, Field(min_length=1)]
    """
    Key of the tuple.
    """
    value: str
    """
    Value of the tuple.
    """


class VictoropsConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VictoropsConfig"]:
            return VictoropsConfig

        def build(self) -> "VictoropsConfig":
            return VictoropsConfig(**self._attrs)

        @overload
        def api_key(self, value_or_callback: Optional[ApiKey], /) -> "VictoropsConfig.Builder": ...

        @overload
        def api_key(
            self,
            value_or_callback: Callable[[ApiKey.Builder], ApiKey.Builder | ApiKey],
            /,
        ) -> "VictoropsConfig.Builder": ...

        @overload
        def api_key(self, value_or_callback: Never = ...) -> "ApiKey.BuilderContext": ...

        def api_key(self, value_or_callback=None, /):
            """
            The secret's key that contains the API key to use when talking to the VictorOps API.
            The secret needs to be in the same namespace as the AlertmanagerConfig
            object and accessible by the Prometheus Operator.
            """
            if self._in_context and value_or_callback is None:
                context = ApiKey.BuilderContext()
                context._parent_builder = self
                context._field_name = "api_key"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ApiKey.builder())
                if isinstance(output, ApiKey.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("api_key", value)

        def api_url(self, value: Optional[str], /) -> Self:
            """
            The VictorOps API URL.
            """
            return self._set("api_url", value)

        @overload
        def custom_fields(
            self, value_or_callback: List[CustomField], /
        ) -> "VictoropsConfig.Builder": ...

        @overload
        def custom_fields(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[CustomField, CustomField.Builder]],
                GenericListBuilder[CustomField, CustomField.Builder] | List[CustomField],
            ],
            /,
        ) -> "VictoropsConfig.Builder": ...

        @overload
        def custom_fields(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[CustomField.Builder]: ...

        def custom_fields(self, value_or_callback=None, /):
            """
            Additional custom fields for notification.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[CustomField.Builder]()
                context._parent_builder = self
                context._field_name = "custom_fields"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CustomField.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("custom_fields", value)

        def entity_display_name(self, value: Optional[str], /) -> Self:
            """
            Contains summary of the alerted problem.
            """
            return self._set("entity_display_name", value)

        @overload
        def http_config(
            self, value_or_callback: Optional[HttpConfig], /
        ) -> "VictoropsConfig.Builder": ...

        @overload
        def http_config(
            self,
            value_or_callback: Callable[[HttpConfig.Builder], HttpConfig.Builder | HttpConfig],
            /,
        ) -> "VictoropsConfig.Builder": ...

        @overload
        def http_config(self, value_or_callback: Never = ...) -> "HttpConfig.BuilderContext": ...

        def http_config(self, value_or_callback=None, /):
            """
            The HTTP client's configuration.
            """
            if self._in_context and value_or_callback is None:
                context = HttpConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpConfig.builder())
                if isinstance(output, HttpConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_config", value)

        def message_type(self, value: Optional[str], /) -> Self:
            """
            Describes the behavior of the alert (CRITICAL, WARNING, INFO).
            """
            return self._set("message_type", value)

        def monitoring_tool(self, value: Optional[str], /) -> Self:
            """
            The monitoring tool the state message is from.
            """
            return self._set("monitoring_tool", value)

        def routing_key(self, value: Optional[str], /) -> Self:
            """
            A key used to map the alert to a team.
            """
            return self._set("routing_key", value)

        def send_resolved(self, value: Optional[bool], /) -> Self:
            """
            Whether or not to notify about resolved alerts.
            """
            return self._set("send_resolved", value)

        def state_message(self, value: Optional[str], /) -> Self:
            """
            Contains long explanation of the alerted problem.
            """
            return self._set("state_message", value)

    class BuilderContext(BuilderContextBase["VictoropsConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VictoropsConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VictoropsConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VictoropsConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VictoropsConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_key: Annotated[Optional[ApiKey], Field(alias="apiKey")] = None
    """
    The secret's key that contains the API key to use when talking to the VictorOps API.
    The secret needs to be in the same namespace as the AlertmanagerConfig
    object and accessible by the Prometheus Operator.
    """
    api_url: Annotated[Optional[str], Field(alias="apiUrl")] = None
    """
    The VictorOps API URL.
    """
    custom_fields: Annotated[Optional[List[CustomField]], Field(alias="customFields")] = None
    """
    Additional custom fields for notification.
    """
    entity_display_name: Annotated[Optional[str], Field(alias="entityDisplayName")] = None
    """
    Contains summary of the alerted problem.
    """
    http_config: Annotated[Optional[HttpConfig], Field(alias="httpConfig")] = None
    """
    The HTTP client's configuration.
    """
    message_type: Annotated[Optional[str], Field(alias="messageType")] = None
    """
    Describes the behavior of the alert (CRITICAL, WARNING, INFO).
    """
    monitoring_tool: Annotated[Optional[str], Field(alias="monitoringTool")] = None
    """
    The monitoring tool the state message is from.
    """
    routing_key: Annotated[Optional[str], Field(alias="routingKey")] = None
    """
    A key used to map the alert to a team.
    """
    send_resolved: Annotated[Optional[bool], Field(alias="sendResolved")] = None
    """
    Whether or not to notify about resolved alerts.
    """
    state_message: Annotated[Optional[str], Field(alias="stateMessage")] = None
    """
    Contains long explanation of the alerted problem.
    """


class WebexConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WebexConfig"]:
            return WebexConfig

        def build(self) -> "WebexConfig":
            return WebexConfig(**self._attrs)

        def api_url(self, value: Optional[str], /) -> Self:
            """
            The Webex Teams API URL i.e. https://webexapis.com/v1/messages
            Provide if different from the default API URL.
            """
            return self._set("api_url", value)

        @overload
        def http_config(
            self, value_or_callback: Optional[HttpConfig], /
        ) -> "WebexConfig.Builder": ...

        @overload
        def http_config(
            self,
            value_or_callback: Callable[[HttpConfig.Builder], HttpConfig.Builder | HttpConfig],
            /,
        ) -> "WebexConfig.Builder": ...

        @overload
        def http_config(self, value_or_callback: Never = ...) -> "HttpConfig.BuilderContext": ...

        def http_config(self, value_or_callback=None, /):
            """
            The HTTP client's configuration.
            You must supply the bot token via the `httpConfig.authorization` field.
            """
            if self._in_context and value_or_callback is None:
                context = HttpConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpConfig.builder())
                if isinstance(output, HttpConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_config", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message template
            """
            return self._set("message", value)

        def room_id(self, value: str, /) -> Self:
            """
            ID of the Webex Teams room where to send the messages.
            """
            return self._set("room_id", value)

        def send_resolved(self, value: Optional[bool], /) -> Self:
            """
            Whether to notify about resolved alerts.
            """
            return self._set("send_resolved", value)

    class BuilderContext(BuilderContextBase["WebexConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WebexConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WebexConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WebexConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WebexConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_url: Annotated[Optional[str], Field(alias="apiURL", pattern="^https?://.+$")] = None
    """
    The Webex Teams API URL i.e. https://webexapis.com/v1/messages
    Provide if different from the default API URL.
    """
    http_config: Annotated[Optional[HttpConfig], Field(alias="httpConfig")] = None
    """
    The HTTP client's configuration.
    You must supply the bot token via the `httpConfig.authorization` field.
    """
    message: Optional[str] = None
    """
    Message template
    """
    room_id: Annotated[str, Field(alias="roomID", min_length=1)]
    """
    ID of the Webex Teams room where to send the messages.
    """
    send_resolved: Annotated[Optional[bool], Field(alias="sendResolved")] = None
    """
    Whether to notify about resolved alerts.
    """


class UrlSecret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UrlSecret"]:
            return UrlSecret

        def build(self) -> "UrlSecret":
            return UrlSecret(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["UrlSecret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UrlSecret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UrlSecret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UrlSecret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UrlSecret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class WebhookConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WebhookConfig"]:
            return WebhookConfig

        def build(self) -> "WebhookConfig":
            return WebhookConfig(**self._attrs)

        @overload
        def http_config(
            self, value_or_callback: Optional[HttpConfig], /
        ) -> "WebhookConfig.Builder": ...

        @overload
        def http_config(
            self,
            value_or_callback: Callable[[HttpConfig.Builder], HttpConfig.Builder | HttpConfig],
            /,
        ) -> "WebhookConfig.Builder": ...

        @overload
        def http_config(self, value_or_callback: Never = ...) -> "HttpConfig.BuilderContext": ...

        def http_config(self, value_or_callback=None, /):
            """
            HTTP client configuration.
            """
            if self._in_context and value_or_callback is None:
                context = HttpConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpConfig.builder())
                if isinstance(output, HttpConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_config", value)

        def max_alerts(self, value: Optional[int], /) -> Self:
            """
            Maximum number of alerts to be sent per webhook message. When 0, all alerts are included.
            """
            return self._set("max_alerts", value)

        def send_resolved(self, value: Optional[bool], /) -> Self:
            """
            Whether or not to notify about resolved alerts.
            """
            return self._set("send_resolved", value)

        def url(self, value: Optional[str], /) -> Self:
            """
            The URL to send HTTP POST requests to. `urlSecret` takes precedence over
            `url`. One of `urlSecret` and `url` should be defined.
            """
            return self._set("url", value)

        @overload
        def url_secret(
            self, value_or_callback: Optional[UrlSecret], /
        ) -> "WebhookConfig.Builder": ...

        @overload
        def url_secret(
            self,
            value_or_callback: Callable[[UrlSecret.Builder], UrlSecret.Builder | UrlSecret],
            /,
        ) -> "WebhookConfig.Builder": ...

        @overload
        def url_secret(self, value_or_callback: Never = ...) -> "UrlSecret.BuilderContext": ...

        def url_secret(self, value_or_callback=None, /):
            """
            The secret's key that contains the webhook URL to send HTTP requests to.
            `urlSecret` takes precedence over `url`. One of `urlSecret` and `url`
            should be defined.
            The secret needs to be in the same namespace as the AlertmanagerConfig
            object and accessible by the Prometheus Operator.
            """
            if self._in_context and value_or_callback is None:
                context = UrlSecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "url_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UrlSecret.builder())
                if isinstance(output, UrlSecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("url_secret", value)

    class BuilderContext(BuilderContextBase["WebhookConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WebhookConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WebhookConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WebhookConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WebhookConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    http_config: Annotated[Optional[HttpConfig], Field(alias="httpConfig")] = None
    """
    HTTP client configuration.
    """
    max_alerts: Annotated[Optional[int], Field(alias="maxAlerts", ge=0)] = None
    """
    Maximum number of alerts to be sent per webhook message. When 0, all alerts are included.
    """
    send_resolved: Annotated[Optional[bool], Field(alias="sendResolved")] = None
    """
    Whether or not to notify about resolved alerts.
    """
    url: Optional[str] = None
    """
    The URL to send HTTP POST requests to. `urlSecret` takes precedence over
    `url`. One of `urlSecret` and `url` should be defined.
    """
    url_secret: Annotated[Optional[UrlSecret], Field(alias="urlSecret")] = None
    """
    The secret's key that contains the webhook URL to send HTTP requests to.
    `urlSecret` takes precedence over `url`. One of `urlSecret` and `url`
    should be defined.
    The secret needs to be in the same namespace as the AlertmanagerConfig
    object and accessible by the Prometheus Operator.
    """


class ApiSecret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ApiSecret"]:
            return ApiSecret

        def build(self) -> "ApiSecret":
            return ApiSecret(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ApiSecret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ApiSecret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ApiSecret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ApiSecret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ApiSecret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class WechatConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WechatConfig"]:
            return WechatConfig

        def build(self) -> "WechatConfig":
            return WechatConfig(**self._attrs)

        def agent_id(self, value: Optional[str], /) -> Self:
            return self._set("agent_id", value)

        @overload
        def api_secret(
            self, value_or_callback: Optional[ApiSecret], /
        ) -> "WechatConfig.Builder": ...

        @overload
        def api_secret(
            self,
            value_or_callback: Callable[[ApiSecret.Builder], ApiSecret.Builder | ApiSecret],
            /,
        ) -> "WechatConfig.Builder": ...

        @overload
        def api_secret(self, value_or_callback: Never = ...) -> "ApiSecret.BuilderContext": ...

        def api_secret(self, value_or_callback=None, /):
            """
            The secret's key that contains the WeChat API key.
            The secret needs to be in the same namespace as the AlertmanagerConfig
            object and accessible by the Prometheus Operator.
            """
            if self._in_context and value_or_callback is None:
                context = ApiSecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "api_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ApiSecret.builder())
                if isinstance(output, ApiSecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("api_secret", value)

        def api_url(self, value: Optional[str], /) -> Self:
            """
            The WeChat API URL.
            """
            return self._set("api_url", value)

        def corp_id(self, value: Optional[str], /) -> Self:
            """
            The corp id for authentication.
            """
            return self._set("corp_id", value)

        @overload
        def http_config(
            self, value_or_callback: Optional[HttpConfig], /
        ) -> "WechatConfig.Builder": ...

        @overload
        def http_config(
            self,
            value_or_callback: Callable[[HttpConfig.Builder], HttpConfig.Builder | HttpConfig],
            /,
        ) -> "WechatConfig.Builder": ...

        @overload
        def http_config(self, value_or_callback: Never = ...) -> "HttpConfig.BuilderContext": ...

        def http_config(self, value_or_callback=None, /):
            """
            HTTP client configuration.
            """
            if self._in_context and value_or_callback is None:
                context = HttpConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpConfig.builder())
                if isinstance(output, HttpConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_config", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            API request data as defined by the WeChat API.
            """
            return self._set("message", value)

        def message_type(self, value: Optional[str], /) -> Self:
            return self._set("message_type", value)

        def send_resolved(self, value: Optional[bool], /) -> Self:
            """
            Whether or not to notify about resolved alerts.
            """
            return self._set("send_resolved", value)

        def to_party(self, value: Optional[str], /) -> Self:
            return self._set("to_party", value)

        def to_tag(self, value: Optional[str], /) -> Self:
            return self._set("to_tag", value)

        def to_user(self, value: Optional[str], /) -> Self:
            return self._set("to_user", value)

    class BuilderContext(BuilderContextBase["WechatConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WechatConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WechatConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WechatConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WechatConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    agent_id: Annotated[Optional[str], Field(alias="agentID")] = None
    api_secret: Annotated[Optional[ApiSecret], Field(alias="apiSecret")] = None
    """
    The secret's key that contains the WeChat API key.
    The secret needs to be in the same namespace as the AlertmanagerConfig
    object and accessible by the Prometheus Operator.
    """
    api_url: Annotated[Optional[str], Field(alias="apiURL")] = None
    """
    The WeChat API URL.
    """
    corp_id: Annotated[Optional[str], Field(alias="corpID")] = None
    """
    The corp id for authentication.
    """
    http_config: Annotated[Optional[HttpConfig], Field(alias="httpConfig")] = None
    """
    HTTP client configuration.
    """
    message: Optional[str] = None
    """
    API request data as defined by the WeChat API.
    """
    message_type: Annotated[Optional[str], Field(alias="messageType")] = None
    send_resolved: Annotated[Optional[bool], Field(alias="sendResolved")] = None
    """
    Whether or not to notify about resolved alerts.
    """
    to_party: Annotated[Optional[str], Field(alias="toParty")] = None
    to_tag: Annotated[Optional[str], Field(alias="toTag")] = None
    to_user: Annotated[Optional[str], Field(alias="toUser")] = None


class Receiver(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Receiver"]:
            return Receiver

        def build(self) -> "Receiver":
            return Receiver(**self._attrs)

        @overload
        def discord_configs(
            self, value_or_callback: List[DiscordConfig], /
        ) -> "Receiver.Builder": ...

        @overload
        def discord_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[DiscordConfig, DiscordConfig.Builder]],
                GenericListBuilder[DiscordConfig, DiscordConfig.Builder] | List[DiscordConfig],
            ],
            /,
        ) -> "Receiver.Builder": ...

        @overload
        def discord_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[DiscordConfig.Builder]: ...

        def discord_configs(self, value_or_callback=None, /):
            """
            List of Discord configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[DiscordConfig.Builder]()
                context._parent_builder = self
                context._field_name = "discord_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DiscordConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("discord_configs", value)

        @overload
        def email_configs(self, value_or_callback: List[EmailConfig], /) -> "Receiver.Builder": ...

        @overload
        def email_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[EmailConfig, EmailConfig.Builder]],
                GenericListBuilder[EmailConfig, EmailConfig.Builder] | List[EmailConfig],
            ],
            /,
        ) -> "Receiver.Builder": ...

        @overload
        def email_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[EmailConfig.Builder]: ...

        def email_configs(self, value_or_callback=None, /):
            """
            List of Email configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[EmailConfig.Builder]()
                context._parent_builder = self
                context._field_name = "email_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(EmailConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("email_configs", value)

        @overload
        def msteams_configs(
            self, value_or_callback: List[MsteamsConfig], /
        ) -> "Receiver.Builder": ...

        @overload
        def msteams_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MsteamsConfig, MsteamsConfig.Builder]],
                GenericListBuilder[MsteamsConfig, MsteamsConfig.Builder] | List[MsteamsConfig],
            ],
            /,
        ) -> "Receiver.Builder": ...

        @overload
        def msteams_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MsteamsConfig.Builder]: ...

        def msteams_configs(self, value_or_callback=None, /):
            """
            List of MSTeams configurations.
            It requires Alertmanager >= 0.26.0.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MsteamsConfig.Builder]()
                context._parent_builder = self
                context._field_name = "msteams_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MsteamsConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("msteams_configs", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the receiver. Must be unique across all items from the list.
            """
            return self._set("name", value)

        @overload
        def opsgenie_configs(
            self, value_or_callback: List[OpsgenieConfig], /
        ) -> "Receiver.Builder": ...

        @overload
        def opsgenie_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[OpsgenieConfig, OpsgenieConfig.Builder]],
                GenericListBuilder[OpsgenieConfig, OpsgenieConfig.Builder] | List[OpsgenieConfig],
            ],
            /,
        ) -> "Receiver.Builder": ...

        @overload
        def opsgenie_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[OpsgenieConfig.Builder]: ...

        def opsgenie_configs(self, value_or_callback=None, /):
            """
            List of OpsGenie configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[OpsgenieConfig.Builder]()
                context._parent_builder = self
                context._field_name = "opsgenie_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OpsgenieConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("opsgenie_configs", value)

        @overload
        def pagerduty_configs(
            self, value_or_callback: List[PagerdutyConfig], /
        ) -> "Receiver.Builder": ...

        @overload
        def pagerduty_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PagerdutyConfig, PagerdutyConfig.Builder]],
                GenericListBuilder[PagerdutyConfig, PagerdutyConfig.Builder]
                | List[PagerdutyConfig],
            ],
            /,
        ) -> "Receiver.Builder": ...

        @overload
        def pagerduty_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PagerdutyConfig.Builder]: ...

        def pagerduty_configs(self, value_or_callback=None, /):
            """
            List of PagerDuty configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PagerdutyConfig.Builder]()
                context._parent_builder = self
                context._field_name = "pagerduty_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PagerdutyConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("pagerduty_configs", value)

        @overload
        def pushover_configs(
            self, value_or_callback: List[PushoverConfig], /
        ) -> "Receiver.Builder": ...

        @overload
        def pushover_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PushoverConfig, PushoverConfig.Builder]],
                GenericListBuilder[PushoverConfig, PushoverConfig.Builder] | List[PushoverConfig],
            ],
            /,
        ) -> "Receiver.Builder": ...

        @overload
        def pushover_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PushoverConfig.Builder]: ...

        def pushover_configs(self, value_or_callback=None, /):
            """
            List of Pushover configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PushoverConfig.Builder]()
                context._parent_builder = self
                context._field_name = "pushover_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PushoverConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("pushover_configs", value)

        @overload
        def slack_configs(self, value_or_callback: List[SlackConfig], /) -> "Receiver.Builder": ...

        @overload
        def slack_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[SlackConfig, SlackConfig.Builder]],
                GenericListBuilder[SlackConfig, SlackConfig.Builder] | List[SlackConfig],
            ],
            /,
        ) -> "Receiver.Builder": ...

        @overload
        def slack_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[SlackConfig.Builder]: ...

        def slack_configs(self, value_or_callback=None, /):
            """
            List of Slack configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[SlackConfig.Builder]()
                context._parent_builder = self
                context._field_name = "slack_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SlackConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("slack_configs", value)

        @overload
        def sns_configs(self, value_or_callback: List[SnsConfig], /) -> "Receiver.Builder": ...

        @overload
        def sns_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[SnsConfig, SnsConfig.Builder]],
                GenericListBuilder[SnsConfig, SnsConfig.Builder] | List[SnsConfig],
            ],
            /,
        ) -> "Receiver.Builder": ...

        @overload
        def sns_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[SnsConfig.Builder]: ...

        def sns_configs(self, value_or_callback=None, /):
            """
            List of SNS configurations
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[SnsConfig.Builder]()
                context._parent_builder = self
                context._field_name = "sns_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SnsConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("sns_configs", value)

        @overload
        def telegram_configs(
            self, value_or_callback: List[TelegramConfig], /
        ) -> "Receiver.Builder": ...

        @overload
        def telegram_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[TelegramConfig, TelegramConfig.Builder]],
                GenericListBuilder[TelegramConfig, TelegramConfig.Builder] | List[TelegramConfig],
            ],
            /,
        ) -> "Receiver.Builder": ...

        @overload
        def telegram_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[TelegramConfig.Builder]: ...

        def telegram_configs(self, value_or_callback=None, /):
            """
            List of Telegram configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[TelegramConfig.Builder]()
                context._parent_builder = self
                context._field_name = "telegram_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TelegramConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("telegram_configs", value)

        @overload
        def victorops_configs(
            self, value_or_callback: List[VictoropsConfig], /
        ) -> "Receiver.Builder": ...

        @overload
        def victorops_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[VictoropsConfig, VictoropsConfig.Builder]],
                GenericListBuilder[VictoropsConfig, VictoropsConfig.Builder]
                | List[VictoropsConfig],
            ],
            /,
        ) -> "Receiver.Builder": ...

        @overload
        def victorops_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[VictoropsConfig.Builder]: ...

        def victorops_configs(self, value_or_callback=None, /):
            """
            List of VictorOps configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[VictoropsConfig.Builder]()
                context._parent_builder = self
                context._field_name = "victorops_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VictoropsConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("victorops_configs", value)

        @overload
        def webex_configs(self, value_or_callback: List[WebexConfig], /) -> "Receiver.Builder": ...

        @overload
        def webex_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[WebexConfig, WebexConfig.Builder]],
                GenericListBuilder[WebexConfig, WebexConfig.Builder] | List[WebexConfig],
            ],
            /,
        ) -> "Receiver.Builder": ...

        @overload
        def webex_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[WebexConfig.Builder]: ...

        def webex_configs(self, value_or_callback=None, /):
            """
            List of Webex configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[WebexConfig.Builder]()
                context._parent_builder = self
                context._field_name = "webex_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WebexConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("webex_configs", value)

        @overload
        def webhook_configs(
            self, value_or_callback: List[WebhookConfig], /
        ) -> "Receiver.Builder": ...

        @overload
        def webhook_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[WebhookConfig, WebhookConfig.Builder]],
                GenericListBuilder[WebhookConfig, WebhookConfig.Builder] | List[WebhookConfig],
            ],
            /,
        ) -> "Receiver.Builder": ...

        @overload
        def webhook_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[WebhookConfig.Builder]: ...

        def webhook_configs(self, value_or_callback=None, /):
            """
            List of webhook configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[WebhookConfig.Builder]()
                context._parent_builder = self
                context._field_name = "webhook_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WebhookConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("webhook_configs", value)

        @overload
        def wechat_configs(
            self, value_or_callback: List[WechatConfig], /
        ) -> "Receiver.Builder": ...

        @overload
        def wechat_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[WechatConfig, WechatConfig.Builder]],
                GenericListBuilder[WechatConfig, WechatConfig.Builder] | List[WechatConfig],
            ],
            /,
        ) -> "Receiver.Builder": ...

        @overload
        def wechat_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[WechatConfig.Builder]: ...

        def wechat_configs(self, value_or_callback=None, /):
            """
            List of WeChat configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[WechatConfig.Builder]()
                context._parent_builder = self
                context._field_name = "wechat_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WechatConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("wechat_configs", value)

    class BuilderContext(BuilderContextBase["Receiver.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Receiver.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Receiver."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Receiver", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Receiver.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    discord_configs: Annotated[Optional[List[DiscordConfig]], Field(alias="discordConfigs")] = None
    """
    List of Discord configurations.
    """
    email_configs: Annotated[Optional[List[EmailConfig]], Field(alias="emailConfigs")] = None
    """
    List of Email configurations.
    """
    msteams_configs: Annotated[Optional[List[MsteamsConfig]], Field(alias="msteamsConfigs")] = None
    """
    List of MSTeams configurations.
    It requires Alertmanager >= 0.26.0.
    """
    name: Annotated[str, Field(min_length=1)]
    """
    Name of the receiver. Must be unique across all items from the list.
    """
    opsgenie_configs: Annotated[Optional[List[OpsgenieConfig]], Field(alias="opsgenieConfigs")] = (
        None
    )
    """
    List of OpsGenie configurations.
    """
    pagerduty_configs: Annotated[
        Optional[List[PagerdutyConfig]], Field(alias="pagerdutyConfigs")
    ] = None
    """
    List of PagerDuty configurations.
    """
    pushover_configs: Annotated[Optional[List[PushoverConfig]], Field(alias="pushoverConfigs")] = (
        None
    )
    """
    List of Pushover configurations.
    """
    slack_configs: Annotated[Optional[List[SlackConfig]], Field(alias="slackConfigs")] = None
    """
    List of Slack configurations.
    """
    sns_configs: Annotated[Optional[List[SnsConfig]], Field(alias="snsConfigs")] = None
    """
    List of SNS configurations
    """
    telegram_configs: Annotated[Optional[List[TelegramConfig]], Field(alias="telegramConfigs")] = (
        None
    )
    """
    List of Telegram configurations.
    """
    victorops_configs: Annotated[
        Optional[List[VictoropsConfig]], Field(alias="victoropsConfigs")
    ] = None
    """
    List of VictorOps configurations.
    """
    webex_configs: Annotated[Optional[List[WebexConfig]], Field(alias="webexConfigs")] = None
    """
    List of Webex configurations.
    """
    webhook_configs: Annotated[Optional[List[WebhookConfig]], Field(alias="webhookConfigs")] = None
    """
    List of webhook configurations.
    """
    wechat_configs: Annotated[Optional[List[WechatConfig]], Field(alias="wechatConfigs")] = None
    """
    List of WeChat configurations.
    """


class Matcher(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Matcher"]:
            return Matcher

        def build(self) -> "Matcher":
            return Matcher(**self._attrs)

        def match_type(self, value: Optional[Literal["!=", "=", "=~", "!~"]], /) -> Self:
            """
            Match operation available with AlertManager >= v0.22.0 and
            takes precedence over Regex (deprecated) if non-empty.
            """
            return self._set("match_type", value)

        def name(self, value: str, /) -> Self:
            """
            Label to match.
            """
            return self._set("name", value)

        def regex(self, value: Optional[bool], /) -> Self:
            """
            Whether to match on equality (false) or regular-expression (true).
            Deprecated: for AlertManager >= v0.22.0, `matchType` should be used instead.
            """
            return self._set("regex", value)

        def value(self, value: Optional[str], /) -> Self:
            """
            Label value to match.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["Matcher.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Matcher.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Matcher."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Matcher", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Matcher.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_type: Annotated[Optional[Literal["!=", "=", "=~", "!~"]], Field(alias="matchType")] = None
    """
    Match operation available with AlertManager >= v0.22.0 and
    takes precedence over Regex (deprecated) if non-empty.
    """
    name: Annotated[str, Field(min_length=1)]
    """
    Label to match.
    """
    regex: Optional[bool] = None
    """
    Whether to match on equality (false) or regular-expression (true).
    Deprecated: for AlertManager >= v0.22.0, `matchType` should be used instead.
    """
    value: Optional[str] = None
    """
    Label value to match.
    """


class Route(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Route"]:
            return Route

        def build(self) -> "Route":
            return Route(**self._attrs)

        def active_time_intervals(self, value: Optional[List[str]], /) -> Self:
            """
            ActiveTimeIntervals is a list of MuteTimeInterval names when this route should be active.
            """
            return self._set("active_time_intervals", value)

        def continue_(self, value: Optional[bool], /) -> Self:
            """
            Boolean indicating whether an alert should continue matching subsequent
            sibling nodes. It will always be overridden to true for the first-level
            route by the Prometheus operator.
            """
            return self._set("continue_", value)

        def group_by(self, value: Optional[List[str]], /) -> Self:
            """
            List of labels to group by.
            Labels must not be repeated (unique list).
            Special label "..." (aggregate by all possible labels), if provided, must be the only element in the list.
            """
            return self._set("group_by", value)

        def group_interval(self, value: Optional[str], /) -> Self:
            """
            How long to wait before sending an updated notification.
            Must match the regular expression`^(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?$`
            Example: "5m"
            """
            return self._set("group_interval", value)

        def group_wait(self, value: Optional[str], /) -> Self:
            """
            How long to wait before sending the initial notification.
            Must match the regular expression`^(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?$`
            Example: "30s"
            """
            return self._set("group_wait", value)

        @overload
        def matchers(self, value_or_callback: List[Matcher], /) -> "Route.Builder": ...

        @overload
        def matchers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Matcher, Matcher.Builder]],
                GenericListBuilder[Matcher, Matcher.Builder] | List[Matcher],
            ],
            /,
        ) -> "Route.Builder": ...

        @overload
        def matchers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Matcher.Builder]: ...

        def matchers(self, value_or_callback=None, /):
            """
            List of matchers that the alert's labels should match. For the first
            level route, the operator removes any existing equality and regexp
            matcher on the `namespace` label and adds a `namespace: <object
            namespace>` matcher.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Matcher.Builder]()
                context._parent_builder = self
                context._field_name = "matchers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Matcher.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("matchers", value)

        def mute_time_intervals(self, value: Optional[List[str]], /) -> Self:
            """
            Note: this comment applies to the field definition above but appears
            below otherwise it gets included in the generated manifest.
            CRD schema doesn't support self-referential types for now (see
            https://github.com/kubernetes/kubernetes/issues/62872). We have to use
            an alternative type to circumvent the limitation. The downside is that
            the Kube API can't validate the data beyond the fact that it is a valid
            JSON representation.
            MuteTimeIntervals is a list of MuteTimeInterval names that will mute this route when matched,
            """
            return self._set("mute_time_intervals", value)

        def receiver(self, value: Optional[str], /) -> Self:
            """
            Name of the receiver for this route. If not empty, it should be listed in
            the `receivers` field.
            """
            return self._set("receiver", value)

        def repeat_interval(self, value: Optional[str], /) -> Self:
            """
            How long to wait before repeating the last notification.
            Must match the regular expression`^(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?$`
            Example: "4h"
            """
            return self._set("repeat_interval", value)

        def routes(self, value: Optional[List[Any]], /) -> Self:
            """
            Child routes.
            """
            return self._set("routes", value)

    class BuilderContext(BuilderContextBase["Route.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Route.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Route."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Route", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Route.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    active_time_intervals: Annotated[Optional[List[str]], Field(alias="activeTimeIntervals")] = None
    """
    ActiveTimeIntervals is a list of MuteTimeInterval names when this route should be active.
    """
    continue_: Annotated[Optional[bool], Field(alias="continue")] = None
    """
    Boolean indicating whether an alert should continue matching subsequent
    sibling nodes. It will always be overridden to true for the first-level
    route by the Prometheus operator.
    """
    group_by: Annotated[Optional[List[str]], Field(alias="groupBy")] = None
    """
    List of labels to group by.
    Labels must not be repeated (unique list).
    Special label "..." (aggregate by all possible labels), if provided, must be the only element in the list.
    """
    group_interval: Annotated[Optional[str], Field(alias="groupInterval")] = None
    """
    How long to wait before sending an updated notification.
    Must match the regular expression`^(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?$`
    Example: "5m"
    """
    group_wait: Annotated[Optional[str], Field(alias="groupWait")] = None
    """
    How long to wait before sending the initial notification.
    Must match the regular expression`^(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?$`
    Example: "30s"
    """
    matchers: Optional[List[Matcher]] = None
    """
    List of matchers that the alert's labels should match. For the first
    level route, the operator removes any existing equality and regexp
    matcher on the `namespace` label and adds a `namespace: <object
    namespace>` matcher.
    """
    mute_time_intervals: Annotated[Optional[List[str]], Field(alias="muteTimeIntervals")] = None
    """
    Note: this comment applies to the field definition above but appears
    below otherwise it gets included in the generated manifest.
    CRD schema doesn't support self-referential types for now (see
    https://github.com/kubernetes/kubernetes/issues/62872). We have to use
    an alternative type to circumvent the limitation. The downside is that
    the Kube API can't validate the data beyond the fact that it is a valid
    JSON representation.
    MuteTimeIntervals is a list of MuteTimeInterval names that will mute this route when matched,
    """
    receiver: Optional[str] = None
    """
    Name of the receiver for this route. If not empty, it should be listed in
    the `receivers` field.
    """
    repeat_interval: Annotated[Optional[str], Field(alias="repeatInterval")] = None
    """
    How long to wait before repeating the last notification.
    Must match the regular expression`^(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?$`
    Example: "4h"
    """
    routes: Optional[List[Any]] = None
    """
    Child routes.
    """


class AlertmanagerConfigSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AlertmanagerConfigSpec"]:
            return AlertmanagerConfigSpec

        def build(self) -> "AlertmanagerConfigSpec":
            return AlertmanagerConfigSpec(**self._attrs)

        @overload
        def inhibit_rules(
            self, value_or_callback: List[InhibitRule], /
        ) -> "AlertmanagerConfigSpec.Builder": ...

        @overload
        def inhibit_rules(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[InhibitRule, InhibitRule.Builder]],
                GenericListBuilder[InhibitRule, InhibitRule.Builder] | List[InhibitRule],
            ],
            /,
        ) -> "AlertmanagerConfigSpec.Builder": ...

        @overload
        def inhibit_rules(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[InhibitRule.Builder]: ...

        def inhibit_rules(self, value_or_callback=None, /):
            """
            List of inhibition rules. The rules will only apply to alerts matching
            the resource's namespace.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[InhibitRule.Builder]()
                context._parent_builder = self
                context._field_name = "inhibit_rules"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InhibitRule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("inhibit_rules", value)

        @overload
        def mute_time_intervals(
            self, value_or_callback: List[MuteTimeInterval], /
        ) -> "AlertmanagerConfigSpec.Builder": ...

        @overload
        def mute_time_intervals(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MuteTimeInterval, MuteTimeInterval.Builder]],
                GenericListBuilder[MuteTimeInterval, MuteTimeInterval.Builder]
                | List[MuteTimeInterval],
            ],
            /,
        ) -> "AlertmanagerConfigSpec.Builder": ...

        @overload
        def mute_time_intervals(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MuteTimeInterval.Builder]: ...

        def mute_time_intervals(self, value_or_callback=None, /):
            """
            List of MuteTimeInterval specifying when the routes should be muted.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MuteTimeInterval.Builder]()
                context._parent_builder = self
                context._field_name = "mute_time_intervals"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MuteTimeInterval.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("mute_time_intervals", value)

        @overload
        def receivers(
            self, value_or_callback: List[Receiver], /
        ) -> "AlertmanagerConfigSpec.Builder": ...

        @overload
        def receivers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Receiver, Receiver.Builder]],
                GenericListBuilder[Receiver, Receiver.Builder] | List[Receiver],
            ],
            /,
        ) -> "AlertmanagerConfigSpec.Builder": ...

        @overload
        def receivers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Receiver.Builder]: ...

        def receivers(self, value_or_callback=None, /):
            """
            List of receivers.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Receiver.Builder]()
                context._parent_builder = self
                context._field_name = "receivers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Receiver.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("receivers", value)

        @overload
        def route(
            self, value_or_callback: Optional[Route], /
        ) -> "AlertmanagerConfigSpec.Builder": ...

        @overload
        def route(
            self, value_or_callback: Callable[[Route.Builder], Route.Builder | Route], /
        ) -> "AlertmanagerConfigSpec.Builder": ...

        @overload
        def route(self, value_or_callback: Never = ...) -> "Route.BuilderContext": ...

        def route(self, value_or_callback=None, /):
            """
            The Alertmanager route definition for alerts matching the resource's
            namespace. If present, it will be added to the generated Alertmanager
            configuration as a first-level route.
            """
            if self._in_context and value_or_callback is None:
                context = Route.BuilderContext()
                context._parent_builder = self
                context._field_name = "route"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Route.builder())
                if isinstance(output, Route.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("route", value)

    class BuilderContext(BuilderContextBase["AlertmanagerConfigSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AlertmanagerConfigSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AlertmanagerConfigSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AlertmanagerConfigSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AlertmanagerConfigSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    inhibit_rules: Annotated[Optional[List[InhibitRule]], Field(alias="inhibitRules")] = None
    """
    List of inhibition rules. The rules will only apply to alerts matching
    the resource's namespace.
    """
    mute_time_intervals: Annotated[
        Optional[List[MuteTimeInterval]], Field(alias="muteTimeIntervals")
    ] = None
    """
    List of MuteTimeInterval specifying when the routes should be muted.
    """
    receivers: Optional[List[Receiver]] = None
    """
    List of receivers.
    """
    route: Optional[Route] = None
    """
    The Alertmanager route definition for alerts matching the resource's
    namespace. If present, it will be added to the generated Alertmanager
    configuration as a first-level route.
    """


class AdditionalArg(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AdditionalArg"]:
            return AdditionalArg

        def build(self) -> "AdditionalArg":
            return AdditionalArg(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the argument, e.g. "scrape.discovery-reload-interval".
            """
            return self._set("name", value)

        def value(self, value: Optional[str], /) -> Self:
            """
            Argument value, e.g. 30s. Can be empty for name-only arguments (e.g. --storage.tsdb.no-lockfile)
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AdditionalArg.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AdditionalArg.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AdditionalArg."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AdditionalArg", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AdditionalArg.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Annotated[str, Field(min_length=1)]
    """
    Name of the argument, e.g. "scrape.discovery-reload-interval".
    """
    value: Optional[str] = None
    """
    Argument value, e.g. 30s. Can be empty for name-only arguments (e.g. --storage.tsdb.no-lockfile)
    """


class AdditionalScrapeConfigs(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AdditionalScrapeConfigs"]:
            return AdditionalScrapeConfigs

        def build(self) -> "AdditionalScrapeConfigs":
            return AdditionalScrapeConfigs(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["AdditionalScrapeConfigs.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AdditionalScrapeConfigs.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AdditionalScrapeConfigs."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AdditionalScrapeConfigs", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AdditionalScrapeConfigs.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class MatchExpression(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchExpression"]:
            return MatchExpression

        def build(self) -> "MatchExpression":
            return MatchExpression(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The label key that the selector applies to.
            """
            return self._set("key", value)

        def operator(self, value: str, /) -> Self:
            """
            Represents a key's relationship to a set of values.
            Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
            """
            return self._set("operator", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            An array of string values. If the operator is In or NotIn,
            the values array must be non-empty. If the operator is Exists or DoesNotExist,
            the values array must be empty. If the operator is Gt or Lt, the values
            array must have a single element, which will be interpreted as an integer.
            This array is replaced during a strategic merge patch.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["MatchExpression.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchExpression.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchExpression."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchExpression", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchExpression.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The label key that the selector applies to.
    """
    operator: str
    """
    Represents a key's relationship to a set of values.
    Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    """
    values: Optional[List[str]] = None
    """
    An array of string values. If the operator is In or NotIn,
    the values array must be non-empty. If the operator is Exists or DoesNotExist,
    the values array must be empty. If the operator is Gt or Lt, the values
    array must have a single element, which will be interpreted as an integer.
    This array is replaced during a strategic merge patch.
    """


class MatchField(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchField"]:
            return MatchField

        def build(self) -> "MatchField":
            return MatchField(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The label key that the selector applies to.
            """
            return self._set("key", value)

        def operator(self, value: str, /) -> Self:
            """
            Represents a key's relationship to a set of values.
            Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
            """
            return self._set("operator", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            An array of string values. If the operator is In or NotIn,
            the values array must be non-empty. If the operator is Exists or DoesNotExist,
            the values array must be empty. If the operator is Gt or Lt, the values
            array must have a single element, which will be interpreted as an integer.
            This array is replaced during a strategic merge patch.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["MatchField.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchField.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchField."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchField", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchField.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The label key that the selector applies to.
    """
    operator: str
    """
    Represents a key's relationship to a set of values.
    Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    """
    values: Optional[List[str]] = None
    """
    An array of string values. If the operator is In or NotIn,
    the values array must be non-empty. If the operator is Exists or DoesNotExist,
    the values array must be empty. If the operator is Gt or Lt, the values
    array must have a single element, which will be interpreted as an integer.
    This array is replaced during a strategic merge patch.
    """


class Preference(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Preference"]:
            return Preference

        def build(self) -> "Preference":
            return Preference(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpression], /
        ) -> "Preference.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpression, MatchExpression.Builder]],
                GenericListBuilder[MatchExpression, MatchExpression.Builder]
                | List[MatchExpression],
            ],
            /,
        ) -> "Preference.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpression.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            A list of node selector requirements by node's labels.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpression.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpression.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        @overload
        def match_fields(self, value_or_callback: List[MatchField], /) -> "Preference.Builder": ...

        @overload
        def match_fields(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchField, MatchField.Builder]],
                GenericListBuilder[MatchField, MatchField.Builder] | List[MatchField],
            ],
            /,
        ) -> "Preference.Builder": ...

        @overload
        def match_fields(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchField.Builder]: ...

        def match_fields(self, value_or_callback=None, /):
            """
            A list of node selector requirements by node's fields.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchField.Builder]()
                context._parent_builder = self
                context._field_name = "match_fields"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchField.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_fields", value)

    class BuilderContext(BuilderContextBase["Preference.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Preference.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Preference."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Preference", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Preference.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpression]], Field(alias="matchExpressions")
    ] = None
    """
    A list of node selector requirements by node's labels.
    """
    match_fields: Annotated[Optional[List[MatchField]], Field(alias="matchFields")] = None
    """
    A list of node selector requirements by node's fields.
    """


class PreferredDuringSchedulingIgnoredDuringExecution(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PreferredDuringSchedulingIgnoredDuringExecution"]:
            return PreferredDuringSchedulingIgnoredDuringExecution

        def build(self) -> "PreferredDuringSchedulingIgnoredDuringExecution":
            return PreferredDuringSchedulingIgnoredDuringExecution(**self._attrs)

        @overload
        def preference(
            self, value_or_callback: Preference, /
        ) -> "PreferredDuringSchedulingIgnoredDuringExecution.Builder": ...

        @overload
        def preference(
            self,
            value_or_callback: Callable[[Preference.Builder], Preference.Builder | Preference],
            /,
        ) -> "PreferredDuringSchedulingIgnoredDuringExecution.Builder": ...

        @overload
        def preference(self, value_or_callback: Never = ...) -> "Preference.BuilderContext": ...

        def preference(self, value_or_callback=None, /):
            """
            A node selector term, associated with the corresponding weight.
            """
            if self._in_context and value_or_callback is None:
                context = Preference.BuilderContext()
                context._parent_builder = self
                context._field_name = "preference"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Preference.builder())
                if isinstance(output, Preference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("preference", value)

        def weight(self, value: int, /) -> Self:
            """
            Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
            """
            return self._set("weight", value)

    class BuilderContext(
        BuilderContextBase["PreferredDuringSchedulingIgnoredDuringExecution.Builder"]
    ):
        def model_post_init(self, __context) -> None:
            self._builder = PreferredDuringSchedulingIgnoredDuringExecution.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PreferredDuringSchedulingIgnoredDuringExecution."""
        return cls.BuilderContext()

    class ListBuilder(
        GenericListBuilder["PreferredDuringSchedulingIgnoredDuringExecution", Builder]
    ):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PreferredDuringSchedulingIgnoredDuringExecution.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    preference: Preference
    """
    A node selector term, associated with the corresponding weight.
    """
    weight: int
    """
    Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
    """


class NodeSelectorTerm(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NodeSelectorTerm"]:
            return NodeSelectorTerm

        def build(self) -> "NodeSelectorTerm":
            return NodeSelectorTerm(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpression], /
        ) -> "NodeSelectorTerm.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpression, MatchExpression.Builder]],
                GenericListBuilder[MatchExpression, MatchExpression.Builder]
                | List[MatchExpression],
            ],
            /,
        ) -> "NodeSelectorTerm.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpression.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            A list of node selector requirements by node's labels.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpression.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpression.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        @overload
        def match_fields(
            self, value_or_callback: List[MatchField], /
        ) -> "NodeSelectorTerm.Builder": ...

        @overload
        def match_fields(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchField, MatchField.Builder]],
                GenericListBuilder[MatchField, MatchField.Builder] | List[MatchField],
            ],
            /,
        ) -> "NodeSelectorTerm.Builder": ...

        @overload
        def match_fields(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchField.Builder]: ...

        def match_fields(self, value_or_callback=None, /):
            """
            A list of node selector requirements by node's fields.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchField.Builder]()
                context._parent_builder = self
                context._field_name = "match_fields"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchField.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_fields", value)

    class BuilderContext(BuilderContextBase["NodeSelectorTerm.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NodeSelectorTerm.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NodeSelectorTerm."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NodeSelectorTerm", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NodeSelectorTerm.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpression]], Field(alias="matchExpressions")
    ] = None
    """
    A list of node selector requirements by node's labels.
    """
    match_fields: Annotated[Optional[List[MatchField]], Field(alias="matchFields")] = None
    """
    A list of node selector requirements by node's fields.
    """


class RequiredDuringSchedulingIgnoredDuringExecution(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RequiredDuringSchedulingIgnoredDuringExecution"]:
            return RequiredDuringSchedulingIgnoredDuringExecution

        def build(self) -> "RequiredDuringSchedulingIgnoredDuringExecution":
            return RequiredDuringSchedulingIgnoredDuringExecution(**self._attrs)

        @overload
        def node_selector_terms(
            self, value_or_callback: List[NodeSelectorTerm], /
        ) -> "RequiredDuringSchedulingIgnoredDuringExecution.Builder": ...

        @overload
        def node_selector_terms(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[NodeSelectorTerm, NodeSelectorTerm.Builder]],
                GenericListBuilder[NodeSelectorTerm, NodeSelectorTerm.Builder]
                | List[NodeSelectorTerm],
            ],
            /,
        ) -> "RequiredDuringSchedulingIgnoredDuringExecution.Builder": ...

        @overload
        def node_selector_terms(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[NodeSelectorTerm.Builder]: ...

        def node_selector_terms(self, value_or_callback=None, /):
            """
            Required. A list of node selector terms. The terms are ORed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[NodeSelectorTerm.Builder]()
                context._parent_builder = self
                context._field_name = "node_selector_terms"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NodeSelectorTerm.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("node_selector_terms", value)

    class BuilderContext(
        BuilderContextBase["RequiredDuringSchedulingIgnoredDuringExecution.Builder"]
    ):
        def model_post_init(self, __context) -> None:
            self._builder = RequiredDuringSchedulingIgnoredDuringExecution.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequiredDuringSchedulingIgnoredDuringExecution."""
        return cls.BuilderContext()

    class ListBuilder(
        GenericListBuilder["RequiredDuringSchedulingIgnoredDuringExecution", Builder]
    ):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RequiredDuringSchedulingIgnoredDuringExecution.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    node_selector_terms: Annotated[List[NodeSelectorTerm], Field(alias="nodeSelectorTerms")]
    """
    Required. A list of node selector terms. The terms are ORed.
    """


class NodeAffinity(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NodeAffinity"]:
            return NodeAffinity

        def build(self) -> "NodeAffinity":
            return NodeAffinity(**self._attrs)

        @overload
        def preferred_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: List[PreferredDuringSchedulingIgnoredDuringExecution],
            /,
        ) -> "NodeAffinity.Builder": ...

        @overload
        def preferred_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        PreferredDuringSchedulingIgnoredDuringExecution,
                        PreferredDuringSchedulingIgnoredDuringExecution.Builder,
                    ]
                ],
                GenericListBuilder[
                    PreferredDuringSchedulingIgnoredDuringExecution,
                    PreferredDuringSchedulingIgnoredDuringExecution.Builder,
                ]
                | List[PreferredDuringSchedulingIgnoredDuringExecution],
            ],
            /,
        ) -> "NodeAffinity.Builder": ...

        @overload
        def preferred_during_scheduling_ignored_during_execution(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PreferredDuringSchedulingIgnoredDuringExecution.Builder]: ...

        def preferred_during_scheduling_ignored_during_execution(self, value_or_callback=None, /):
            """
            The scheduler will prefer to schedule pods to nodes that satisfy
            the affinity expressions specified by this field, but it may choose
            a node that violates one or more of the expressions. The node that is
            most preferred is the one with the greatest sum of weights, i.e.
            for each node that meets all of the scheduling requirements (resource
            request, requiredDuringScheduling affinity expressions, etc.),
            compute a sum by iterating through the elements of this field and adding
            "weight" to the sum if the node matches the corresponding matchExpressions; the
            node(s) with the highest sum are the most preferred.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[
                    PreferredDuringSchedulingIgnoredDuringExecution.Builder
                ]()
                context._parent_builder = self
                context._field_name = "preferred_during_scheduling_ignored_during_execution"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(
                    PreferredDuringSchedulingIgnoredDuringExecution.list_builder()
                )
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("preferred_during_scheduling_ignored_during_execution", value)

        @overload
        def required_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: Optional[RequiredDuringSchedulingIgnoredDuringExecution],
            /,
        ) -> "NodeAffinity.Builder": ...

        @overload
        def required_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: Callable[
                [RequiredDuringSchedulingIgnoredDuringExecution.Builder],
                RequiredDuringSchedulingIgnoredDuringExecution.Builder
                | RequiredDuringSchedulingIgnoredDuringExecution,
            ],
            /,
        ) -> "NodeAffinity.Builder": ...

        @overload
        def required_during_scheduling_ignored_during_execution(
            self, value_or_callback: Never = ...
        ) -> "RequiredDuringSchedulingIgnoredDuringExecution.BuilderContext": ...

        def required_during_scheduling_ignored_during_execution(self, value_or_callback=None, /):
            """
            If the affinity requirements specified by this field are not met at
            scheduling time, the pod will not be scheduled onto the node.
            If the affinity requirements specified by this field cease to be met
            at some point during pod execution (e.g. due to an update), the system
            may or may not try to eventually evict the pod from its node.
            """
            if self._in_context and value_or_callback is None:
                context = RequiredDuringSchedulingIgnoredDuringExecution.BuilderContext()
                context._parent_builder = self
                context._field_name = "required_during_scheduling_ignored_during_execution"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RequiredDuringSchedulingIgnoredDuringExecution.builder())
                if isinstance(output, RequiredDuringSchedulingIgnoredDuringExecution.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("required_during_scheduling_ignored_during_execution", value)

    class BuilderContext(BuilderContextBase["NodeAffinity.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NodeAffinity.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NodeAffinity."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NodeAffinity", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NodeAffinity.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    preferred_during_scheduling_ignored_during_execution: Annotated[
        Optional[List[PreferredDuringSchedulingIgnoredDuringExecution]],
        Field(alias="preferredDuringSchedulingIgnoredDuringExecution"),
    ] = None
    """
    The scheduler will prefer to schedule pods to nodes that satisfy
    the affinity expressions specified by this field, but it may choose
    a node that violates one or more of the expressions. The node that is
    most preferred is the one with the greatest sum of weights, i.e.
    for each node that meets all of the scheduling requirements (resource
    request, requiredDuringScheduling affinity expressions, etc.),
    compute a sum by iterating through the elements of this field and adding
    "weight" to the sum if the node matches the corresponding matchExpressions; the
    node(s) with the highest sum are the most preferred.
    """
    required_during_scheduling_ignored_during_execution: Annotated[
        Optional[RequiredDuringSchedulingIgnoredDuringExecution],
        Field(alias="requiredDuringSchedulingIgnoredDuringExecution"),
    ] = None
    """
    If the affinity requirements specified by this field are not met at
    scheduling time, the pod will not be scheduled onto the node.
    If the affinity requirements specified by this field cease to be met
    at some point during pod execution (e.g. due to an update), the system
    may or may not try to eventually evict the pod from its node.
    """


class MatchExpressionModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchExpressionModel"]:
            return MatchExpressionModel

        def build(self) -> "MatchExpressionModel":
            return MatchExpressionModel(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key is the label key that the selector applies to.
            """
            return self._set("key", value)

        def operator(self, value: str, /) -> Self:
            """
            operator represents a key's relationship to a set of values.
            Valid operators are In, NotIn, Exists and DoesNotExist.
            """
            return self._set("operator", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            values is an array of string values. If the operator is In or NotIn,
            the values array must be non-empty. If the operator is Exists or DoesNotExist,
            the values array must be empty. This array is replaced during a strategic
            merge patch.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["MatchExpressionModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchExpressionModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchExpressionModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchExpressionModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchExpressionModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key is the label key that the selector applies to.
    """
    operator: str
    """
    operator represents a key's relationship to a set of values.
    Valid operators are In, NotIn, Exists and DoesNotExist.
    """
    values: Optional[List[str]] = None
    """
    values is an array of string values. If the operator is In or NotIn,
    the values array must be non-empty. If the operator is Exists or DoesNotExist,
    the values array must be empty. This array is replaced during a strategic
    merge patch.
    """


class LabelSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LabelSelector"]:
            return LabelSelector

        def build(self) -> "LabelSelector":
            return LabelSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel], /
        ) -> "LabelSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]],
                GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]
                | List[MatchExpressionModel],
            ],
            /,
        ) -> "LabelSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["LabelSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LabelSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LabelSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LabelSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LabelSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class NamespaceSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NamespaceSelector"]:
            return NamespaceSelector

        def build(self) -> "NamespaceSelector":
            return NamespaceSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel], /
        ) -> "NamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]],
                GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]
                | List[MatchExpressionModel],
            ],
            /,
        ) -> "NamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["NamespaceSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NamespaceSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NamespaceSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NamespaceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamespaceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class PodAffinityTerm(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodAffinityTerm"]:
            return PodAffinityTerm

        def build(self) -> "PodAffinityTerm":
            return PodAffinityTerm(**self._attrs)

        @overload
        def label_selector(
            self, value_or_callback: Optional[LabelSelector], /
        ) -> "PodAffinityTerm.Builder": ...

        @overload
        def label_selector(
            self,
            value_or_callback: Callable[
                [LabelSelector.Builder], LabelSelector.Builder | LabelSelector
            ],
            /,
        ) -> "PodAffinityTerm.Builder": ...

        @overload
        def label_selector(
            self, value_or_callback: Never = ...
        ) -> "LabelSelector.BuilderContext": ...

        def label_selector(self, value_or_callback=None, /):
            """
            A label query over a set of resources, in this case pods.
            If it's null, this PodAffinityTerm matches with no Pods.
            """
            if self._in_context and value_or_callback is None:
                context = LabelSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "label_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LabelSelector.builder())
                if isinstance(output, LabelSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("label_selector", value)

        def match_label_keys(self, value: Optional[List[str]], /) -> Self:
            """
            MatchLabelKeys is a set of pod label keys to select which pods will
            be taken into consideration. The keys are used to lookup values from the
            incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
            to select the group of existing pods which pods will be taken into consideration
            for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
            pod labels will be ignored. The default value is empty.
            The same key is forbidden to exist in both matchLabelKeys and labelSelector.
            Also, matchLabelKeys cannot be set when labelSelector isn't set.
            This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
            """
            return self._set("match_label_keys", value)

        def mismatch_label_keys(self, value: Optional[List[str]], /) -> Self:
            """
            MismatchLabelKeys is a set of pod label keys to select which pods will
            be taken into consideration. The keys are used to lookup values from the
            incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
            to select the group of existing pods which pods will be taken into consideration
            for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
            pod labels will be ignored. The default value is empty.
            The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
            Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
            This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
            """
            return self._set("mismatch_label_keys", value)

        @overload
        def namespace_selector(
            self, value_or_callback: Optional[NamespaceSelector], /
        ) -> "PodAffinityTerm.Builder": ...

        @overload
        def namespace_selector(
            self,
            value_or_callback: Callable[
                [NamespaceSelector.Builder],
                NamespaceSelector.Builder | NamespaceSelector,
            ],
            /,
        ) -> "PodAffinityTerm.Builder": ...

        @overload
        def namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "NamespaceSelector.BuilderContext": ...

        def namespace_selector(self, value_or_callback=None, /):
            """
            A label query over the set of namespaces that the term applies to.
            The term is applied to the union of the namespaces selected by this field
            and the ones listed in the namespaces field.
            null selector and null or empty namespaces list means "this pod's namespace".
            An empty selector ({}) matches all namespaces.
            """
            if self._in_context and value_or_callback is None:
                context = NamespaceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamespaceSelector.builder())
                if isinstance(output, NamespaceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("namespace_selector", value)

        def namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            namespaces specifies a static list of namespace names that the term applies to.
            The term is applied to the union of the namespaces listed in this field
            and the ones selected by namespaceSelector.
            null or empty namespaces list and null namespaceSelector means "this pod's namespace".
            """
            return self._set("namespaces", value)

        def topology_key(self, value: str, /) -> Self:
            """
            This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
            the labelSelector in the specified namespaces, where co-located is defined as running on a node
            whose value of the label with key topologyKey matches that of any node on which any of the
            selected pods is running.
            Empty topologyKey is not allowed.
            """
            return self._set("topology_key", value)

    class BuilderContext(BuilderContextBase["PodAffinityTerm.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodAffinityTerm.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodAffinityTerm."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodAffinityTerm", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodAffinityTerm.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    label_selector: Annotated[Optional[LabelSelector], Field(alias="labelSelector")] = None
    """
    A label query over a set of resources, in this case pods.
    If it's null, this PodAffinityTerm matches with no Pods.
    """
    match_label_keys: Annotated[Optional[List[str]], Field(alias="matchLabelKeys")] = None
    """
    MatchLabelKeys is a set of pod label keys to select which pods will
    be taken into consideration. The keys are used to lookup values from the
    incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
    to select the group of existing pods which pods will be taken into consideration
    for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    pod labels will be ignored. The default value is empty.
    The same key is forbidden to exist in both matchLabelKeys and labelSelector.
    Also, matchLabelKeys cannot be set when labelSelector isn't set.
    This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
    """
    mismatch_label_keys: Annotated[Optional[List[str]], Field(alias="mismatchLabelKeys")] = None
    """
    MismatchLabelKeys is a set of pod label keys to select which pods will
    be taken into consideration. The keys are used to lookup values from the
    incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
    to select the group of existing pods which pods will be taken into consideration
    for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    pod labels will be ignored. The default value is empty.
    The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
    Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
    This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
    """
    namespace_selector: Annotated[Optional[NamespaceSelector], Field(alias="namespaceSelector")] = (
        None
    )
    """
    A label query over the set of namespaces that the term applies to.
    The term is applied to the union of the namespaces selected by this field
    and the ones listed in the namespaces field.
    null selector and null or empty namespaces list means "this pod's namespace".
    An empty selector ({}) matches all namespaces.
    """
    namespaces: Optional[List[str]] = None
    """
    namespaces specifies a static list of namespace names that the term applies to.
    The term is applied to the union of the namespaces listed in this field
    and the ones selected by namespaceSelector.
    null or empty namespaces list and null namespaceSelector means "this pod's namespace".
    """
    topology_key: Annotated[str, Field(alias="topologyKey")]
    """
    This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
    the labelSelector in the specified namespaces, where co-located is defined as running on a node
    whose value of the label with key topologyKey matches that of any node on which any of the
    selected pods is running.
    Empty topologyKey is not allowed.
    """


class PreferredDuringSchedulingIgnoredDuringExecutionModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PreferredDuringSchedulingIgnoredDuringExecutionModel"]:
            return PreferredDuringSchedulingIgnoredDuringExecutionModel

        def build(self) -> "PreferredDuringSchedulingIgnoredDuringExecutionModel":
            return PreferredDuringSchedulingIgnoredDuringExecutionModel(**self._attrs)

        @overload
        def pod_affinity_term(
            self, value_or_callback: PodAffinityTerm, /
        ) -> "PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder": ...

        @overload
        def pod_affinity_term(
            self,
            value_or_callback: Callable[
                [PodAffinityTerm.Builder], PodAffinityTerm.Builder | PodAffinityTerm
            ],
            /,
        ) -> "PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder": ...

        @overload
        def pod_affinity_term(
            self, value_or_callback: Never = ...
        ) -> "PodAffinityTerm.BuilderContext": ...

        def pod_affinity_term(self, value_or_callback=None, /):
            """
            Required. A pod affinity term, associated with the corresponding weight.
            """
            if self._in_context and value_or_callback is None:
                context = PodAffinityTerm.BuilderContext()
                context._parent_builder = self
                context._field_name = "pod_affinity_term"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodAffinityTerm.builder())
                if isinstance(output, PodAffinityTerm.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("pod_affinity_term", value)

        def weight(self, value: int, /) -> Self:
            """
            weight associated with matching the corresponding podAffinityTerm,
            in the range 1-100.
            """
            return self._set("weight", value)

    class BuilderContext(
        BuilderContextBase["PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder"]
    ):
        def model_post_init(self, __context) -> None:
            self._builder = PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PreferredDuringSchedulingIgnoredDuringExecutionModel."""
        return cls.BuilderContext()

    class ListBuilder(
        GenericListBuilder["PreferredDuringSchedulingIgnoredDuringExecutionModel", Builder]
    ):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PreferredDuringSchedulingIgnoredDuringExecutionModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    pod_affinity_term: Annotated[PodAffinityTerm, Field(alias="podAffinityTerm")]
    """
    Required. A pod affinity term, associated with the corresponding weight.
    """
    weight: int
    """
    weight associated with matching the corresponding podAffinityTerm,
    in the range 1-100.
    """


class RequiredDuringSchedulingIgnoredDuringExecutionModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RequiredDuringSchedulingIgnoredDuringExecutionModel"]:
            return RequiredDuringSchedulingIgnoredDuringExecutionModel

        def build(self) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel":
            return RequiredDuringSchedulingIgnoredDuringExecutionModel(**self._attrs)

        @overload
        def label_selector(
            self, value_or_callback: Optional[LabelSelector], /
        ) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder": ...

        @overload
        def label_selector(
            self,
            value_or_callback: Callable[
                [LabelSelector.Builder], LabelSelector.Builder | LabelSelector
            ],
            /,
        ) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder": ...

        @overload
        def label_selector(
            self, value_or_callback: Never = ...
        ) -> "LabelSelector.BuilderContext": ...

        def label_selector(self, value_or_callback=None, /):
            """
            A label query over a set of resources, in this case pods.
            If it's null, this PodAffinityTerm matches with no Pods.
            """
            if self._in_context and value_or_callback is None:
                context = LabelSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "label_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LabelSelector.builder())
                if isinstance(output, LabelSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("label_selector", value)

        def match_label_keys(self, value: Optional[List[str]], /) -> Self:
            """
            MatchLabelKeys is a set of pod label keys to select which pods will
            be taken into consideration. The keys are used to lookup values from the
            incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
            to select the group of existing pods which pods will be taken into consideration
            for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
            pod labels will be ignored. The default value is empty.
            The same key is forbidden to exist in both matchLabelKeys and labelSelector.
            Also, matchLabelKeys cannot be set when labelSelector isn't set.
            This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
            """
            return self._set("match_label_keys", value)

        def mismatch_label_keys(self, value: Optional[List[str]], /) -> Self:
            """
            MismatchLabelKeys is a set of pod label keys to select which pods will
            be taken into consideration. The keys are used to lookup values from the
            incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
            to select the group of existing pods which pods will be taken into consideration
            for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
            pod labels will be ignored. The default value is empty.
            The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
            Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
            This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
            """
            return self._set("mismatch_label_keys", value)

        @overload
        def namespace_selector(
            self, value_or_callback: Optional[NamespaceSelector], /
        ) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder": ...

        @overload
        def namespace_selector(
            self,
            value_or_callback: Callable[
                [NamespaceSelector.Builder],
                NamespaceSelector.Builder | NamespaceSelector,
            ],
            /,
        ) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder": ...

        @overload
        def namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "NamespaceSelector.BuilderContext": ...

        def namespace_selector(self, value_or_callback=None, /):
            """
            A label query over the set of namespaces that the term applies to.
            The term is applied to the union of the namespaces selected by this field
            and the ones listed in the namespaces field.
            null selector and null or empty namespaces list means "this pod's namespace".
            An empty selector ({}) matches all namespaces.
            """
            if self._in_context and value_or_callback is None:
                context = NamespaceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamespaceSelector.builder())
                if isinstance(output, NamespaceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("namespace_selector", value)

        def namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            namespaces specifies a static list of namespace names that the term applies to.
            The term is applied to the union of the namespaces listed in this field
            and the ones selected by namespaceSelector.
            null or empty namespaces list and null namespaceSelector means "this pod's namespace".
            """
            return self._set("namespaces", value)

        def topology_key(self, value: str, /) -> Self:
            """
            This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
            the labelSelector in the specified namespaces, where co-located is defined as running on a node
            whose value of the label with key topologyKey matches that of any node on which any of the
            selected pods is running.
            Empty topologyKey is not allowed.
            """
            return self._set("topology_key", value)

    class BuilderContext(
        BuilderContextBase["RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder"]
    ):
        def model_post_init(self, __context) -> None:
            self._builder = RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequiredDuringSchedulingIgnoredDuringExecutionModel."""
        return cls.BuilderContext()

    class ListBuilder(
        GenericListBuilder["RequiredDuringSchedulingIgnoredDuringExecutionModel", Builder]
    ):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RequiredDuringSchedulingIgnoredDuringExecutionModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    label_selector: Annotated[Optional[LabelSelector], Field(alias="labelSelector")] = None
    """
    A label query over a set of resources, in this case pods.
    If it's null, this PodAffinityTerm matches with no Pods.
    """
    match_label_keys: Annotated[Optional[List[str]], Field(alias="matchLabelKeys")] = None
    """
    MatchLabelKeys is a set of pod label keys to select which pods will
    be taken into consideration. The keys are used to lookup values from the
    incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
    to select the group of existing pods which pods will be taken into consideration
    for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    pod labels will be ignored. The default value is empty.
    The same key is forbidden to exist in both matchLabelKeys and labelSelector.
    Also, matchLabelKeys cannot be set when labelSelector isn't set.
    This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
    """
    mismatch_label_keys: Annotated[Optional[List[str]], Field(alias="mismatchLabelKeys")] = None
    """
    MismatchLabelKeys is a set of pod label keys to select which pods will
    be taken into consideration. The keys are used to lookup values from the
    incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
    to select the group of existing pods which pods will be taken into consideration
    for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    pod labels will be ignored. The default value is empty.
    The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
    Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
    This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
    """
    namespace_selector: Annotated[Optional[NamespaceSelector], Field(alias="namespaceSelector")] = (
        None
    )
    """
    A label query over the set of namespaces that the term applies to.
    The term is applied to the union of the namespaces selected by this field
    and the ones listed in the namespaces field.
    null selector and null or empty namespaces list means "this pod's namespace".
    An empty selector ({}) matches all namespaces.
    """
    namespaces: Optional[List[str]] = None
    """
    namespaces specifies a static list of namespace names that the term applies to.
    The term is applied to the union of the namespaces listed in this field
    and the ones selected by namespaceSelector.
    null or empty namespaces list and null namespaceSelector means "this pod's namespace".
    """
    topology_key: Annotated[str, Field(alias="topologyKey")]
    """
    This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
    the labelSelector in the specified namespaces, where co-located is defined as running on a node
    whose value of the label with key topologyKey matches that of any node on which any of the
    selected pods is running.
    Empty topologyKey is not allowed.
    """


class PodAffinity(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodAffinity"]:
            return PodAffinity

        def build(self) -> "PodAffinity":
            return PodAffinity(**self._attrs)

        @overload
        def preferred_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: List[PreferredDuringSchedulingIgnoredDuringExecutionModel],
            /,
        ) -> "PodAffinity.Builder": ...

        @overload
        def preferred_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        PreferredDuringSchedulingIgnoredDuringExecutionModel,
                        PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder,
                    ]
                ],
                GenericListBuilder[
                    PreferredDuringSchedulingIgnoredDuringExecutionModel,
                    PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder,
                ]
                | List[PreferredDuringSchedulingIgnoredDuringExecutionModel],
            ],
            /,
        ) -> "PodAffinity.Builder": ...

        @overload
        def preferred_during_scheduling_ignored_during_execution(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder]: ...

        def preferred_during_scheduling_ignored_during_execution(self, value_or_callback=None, /):
            """
            The scheduler will prefer to schedule pods to nodes that satisfy
            the affinity expressions specified by this field, but it may choose
            a node that violates one or more of the expressions. The node that is
            most preferred is the one with the greatest sum of weights, i.e.
            for each node that meets all of the scheduling requirements (resource
            request, requiredDuringScheduling affinity expressions, etc.),
            compute a sum by iterating through the elements of this field and adding
            "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
            node(s) with the highest sum are the most preferred.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[
                    PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder
                ]()
                context._parent_builder = self
                context._field_name = "preferred_during_scheduling_ignored_during_execution"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(
                    PreferredDuringSchedulingIgnoredDuringExecutionModel.list_builder()
                )
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("preferred_during_scheduling_ignored_during_execution", value)

        @overload
        def required_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: List[RequiredDuringSchedulingIgnoredDuringExecutionModel],
            /,
        ) -> "PodAffinity.Builder": ...

        @overload
        def required_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        RequiredDuringSchedulingIgnoredDuringExecutionModel,
                        RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder,
                    ]
                ],
                GenericListBuilder[
                    RequiredDuringSchedulingIgnoredDuringExecutionModel,
                    RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder,
                ]
                | List[RequiredDuringSchedulingIgnoredDuringExecutionModel],
            ],
            /,
        ) -> "PodAffinity.Builder": ...

        @overload
        def required_during_scheduling_ignored_during_execution(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder]: ...

        def required_during_scheduling_ignored_during_execution(self, value_or_callback=None, /):
            """
            If the affinity requirements specified by this field are not met at
            scheduling time, the pod will not be scheduled onto the node.
            If the affinity requirements specified by this field cease to be met
            at some point during pod execution (e.g. due to a pod label update), the
            system may or may not try to eventually evict the pod from its node.
            When there are multiple elements, the lists of nodes corresponding to each
            podAffinityTerm are intersected, i.e. all terms must be satisfied.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[
                    RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder
                ]()
                context._parent_builder = self
                context._field_name = "required_during_scheduling_ignored_during_execution"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(
                    RequiredDuringSchedulingIgnoredDuringExecutionModel.list_builder()
                )
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("required_during_scheduling_ignored_during_execution", value)

    class BuilderContext(BuilderContextBase["PodAffinity.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodAffinity.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodAffinity."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodAffinity", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodAffinity.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    preferred_during_scheduling_ignored_during_execution: Annotated[
        Optional[List[PreferredDuringSchedulingIgnoredDuringExecutionModel]],
        Field(alias="preferredDuringSchedulingIgnoredDuringExecution"),
    ] = None
    """
    The scheduler will prefer to schedule pods to nodes that satisfy
    the affinity expressions specified by this field, but it may choose
    a node that violates one or more of the expressions. The node that is
    most preferred is the one with the greatest sum of weights, i.e.
    for each node that meets all of the scheduling requirements (resource
    request, requiredDuringScheduling affinity expressions, etc.),
    compute a sum by iterating through the elements of this field and adding
    "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
    node(s) with the highest sum are the most preferred.
    """
    required_during_scheduling_ignored_during_execution: Annotated[
        Optional[List[RequiredDuringSchedulingIgnoredDuringExecutionModel]],
        Field(alias="requiredDuringSchedulingIgnoredDuringExecution"),
    ] = None
    """
    If the affinity requirements specified by this field are not met at
    scheduling time, the pod will not be scheduled onto the node.
    If the affinity requirements specified by this field cease to be met
    at some point during pod execution (e.g. due to a pod label update), the
    system may or may not try to eventually evict the pod from its node.
    When there are multiple elements, the lists of nodes corresponding to each
    podAffinityTerm are intersected, i.e. all terms must be satisfied.
    """


class PodAntiAffinity(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodAntiAffinity"]:
            return PodAntiAffinity

        def build(self) -> "PodAntiAffinity":
            return PodAntiAffinity(**self._attrs)

        @overload
        def preferred_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: List[PreferredDuringSchedulingIgnoredDuringExecutionModel],
            /,
        ) -> "PodAntiAffinity.Builder": ...

        @overload
        def preferred_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        PreferredDuringSchedulingIgnoredDuringExecutionModel,
                        PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder,
                    ]
                ],
                GenericListBuilder[
                    PreferredDuringSchedulingIgnoredDuringExecutionModel,
                    PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder,
                ]
                | List[PreferredDuringSchedulingIgnoredDuringExecutionModel],
            ],
            /,
        ) -> "PodAntiAffinity.Builder": ...

        @overload
        def preferred_during_scheduling_ignored_during_execution(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder]: ...

        def preferred_during_scheduling_ignored_during_execution(self, value_or_callback=None, /):
            """
            The scheduler will prefer to schedule pods to nodes that satisfy
            the anti-affinity expressions specified by this field, but it may choose
            a node that violates one or more of the expressions. The node that is
            most preferred is the one with the greatest sum of weights, i.e.
            for each node that meets all of the scheduling requirements (resource
            request, requiredDuringScheduling anti-affinity expressions, etc.),
            compute a sum by iterating through the elements of this field and adding
            "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
            node(s) with the highest sum are the most preferred.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[
                    PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder
                ]()
                context._parent_builder = self
                context._field_name = "preferred_during_scheduling_ignored_during_execution"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(
                    PreferredDuringSchedulingIgnoredDuringExecutionModel.list_builder()
                )
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("preferred_during_scheduling_ignored_during_execution", value)

        @overload
        def required_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: List[RequiredDuringSchedulingIgnoredDuringExecutionModel],
            /,
        ) -> "PodAntiAffinity.Builder": ...

        @overload
        def required_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        RequiredDuringSchedulingIgnoredDuringExecutionModel,
                        RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder,
                    ]
                ],
                GenericListBuilder[
                    RequiredDuringSchedulingIgnoredDuringExecutionModel,
                    RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder,
                ]
                | List[RequiredDuringSchedulingIgnoredDuringExecutionModel],
            ],
            /,
        ) -> "PodAntiAffinity.Builder": ...

        @overload
        def required_during_scheduling_ignored_during_execution(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder]: ...

        def required_during_scheduling_ignored_during_execution(self, value_or_callback=None, /):
            """
            If the anti-affinity requirements specified by this field are not met at
            scheduling time, the pod will not be scheduled onto the node.
            If the anti-affinity requirements specified by this field cease to be met
            at some point during pod execution (e.g. due to a pod label update), the
            system may or may not try to eventually evict the pod from its node.
            When there are multiple elements, the lists of nodes corresponding to each
            podAffinityTerm are intersected, i.e. all terms must be satisfied.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[
                    RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder
                ]()
                context._parent_builder = self
                context._field_name = "required_during_scheduling_ignored_during_execution"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(
                    RequiredDuringSchedulingIgnoredDuringExecutionModel.list_builder()
                )
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("required_during_scheduling_ignored_during_execution", value)

    class BuilderContext(BuilderContextBase["PodAntiAffinity.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodAntiAffinity.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodAntiAffinity."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodAntiAffinity", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodAntiAffinity.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    preferred_during_scheduling_ignored_during_execution: Annotated[
        Optional[List[PreferredDuringSchedulingIgnoredDuringExecutionModel]],
        Field(alias="preferredDuringSchedulingIgnoredDuringExecution"),
    ] = None
    """
    The scheduler will prefer to schedule pods to nodes that satisfy
    the anti-affinity expressions specified by this field, but it may choose
    a node that violates one or more of the expressions. The node that is
    most preferred is the one with the greatest sum of weights, i.e.
    for each node that meets all of the scheduling requirements (resource
    request, requiredDuringScheduling anti-affinity expressions, etc.),
    compute a sum by iterating through the elements of this field and adding
    "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
    node(s) with the highest sum are the most preferred.
    """
    required_during_scheduling_ignored_during_execution: Annotated[
        Optional[List[RequiredDuringSchedulingIgnoredDuringExecutionModel]],
        Field(alias="requiredDuringSchedulingIgnoredDuringExecution"),
    ] = None
    """
    If the anti-affinity requirements specified by this field are not met at
    scheduling time, the pod will not be scheduled onto the node.
    If the anti-affinity requirements specified by this field cease to be met
    at some point during pod execution (e.g. due to a pod label update), the
    system may or may not try to eventually evict the pod from its node.
    When there are multiple elements, the lists of nodes corresponding to each
    podAffinityTerm are intersected, i.e. all terms must be satisfied.
    """


class Affinity(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Affinity"]:
            return Affinity

        def build(self) -> "Affinity":
            return Affinity(**self._attrs)

        @overload
        def node_affinity(
            self, value_or_callback: Optional[NodeAffinity], /
        ) -> "Affinity.Builder": ...

        @overload
        def node_affinity(
            self,
            value_or_callback: Callable[
                [NodeAffinity.Builder], NodeAffinity.Builder | NodeAffinity
            ],
            /,
        ) -> "Affinity.Builder": ...

        @overload
        def node_affinity(
            self, value_or_callback: Never = ...
        ) -> "NodeAffinity.BuilderContext": ...

        def node_affinity(self, value_or_callback=None, /):
            """
            Describes node affinity scheduling rules for the pod.
            """
            if self._in_context and value_or_callback is None:
                context = NodeAffinity.BuilderContext()
                context._parent_builder = self
                context._field_name = "node_affinity"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NodeAffinity.builder())
                if isinstance(output, NodeAffinity.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("node_affinity", value)

        @overload
        def pod_affinity(
            self, value_or_callback: Optional[PodAffinity], /
        ) -> "Affinity.Builder": ...

        @overload
        def pod_affinity(
            self,
            value_or_callback: Callable[[PodAffinity.Builder], PodAffinity.Builder | PodAffinity],
            /,
        ) -> "Affinity.Builder": ...

        @overload
        def pod_affinity(self, value_or_callback: Never = ...) -> "PodAffinity.BuilderContext": ...

        def pod_affinity(self, value_or_callback=None, /):
            """
            Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
            """
            if self._in_context and value_or_callback is None:
                context = PodAffinity.BuilderContext()
                context._parent_builder = self
                context._field_name = "pod_affinity"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodAffinity.builder())
                if isinstance(output, PodAffinity.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("pod_affinity", value)

        @overload
        def pod_anti_affinity(
            self, value_or_callback: Optional[PodAntiAffinity], /
        ) -> "Affinity.Builder": ...

        @overload
        def pod_anti_affinity(
            self,
            value_or_callback: Callable[
                [PodAntiAffinity.Builder], PodAntiAffinity.Builder | PodAntiAffinity
            ],
            /,
        ) -> "Affinity.Builder": ...

        @overload
        def pod_anti_affinity(
            self, value_or_callback: Never = ...
        ) -> "PodAntiAffinity.BuilderContext": ...

        def pod_anti_affinity(self, value_or_callback=None, /):
            """
            Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
            """
            if self._in_context and value_or_callback is None:
                context = PodAntiAffinity.BuilderContext()
                context._parent_builder = self
                context._field_name = "pod_anti_affinity"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodAntiAffinity.builder())
                if isinstance(output, PodAntiAffinity.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("pod_anti_affinity", value)

    class BuilderContext(BuilderContextBase["Affinity.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Affinity.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Affinity."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Affinity", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Affinity.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    node_affinity: Annotated[Optional[NodeAffinity], Field(alias="nodeAffinity")] = None
    """
    Describes node affinity scheduling rules for the pod.
    """
    pod_affinity: Annotated[Optional[PodAffinity], Field(alias="podAffinity")] = None
    """
    Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
    """
    pod_anti_affinity: Annotated[Optional[PodAntiAffinity], Field(alias="podAntiAffinity")] = None
    """
    Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
    """


class AuthorizationModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AuthorizationModel"]:
            return AuthorizationModel

        def build(self) -> "AuthorizationModel":
            return AuthorizationModel(**self._attrs)

        @overload
        def credentials(
            self, value_or_callback: Optional[Credentials], /
        ) -> "AuthorizationModel.Builder": ...

        @overload
        def credentials(
            self,
            value_or_callback: Callable[[Credentials.Builder], Credentials.Builder | Credentials],
            /,
        ) -> "AuthorizationModel.Builder": ...

        @overload
        def credentials(self, value_or_callback: Never = ...) -> "Credentials.BuilderContext": ...

        def credentials(self, value_or_callback=None, /):
            """
            Selects a key of a Secret in the namespace that contains the credentials for authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Credentials.BuilderContext()
                context._parent_builder = self
                context._field_name = "credentials"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Credentials.builder())
                if isinstance(output, Credentials.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("credentials", value)

        def credentials_file(self, value: Optional[str], /) -> Self:
            """
            File to read a secret from, mutually exclusive with `credentials`.
            """
            return self._set("credentials_file", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Defines the authentication type. The value is case-insensitive.

            "Basic" is not a supported value.

            Default: "Bearer"
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["AuthorizationModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AuthorizationModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AuthorizationModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AuthorizationModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AuthorizationModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    credentials: Optional[Credentials] = None
    """
    Selects a key of a Secret in the namespace that contains the credentials for authentication.
    """
    credentials_file: Annotated[Optional[str], Field(alias="credentialsFile")] = None
    """
    File to read a secret from, mutually exclusive with `credentials`.
    """
    type: Optional[str] = None
    """
    Defines the authentication type. The value is case-insensitive.

    "Basic" is not a supported value.

    Default: "Bearer"
    """


class TlsConfigModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsConfigModel"]:
            return TlsConfigModel

        def build(self) -> "TlsConfigModel":
            return TlsConfigModel(**self._attrs)

        @overload
        def ca(self, value_or_callback: Optional[Ca], /) -> "TlsConfigModel.Builder": ...

        @overload
        def ca(
            self, value_or_callback: Callable[[Ca.Builder], Ca.Builder | Ca], /
        ) -> "TlsConfigModel.Builder": ...

        @overload
        def ca(self, value_or_callback: Never = ...) -> "Ca.BuilderContext": ...

        def ca(self, value_or_callback=None, /):
            """
            Certificate authority used when verifying server certificates.
            """
            if self._in_context and value_or_callback is None:
                context = Ca.BuilderContext()
                context._parent_builder = self
                context._field_name = "ca"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ca.builder())
                if isinstance(output, Ca.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ca", value)

        def ca_file(self, value: Optional[str], /) -> Self:
            """
            Path to the CA cert in the Prometheus container to use for the targets.
            """
            return self._set("ca_file", value)

        @overload
        def cert(self, value_or_callback: Optional[Cert], /) -> "TlsConfigModel.Builder": ...

        @overload
        def cert(
            self, value_or_callback: Callable[[Cert.Builder], Cert.Builder | Cert], /
        ) -> "TlsConfigModel.Builder": ...

        @overload
        def cert(self, value_or_callback: Never = ...) -> "Cert.BuilderContext": ...

        def cert(self, value_or_callback=None, /):
            """
            Client certificate to present when doing client-authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Cert.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cert.builder())
                if isinstance(output, Cert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert", value)

        def cert_file(self, value: Optional[str], /) -> Self:
            """
            Path to the client cert file in the Prometheus container for the targets.
            """
            return self._set("cert_file", value)

        def insecure_skip_verify(self, value: Optional[bool], /) -> Self:
            """
            Disable target certificate validation.
            """
            return self._set("insecure_skip_verify", value)

        def key_file(self, value: Optional[str], /) -> Self:
            """
            Path to the client key file in the Prometheus container for the targets.
            """
            return self._set("key_file", value)

        @overload
        def key_secret(
            self, value_or_callback: Optional[KeySecret], /
        ) -> "TlsConfigModel.Builder": ...

        @overload
        def key_secret(
            self,
            value_or_callback: Callable[[KeySecret.Builder], KeySecret.Builder | KeySecret],
            /,
        ) -> "TlsConfigModel.Builder": ...

        @overload
        def key_secret(self, value_or_callback: Never = ...) -> "KeySecret.BuilderContext": ...

        def key_secret(self, value_or_callback=None, /):
            """
            Secret containing the client key file for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = KeySecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "key_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KeySecret.builder())
                if isinstance(output, KeySecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("key_secret", value)

        def max_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Maximum acceptable TLS version.

            It requires Prometheus >= v2.41.0.
            """
            return self._set("max_version", value)

        def min_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Minimum acceptable TLS version.

            It requires Prometheus >= v2.35.0.
            """
            return self._set("min_version", value)

        def server_name(self, value: Optional[str], /) -> Self:
            """
            Used to verify the hostname for the targets.
            """
            return self._set("server_name", value)

    class BuilderContext(BuilderContextBase["TlsConfigModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsConfigModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsConfigModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsConfigModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsConfigModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca: Optional[Ca] = None
    """
    Certificate authority used when verifying server certificates.
    """
    ca_file: Annotated[Optional[str], Field(alias="caFile")] = None
    """
    Path to the CA cert in the Prometheus container to use for the targets.
    """
    cert: Optional[Cert] = None
    """
    Client certificate to present when doing client-authentication.
    """
    cert_file: Annotated[Optional[str], Field(alias="certFile")] = None
    """
    Path to the client cert file in the Prometheus container for the targets.
    """
    insecure_skip_verify: Annotated[Optional[bool], Field(alias="insecureSkipVerify")] = None
    """
    Disable target certificate validation.
    """
    key_file: Annotated[Optional[str], Field(alias="keyFile")] = None
    """
    Path to the client key file in the Prometheus container for the targets.
    """
    key_secret: Annotated[Optional[KeySecret], Field(alias="keySecret")] = None
    """
    Secret containing the client key file for the targets.
    """
    max_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="maxVersion")
    ] = None
    """
    Maximum acceptable TLS version.

    It requires Prometheus >= v2.41.0.
    """
    min_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="minVersion")
    ] = None
    """
    Minimum acceptable TLS version.

    It requires Prometheus >= v2.35.0.
    """
    server_name: Annotated[Optional[str], Field(alias="serverName")] = None
    """
    Used to verify the hostname for the targets.
    """


class ApiserverConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ApiserverConfig"]:
            return ApiserverConfig

        def build(self) -> "ApiserverConfig":
            return ApiserverConfig(**self._attrs)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel], /
        ) -> "ApiserverConfig.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel.Builder],
                AuthorizationModel.Builder | AuthorizationModel,
            ],
            /,
        ) -> "ApiserverConfig.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization section for the API server.

            Cannot be set at the same time as `basicAuth`, `bearerToken`, or
            `bearerTokenFile`.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel.builder())
                if isinstance(output, AuthorizationModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def basic_auth(
            self, value_or_callback: Optional[BasicAuth], /
        ) -> "ApiserverConfig.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "ApiserverConfig.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            BasicAuth configuration for the API server.

            Cannot be set at the same time as `authorization`, `bearerToken`, or
            `bearerTokenFile`.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        def bearer_token(self, value: Optional[str], /) -> Self:
            """
            *Warning: this field shouldn't be used because the token value appears
            in clear-text. Prefer using `authorization`.*

            Deprecated: this will be removed in a future release.
            """
            return self._set("bearer_token", value)

        def bearer_token_file(self, value: Optional[str], /) -> Self:
            """
            File to read bearer token for accessing apiserver.

            Cannot be set at the same time as `basicAuth`, `authorization`, or `bearerToken`.

            Deprecated: this will be removed in a future release. Prefer using `authorization`.
            """
            return self._set("bearer_token_file", value)

        def host(self, value: str, /) -> Self:
            """
            Kubernetes API address consisting of a hostname or IP address followed
            by an optional port number.
            """
            return self._set("host", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel], /
        ) -> "ApiserverConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel.Builder], TlsConfigModel.Builder | TlsConfigModel
            ],
            /,
        ) -> "ApiserverConfig.Builder": ...

        @overload
        def tls_config(self, value_or_callback: Never = ...) -> "TlsConfigModel.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS Config to use for the API server.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel.builder())
                if isinstance(output, TlsConfigModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["ApiserverConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ApiserverConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ApiserverConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ApiserverConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ApiserverConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authorization: Optional[AuthorizationModel] = None
    """
    Authorization section for the API server.

    Cannot be set at the same time as `basicAuth`, `bearerToken`, or
    `bearerTokenFile`.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    BasicAuth configuration for the API server.

    Cannot be set at the same time as `authorization`, `bearerToken`, or
    `bearerTokenFile`.
    """
    bearer_token: Annotated[Optional[str], Field(alias="bearerToken")] = None
    """
    *Warning: this field shouldn't be used because the token value appears
    in clear-text. Prefer using `authorization`.*

    Deprecated: this will be removed in a future release.
    """
    bearer_token_file: Annotated[Optional[str], Field(alias="bearerTokenFile")] = None
    """
    File to read bearer token for accessing apiserver.

    Cannot be set at the same time as `basicAuth`, `authorization`, or `bearerToken`.

    Deprecated: this will be removed in a future release. Prefer using `authorization`.
    """
    host: str
    """
    Kubernetes API address consisting of a hostname or IP address followed
    by an optional port number.
    """
    tls_config: Annotated[Optional[TlsConfigModel], Field(alias="tlsConfig")] = None
    """
    TLS Config to use for the API server.
    """


class ArbitraryFsAccessThroughSMs(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ArbitraryFsAccessThroughSMs"]:
            return ArbitraryFsAccessThroughSMs

        def build(self) -> "ArbitraryFsAccessThroughSMs":
            return ArbitraryFsAccessThroughSMs(**self._attrs)

        def deny(self, value: Optional[bool], /) -> Self:
            return self._set("deny", value)

    class BuilderContext(BuilderContextBase["ArbitraryFsAccessThroughSMs.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ArbitraryFsAccessThroughSMs.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ArbitraryFsAccessThroughSMs."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ArbitraryFsAccessThroughSMs", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ArbitraryFsAccessThroughSMs.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deny: Optional[bool] = None


class ConfigMapKeyRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapKeyRef"]:
            return ConfigMapKeyRef

        def build(self) -> "ConfigMapKeyRef":
            return ConfigMapKeyRef(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key to select.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the ConfigMap or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapKeyRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapKeyRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapKeyRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapKeyRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapKeyRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key to select.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the ConfigMap or its key must be defined
    """


class FieldRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FieldRef"]:
            return FieldRef

        def build(self) -> "FieldRef":
            return FieldRef(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            Version of the schema the FieldPath is written in terms of, defaults to "v1".
            """
            return self._set("api_version", value)

        def field_path(self, value: str, /) -> Self:
            """
            Path of the field to select in the specified API version.
            """
            return self._set("field_path", value)

    class BuilderContext(BuilderContextBase["FieldRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FieldRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FieldRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FieldRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FieldRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    Version of the schema the FieldPath is written in terms of, defaults to "v1".
    """
    field_path: Annotated[str, Field(alias="fieldPath")]
    """
    Path of the field to select in the specified API version.
    """


class Divisor(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "Divisor":
            value = cast(int, self._value)
            return Divisor(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["Divisor.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Divisor.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Divisor."""
        return cls.BuilderContext()


class DivisorModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel":
            value = cast(str, self._value)
            return DivisorModel(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel."""
        return cls.BuilderContext()


class ResourceFieldRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceFieldRef"]:
            return ResourceFieldRef

        def build(self) -> "ResourceFieldRef":
            return ResourceFieldRef(**self._attrs)

        def container_name(self, value: Optional[str], /) -> Self:
            """
            Container name: required for volumes, optional for env vars
            """
            return self._set("container_name", value)

        def divisor(self, value: Optional[Union[Divisor, DivisorModel]], /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            return self._set("divisor", value)

        def resource(self, value: str, /) -> Self:
            """
            Required: resource to select
            """
            return self._set("resource", value)

    class BuilderContext(BuilderContextBase["ResourceFieldRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceFieldRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceFieldRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceFieldRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceFieldRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    container_name: Annotated[Optional[str], Field(alias="containerName")] = None
    """
    Container name: required for volumes, optional for env vars
    """
    divisor: Optional[Union[Divisor, DivisorModel]] = None
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """
    resource: str
    """
    Required: resource to select
    """


class SecretKeyRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretKeyRef"]:
            return SecretKeyRef

        def build(self) -> "SecretKeyRef":
            return SecretKeyRef(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["SecretKeyRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretKeyRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretKeyRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretKeyRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretKeyRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class ValueFrom(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ValueFrom"]:
            return ValueFrom

        def build(self) -> "ValueFrom":
            return ValueFrom(**self._attrs)

        @overload
        def config_map_key_ref(
            self, value_or_callback: Optional[ConfigMapKeyRef], /
        ) -> "ValueFrom.Builder": ...

        @overload
        def config_map_key_ref(
            self,
            value_or_callback: Callable[
                [ConfigMapKeyRef.Builder], ConfigMapKeyRef.Builder | ConfigMapKeyRef
            ],
            /,
        ) -> "ValueFrom.Builder": ...

        @overload
        def config_map_key_ref(
            self, value_or_callback: Never = ...
        ) -> "ConfigMapKeyRef.BuilderContext": ...

        def config_map_key_ref(self, value_or_callback=None, /):
            """
            Selects a key of a ConfigMap.
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMapKeyRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map_key_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMapKeyRef.builder())
                if isinstance(output, ConfigMapKeyRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map_key_ref", value)

        @overload
        def field_ref(self, value_or_callback: Optional[FieldRef], /) -> "ValueFrom.Builder": ...

        @overload
        def field_ref(
            self,
            value_or_callback: Callable[[FieldRef.Builder], FieldRef.Builder | FieldRef],
            /,
        ) -> "ValueFrom.Builder": ...

        @overload
        def field_ref(self, value_or_callback: Never = ...) -> "FieldRef.BuilderContext": ...

        def field_ref(self, value_or_callback=None, /):
            """
            Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
            spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
            """
            if self._in_context and value_or_callback is None:
                context = FieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FieldRef.builder())
                if isinstance(output, FieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("field_ref", value)

        @overload
        def resource_field_ref(
            self, value_or_callback: Optional[ResourceFieldRef], /
        ) -> "ValueFrom.Builder": ...

        @overload
        def resource_field_ref(
            self,
            value_or_callback: Callable[
                [ResourceFieldRef.Builder], ResourceFieldRef.Builder | ResourceFieldRef
            ],
            /,
        ) -> "ValueFrom.Builder": ...

        @overload
        def resource_field_ref(
            self, value_or_callback: Never = ...
        ) -> "ResourceFieldRef.BuilderContext": ...

        def resource_field_ref(self, value_or_callback=None, /):
            """
            Selects a resource of the container: only resources limits and requests
            (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceFieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource_field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceFieldRef.builder())
                if isinstance(output, ResourceFieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_field_ref", value)

        @overload
        def secret_key_ref(
            self, value_or_callback: Optional[SecretKeyRef], /
        ) -> "ValueFrom.Builder": ...

        @overload
        def secret_key_ref(
            self,
            value_or_callback: Callable[
                [SecretKeyRef.Builder], SecretKeyRef.Builder | SecretKeyRef
            ],
            /,
        ) -> "ValueFrom.Builder": ...

        @overload
        def secret_key_ref(
            self, value_or_callback: Never = ...
        ) -> "SecretKeyRef.BuilderContext": ...

        def secret_key_ref(self, value_or_callback=None, /):
            """
            Selects a key of a secret in the pod's namespace
            """
            if self._in_context and value_or_callback is None:
                context = SecretKeyRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_key_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretKeyRef.builder())
                if isinstance(output, SecretKeyRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_key_ref", value)

    class BuilderContext(BuilderContextBase["ValueFrom.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ValueFrom.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ValueFrom."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ValueFrom", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ValueFrom.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_map_key_ref: Annotated[Optional[ConfigMapKeyRef], Field(alias="configMapKeyRef")] = None
    """
    Selects a key of a ConfigMap.
    """
    field_ref: Annotated[Optional[FieldRef], Field(alias="fieldRef")] = None
    """
    Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    """
    resource_field_ref: Annotated[Optional[ResourceFieldRef], Field(alias="resourceFieldRef")] = (
        None
    )
    """
    Selects a resource of the container: only resources limits and requests
    (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    """
    secret_key_ref: Annotated[Optional[SecretKeyRef], Field(alias="secretKeyRef")] = None
    """
    Selects a key of a secret in the pod's namespace
    """


class Env(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Env"]:
            return Env

        def build(self) -> "Env":
            return Env(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the environment variable. Must be a C_IDENTIFIER.
            """
            return self._set("name", value)

        def value(self, value: Optional[str], /) -> Self:
            """
            Variable references $(VAR_NAME) are expanded
            using the previously defined environment variables in the container and
            any service environment variables. If a variable cannot be resolved,
            the reference in the input string will be unchanged. Double $$ are reduced
            to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
            "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
            Escaped references will never be expanded, regardless of whether the variable
            exists or not.
            Defaults to "".
            """
            return self._set("value", value)

        @overload
        def value_from(self, value_or_callback: Optional[ValueFrom], /) -> "Env.Builder": ...

        @overload
        def value_from(
            self,
            value_or_callback: Callable[[ValueFrom.Builder], ValueFrom.Builder | ValueFrom],
            /,
        ) -> "Env.Builder": ...

        @overload
        def value_from(self, value_or_callback: Never = ...) -> "ValueFrom.BuilderContext": ...

        def value_from(self, value_or_callback=None, /):
            """
            Source for the environment variable's value. Cannot be used if value is not empty.
            """
            if self._in_context and value_or_callback is None:
                context = ValueFrom.BuilderContext()
                context._parent_builder = self
                context._field_name = "value_from"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ValueFrom.builder())
                if isinstance(output, ValueFrom.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("value_from", value)

    class BuilderContext(BuilderContextBase["Env.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Env.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Env."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Env", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Env.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the environment variable. Must be a C_IDENTIFIER.
    """
    value: Optional[str] = None
    """
    Variable references $(VAR_NAME) are expanded
    using the previously defined environment variables in the container and
    any service environment variables. If a variable cannot be resolved,
    the reference in the input string will be unchanged. Double $$ are reduced
    to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    Escaped references will never be expanded, regardless of whether the variable
    exists or not.
    Defaults to "".
    """
    value_from: Annotated[Optional[ValueFrom], Field(alias="valueFrom")] = None
    """
    Source for the environment variable's value. Cannot be used if value is not empty.
    """


class ConfigMapRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapRef"]:
            return ConfigMapRef

        def build(self) -> "ConfigMapRef":
            return ConfigMapRef(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the ConfigMap must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the ConfigMap must be defined
    """


class SecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretRef"]:
            return SecretRef

        def build(self) -> "SecretRef":
            return SecretRef(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["SecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret must be defined
    """


class EnvFrom(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["EnvFrom"]:
            return EnvFrom

        def build(self) -> "EnvFrom":
            return EnvFrom(**self._attrs)

        @overload
        def config_map_ref(
            self, value_or_callback: Optional[ConfigMapRef], /
        ) -> "EnvFrom.Builder": ...

        @overload
        def config_map_ref(
            self,
            value_or_callback: Callable[
                [ConfigMapRef.Builder], ConfigMapRef.Builder | ConfigMapRef
            ],
            /,
        ) -> "EnvFrom.Builder": ...

        @overload
        def config_map_ref(
            self, value_or_callback: Never = ...
        ) -> "ConfigMapRef.BuilderContext": ...

        def config_map_ref(self, value_or_callback=None, /):
            """
            The ConfigMap to select from
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMapRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMapRef.builder())
                if isinstance(output, ConfigMapRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map_ref", value)

        def prefix(self, value: Optional[str], /) -> Self:
            """
            An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
            """
            return self._set("prefix", value)

        @overload
        def secret_ref(self, value_or_callback: Optional[SecretRef], /) -> "EnvFrom.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "EnvFrom.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            The Secret to select from
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

    class BuilderContext(BuilderContextBase["EnvFrom.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = EnvFrom.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for EnvFrom."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["EnvFrom", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use EnvFrom.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_map_ref: Annotated[Optional[ConfigMapRef], Field(alias="configMapRef")] = None
    """
    The ConfigMap to select from
    """
    prefix: Optional[str] = None
    """
    An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
    """
    secret_ref: Annotated[Optional[SecretRef], Field(alias="secretRef")] = None
    """
    The Secret to select from
    """


class Exec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Exec"]:
            return Exec

        def build(self) -> "Exec":
            return Exec(**self._attrs)

        def command(self, value: Optional[List[str]], /) -> Self:
            """
            Command is the command line to execute inside the container, the working directory for the
            command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
            not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
            a shell, you need to explicitly call out to that shell.
            Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
            """
            return self._set("command", value)

    class BuilderContext(BuilderContextBase["Exec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Exec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Exec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Exec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Exec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    command: Optional[List[str]] = None
    """
    Command is the command line to execute inside the container, the working directory for the
    command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    a shell, you need to explicitly call out to that shell.
    Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    """


class HttpHeader(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HttpHeader"]:
            return HttpHeader

        def build(self) -> "HttpHeader":
            return HttpHeader(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            The header field name.
            This will be canonicalized upon output, so case-variant names will be understood as the same header.
            """
            return self._set("name", value)

        def value(self, value: str, /) -> Self:
            """
            The header field value
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["HttpHeader.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HttpHeader.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HttpHeader."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HttpHeader", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HttpHeader.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    The header field name.
    This will be canonicalized upon output, so case-variant names will be understood as the same header.
    """
    value: str
    """
    The header field value
    """


class HttpGet(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HttpGet"]:
            return HttpGet

        def build(self) -> "HttpGet":
            return HttpGet(**self._attrs)

        def host(self, value: Optional[str], /) -> Self:
            """
            Host name to connect to, defaults to the pod IP. You probably want to set
            "Host" in httpHeaders instead.
            """
            return self._set("host", value)

        @overload
        def http_headers(self, value_or_callback: List[HttpHeader], /) -> "HttpGet.Builder": ...

        @overload
        def http_headers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[HttpHeader, HttpHeader.Builder]],
                GenericListBuilder[HttpHeader, HttpHeader.Builder] | List[HttpHeader],
            ],
            /,
        ) -> "HttpGet.Builder": ...

        @overload
        def http_headers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[HttpHeader.Builder]: ...

        def http_headers(self, value_or_callback=None, /):
            """
            Custom headers to set in the request. HTTP allows repeated headers.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[HttpHeader.Builder]()
                context._parent_builder = self
                context._field_name = "http_headers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpHeader.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_headers", value)

        def path(self, value: Optional[str], /) -> Self:
            """
            Path to access on the HTTP server.
            """
            return self._set("path", value)

        def port(self, value: Union[int, str], /) -> Self:
            """
            Name or number of the port to access on the container.
            Number must be in the range 1 to 65535.
            Name must be an IANA_SVC_NAME.
            """
            return self._set("port", value)

        def scheme(self, value: Optional[str], /) -> Self:
            """
            Scheme to use for connecting to the host.
            Defaults to HTTP.
            """
            return self._set("scheme", value)

    class BuilderContext(BuilderContextBase["HttpGet.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HttpGet.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HttpGet."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HttpGet", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HttpGet.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    host: Optional[str] = None
    """
    Host name to connect to, defaults to the pod IP. You probably want to set
    "Host" in httpHeaders instead.
    """
    http_headers: Annotated[Optional[List[HttpHeader]], Field(alias="httpHeaders")] = None
    """
    Custom headers to set in the request. HTTP allows repeated headers.
    """
    path: Optional[str] = None
    """
    Path to access on the HTTP server.
    """
    port: Union[int, str]
    """
    Name or number of the port to access on the container.
    Number must be in the range 1 to 65535.
    Name must be an IANA_SVC_NAME.
    """
    scheme: Optional[str] = None
    """
    Scheme to use for connecting to the host.
    Defaults to HTTP.
    """


class Sleep(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Sleep"]:
            return Sleep

        def build(self) -> "Sleep":
            return Sleep(**self._attrs)

        def seconds(self, value: int, /) -> Self:
            """
            Seconds is the number of seconds to sleep.
            """
            return self._set("seconds", value)

    class BuilderContext(BuilderContextBase["Sleep.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Sleep.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Sleep."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Sleep", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Sleep.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    seconds: int
    """
    Seconds is the number of seconds to sleep.
    """


class TcpSocket(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TcpSocket"]:
            return TcpSocket

        def build(self) -> "TcpSocket":
            return TcpSocket(**self._attrs)

        def host(self, value: Optional[str], /) -> Self:
            """
            Optional: Host name to connect to, defaults to the pod IP.
            """
            return self._set("host", value)

        def port(self, value: Union[int, str], /) -> Self:
            """
            Number or name of the port to access on the container.
            Number must be in the range 1 to 65535.
            Name must be an IANA_SVC_NAME.
            """
            return self._set("port", value)

    class BuilderContext(BuilderContextBase["TcpSocket.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TcpSocket.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TcpSocket."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TcpSocket", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TcpSocket.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    host: Optional[str] = None
    """
    Optional: Host name to connect to, defaults to the pod IP.
    """
    port: Union[int, str]
    """
    Number or name of the port to access on the container.
    Number must be in the range 1 to 65535.
    Name must be an IANA_SVC_NAME.
    """


class PostStart(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PostStart"]:
            return PostStart

        def build(self) -> "PostStart":
            return PostStart(**self._attrs)

        @overload
        def exec(self, value_or_callback: Optional[Exec], /) -> "PostStart.Builder": ...

        @overload
        def exec(
            self, value_or_callback: Callable[[Exec.Builder], Exec.Builder | Exec], /
        ) -> "PostStart.Builder": ...

        @overload
        def exec(self, value_or_callback: Never = ...) -> "Exec.BuilderContext": ...

        def exec(self, value_or_callback=None, /):
            """
            Exec specifies a command to execute in the container.
            """
            if self._in_context and value_or_callback is None:
                context = Exec.BuilderContext()
                context._parent_builder = self
                context._field_name = "exec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exec.builder())
                if isinstance(output, Exec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exec", value)

        @overload
        def http_get(self, value_or_callback: Optional[HttpGet], /) -> "PostStart.Builder": ...

        @overload
        def http_get(
            self,
            value_or_callback: Callable[[HttpGet.Builder], HttpGet.Builder | HttpGet],
            /,
        ) -> "PostStart.Builder": ...

        @overload
        def http_get(self, value_or_callback: Never = ...) -> "HttpGet.BuilderContext": ...

        def http_get(self, value_or_callback=None, /):
            """
            HTTPGet specifies an HTTP GET request to perform.
            """
            if self._in_context and value_or_callback is None:
                context = HttpGet.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_get"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpGet.builder())
                if isinstance(output, HttpGet.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_get", value)

        @overload
        def sleep(self, value_or_callback: Optional[Sleep], /) -> "PostStart.Builder": ...

        @overload
        def sleep(
            self, value_or_callback: Callable[[Sleep.Builder], Sleep.Builder | Sleep], /
        ) -> "PostStart.Builder": ...

        @overload
        def sleep(self, value_or_callback: Never = ...) -> "Sleep.BuilderContext": ...

        def sleep(self, value_or_callback=None, /):
            """
            Sleep represents a duration that the container should sleep.
            """
            if self._in_context and value_or_callback is None:
                context = Sleep.BuilderContext()
                context._parent_builder = self
                context._field_name = "sleep"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sleep.builder())
                if isinstance(output, Sleep.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sleep", value)

        @overload
        def tcp_socket(self, value_or_callback: Optional[TcpSocket], /) -> "PostStart.Builder": ...

        @overload
        def tcp_socket(
            self,
            value_or_callback: Callable[[TcpSocket.Builder], TcpSocket.Builder | TcpSocket],
            /,
        ) -> "PostStart.Builder": ...

        @overload
        def tcp_socket(self, value_or_callback: Never = ...) -> "TcpSocket.BuilderContext": ...

        def tcp_socket(self, value_or_callback=None, /):
            """
            Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
            for backward compatibility. There is no validation of this field and
            lifecycle hooks will fail at runtime when it is specified.
            """
            if self._in_context and value_or_callback is None:
                context = TcpSocket.BuilderContext()
                context._parent_builder = self
                context._field_name = "tcp_socket"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TcpSocket.builder())
                if isinstance(output, TcpSocket.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tcp_socket", value)

    class BuilderContext(BuilderContextBase["PostStart.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PostStart.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PostStart."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PostStart", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PostStart.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exec: Optional[Exec] = None
    """
    Exec specifies a command to execute in the container.
    """
    http_get: Annotated[Optional[HttpGet], Field(alias="httpGet")] = None
    """
    HTTPGet specifies an HTTP GET request to perform.
    """
    sleep: Optional[Sleep] = None
    """
    Sleep represents a duration that the container should sleep.
    """
    tcp_socket: Annotated[Optional[TcpSocket], Field(alias="tcpSocket")] = None
    """
    Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    for backward compatibility. There is no validation of this field and
    lifecycle hooks will fail at runtime when it is specified.
    """


class PreStop(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PreStop"]:
            return PreStop

        def build(self) -> "PreStop":
            return PreStop(**self._attrs)

        @overload
        def exec(self, value_or_callback: Optional[Exec], /) -> "PreStop.Builder": ...

        @overload
        def exec(
            self, value_or_callback: Callable[[Exec.Builder], Exec.Builder | Exec], /
        ) -> "PreStop.Builder": ...

        @overload
        def exec(self, value_or_callback: Never = ...) -> "Exec.BuilderContext": ...

        def exec(self, value_or_callback=None, /):
            """
            Exec specifies a command to execute in the container.
            """
            if self._in_context and value_or_callback is None:
                context = Exec.BuilderContext()
                context._parent_builder = self
                context._field_name = "exec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exec.builder())
                if isinstance(output, Exec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exec", value)

        @overload
        def http_get(self, value_or_callback: Optional[HttpGet], /) -> "PreStop.Builder": ...

        @overload
        def http_get(
            self,
            value_or_callback: Callable[[HttpGet.Builder], HttpGet.Builder | HttpGet],
            /,
        ) -> "PreStop.Builder": ...

        @overload
        def http_get(self, value_or_callback: Never = ...) -> "HttpGet.BuilderContext": ...

        def http_get(self, value_or_callback=None, /):
            """
            HTTPGet specifies an HTTP GET request to perform.
            """
            if self._in_context and value_or_callback is None:
                context = HttpGet.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_get"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpGet.builder())
                if isinstance(output, HttpGet.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_get", value)

        @overload
        def sleep(self, value_or_callback: Optional[Sleep], /) -> "PreStop.Builder": ...

        @overload
        def sleep(
            self, value_or_callback: Callable[[Sleep.Builder], Sleep.Builder | Sleep], /
        ) -> "PreStop.Builder": ...

        @overload
        def sleep(self, value_or_callback: Never = ...) -> "Sleep.BuilderContext": ...

        def sleep(self, value_or_callback=None, /):
            """
            Sleep represents a duration that the container should sleep.
            """
            if self._in_context and value_or_callback is None:
                context = Sleep.BuilderContext()
                context._parent_builder = self
                context._field_name = "sleep"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sleep.builder())
                if isinstance(output, Sleep.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sleep", value)

        @overload
        def tcp_socket(self, value_or_callback: Optional[TcpSocket], /) -> "PreStop.Builder": ...

        @overload
        def tcp_socket(
            self,
            value_or_callback: Callable[[TcpSocket.Builder], TcpSocket.Builder | TcpSocket],
            /,
        ) -> "PreStop.Builder": ...

        @overload
        def tcp_socket(self, value_or_callback: Never = ...) -> "TcpSocket.BuilderContext": ...

        def tcp_socket(self, value_or_callback=None, /):
            """
            Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
            for backward compatibility. There is no validation of this field and
            lifecycle hooks will fail at runtime when it is specified.
            """
            if self._in_context and value_or_callback is None:
                context = TcpSocket.BuilderContext()
                context._parent_builder = self
                context._field_name = "tcp_socket"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TcpSocket.builder())
                if isinstance(output, TcpSocket.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tcp_socket", value)

    class BuilderContext(BuilderContextBase["PreStop.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PreStop.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PreStop."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PreStop", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PreStop.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exec: Optional[Exec] = None
    """
    Exec specifies a command to execute in the container.
    """
    http_get: Annotated[Optional[HttpGet], Field(alias="httpGet")] = None
    """
    HTTPGet specifies an HTTP GET request to perform.
    """
    sleep: Optional[Sleep] = None
    """
    Sleep represents a duration that the container should sleep.
    """
    tcp_socket: Annotated[Optional[TcpSocket], Field(alias="tcpSocket")] = None
    """
    Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    for backward compatibility. There is no validation of this field and
    lifecycle hooks will fail at runtime when it is specified.
    """


class Lifecycle(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Lifecycle"]:
            return Lifecycle

        def build(self) -> "Lifecycle":
            return Lifecycle(**self._attrs)

        @overload
        def post_start(self, value_or_callback: Optional[PostStart], /) -> "Lifecycle.Builder": ...

        @overload
        def post_start(
            self,
            value_or_callback: Callable[[PostStart.Builder], PostStart.Builder | PostStart],
            /,
        ) -> "Lifecycle.Builder": ...

        @overload
        def post_start(self, value_or_callback: Never = ...) -> "PostStart.BuilderContext": ...

        def post_start(self, value_or_callback=None, /):
            """
            PostStart is called immediately after a container is created. If the handler fails,
            the container is terminated and restarted according to its restart policy.
            Other management of the container blocks until the hook completes.
            More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
            """
            if self._in_context and value_or_callback is None:
                context = PostStart.BuilderContext()
                context._parent_builder = self
                context._field_name = "post_start"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PostStart.builder())
                if isinstance(output, PostStart.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("post_start", value)

        @overload
        def pre_stop(self, value_or_callback: Optional[PreStop], /) -> "Lifecycle.Builder": ...

        @overload
        def pre_stop(
            self,
            value_or_callback: Callable[[PreStop.Builder], PreStop.Builder | PreStop],
            /,
        ) -> "Lifecycle.Builder": ...

        @overload
        def pre_stop(self, value_or_callback: Never = ...) -> "PreStop.BuilderContext": ...

        def pre_stop(self, value_or_callback=None, /):
            """
            PreStop is called immediately before a container is terminated due to an
            API request or management event such as liveness/startup probe failure,
            preemption, resource contention, etc. The handler is not called if the
            container crashes or exits. The Pod's termination grace period countdown begins before the
            PreStop hook is executed. Regardless of the outcome of the handler, the
            container will eventually terminate within the Pod's termination grace
            period (unless delayed by finalizers). Other management of the container blocks until the hook completes
            or until the termination grace period is reached.
            More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
            """
            if self._in_context and value_or_callback is None:
                context = PreStop.BuilderContext()
                context._parent_builder = self
                context._field_name = "pre_stop"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PreStop.builder())
                if isinstance(output, PreStop.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("pre_stop", value)

    class BuilderContext(BuilderContextBase["Lifecycle.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Lifecycle.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Lifecycle."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Lifecycle", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Lifecycle.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    post_start: Annotated[Optional[PostStart], Field(alias="postStart")] = None
    """
    PostStart is called immediately after a container is created. If the handler fails,
    the container is terminated and restarted according to its restart policy.
    Other management of the container blocks until the hook completes.
    More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
    """
    pre_stop: Annotated[Optional[PreStop], Field(alias="preStop")] = None
    """
    PreStop is called immediately before a container is terminated due to an
    API request or management event such as liveness/startup probe failure,
    preemption, resource contention, etc. The handler is not called if the
    container crashes or exits. The Pod's termination grace period countdown begins before the
    PreStop hook is executed. Regardless of the outcome of the handler, the
    container will eventually terminate within the Pod's termination grace
    period (unless delayed by finalizers). Other management of the container blocks until the hook completes
    or until the termination grace period is reached.
    More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
    """


class Grpc(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Grpc"]:
            return Grpc

        def build(self) -> "Grpc":
            return Grpc(**self._attrs)

        def port(self, value: int, /) -> Self:
            """
            Port number of the gRPC service. Number must be in the range 1 to 65535.
            """
            return self._set("port", value)

        def service(self, value: Optional[str], /) -> Self:
            """
            Service is the name of the service to place in the gRPC HealthCheckRequest
            (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).

            If this is not specified, the default behavior is defined by gRPC.
            """
            return self._set("service", value)

    class BuilderContext(BuilderContextBase["Grpc.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Grpc.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Grpc."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Grpc", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Grpc.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    port: int
    """
    Port number of the gRPC service. Number must be in the range 1 to 65535.
    """
    service: Optional[str] = ""
    """
    Service is the name of the service to place in the gRPC HealthCheckRequest
    (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).

    If this is not specified, the default behavior is defined by gRPC.
    """


class LivenessProbe(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LivenessProbe"]:
            return LivenessProbe

        def build(self) -> "LivenessProbe":
            return LivenessProbe(**self._attrs)

        @overload
        def exec(self, value_or_callback: Optional[Exec], /) -> "LivenessProbe.Builder": ...

        @overload
        def exec(
            self, value_or_callback: Callable[[Exec.Builder], Exec.Builder | Exec], /
        ) -> "LivenessProbe.Builder": ...

        @overload
        def exec(self, value_or_callback: Never = ...) -> "Exec.BuilderContext": ...

        def exec(self, value_or_callback=None, /):
            """
            Exec specifies a command to execute in the container.
            """
            if self._in_context and value_or_callback is None:
                context = Exec.BuilderContext()
                context._parent_builder = self
                context._field_name = "exec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exec.builder())
                if isinstance(output, Exec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exec", value)

        def failure_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive failures for the probe to be considered failed after having succeeded.
            Defaults to 3. Minimum value is 1.
            """
            return self._set("failure_threshold", value)

        @overload
        def grpc(self, value_or_callback: Optional[Grpc], /) -> "LivenessProbe.Builder": ...

        @overload
        def grpc(
            self, value_or_callback: Callable[[Grpc.Builder], Grpc.Builder | Grpc], /
        ) -> "LivenessProbe.Builder": ...

        @overload
        def grpc(self, value_or_callback: Never = ...) -> "Grpc.BuilderContext": ...

        def grpc(self, value_or_callback=None, /):
            """
            GRPC specifies a GRPC HealthCheckRequest.
            """
            if self._in_context and value_or_callback is None:
                context = Grpc.BuilderContext()
                context._parent_builder = self
                context._field_name = "grpc"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Grpc.builder())
                if isinstance(output, Grpc.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("grpc", value)

        @overload
        def http_get(self, value_or_callback: Optional[HttpGet], /) -> "LivenessProbe.Builder": ...

        @overload
        def http_get(
            self,
            value_or_callback: Callable[[HttpGet.Builder], HttpGet.Builder | HttpGet],
            /,
        ) -> "LivenessProbe.Builder": ...

        @overload
        def http_get(self, value_or_callback: Never = ...) -> "HttpGet.BuilderContext": ...

        def http_get(self, value_or_callback=None, /):
            """
            HTTPGet specifies an HTTP GET request to perform.
            """
            if self._in_context and value_or_callback is None:
                context = HttpGet.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_get"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpGet.builder())
                if isinstance(output, HttpGet.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_get", value)

        def initial_delay_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after the container has started before liveness probes are initiated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            return self._set("initial_delay_seconds", value)

        def period_seconds(self, value: Optional[int], /) -> Self:
            """
            How often (in seconds) to perform the probe.
            Default to 10 seconds. Minimum value is 1.
            """
            return self._set("period_seconds", value)

        def success_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive successes for the probe to be considered successful after having failed.
            Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
            """
            return self._set("success_threshold", value)

        @overload
        def tcp_socket(
            self, value_or_callback: Optional[TcpSocket], /
        ) -> "LivenessProbe.Builder": ...

        @overload
        def tcp_socket(
            self,
            value_or_callback: Callable[[TcpSocket.Builder], TcpSocket.Builder | TcpSocket],
            /,
        ) -> "LivenessProbe.Builder": ...

        @overload
        def tcp_socket(self, value_or_callback: Never = ...) -> "TcpSocket.BuilderContext": ...

        def tcp_socket(self, value_or_callback=None, /):
            """
            TCPSocket specifies a connection to a TCP port.
            """
            if self._in_context and value_or_callback is None:
                context = TcpSocket.BuilderContext()
                context._parent_builder = self
                context._field_name = "tcp_socket"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TcpSocket.builder())
                if isinstance(output, TcpSocket.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tcp_socket", value)

        def termination_grace_period_seconds(self, value: Optional[int], /) -> Self:
            """
            Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
            The grace period is the duration in seconds after the processes running in the pod are sent
            a termination signal and the time when the processes are forcibly halted with a kill signal.
            Set this value longer than the expected cleanup time for your process.
            If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
            value overrides the value provided by the pod spec.
            Value must be non-negative integer. The value zero indicates stop immediately via
            the kill signal (no opportunity to shut down).
            This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
            Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
            """
            return self._set("termination_grace_period_seconds", value)

        def timeout_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after which the probe times out.
            Defaults to 1 second. Minimum value is 1.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            return self._set("timeout_seconds", value)

    class BuilderContext(BuilderContextBase["LivenessProbe.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LivenessProbe.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LivenessProbe."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LivenessProbe", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LivenessProbe.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exec: Optional[Exec] = None
    """
    Exec specifies a command to execute in the container.
    """
    failure_threshold: Annotated[Optional[int], Field(alias="failureThreshold")] = None
    """
    Minimum consecutive failures for the probe to be considered failed after having succeeded.
    Defaults to 3. Minimum value is 1.
    """
    grpc: Optional[Grpc] = None
    """
    GRPC specifies a GRPC HealthCheckRequest.
    """
    http_get: Annotated[Optional[HttpGet], Field(alias="httpGet")] = None
    """
    HTTPGet specifies an HTTP GET request to perform.
    """
    initial_delay_seconds: Annotated[Optional[int], Field(alias="initialDelaySeconds")] = None
    """
    Number of seconds after the container has started before liveness probes are initiated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    period_seconds: Annotated[Optional[int], Field(alias="periodSeconds")] = None
    """
    How often (in seconds) to perform the probe.
    Default to 10 seconds. Minimum value is 1.
    """
    success_threshold: Annotated[Optional[int], Field(alias="successThreshold")] = None
    """
    Minimum consecutive successes for the probe to be considered successful after having failed.
    Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    """
    tcp_socket: Annotated[Optional[TcpSocket], Field(alias="tcpSocket")] = None
    """
    TCPSocket specifies a connection to a TCP port.
    """
    termination_grace_period_seconds: Annotated[
        Optional[int], Field(alias="terminationGracePeriodSeconds")
    ] = None
    """
    Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    The grace period is the duration in seconds after the processes running in the pod are sent
    a termination signal and the time when the processes are forcibly halted with a kill signal.
    Set this value longer than the expected cleanup time for your process.
    If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    value overrides the value provided by the pod spec.
    Value must be non-negative integer. The value zero indicates stop immediately via
    the kill signal (no opportunity to shut down).
    This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    """
    timeout_seconds: Annotated[Optional[int], Field(alias="timeoutSeconds")] = None
    """
    Number of seconds after which the probe times out.
    Defaults to 1 second. Minimum value is 1.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """


class Port(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Port"]:
            return Port

        def build(self) -> "Port":
            return Port(**self._attrs)

        def container_port(self, value: int, /) -> Self:
            """
            Number of port to expose on the pod's IP address.
            This must be a valid port number, 0 < x < 65536.
            """
            return self._set("container_port", value)

        def host_ip(self, value: Optional[str], /) -> Self:
            """
            What host IP to bind the external port to.
            """
            return self._set("host_ip", value)

        def host_port(self, value: Optional[int], /) -> Self:
            """
            Number of port to expose on the host.
            If specified, this must be a valid port number, 0 < x < 65536.
            If HostNetwork is specified, this must match ContainerPort.
            Most containers do not need this.
            """
            return self._set("host_port", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
            named port in a pod must have a unique name. Name for the port that can be
            referred to by services.
            """
            return self._set("name", value)

        def protocol(self, value: Optional[str], /) -> Self:
            """
            Protocol for port. Must be UDP, TCP, or SCTP.
            Defaults to "TCP".
            """
            return self._set("protocol", value)

    class BuilderContext(BuilderContextBase["Port.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Port.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Port."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Port", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Port.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    container_port: Annotated[int, Field(alias="containerPort")]
    """
    Number of port to expose on the pod's IP address.
    This must be a valid port number, 0 < x < 65536.
    """
    host_ip: Annotated[Optional[str], Field(alias="hostIP")] = None
    """
    What host IP to bind the external port to.
    """
    host_port: Annotated[Optional[int], Field(alias="hostPort")] = None
    """
    Number of port to expose on the host.
    If specified, this must be a valid port number, 0 < x < 65536.
    If HostNetwork is specified, this must match ContainerPort.
    Most containers do not need this.
    """
    name: Optional[str] = None
    """
    If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
    named port in a pod must have a unique name. Name for the port that can be
    referred to by services.
    """
    protocol: Optional[str] = "TCP"
    """
    Protocol for port. Must be UDP, TCP, or SCTP.
    Defaults to "TCP".
    """


class ReadinessProbe(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ReadinessProbe"]:
            return ReadinessProbe

        def build(self) -> "ReadinessProbe":
            return ReadinessProbe(**self._attrs)

        @overload
        def exec(self, value_or_callback: Optional[Exec], /) -> "ReadinessProbe.Builder": ...

        @overload
        def exec(
            self, value_or_callback: Callable[[Exec.Builder], Exec.Builder | Exec], /
        ) -> "ReadinessProbe.Builder": ...

        @overload
        def exec(self, value_or_callback: Never = ...) -> "Exec.BuilderContext": ...

        def exec(self, value_or_callback=None, /):
            """
            Exec specifies a command to execute in the container.
            """
            if self._in_context and value_or_callback is None:
                context = Exec.BuilderContext()
                context._parent_builder = self
                context._field_name = "exec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exec.builder())
                if isinstance(output, Exec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exec", value)

        def failure_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive failures for the probe to be considered failed after having succeeded.
            Defaults to 3. Minimum value is 1.
            """
            return self._set("failure_threshold", value)

        @overload
        def grpc(self, value_or_callback: Optional[Grpc], /) -> "ReadinessProbe.Builder": ...

        @overload
        def grpc(
            self, value_or_callback: Callable[[Grpc.Builder], Grpc.Builder | Grpc], /
        ) -> "ReadinessProbe.Builder": ...

        @overload
        def grpc(self, value_or_callback: Never = ...) -> "Grpc.BuilderContext": ...

        def grpc(self, value_or_callback=None, /):
            """
            GRPC specifies a GRPC HealthCheckRequest.
            """
            if self._in_context and value_or_callback is None:
                context = Grpc.BuilderContext()
                context._parent_builder = self
                context._field_name = "grpc"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Grpc.builder())
                if isinstance(output, Grpc.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("grpc", value)

        @overload
        def http_get(self, value_or_callback: Optional[HttpGet], /) -> "ReadinessProbe.Builder": ...

        @overload
        def http_get(
            self,
            value_or_callback: Callable[[HttpGet.Builder], HttpGet.Builder | HttpGet],
            /,
        ) -> "ReadinessProbe.Builder": ...

        @overload
        def http_get(self, value_or_callback: Never = ...) -> "HttpGet.BuilderContext": ...

        def http_get(self, value_or_callback=None, /):
            """
            HTTPGet specifies an HTTP GET request to perform.
            """
            if self._in_context and value_or_callback is None:
                context = HttpGet.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_get"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpGet.builder())
                if isinstance(output, HttpGet.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_get", value)

        def initial_delay_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after the container has started before liveness probes are initiated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            return self._set("initial_delay_seconds", value)

        def period_seconds(self, value: Optional[int], /) -> Self:
            """
            How often (in seconds) to perform the probe.
            Default to 10 seconds. Minimum value is 1.
            """
            return self._set("period_seconds", value)

        def success_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive successes for the probe to be considered successful after having failed.
            Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
            """
            return self._set("success_threshold", value)

        @overload
        def tcp_socket(
            self, value_or_callback: Optional[TcpSocket], /
        ) -> "ReadinessProbe.Builder": ...

        @overload
        def tcp_socket(
            self,
            value_or_callback: Callable[[TcpSocket.Builder], TcpSocket.Builder | TcpSocket],
            /,
        ) -> "ReadinessProbe.Builder": ...

        @overload
        def tcp_socket(self, value_or_callback: Never = ...) -> "TcpSocket.BuilderContext": ...

        def tcp_socket(self, value_or_callback=None, /):
            """
            TCPSocket specifies a connection to a TCP port.
            """
            if self._in_context and value_or_callback is None:
                context = TcpSocket.BuilderContext()
                context._parent_builder = self
                context._field_name = "tcp_socket"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TcpSocket.builder())
                if isinstance(output, TcpSocket.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tcp_socket", value)

        def termination_grace_period_seconds(self, value: Optional[int], /) -> Self:
            """
            Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
            The grace period is the duration in seconds after the processes running in the pod are sent
            a termination signal and the time when the processes are forcibly halted with a kill signal.
            Set this value longer than the expected cleanup time for your process.
            If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
            value overrides the value provided by the pod spec.
            Value must be non-negative integer. The value zero indicates stop immediately via
            the kill signal (no opportunity to shut down).
            This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
            Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
            """
            return self._set("termination_grace_period_seconds", value)

        def timeout_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after which the probe times out.
            Defaults to 1 second. Minimum value is 1.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            return self._set("timeout_seconds", value)

    class BuilderContext(BuilderContextBase["ReadinessProbe.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ReadinessProbe.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ReadinessProbe."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ReadinessProbe", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ReadinessProbe.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exec: Optional[Exec] = None
    """
    Exec specifies a command to execute in the container.
    """
    failure_threshold: Annotated[Optional[int], Field(alias="failureThreshold")] = None
    """
    Minimum consecutive failures for the probe to be considered failed after having succeeded.
    Defaults to 3. Minimum value is 1.
    """
    grpc: Optional[Grpc] = None
    """
    GRPC specifies a GRPC HealthCheckRequest.
    """
    http_get: Annotated[Optional[HttpGet], Field(alias="httpGet")] = None
    """
    HTTPGet specifies an HTTP GET request to perform.
    """
    initial_delay_seconds: Annotated[Optional[int], Field(alias="initialDelaySeconds")] = None
    """
    Number of seconds after the container has started before liveness probes are initiated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    period_seconds: Annotated[Optional[int], Field(alias="periodSeconds")] = None
    """
    How often (in seconds) to perform the probe.
    Default to 10 seconds. Minimum value is 1.
    """
    success_threshold: Annotated[Optional[int], Field(alias="successThreshold")] = None
    """
    Minimum consecutive successes for the probe to be considered successful after having failed.
    Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    """
    tcp_socket: Annotated[Optional[TcpSocket], Field(alias="tcpSocket")] = None
    """
    TCPSocket specifies a connection to a TCP port.
    """
    termination_grace_period_seconds: Annotated[
        Optional[int], Field(alias="terminationGracePeriodSeconds")
    ] = None
    """
    Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    The grace period is the duration in seconds after the processes running in the pod are sent
    a termination signal and the time when the processes are forcibly halted with a kill signal.
    Set this value longer than the expected cleanup time for your process.
    If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    value overrides the value provided by the pod spec.
    Value must be non-negative integer. The value zero indicates stop immediately via
    the kill signal (no opportunity to shut down).
    This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    """
    timeout_seconds: Annotated[Optional[int], Field(alias="timeoutSeconds")] = None
    """
    Number of seconds after which the probe times out.
    Defaults to 1 second. Minimum value is 1.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """


class ResizePolicy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResizePolicy"]:
            return ResizePolicy

        def build(self) -> "ResizePolicy":
            return ResizePolicy(**self._attrs)

        def resource_name(self, value: str, /) -> Self:
            """
            Name of the resource to which this resource resize policy applies.
            Supported values: cpu, memory.
            """
            return self._set("resource_name", value)

        def restart_policy(self, value: str, /) -> Self:
            """
            Restart policy to apply when specified resource is resized.
            If not specified, it defaults to NotRequired.
            """
            return self._set("restart_policy", value)

    class BuilderContext(BuilderContextBase["ResizePolicy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResizePolicy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResizePolicy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResizePolicy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResizePolicy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    resource_name: Annotated[str, Field(alias="resourceName")]
    """
    Name of the resource to which this resource resize policy applies.
    Supported values: cpu, memory.
    """
    restart_policy: Annotated[str, Field(alias="restartPolicy")]
    """
    Restart policy to apply when specified resource is resized.
    If not specified, it defaults to NotRequired.
    """


class Claim(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Claim"]:
            return Claim

        def build(self) -> "Claim":
            return Claim(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name must match the name of one entry in pod.spec.resourceClaims of
            the Pod where this field is used. It makes that resource available
            inside a container.
            """
            return self._set("name", value)

        def request(self, value: Optional[str], /) -> Self:
            """
            Request is the name chosen for a request in the referenced claim.
            If empty, everything from the claim is made available, otherwise
            only the result of this request.
            """
            return self._set("request", value)

    class BuilderContext(BuilderContextBase["Claim.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Claim.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Claim."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Claim", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Claim.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name must match the name of one entry in pod.spec.resourceClaims of
    the Pod where this field is used. It makes that resource available
    inside a container.
    """
    request: Optional[str] = None
    """
    Request is the name chosen for a request in the referenced claim.
    If empty, everything from the claim is made available, otherwise
    only the result of this request.
    """


class Limits(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "Limits":
            value = cast(int, self._value)
            return Limits(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["Limits.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Limits.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Limits."""
        return cls.BuilderContext()


class LimitsModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel":
            value = cast(str, self._value)
            return LimitsModel(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel."""
        return cls.BuilderContext()


class Requests(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "Requests":
            value = cast(int, self._value)
            return Requests(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["Requests.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Requests.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Requests."""
        return cls.BuilderContext()


class RequestsModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel":
            value = cast(str, self._value)
            return RequestsModel(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel."""
        return cls.BuilderContext()


class Resources(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Resources"]:
            return Resources

        def build(self) -> "Resources":
            return Resources(**self._attrs)

        @overload
        def claims(self, value_or_callback: List[Claim], /) -> "Resources.Builder": ...

        @overload
        def claims(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Claim, Claim.Builder]],
                GenericListBuilder[Claim, Claim.Builder] | List[Claim],
            ],
            /,
        ) -> "Resources.Builder": ...

        @overload
        def claims(self, value_or_callback: Never = ...) -> ListBuilderContext[Claim.Builder]: ...

        def claims(self, value_or_callback=None, /):
            """
            Claims lists the names of resources, defined in spec.resourceClaims,
            that are used by this container.

            This is an alpha field and requires enabling the
            DynamicResourceAllocation feature gate.

            This field is immutable. It can only be set for containers.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Claim.Builder]()
                context._parent_builder = self
                context._field_name = "claims"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Claim.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("claims", value)

        def limits(self, value: Optional[Dict[str, Union[Limits, LimitsModel]]], /) -> Self:
            """
            Limits describes the maximum amount of compute resources allowed.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            return self._set("limits", value)

        def requests(self, value: Optional[Dict[str, Union[Requests, RequestsModel]]], /) -> Self:
            """
            Requests describes the minimum amount of compute resources required.
            If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
            otherwise to an implementation-defined value. Requests cannot exceed Limits.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            return self._set("requests", value)

    class BuilderContext(BuilderContextBase["Resources.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Resources.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Resources."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Resources", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Resources.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    claims: Optional[List[Claim]] = None
    """
    Claims lists the names of resources, defined in spec.resourceClaims,
    that are used by this container.

    This is an alpha field and requires enabling the
    DynamicResourceAllocation feature gate.

    This field is immutable. It can only be set for containers.
    """
    limits: Optional[Dict[str, Union[Limits, LimitsModel]]] = None
    """
    Limits describes the maximum amount of compute resources allowed.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """
    requests: Optional[Dict[str, Union[Requests, RequestsModel]]] = None
    """
    Requests describes the minimum amount of compute resources required.
    If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    otherwise to an implementation-defined value. Requests cannot exceed Limits.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """


class AppArmorProfile(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AppArmorProfile"]:
            return AppArmorProfile

        def build(self) -> "AppArmorProfile":
            return AppArmorProfile(**self._attrs)

        def localhost_profile(self, value: Optional[str], /) -> Self:
            """
            localhostProfile indicates a profile loaded on the node that should be used.
            The profile must be preconfigured on the node to work.
            Must match the loaded name of the profile.
            Must be set if and only if type is "Localhost".
            """
            return self._set("localhost_profile", value)

        def type(self, value: str, /) -> Self:
            """
            type indicates which kind of AppArmor profile will be applied.
            Valid options are:
              Localhost - a profile pre-loaded on the node.
              RuntimeDefault - the container runtime's default profile.
              Unconfined - no AppArmor enforcement.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["AppArmorProfile.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AppArmorProfile.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AppArmorProfile."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AppArmorProfile", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AppArmorProfile.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    localhost_profile: Annotated[Optional[str], Field(alias="localhostProfile")] = None
    """
    localhostProfile indicates a profile loaded on the node that should be used.
    The profile must be preconfigured on the node to work.
    Must match the loaded name of the profile.
    Must be set if and only if type is "Localhost".
    """
    type: str
    """
    type indicates which kind of AppArmor profile will be applied.
    Valid options are:
      Localhost - a profile pre-loaded on the node.
      RuntimeDefault - the container runtime's default profile.
      Unconfined - no AppArmor enforcement.
    """


class Capabilities(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Capabilities"]:
            return Capabilities

        def build(self) -> "Capabilities":
            return Capabilities(**self._attrs)

        def add(self, value: Optional[List[str]], /) -> Self:
            """
            Added capabilities
            """
            return self._set("add", value)

        def drop(self, value: Optional[List[str]], /) -> Self:
            """
            Removed capabilities
            """
            return self._set("drop", value)

    class BuilderContext(BuilderContextBase["Capabilities.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Capabilities.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Capabilities."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Capabilities", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Capabilities.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    add: Optional[List[str]] = None
    """
    Added capabilities
    """
    drop: Optional[List[str]] = None
    """
    Removed capabilities
    """


class SeLinuxOptions(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SeLinuxOptions"]:
            return SeLinuxOptions

        def build(self) -> "SeLinuxOptions":
            return SeLinuxOptions(**self._attrs)

        def level(self, value: Optional[str], /) -> Self:
            """
            Level is SELinux level label that applies to the container.
            """
            return self._set("level", value)

        def role(self, value: Optional[str], /) -> Self:
            """
            Role is a SELinux role label that applies to the container.
            """
            return self._set("role", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Type is a SELinux type label that applies to the container.
            """
            return self._set("type", value)

        def user(self, value: Optional[str], /) -> Self:
            """
            User is a SELinux user label that applies to the container.
            """
            return self._set("user", value)

    class BuilderContext(BuilderContextBase["SeLinuxOptions.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SeLinuxOptions.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SeLinuxOptions."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SeLinuxOptions", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SeLinuxOptions.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    level: Optional[str] = None
    """
    Level is SELinux level label that applies to the container.
    """
    role: Optional[str] = None
    """
    Role is a SELinux role label that applies to the container.
    """
    type: Optional[str] = None
    """
    Type is a SELinux type label that applies to the container.
    """
    user: Optional[str] = None
    """
    User is a SELinux user label that applies to the container.
    """


class SeccompProfile(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SeccompProfile"]:
            return SeccompProfile

        def build(self) -> "SeccompProfile":
            return SeccompProfile(**self._attrs)

        def localhost_profile(self, value: Optional[str], /) -> Self:
            """
            localhostProfile indicates a profile defined in a file on the node should be used.
            The profile must be preconfigured on the node to work.
            Must be a descending path, relative to the kubelet's configured seccomp profile location.
            Must be set if type is "Localhost". Must NOT be set for any other type.
            """
            return self._set("localhost_profile", value)

        def type(self, value: str, /) -> Self:
            """
            type indicates which kind of seccomp profile will be applied.
            Valid options are:

            Localhost - a profile defined in a file on the node should be used.
            RuntimeDefault - the container runtime default profile should be used.
            Unconfined - no profile should be applied.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["SeccompProfile.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SeccompProfile.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SeccompProfile."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SeccompProfile", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SeccompProfile.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    localhost_profile: Annotated[Optional[str], Field(alias="localhostProfile")] = None
    """
    localhostProfile indicates a profile defined in a file on the node should be used.
    The profile must be preconfigured on the node to work.
    Must be a descending path, relative to the kubelet's configured seccomp profile location.
    Must be set if type is "Localhost". Must NOT be set for any other type.
    """
    type: str
    """
    type indicates which kind of seccomp profile will be applied.
    Valid options are:

    Localhost - a profile defined in a file on the node should be used.
    RuntimeDefault - the container runtime default profile should be used.
    Unconfined - no profile should be applied.
    """


class WindowsOptions(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WindowsOptions"]:
            return WindowsOptions

        def build(self) -> "WindowsOptions":
            return WindowsOptions(**self._attrs)

        def gmsa_credential_spec(self, value: Optional[str], /) -> Self:
            """
            GMSACredentialSpec is where the GMSA admission webhook
            (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
            GMSA credential spec named by the GMSACredentialSpecName field.
            """
            return self._set("gmsa_credential_spec", value)

        def gmsa_credential_spec_name(self, value: Optional[str], /) -> Self:
            """
            GMSACredentialSpecName is the name of the GMSA credential spec to use.
            """
            return self._set("gmsa_credential_spec_name", value)

        def host_process(self, value: Optional[bool], /) -> Self:
            """
            HostProcess determines if a container should be run as a 'Host Process' container.
            All of a Pod's containers must have the same effective HostProcess value
            (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
            In addition, if HostProcess is true then HostNetwork must also be set to true.
            """
            return self._set("host_process", value)

        def run_as_user_name(self, value: Optional[str], /) -> Self:
            """
            The UserName in Windows to run the entrypoint of the container process.
            Defaults to the user specified in image metadata if unspecified.
            May also be set in PodSecurityContext. If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            """
            return self._set("run_as_user_name", value)

    class BuilderContext(BuilderContextBase["WindowsOptions.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WindowsOptions.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WindowsOptions."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WindowsOptions", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WindowsOptions.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    gmsa_credential_spec: Annotated[Optional[str], Field(alias="gmsaCredentialSpec")] = None
    """
    GMSACredentialSpec is where the GMSA admission webhook
    (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
    GMSA credential spec named by the GMSACredentialSpecName field.
    """
    gmsa_credential_spec_name: Annotated[Optional[str], Field(alias="gmsaCredentialSpecName")] = (
        None
    )
    """
    GMSACredentialSpecName is the name of the GMSA credential spec to use.
    """
    host_process: Annotated[Optional[bool], Field(alias="hostProcess")] = None
    """
    HostProcess determines if a container should be run as a 'Host Process' container.
    All of a Pod's containers must have the same effective HostProcess value
    (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
    In addition, if HostProcess is true then HostNetwork must also be set to true.
    """
    run_as_user_name: Annotated[Optional[str], Field(alias="runAsUserName")] = None
    """
    The UserName in Windows to run the entrypoint of the container process.
    Defaults to the user specified in image metadata if unspecified.
    May also be set in PodSecurityContext. If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    """


class SecurityContext(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecurityContext"]:
            return SecurityContext

        def build(self) -> "SecurityContext":
            return SecurityContext(**self._attrs)

        def allow_privilege_escalation(self, value: Optional[bool], /) -> Self:
            """
            AllowPrivilegeEscalation controls whether a process can gain more
            privileges than its parent process. This bool directly controls if
            the no_new_privs flag will be set on the container process.
            AllowPrivilegeEscalation is true always when the container is:
            1) run as Privileged
            2) has CAP_SYS_ADMIN
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("allow_privilege_escalation", value)

        @overload
        def app_armor_profile(
            self, value_or_callback: Optional[AppArmorProfile], /
        ) -> "SecurityContext.Builder": ...

        @overload
        def app_armor_profile(
            self,
            value_or_callback: Callable[
                [AppArmorProfile.Builder], AppArmorProfile.Builder | AppArmorProfile
            ],
            /,
        ) -> "SecurityContext.Builder": ...

        @overload
        def app_armor_profile(
            self, value_or_callback: Never = ...
        ) -> "AppArmorProfile.BuilderContext": ...

        def app_armor_profile(self, value_or_callback=None, /):
            """
            appArmorProfile is the AppArmor options to use by this container. If set, this profile
            overrides the pod's appArmorProfile.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = AppArmorProfile.BuilderContext()
                context._parent_builder = self
                context._field_name = "app_armor_profile"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AppArmorProfile.builder())
                if isinstance(output, AppArmorProfile.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("app_armor_profile", value)

        @overload
        def capabilities(
            self, value_or_callback: Optional[Capabilities], /
        ) -> "SecurityContext.Builder": ...

        @overload
        def capabilities(
            self,
            value_or_callback: Callable[
                [Capabilities.Builder], Capabilities.Builder | Capabilities
            ],
            /,
        ) -> "SecurityContext.Builder": ...

        @overload
        def capabilities(self, value_or_callback: Never = ...) -> "Capabilities.BuilderContext": ...

        def capabilities(self, value_or_callback=None, /):
            """
            The capabilities to add/drop when running containers.
            Defaults to the default set of capabilities granted by the container runtime.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = Capabilities.BuilderContext()
                context._parent_builder = self
                context._field_name = "capabilities"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Capabilities.builder())
                if isinstance(output, Capabilities.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("capabilities", value)

        def privileged(self, value: Optional[bool], /) -> Self:
            """
            Run container in privileged mode.
            Processes in privileged containers are essentially equivalent to root on the host.
            Defaults to false.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("privileged", value)

        def proc_mount(self, value: Optional[str], /) -> Self:
            """
            procMount denotes the type of proc mount to use for the containers.
            The default value is Default which uses the container runtime defaults for
            readonly paths and masked paths.
            This requires the ProcMountType feature flag to be enabled.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("proc_mount", value)

        def read_only_root_filesystem(self, value: Optional[bool], /) -> Self:
            """
            Whether this container has a read-only root filesystem.
            Default is false.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("read_only_root_filesystem", value)

        def run_as_group(self, value: Optional[int], /) -> Self:
            """
            The GID to run the entrypoint of the container process.
            Uses runtime default if unset.
            May also be set in PodSecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("run_as_group", value)

        def run_as_non_root(self, value: Optional[bool], /) -> Self:
            """
            Indicates that the container must run as a non-root user.
            If true, the Kubelet will validate the image at runtime to ensure that it
            does not run as UID 0 (root) and fail to start the container if it does.
            If unset or false, no such validation will be performed.
            May also be set in PodSecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            """
            return self._set("run_as_non_root", value)

        def run_as_user(self, value: Optional[int], /) -> Self:
            """
            The UID to run the entrypoint of the container process.
            Defaults to user specified in image metadata if unspecified.
            May also be set in PodSecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("run_as_user", value)

        @overload
        def se_linux_options(
            self, value_or_callback: Optional[SeLinuxOptions], /
        ) -> "SecurityContext.Builder": ...

        @overload
        def se_linux_options(
            self,
            value_or_callback: Callable[
                [SeLinuxOptions.Builder], SeLinuxOptions.Builder | SeLinuxOptions
            ],
            /,
        ) -> "SecurityContext.Builder": ...

        @overload
        def se_linux_options(
            self, value_or_callback: Never = ...
        ) -> "SeLinuxOptions.BuilderContext": ...

        def se_linux_options(self, value_or_callback=None, /):
            """
            The SELinux context to be applied to the container.
            If unspecified, the container runtime will allocate a random SELinux context for each
            container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = SeLinuxOptions.BuilderContext()
                context._parent_builder = self
                context._field_name = "se_linux_options"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SeLinuxOptions.builder())
                if isinstance(output, SeLinuxOptions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("se_linux_options", value)

        @overload
        def seccomp_profile(
            self, value_or_callback: Optional[SeccompProfile], /
        ) -> "SecurityContext.Builder": ...

        @overload
        def seccomp_profile(
            self,
            value_or_callback: Callable[
                [SeccompProfile.Builder], SeccompProfile.Builder | SeccompProfile
            ],
            /,
        ) -> "SecurityContext.Builder": ...

        @overload
        def seccomp_profile(
            self, value_or_callback: Never = ...
        ) -> "SeccompProfile.BuilderContext": ...

        def seccomp_profile(self, value_or_callback=None, /):
            """
            The seccomp options to use by this container. If seccomp options are
            provided at both the pod & container level, the container options
            override the pod options.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = SeccompProfile.BuilderContext()
                context._parent_builder = self
                context._field_name = "seccomp_profile"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SeccompProfile.builder())
                if isinstance(output, SeccompProfile.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("seccomp_profile", value)

        @overload
        def windows_options(
            self, value_or_callback: Optional[WindowsOptions], /
        ) -> "SecurityContext.Builder": ...

        @overload
        def windows_options(
            self,
            value_or_callback: Callable[
                [WindowsOptions.Builder], WindowsOptions.Builder | WindowsOptions
            ],
            /,
        ) -> "SecurityContext.Builder": ...

        @overload
        def windows_options(
            self, value_or_callback: Never = ...
        ) -> "WindowsOptions.BuilderContext": ...

        def windows_options(self, value_or_callback=None, /):
            """
            The Windows specific settings applied to all containers.
            If unspecified, the options from the PodSecurityContext will be used.
            If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
            Note that this field cannot be set when spec.os.name is linux.
            """
            if self._in_context and value_or_callback is None:
                context = WindowsOptions.BuilderContext()
                context._parent_builder = self
                context._field_name = "windows_options"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WindowsOptions.builder())
                if isinstance(output, WindowsOptions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("windows_options", value)

    class BuilderContext(BuilderContextBase["SecurityContext.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecurityContext.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecurityContext."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecurityContext", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecurityContext.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    allow_privilege_escalation: Annotated[
        Optional[bool], Field(alias="allowPrivilegeEscalation")
    ] = None
    """
    AllowPrivilegeEscalation controls whether a process can gain more
    privileges than its parent process. This bool directly controls if
    the no_new_privs flag will be set on the container process.
    AllowPrivilegeEscalation is true always when the container is:
    1) run as Privileged
    2) has CAP_SYS_ADMIN
    Note that this field cannot be set when spec.os.name is windows.
    """
    app_armor_profile: Annotated[Optional[AppArmorProfile], Field(alias="appArmorProfile")] = None
    """
    appArmorProfile is the AppArmor options to use by this container. If set, this profile
    overrides the pod's appArmorProfile.
    Note that this field cannot be set when spec.os.name is windows.
    """
    capabilities: Optional[Capabilities] = None
    """
    The capabilities to add/drop when running containers.
    Defaults to the default set of capabilities granted by the container runtime.
    Note that this field cannot be set when spec.os.name is windows.
    """
    privileged: Optional[bool] = None
    """
    Run container in privileged mode.
    Processes in privileged containers are essentially equivalent to root on the host.
    Defaults to false.
    Note that this field cannot be set when spec.os.name is windows.
    """
    proc_mount: Annotated[Optional[str], Field(alias="procMount")] = None
    """
    procMount denotes the type of proc mount to use for the containers.
    The default value is Default which uses the container runtime defaults for
    readonly paths and masked paths.
    This requires the ProcMountType feature flag to be enabled.
    Note that this field cannot be set when spec.os.name is windows.
    """
    read_only_root_filesystem: Annotated[Optional[bool], Field(alias="readOnlyRootFilesystem")] = (
        None
    )
    """
    Whether this container has a read-only root filesystem.
    Default is false.
    Note that this field cannot be set when spec.os.name is windows.
    """
    run_as_group: Annotated[Optional[int], Field(alias="runAsGroup")] = None
    """
    The GID to run the entrypoint of the container process.
    Uses runtime default if unset.
    May also be set in PodSecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    Note that this field cannot be set when spec.os.name is windows.
    """
    run_as_non_root: Annotated[Optional[bool], Field(alias="runAsNonRoot")] = None
    """
    Indicates that the container must run as a non-root user.
    If true, the Kubelet will validate the image at runtime to ensure that it
    does not run as UID 0 (root) and fail to start the container if it does.
    If unset or false, no such validation will be performed.
    May also be set in PodSecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    """
    run_as_user: Annotated[Optional[int], Field(alias="runAsUser")] = None
    """
    The UID to run the entrypoint of the container process.
    Defaults to user specified in image metadata if unspecified.
    May also be set in PodSecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    Note that this field cannot be set when spec.os.name is windows.
    """
    se_linux_options: Annotated[Optional[SeLinuxOptions], Field(alias="seLinuxOptions")] = None
    """
    The SELinux context to be applied to the container.
    If unspecified, the container runtime will allocate a random SELinux context for each
    container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    Note that this field cannot be set when spec.os.name is windows.
    """
    seccomp_profile: Annotated[Optional[SeccompProfile], Field(alias="seccompProfile")] = None
    """
    The seccomp options to use by this container. If seccomp options are
    provided at both the pod & container level, the container options
    override the pod options.
    Note that this field cannot be set when spec.os.name is windows.
    """
    windows_options: Annotated[Optional[WindowsOptions], Field(alias="windowsOptions")] = None
    """
    The Windows specific settings applied to all containers.
    If unspecified, the options from the PodSecurityContext will be used.
    If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
    Note that this field cannot be set when spec.os.name is linux.
    """


class StartupProbe(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StartupProbe"]:
            return StartupProbe

        def build(self) -> "StartupProbe":
            return StartupProbe(**self._attrs)

        @overload
        def exec(self, value_or_callback: Optional[Exec], /) -> "StartupProbe.Builder": ...

        @overload
        def exec(
            self, value_or_callback: Callable[[Exec.Builder], Exec.Builder | Exec], /
        ) -> "StartupProbe.Builder": ...

        @overload
        def exec(self, value_or_callback: Never = ...) -> "Exec.BuilderContext": ...

        def exec(self, value_or_callback=None, /):
            """
            Exec specifies a command to execute in the container.
            """
            if self._in_context and value_or_callback is None:
                context = Exec.BuilderContext()
                context._parent_builder = self
                context._field_name = "exec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exec.builder())
                if isinstance(output, Exec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exec", value)

        def failure_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive failures for the probe to be considered failed after having succeeded.
            Defaults to 3. Minimum value is 1.
            """
            return self._set("failure_threshold", value)

        @overload
        def grpc(self, value_or_callback: Optional[Grpc], /) -> "StartupProbe.Builder": ...

        @overload
        def grpc(
            self, value_or_callback: Callable[[Grpc.Builder], Grpc.Builder | Grpc], /
        ) -> "StartupProbe.Builder": ...

        @overload
        def grpc(self, value_or_callback: Never = ...) -> "Grpc.BuilderContext": ...

        def grpc(self, value_or_callback=None, /):
            """
            GRPC specifies a GRPC HealthCheckRequest.
            """
            if self._in_context and value_or_callback is None:
                context = Grpc.BuilderContext()
                context._parent_builder = self
                context._field_name = "grpc"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Grpc.builder())
                if isinstance(output, Grpc.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("grpc", value)

        @overload
        def http_get(self, value_or_callback: Optional[HttpGet], /) -> "StartupProbe.Builder": ...

        @overload
        def http_get(
            self,
            value_or_callback: Callable[[HttpGet.Builder], HttpGet.Builder | HttpGet],
            /,
        ) -> "StartupProbe.Builder": ...

        @overload
        def http_get(self, value_or_callback: Never = ...) -> "HttpGet.BuilderContext": ...

        def http_get(self, value_or_callback=None, /):
            """
            HTTPGet specifies an HTTP GET request to perform.
            """
            if self._in_context and value_or_callback is None:
                context = HttpGet.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_get"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpGet.builder())
                if isinstance(output, HttpGet.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_get", value)

        def initial_delay_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after the container has started before liveness probes are initiated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            return self._set("initial_delay_seconds", value)

        def period_seconds(self, value: Optional[int], /) -> Self:
            """
            How often (in seconds) to perform the probe.
            Default to 10 seconds. Minimum value is 1.
            """
            return self._set("period_seconds", value)

        def success_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive successes for the probe to be considered successful after having failed.
            Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
            """
            return self._set("success_threshold", value)

        @overload
        def tcp_socket(
            self, value_or_callback: Optional[TcpSocket], /
        ) -> "StartupProbe.Builder": ...

        @overload
        def tcp_socket(
            self,
            value_or_callback: Callable[[TcpSocket.Builder], TcpSocket.Builder | TcpSocket],
            /,
        ) -> "StartupProbe.Builder": ...

        @overload
        def tcp_socket(self, value_or_callback: Never = ...) -> "TcpSocket.BuilderContext": ...

        def tcp_socket(self, value_or_callback=None, /):
            """
            TCPSocket specifies a connection to a TCP port.
            """
            if self._in_context and value_or_callback is None:
                context = TcpSocket.BuilderContext()
                context._parent_builder = self
                context._field_name = "tcp_socket"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TcpSocket.builder())
                if isinstance(output, TcpSocket.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tcp_socket", value)

        def termination_grace_period_seconds(self, value: Optional[int], /) -> Self:
            """
            Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
            The grace period is the duration in seconds after the processes running in the pod are sent
            a termination signal and the time when the processes are forcibly halted with a kill signal.
            Set this value longer than the expected cleanup time for your process.
            If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
            value overrides the value provided by the pod spec.
            Value must be non-negative integer. The value zero indicates stop immediately via
            the kill signal (no opportunity to shut down).
            This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
            Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
            """
            return self._set("termination_grace_period_seconds", value)

        def timeout_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after which the probe times out.
            Defaults to 1 second. Minimum value is 1.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            return self._set("timeout_seconds", value)

    class BuilderContext(BuilderContextBase["StartupProbe.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StartupProbe.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StartupProbe."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StartupProbe", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StartupProbe.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exec: Optional[Exec] = None
    """
    Exec specifies a command to execute in the container.
    """
    failure_threshold: Annotated[Optional[int], Field(alias="failureThreshold")] = None
    """
    Minimum consecutive failures for the probe to be considered failed after having succeeded.
    Defaults to 3. Minimum value is 1.
    """
    grpc: Optional[Grpc] = None
    """
    GRPC specifies a GRPC HealthCheckRequest.
    """
    http_get: Annotated[Optional[HttpGet], Field(alias="httpGet")] = None
    """
    HTTPGet specifies an HTTP GET request to perform.
    """
    initial_delay_seconds: Annotated[Optional[int], Field(alias="initialDelaySeconds")] = None
    """
    Number of seconds after the container has started before liveness probes are initiated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    period_seconds: Annotated[Optional[int], Field(alias="periodSeconds")] = None
    """
    How often (in seconds) to perform the probe.
    Default to 10 seconds. Minimum value is 1.
    """
    success_threshold: Annotated[Optional[int], Field(alias="successThreshold")] = None
    """
    Minimum consecutive successes for the probe to be considered successful after having failed.
    Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    """
    tcp_socket: Annotated[Optional[TcpSocket], Field(alias="tcpSocket")] = None
    """
    TCPSocket specifies a connection to a TCP port.
    """
    termination_grace_period_seconds: Annotated[
        Optional[int], Field(alias="terminationGracePeriodSeconds")
    ] = None
    """
    Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    The grace period is the duration in seconds after the processes running in the pod are sent
    a termination signal and the time when the processes are forcibly halted with a kill signal.
    Set this value longer than the expected cleanup time for your process.
    If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    value overrides the value provided by the pod spec.
    Value must be non-negative integer. The value zero indicates stop immediately via
    the kill signal (no opportunity to shut down).
    This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    """
    timeout_seconds: Annotated[Optional[int], Field(alias="timeoutSeconds")] = None
    """
    Number of seconds after which the probe times out.
    Defaults to 1 second. Minimum value is 1.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """


class VolumeDevice(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VolumeDevice"]:
            return VolumeDevice

        def build(self) -> "VolumeDevice":
            return VolumeDevice(**self._attrs)

        def device_path(self, value: str, /) -> Self:
            """
            devicePath is the path inside of the container that the device will be mapped to.
            """
            return self._set("device_path", value)

        def name(self, value: str, /) -> Self:
            """
            name must match the name of a persistentVolumeClaim in the pod
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["VolumeDevice.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VolumeDevice.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VolumeDevice."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VolumeDevice", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VolumeDevice.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    device_path: Annotated[str, Field(alias="devicePath")]
    """
    devicePath is the path inside of the container that the device will be mapped to.
    """
    name: str
    """
    name must match the name of a persistentVolumeClaim in the pod
    """


class VolumeMount(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VolumeMount"]:
            return VolumeMount

        def build(self) -> "VolumeMount":
            return VolumeMount(**self._attrs)

        def mount_path(self, value: str, /) -> Self:
            """
            Path within the container at which the volume should be mounted.  Must
            not contain ':'.
            """
            return self._set("mount_path", value)

        def mount_propagation(self, value: Optional[str], /) -> Self:
            """
            mountPropagation determines how mounts are propagated from the host
            to container and the other way around.
            When not set, MountPropagationNone is used.
            This field is beta in 1.10.
            When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
            (which defaults to None).
            """
            return self._set("mount_propagation", value)

        def name(self, value: str, /) -> Self:
            """
            This must match the Name of a Volume.
            """
            return self._set("name", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            Mounted read-only if true, read-write otherwise (false or unspecified).
            Defaults to false.
            """
            return self._set("read_only", value)

        def recursive_read_only(self, value: Optional[str], /) -> Self:
            """
            RecursiveReadOnly specifies whether read-only mounts should be handled
            recursively.

            If ReadOnly is false, this field has no meaning and must be unspecified.

            If ReadOnly is true, and this field is set to Disabled, the mount is not made
            recursively read-only.  If this field is set to IfPossible, the mount is made
            recursively read-only, if it is supported by the container runtime.  If this
            field is set to Enabled, the mount is made recursively read-only if it is
            supported by the container runtime, otherwise the pod will not be started and
            an error will be generated to indicate the reason.

            If this field is set to IfPossible or Enabled, MountPropagation must be set to
            None (or be unspecified, which defaults to None).

            If this field is not specified, it is treated as an equivalent of Disabled.
            """
            return self._set("recursive_read_only", value)

        def sub_path(self, value: Optional[str], /) -> Self:
            """
            Path within the volume from which the container's volume should be mounted.
            Defaults to "" (volume's root).
            """
            return self._set("sub_path", value)

        def sub_path_expr(self, value: Optional[str], /) -> Self:
            """
            Expanded path within the volume from which the container's volume should be mounted.
            Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
            Defaults to "" (volume's root).
            SubPathExpr and SubPath are mutually exclusive.
            """
            return self._set("sub_path_expr", value)

    class BuilderContext(BuilderContextBase["VolumeMount.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VolumeMount.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VolumeMount."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VolumeMount", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VolumeMount.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    mount_path: Annotated[str, Field(alias="mountPath")]
    """
    Path within the container at which the volume should be mounted.  Must
    not contain ':'.
    """
    mount_propagation: Annotated[Optional[str], Field(alias="mountPropagation")] = None
    """
    mountPropagation determines how mounts are propagated from the host
    to container and the other way around.
    When not set, MountPropagationNone is used.
    This field is beta in 1.10.
    When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
    (which defaults to None).
    """
    name: str
    """
    This must match the Name of a Volume.
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    Mounted read-only if true, read-write otherwise (false or unspecified).
    Defaults to false.
    """
    recursive_read_only: Annotated[Optional[str], Field(alias="recursiveReadOnly")] = None
    """
    RecursiveReadOnly specifies whether read-only mounts should be handled
    recursively.

    If ReadOnly is false, this field has no meaning and must be unspecified.

    If ReadOnly is true, and this field is set to Disabled, the mount is not made
    recursively read-only.  If this field is set to IfPossible, the mount is made
    recursively read-only, if it is supported by the container runtime.  If this
    field is set to Enabled, the mount is made recursively read-only if it is
    supported by the container runtime, otherwise the pod will not be started and
    an error will be generated to indicate the reason.

    If this field is set to IfPossible or Enabled, MountPropagation must be set to
    None (or be unspecified, which defaults to None).

    If this field is not specified, it is treated as an equivalent of Disabled.
    """
    sub_path: Annotated[Optional[str], Field(alias="subPath")] = None
    """
    Path within the volume from which the container's volume should be mounted.
    Defaults to "" (volume's root).
    """
    sub_path_expr: Annotated[Optional[str], Field(alias="subPathExpr")] = None
    """
    Expanded path within the volume from which the container's volume should be mounted.
    Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    Defaults to "" (volume's root).
    SubPathExpr and SubPath are mutually exclusive.
    """


class Container(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Container"]:
            return Container

        def build(self) -> "Container":
            return Container(**self._attrs)

        def args(self, value: Optional[List[str]], /) -> Self:
            """
            Arguments to the entrypoint.
            The container image's CMD is used if this is not provided.
            Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
            cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
            to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
            produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
            of whether the variable exists or not. Cannot be updated.
            More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
            """
            return self._set("args", value)

        def command(self, value: Optional[List[str]], /) -> Self:
            """
            Entrypoint array. Not executed within a shell.
            The container image's ENTRYPOINT is used if this is not provided.
            Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
            cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
            to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
            produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
            of whether the variable exists or not. Cannot be updated.
            More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
            """
            return self._set("command", value)

        @overload
        def env(self, value_or_callback: List[Env], /) -> "Container.Builder": ...

        @overload
        def env(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Env, Env.Builder]],
                GenericListBuilder[Env, Env.Builder] | List[Env],
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def env(self, value_or_callback: Never = ...) -> ListBuilderContext[Env.Builder]: ...

        def env(self, value_or_callback=None, /):
            """
            List of environment variables to set in the container.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Env.Builder]()
                context._parent_builder = self
                context._field_name = "env"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Env.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("env", value)

        @overload
        def env_from(self, value_or_callback: List[EnvFrom], /) -> "Container.Builder": ...

        @overload
        def env_from(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[EnvFrom, EnvFrom.Builder]],
                GenericListBuilder[EnvFrom, EnvFrom.Builder] | List[EnvFrom],
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def env_from(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[EnvFrom.Builder]: ...

        def env_from(self, value_or_callback=None, /):
            """
            List of sources to populate environment variables in the container.
            The keys defined within a source must be a C_IDENTIFIER. All invalid keys
            will be reported as an event when the container is starting. When a key exists in multiple
            sources, the value associated with the last source will take precedence.
            Values defined by an Env with a duplicate key will take precedence.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[EnvFrom.Builder]()
                context._parent_builder = self
                context._field_name = "env_from"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(EnvFrom.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("env_from", value)

        def image(self, value: Optional[str], /) -> Self:
            """
            Container image name.
            More info: https://kubernetes.io/docs/concepts/containers/images
            This field is optional to allow higher level config management to default or override
            container images in workload controllers like Deployments and StatefulSets.
            """
            return self._set("image", value)

        def image_pull_policy(self, value: Optional[str], /) -> Self:
            """
            Image pull policy.
            One of Always, Never, IfNotPresent.
            Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
            Cannot be updated.
            More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
            """
            return self._set("image_pull_policy", value)

        @overload
        def lifecycle(self, value_or_callback: Optional[Lifecycle], /) -> "Container.Builder": ...

        @overload
        def lifecycle(
            self,
            value_or_callback: Callable[[Lifecycle.Builder], Lifecycle.Builder | Lifecycle],
            /,
        ) -> "Container.Builder": ...

        @overload
        def lifecycle(self, value_or_callback: Never = ...) -> "Lifecycle.BuilderContext": ...

        def lifecycle(self, value_or_callback=None, /):
            """
            Actions that the management system should take in response to container lifecycle events.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = Lifecycle.BuilderContext()
                context._parent_builder = self
                context._field_name = "lifecycle"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Lifecycle.builder())
                if isinstance(output, Lifecycle.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("lifecycle", value)

        @overload
        def liveness_probe(
            self, value_or_callback: Optional[LivenessProbe], /
        ) -> "Container.Builder": ...

        @overload
        def liveness_probe(
            self,
            value_or_callback: Callable[
                [LivenessProbe.Builder], LivenessProbe.Builder | LivenessProbe
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def liveness_probe(
            self, value_or_callback: Never = ...
        ) -> "LivenessProbe.BuilderContext": ...

        def liveness_probe(self, value_or_callback=None, /):
            """
            Periodic probe of container liveness.
            Container will be restarted if the probe fails.
            Cannot be updated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            if self._in_context and value_or_callback is None:
                context = LivenessProbe.BuilderContext()
                context._parent_builder = self
                context._field_name = "liveness_probe"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LivenessProbe.builder())
                if isinstance(output, LivenessProbe.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("liveness_probe", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the container specified as a DNS_LABEL.
            Each container in a pod must have a unique name (DNS_LABEL).
            Cannot be updated.
            """
            return self._set("name", value)

        @overload
        def ports(self, value_or_callback: List[Port], /) -> "Container.Builder": ...

        @overload
        def ports(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Port, Port.Builder]],
                GenericListBuilder[Port, Port.Builder] | List[Port],
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def ports(self, value_or_callback: Never = ...) -> ListBuilderContext[Port.Builder]: ...

        def ports(self, value_or_callback=None, /):
            """
            List of ports to expose from the container. Not specifying a port here
            DOES NOT prevent that port from being exposed. Any port which is
            listening on the default "0.0.0.0" address inside a container will be
            accessible from the network.
            Modifying this array with strategic merge patch may corrupt the data.
            For more information See https://github.com/kubernetes/kubernetes/issues/108255.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Port.Builder]()
                context._parent_builder = self
                context._field_name = "ports"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Port.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("ports", value)

        @overload
        def readiness_probe(
            self, value_or_callback: Optional[ReadinessProbe], /
        ) -> "Container.Builder": ...

        @overload
        def readiness_probe(
            self,
            value_or_callback: Callable[
                [ReadinessProbe.Builder], ReadinessProbe.Builder | ReadinessProbe
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def readiness_probe(
            self, value_or_callback: Never = ...
        ) -> "ReadinessProbe.BuilderContext": ...

        def readiness_probe(self, value_or_callback=None, /):
            """
            Periodic probe of container service readiness.
            Container will be removed from service endpoints if the probe fails.
            Cannot be updated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            if self._in_context and value_or_callback is None:
                context = ReadinessProbe.BuilderContext()
                context._parent_builder = self
                context._field_name = "readiness_probe"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ReadinessProbe.builder())
                if isinstance(output, ReadinessProbe.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("readiness_probe", value)

        @overload
        def resize_policy(
            self, value_or_callback: List[ResizePolicy], /
        ) -> "Container.Builder": ...

        @overload
        def resize_policy(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ResizePolicy, ResizePolicy.Builder]],
                GenericListBuilder[ResizePolicy, ResizePolicy.Builder] | List[ResizePolicy],
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def resize_policy(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ResizePolicy.Builder]: ...

        def resize_policy(self, value_or_callback=None, /):
            """
            Resources resize policy for the container.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ResizePolicy.Builder]()
                context._parent_builder = self
                context._field_name = "resize_policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResizePolicy.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("resize_policy", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "Container.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "Container.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            Compute Resources required by this container.
            Cannot be updated.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def restart_policy(self, value: Optional[str], /) -> Self:
            """
            RestartPolicy defines the restart behavior of individual containers in a pod.
            This field may only be set for init containers, and the only allowed value is "Always".
            For non-init containers or when this field is not specified,
            the restart behavior is defined by the Pod's restart policy and the container type.
            Setting the RestartPolicy as "Always" for the init container will have the following effect:
            this init container will be continually restarted on
            exit until all regular containers have terminated. Once all regular
            containers have completed, all init containers with restartPolicy "Always"
            will be shut down. This lifecycle differs from normal init containers and
            is often referred to as a "sidecar" container. Although this init
            container still starts in the init container sequence, it does not wait
            for the container to complete before proceeding to the next init
            container. Instead, the next init container starts immediately after this
            init container is started, or after any startupProbe has successfully
            completed.
            """
            return self._set("restart_policy", value)

        @overload
        def security_context(
            self, value_or_callback: Optional[SecurityContext], /
        ) -> "Container.Builder": ...

        @overload
        def security_context(
            self,
            value_or_callback: Callable[
                [SecurityContext.Builder], SecurityContext.Builder | SecurityContext
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def security_context(
            self, value_or_callback: Never = ...
        ) -> "SecurityContext.BuilderContext": ...

        def security_context(self, value_or_callback=None, /):
            """
            SecurityContext defines the security options the container should be run with.
            If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
            More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
            """
            if self._in_context and value_or_callback is None:
                context = SecurityContext.BuilderContext()
                context._parent_builder = self
                context._field_name = "security_context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecurityContext.builder())
                if isinstance(output, SecurityContext.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("security_context", value)

        @overload
        def startup_probe(
            self, value_or_callback: Optional[StartupProbe], /
        ) -> "Container.Builder": ...

        @overload
        def startup_probe(
            self,
            value_or_callback: Callable[
                [StartupProbe.Builder], StartupProbe.Builder | StartupProbe
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def startup_probe(
            self, value_or_callback: Never = ...
        ) -> "StartupProbe.BuilderContext": ...

        def startup_probe(self, value_or_callback=None, /):
            """
            StartupProbe indicates that the Pod has successfully initialized.
            If specified, no other probes are executed until this completes successfully.
            If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
            This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
            when it might take a long time to load data or warm a cache, than during steady-state operation.
            This cannot be updated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            if self._in_context and value_or_callback is None:
                context = StartupProbe.BuilderContext()
                context._parent_builder = self
                context._field_name = "startup_probe"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(StartupProbe.builder())
                if isinstance(output, StartupProbe.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("startup_probe", value)

        def stdin(self, value: Optional[bool], /) -> Self:
            """
            Whether this container should allocate a buffer for stdin in the container runtime. If this
            is not set, reads from stdin in the container will always result in EOF.
            Default is false.
            """
            return self._set("stdin", value)

        def stdin_once(self, value: Optional[bool], /) -> Self:
            """
            Whether the container runtime should close the stdin channel after it has been opened by
            a single attach. When stdin is true the stdin stream will remain open across multiple attach
            sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
            first client attaches to stdin, and then remains open and accepts data until the client disconnects,
            at which time stdin is closed and remains closed until the container is restarted. If this
            flag is false, a container processes that reads from stdin will never receive an EOF.
            Default is false
            """
            return self._set("stdin_once", value)

        def termination_message_path(self, value: Optional[str], /) -> Self:
            """
            Optional: Path at which the file to which the container's termination message
            will be written is mounted into the container's filesystem.
            Message written is intended to be brief final status, such as an assertion failure message.
            Will be truncated by the node if greater than 4096 bytes. The total message length across
            all containers will be limited to 12kb.
            Defaults to /dev/termination-log.
            Cannot be updated.
            """
            return self._set("termination_message_path", value)

        def termination_message_policy(self, value: Optional[str], /) -> Self:
            """
            Indicate how the termination message should be populated. File will use the contents of
            terminationMessagePath to populate the container status message on both success and failure.
            FallbackToLogsOnError will use the last chunk of container log output if the termination
            message file is empty and the container exited with an error.
            The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
            Defaults to File.
            Cannot be updated.
            """
            return self._set("termination_message_policy", value)

        def tty(self, value: Optional[bool], /) -> Self:
            """
            Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
            Default is false.
            """
            return self._set("tty", value)

        @overload
        def volume_devices(
            self, value_or_callback: List[VolumeDevice], /
        ) -> "Container.Builder": ...

        @overload
        def volume_devices(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[VolumeDevice, VolumeDevice.Builder]],
                GenericListBuilder[VolumeDevice, VolumeDevice.Builder] | List[VolumeDevice],
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def volume_devices(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[VolumeDevice.Builder]: ...

        def volume_devices(self, value_or_callback=None, /):
            """
            volumeDevices is the list of block devices to be used by the container.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[VolumeDevice.Builder]()
                context._parent_builder = self
                context._field_name = "volume_devices"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VolumeDevice.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("volume_devices", value)

        @overload
        def volume_mounts(self, value_or_callback: List[VolumeMount], /) -> "Container.Builder": ...

        @overload
        def volume_mounts(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[VolumeMount, VolumeMount.Builder]],
                GenericListBuilder[VolumeMount, VolumeMount.Builder] | List[VolumeMount],
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def volume_mounts(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[VolumeMount.Builder]: ...

        def volume_mounts(self, value_or_callback=None, /):
            """
            Pod volumes to mount into the container's filesystem.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[VolumeMount.Builder]()
                context._parent_builder = self
                context._field_name = "volume_mounts"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VolumeMount.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("volume_mounts", value)

        def working_dir(self, value: Optional[str], /) -> Self:
            """
            Container's working directory.
            If not specified, the container runtime's default will be used, which
            might be configured in the container image.
            Cannot be updated.
            """
            return self._set("working_dir", value)

    class BuilderContext(BuilderContextBase["Container.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Container.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Container."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Container", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Container.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    args: Optional[List[str]] = None
    """
    Arguments to the entrypoint.
    The container image's CMD is used if this is not provided.
    Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    of whether the variable exists or not. Cannot be updated.
    More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
    """
    command: Optional[List[str]] = None
    """
    Entrypoint array. Not executed within a shell.
    The container image's ENTRYPOINT is used if this is not provided.
    Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    of whether the variable exists or not. Cannot be updated.
    More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
    """
    env: Optional[List[Env]] = None
    """
    List of environment variables to set in the container.
    Cannot be updated.
    """
    env_from: Annotated[Optional[List[EnvFrom]], Field(alias="envFrom")] = None
    """
    List of sources to populate environment variables in the container.
    The keys defined within a source must be a C_IDENTIFIER. All invalid keys
    will be reported as an event when the container is starting. When a key exists in multiple
    sources, the value associated with the last source will take precedence.
    Values defined by an Env with a duplicate key will take precedence.
    Cannot be updated.
    """
    image: Optional[str] = None
    """
    Container image name.
    More info: https://kubernetes.io/docs/concepts/containers/images
    This field is optional to allow higher level config management to default or override
    container images in workload controllers like Deployments and StatefulSets.
    """
    image_pull_policy: Annotated[Optional[str], Field(alias="imagePullPolicy")] = None
    """
    Image pull policy.
    One of Always, Never, IfNotPresent.
    Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    Cannot be updated.
    More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
    """
    lifecycle: Optional[Lifecycle] = None
    """
    Actions that the management system should take in response to container lifecycle events.
    Cannot be updated.
    """
    liveness_probe: Annotated[Optional[LivenessProbe], Field(alias="livenessProbe")] = None
    """
    Periodic probe of container liveness.
    Container will be restarted if the probe fails.
    Cannot be updated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    name: str
    """
    Name of the container specified as a DNS_LABEL.
    Each container in a pod must have a unique name (DNS_LABEL).
    Cannot be updated.
    """
    ports: Optional[List[Port]] = None
    """
    List of ports to expose from the container. Not specifying a port here
    DOES NOT prevent that port from being exposed. Any port which is
    listening on the default "0.0.0.0" address inside a container will be
    accessible from the network.
    Modifying this array with strategic merge patch may corrupt the data.
    For more information See https://github.com/kubernetes/kubernetes/issues/108255.
    Cannot be updated.
    """
    readiness_probe: Annotated[Optional[ReadinessProbe], Field(alias="readinessProbe")] = None
    """
    Periodic probe of container service readiness.
    Container will be removed from service endpoints if the probe fails.
    Cannot be updated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    resize_policy: Annotated[Optional[List[ResizePolicy]], Field(alias="resizePolicy")] = None
    """
    Resources resize policy for the container.
    """
    resources: Optional[Resources] = None
    """
    Compute Resources required by this container.
    Cannot be updated.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """
    restart_policy: Annotated[Optional[str], Field(alias="restartPolicy")] = None
    """
    RestartPolicy defines the restart behavior of individual containers in a pod.
    This field may only be set for init containers, and the only allowed value is "Always".
    For non-init containers or when this field is not specified,
    the restart behavior is defined by the Pod's restart policy and the container type.
    Setting the RestartPolicy as "Always" for the init container will have the following effect:
    this init container will be continually restarted on
    exit until all regular containers have terminated. Once all regular
    containers have completed, all init containers with restartPolicy "Always"
    will be shut down. This lifecycle differs from normal init containers and
    is often referred to as a "sidecar" container. Although this init
    container still starts in the init container sequence, it does not wait
    for the container to complete before proceeding to the next init
    container. Instead, the next init container starts immediately after this
    init container is started, or after any startupProbe has successfully
    completed.
    """
    security_context: Annotated[Optional[SecurityContext], Field(alias="securityContext")] = None
    """
    SecurityContext defines the security options the container should be run with.
    If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
    More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
    """
    startup_probe: Annotated[Optional[StartupProbe], Field(alias="startupProbe")] = None
    """
    StartupProbe indicates that the Pod has successfully initialized.
    If specified, no other probes are executed until this completes successfully.
    If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
    This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
    when it might take a long time to load data or warm a cache, than during steady-state operation.
    This cannot be updated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    stdin: Optional[bool] = None
    """
    Whether this container should allocate a buffer for stdin in the container runtime. If this
    is not set, reads from stdin in the container will always result in EOF.
    Default is false.
    """
    stdin_once: Annotated[Optional[bool], Field(alias="stdinOnce")] = None
    """
    Whether the container runtime should close the stdin channel after it has been opened by
    a single attach. When stdin is true the stdin stream will remain open across multiple attach
    sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
    first client attaches to stdin, and then remains open and accepts data until the client disconnects,
    at which time stdin is closed and remains closed until the container is restarted. If this
    flag is false, a container processes that reads from stdin will never receive an EOF.
    Default is false
    """
    termination_message_path: Annotated[Optional[str], Field(alias="terminationMessagePath")] = None
    """
    Optional: Path at which the file to which the container's termination message
    will be written is mounted into the container's filesystem.
    Message written is intended to be brief final status, such as an assertion failure message.
    Will be truncated by the node if greater than 4096 bytes. The total message length across
    all containers will be limited to 12kb.
    Defaults to /dev/termination-log.
    Cannot be updated.
    """
    termination_message_policy: Annotated[
        Optional[str], Field(alias="terminationMessagePolicy")
    ] = None
    """
    Indicate how the termination message should be populated. File will use the contents of
    terminationMessagePath to populate the container status message on both success and failure.
    FallbackToLogsOnError will use the last chunk of container log output if the termination
    message file is empty and the container exited with an error.
    The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
    Defaults to File.
    Cannot be updated.
    """
    tty: Optional[bool] = None
    """
    Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
    Default is false.
    """
    volume_devices: Annotated[Optional[List[VolumeDevice]], Field(alias="volumeDevices")] = None
    """
    volumeDevices is the list of block devices to be used by the container.
    """
    volume_mounts: Annotated[Optional[List[VolumeMount]], Field(alias="volumeMounts")] = None
    """
    Pod volumes to mount into the container's filesystem.
    Cannot be updated.
    """
    working_dir: Annotated[Optional[str], Field(alias="workingDir")] = None
    """
    Container's working directory.
    If not specified, the container runtime's default will be used, which
    might be configured in the container image.
    Cannot be updated.
    """


class Nameserver(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "Nameserver":
            value = cast(str, self._value)
            return Nameserver(value)

    root: Annotated[str, Field(min_length=1)]

    class BuilderContext(BuilderContextBase["Nameserver.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Nameserver.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Nameserver."""
        return cls.BuilderContext()


class Option(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Option"]:
            return Option

        def build(self) -> "Option":
            return Option(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name is required and must be unique.
            """
            return self._set("name", value)

        def value(self, value: Optional[str], /) -> Self:
            """
            Value is optional.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["Option.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Option.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Option."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Option", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Option.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Annotated[str, Field(min_length=1)]
    """
    Name is required and must be unique.
    """
    value: Optional[str] = None
    """
    Value is optional.
    """


class Search(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "Search":
            value = cast(str, self._value)
            return Search(value)

    root: Annotated[str, Field(min_length=1)]

    class BuilderContext(BuilderContextBase["Search.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Search.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Search."""
        return cls.BuilderContext()


class DnsConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DnsConfig"]:
            return DnsConfig

        def build(self) -> "DnsConfig":
            return DnsConfig(**self._attrs)

        @overload
        def nameservers(self, value_or_callback: List[Nameserver], /) -> "DnsConfig.Builder": ...

        @overload
        def nameservers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Nameserver, Nameserver.Builder]],
                GenericListBuilder[Nameserver, Nameserver.Builder] | List[Nameserver],
            ],
            /,
        ) -> "DnsConfig.Builder": ...

        @overload
        def nameservers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Nameserver.Builder]: ...

        def nameservers(self, value_or_callback=None, /):
            """
            A list of DNS name server IP addresses.
            This will be appended to the base nameservers generated from DNSPolicy.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Nameserver.Builder]()
                context._parent_builder = self
                context._field_name = "nameservers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Nameserver.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("nameservers", value)

        @overload
        def options(self, value_or_callback: List[Option], /) -> "DnsConfig.Builder": ...

        @overload
        def options(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Option, Option.Builder]],
                GenericListBuilder[Option, Option.Builder] | List[Option],
            ],
            /,
        ) -> "DnsConfig.Builder": ...

        @overload
        def options(self, value_or_callback: Never = ...) -> ListBuilderContext[Option.Builder]: ...

        def options(self, value_or_callback=None, /):
            """
            A list of DNS resolver options.
            This will be merged with the base options generated from DNSPolicy.
            Resolution options given in Options
            will override those that appear in the base DNSPolicy.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Option.Builder]()
                context._parent_builder = self
                context._field_name = "options"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Option.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("options", value)

        @overload
        def searches(self, value_or_callback: List[Search], /) -> "DnsConfig.Builder": ...

        @overload
        def searches(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Search, Search.Builder]],
                GenericListBuilder[Search, Search.Builder] | List[Search],
            ],
            /,
        ) -> "DnsConfig.Builder": ...

        @overload
        def searches(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Search.Builder]: ...

        def searches(self, value_or_callback=None, /):
            """
            A list of DNS search domains for host-name lookup.
            This will be appended to the base search paths generated from DNSPolicy.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Search.Builder]()
                context._parent_builder = self
                context._field_name = "searches"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Search.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("searches", value)

    class BuilderContext(BuilderContextBase["DnsConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DnsConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DnsConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DnsConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DnsConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    nameservers: Optional[List[Nameserver]] = None
    """
    A list of DNS name server IP addresses.
    This will be appended to the base nameservers generated from DNSPolicy.
    """
    options: Optional[List[Option]] = None
    """
    A list of DNS resolver options.
    This will be merged with the base options generated from DNSPolicy.
    Resolution options given in Options
    will override those that appear in the base DNSPolicy.
    """
    searches: Optional[List[Search]] = None
    """
    A list of DNS search domains for host-name lookup.
    This will be appended to the base search paths generated from DNSPolicy.
    """


class EnableFeature(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "EnableFeature":
            value = cast(str, self._value)
            return EnableFeature(value)

    root: Annotated[str, Field(min_length=1)]

    class BuilderContext(BuilderContextBase["EnableFeature.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = EnableFeature.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for EnableFeature."""
        return cls.BuilderContext()


class ExcludedFromEnforcement(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ExcludedFromEnforcement"]:
            return ExcludedFromEnforcement

        def build(self) -> "ExcludedFromEnforcement":
            return ExcludedFromEnforcement(**self._attrs)

        def group(self, value: Optional[Literal["monitoring.coreos.com"]], /) -> Self:
            """
            Group of the referent. When not specified, it defaults to `monitoring.coreos.com`
            """
            return self._set("group", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent. When not set, all resources in the namespace are matched.
            """
            return self._set("name", value)

        def namespace(self, value: str, /) -> Self:
            """
            Namespace of the referent.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
            """
            return self._set("namespace", value)

        def resource(
            self,
            value: Literal[
                "prometheusrules",
                "servicemonitors",
                "podmonitors",
                "probes",
                "scrapeconfigs",
            ],
            /,
        ) -> Self:
            """
            Resource of the referent.
            """
            return self._set("resource", value)

    class BuilderContext(BuilderContextBase["ExcludedFromEnforcement.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ExcludedFromEnforcement.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ExcludedFromEnforcement."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ExcludedFromEnforcement", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ExcludedFromEnforcement.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    group: Optional[Literal["monitoring.coreos.com"]] = "monitoring.coreos.com"
    """
    Group of the referent. When not specified, it defaults to `monitoring.coreos.com`
    """
    name: Optional[str] = None
    """
    Name of the referent. When not set, all resources in the namespace are matched.
    """
    namespace: Annotated[str, Field(min_length=1)]
    """
    Namespace of the referent.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    """
    resource: Literal[
        "prometheusrules", "servicemonitors", "podmonitors", "probes", "scrapeconfigs"
    ]
    """
    Resource of the referent.
    """


class HostAliase(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HostAliase"]:
            return HostAliase

        def build(self) -> "HostAliase":
            return HostAliase(**self._attrs)

        def hostnames(self, value: List[str], /) -> Self:
            """
            Hostnames for the above IP address.
            """
            return self._set("hostnames", value)

        def ip(self, value: str, /) -> Self:
            """
            IP address of the host file entry.
            """
            return self._set("ip", value)

    class BuilderContext(BuilderContextBase["HostAliase.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HostAliase.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HostAliase."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HostAliase", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HostAliase.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    hostnames: List[str]
    """
    Hostnames for the above IP address.
    """
    ip: str
    """
    IP address of the host file entry.
    """


class ImagePullSecret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImagePullSecret"]:
            return ImagePullSecret

        def build(self) -> "ImagePullSecret":
            return ImagePullSecret(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["ImagePullSecret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImagePullSecret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImagePullSecret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImagePullSecret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImagePullSecret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """


class DivisorModel1(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel1":
            value = cast(int, self._value)
            return DivisorModel1(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel1.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel1."""
        return cls.BuilderContext()


class DivisorModel2(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel2":
            value = cast(str, self._value)
            return DivisorModel2(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel2.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel2."""
        return cls.BuilderContext()


class LimitsModel1(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel1":
            value = cast(int, self._value)
            return LimitsModel1(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel1.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel1."""
        return cls.BuilderContext()


class LimitsModel2(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel2":
            value = cast(str, self._value)
            return LimitsModel2(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel2.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel2."""
        return cls.BuilderContext()


class RequestsModel1(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel1":
            value = cast(int, self._value)
            return RequestsModel1(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel1.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel1."""
        return cls.BuilderContext()


class RequestsModel2(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel2":
            value = cast(str, self._value)
            return RequestsModel2(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel2.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel2."""
        return cls.BuilderContext()


class InitContainer(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitContainer"]:
            return InitContainer

        def build(self) -> "InitContainer":
            return InitContainer(**self._attrs)

        def args(self, value: Optional[List[str]], /) -> Self:
            """
            Arguments to the entrypoint.
            The container image's CMD is used if this is not provided.
            Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
            cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
            to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
            produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
            of whether the variable exists or not. Cannot be updated.
            More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
            """
            return self._set("args", value)

        def command(self, value: Optional[List[str]], /) -> Self:
            """
            Entrypoint array. Not executed within a shell.
            The container image's ENTRYPOINT is used if this is not provided.
            Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
            cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
            to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
            produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
            of whether the variable exists or not. Cannot be updated.
            More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
            """
            return self._set("command", value)

        @overload
        def env(self, value_or_callback: List[Env], /) -> "InitContainer.Builder": ...

        @overload
        def env(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Env, Env.Builder]],
                GenericListBuilder[Env, Env.Builder] | List[Env],
            ],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def env(self, value_or_callback: Never = ...) -> ListBuilderContext[Env.Builder]: ...

        def env(self, value_or_callback=None, /):
            """
            List of environment variables to set in the container.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Env.Builder]()
                context._parent_builder = self
                context._field_name = "env"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Env.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("env", value)

        @overload
        def env_from(self, value_or_callback: List[EnvFrom], /) -> "InitContainer.Builder": ...

        @overload
        def env_from(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[EnvFrom, EnvFrom.Builder]],
                GenericListBuilder[EnvFrom, EnvFrom.Builder] | List[EnvFrom],
            ],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def env_from(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[EnvFrom.Builder]: ...

        def env_from(self, value_or_callback=None, /):
            """
            List of sources to populate environment variables in the container.
            The keys defined within a source must be a C_IDENTIFIER. All invalid keys
            will be reported as an event when the container is starting. When a key exists in multiple
            sources, the value associated with the last source will take precedence.
            Values defined by an Env with a duplicate key will take precedence.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[EnvFrom.Builder]()
                context._parent_builder = self
                context._field_name = "env_from"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(EnvFrom.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("env_from", value)

        def image(self, value: Optional[str], /) -> Self:
            """
            Container image name.
            More info: https://kubernetes.io/docs/concepts/containers/images
            This field is optional to allow higher level config management to default or override
            container images in workload controllers like Deployments and StatefulSets.
            """
            return self._set("image", value)

        def image_pull_policy(self, value: Optional[str], /) -> Self:
            """
            Image pull policy.
            One of Always, Never, IfNotPresent.
            Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
            Cannot be updated.
            More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
            """
            return self._set("image_pull_policy", value)

        @overload
        def lifecycle(
            self, value_or_callback: Optional[Lifecycle], /
        ) -> "InitContainer.Builder": ...

        @overload
        def lifecycle(
            self,
            value_or_callback: Callable[[Lifecycle.Builder], Lifecycle.Builder | Lifecycle],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def lifecycle(self, value_or_callback: Never = ...) -> "Lifecycle.BuilderContext": ...

        def lifecycle(self, value_or_callback=None, /):
            """
            Actions that the management system should take in response to container lifecycle events.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = Lifecycle.BuilderContext()
                context._parent_builder = self
                context._field_name = "lifecycle"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Lifecycle.builder())
                if isinstance(output, Lifecycle.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("lifecycle", value)

        @overload
        def liveness_probe(
            self, value_or_callback: Optional[LivenessProbe], /
        ) -> "InitContainer.Builder": ...

        @overload
        def liveness_probe(
            self,
            value_or_callback: Callable[
                [LivenessProbe.Builder], LivenessProbe.Builder | LivenessProbe
            ],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def liveness_probe(
            self, value_or_callback: Never = ...
        ) -> "LivenessProbe.BuilderContext": ...

        def liveness_probe(self, value_or_callback=None, /):
            """
            Periodic probe of container liveness.
            Container will be restarted if the probe fails.
            Cannot be updated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            if self._in_context and value_or_callback is None:
                context = LivenessProbe.BuilderContext()
                context._parent_builder = self
                context._field_name = "liveness_probe"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LivenessProbe.builder())
                if isinstance(output, LivenessProbe.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("liveness_probe", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the container specified as a DNS_LABEL.
            Each container in a pod must have a unique name (DNS_LABEL).
            Cannot be updated.
            """
            return self._set("name", value)

        @overload
        def ports(self, value_or_callback: List[Port], /) -> "InitContainer.Builder": ...

        @overload
        def ports(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Port, Port.Builder]],
                GenericListBuilder[Port, Port.Builder] | List[Port],
            ],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def ports(self, value_or_callback: Never = ...) -> ListBuilderContext[Port.Builder]: ...

        def ports(self, value_or_callback=None, /):
            """
            List of ports to expose from the container. Not specifying a port here
            DOES NOT prevent that port from being exposed. Any port which is
            listening on the default "0.0.0.0" address inside a container will be
            accessible from the network.
            Modifying this array with strategic merge patch may corrupt the data.
            For more information See https://github.com/kubernetes/kubernetes/issues/108255.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Port.Builder]()
                context._parent_builder = self
                context._field_name = "ports"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Port.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("ports", value)

        @overload
        def readiness_probe(
            self, value_or_callback: Optional[ReadinessProbe], /
        ) -> "InitContainer.Builder": ...

        @overload
        def readiness_probe(
            self,
            value_or_callback: Callable[
                [ReadinessProbe.Builder], ReadinessProbe.Builder | ReadinessProbe
            ],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def readiness_probe(
            self, value_or_callback: Never = ...
        ) -> "ReadinessProbe.BuilderContext": ...

        def readiness_probe(self, value_or_callback=None, /):
            """
            Periodic probe of container service readiness.
            Container will be removed from service endpoints if the probe fails.
            Cannot be updated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            if self._in_context and value_or_callback is None:
                context = ReadinessProbe.BuilderContext()
                context._parent_builder = self
                context._field_name = "readiness_probe"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ReadinessProbe.builder())
                if isinstance(output, ReadinessProbe.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("readiness_probe", value)

        @overload
        def resize_policy(
            self, value_or_callback: List[ResizePolicy], /
        ) -> "InitContainer.Builder": ...

        @overload
        def resize_policy(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ResizePolicy, ResizePolicy.Builder]],
                GenericListBuilder[ResizePolicy, ResizePolicy.Builder] | List[ResizePolicy],
            ],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def resize_policy(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ResizePolicy.Builder]: ...

        def resize_policy(self, value_or_callback=None, /):
            """
            Resources resize policy for the container.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ResizePolicy.Builder]()
                context._parent_builder = self
                context._field_name = "resize_policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResizePolicy.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("resize_policy", value)

        @overload
        def resources(
            self, value_or_callback: Optional[Resources], /
        ) -> "InitContainer.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            Compute Resources required by this container.
            Cannot be updated.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def restart_policy(self, value: Optional[str], /) -> Self:
            """
            RestartPolicy defines the restart behavior of individual containers in a pod.
            This field may only be set for init containers, and the only allowed value is "Always".
            For non-init containers or when this field is not specified,
            the restart behavior is defined by the Pod's restart policy and the container type.
            Setting the RestartPolicy as "Always" for the init container will have the following effect:
            this init container will be continually restarted on
            exit until all regular containers have terminated. Once all regular
            containers have completed, all init containers with restartPolicy "Always"
            will be shut down. This lifecycle differs from normal init containers and
            is often referred to as a "sidecar" container. Although this init
            container still starts in the init container sequence, it does not wait
            for the container to complete before proceeding to the next init
            container. Instead, the next init container starts immediately after this
            init container is started, or after any startupProbe has successfully
            completed.
            """
            return self._set("restart_policy", value)

        @overload
        def security_context(
            self, value_or_callback: Optional[SecurityContext], /
        ) -> "InitContainer.Builder": ...

        @overload
        def security_context(
            self,
            value_or_callback: Callable[
                [SecurityContext.Builder], SecurityContext.Builder | SecurityContext
            ],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def security_context(
            self, value_or_callback: Never = ...
        ) -> "SecurityContext.BuilderContext": ...

        def security_context(self, value_or_callback=None, /):
            """
            SecurityContext defines the security options the container should be run with.
            If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
            More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
            """
            if self._in_context and value_or_callback is None:
                context = SecurityContext.BuilderContext()
                context._parent_builder = self
                context._field_name = "security_context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecurityContext.builder())
                if isinstance(output, SecurityContext.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("security_context", value)

        @overload
        def startup_probe(
            self, value_or_callback: Optional[StartupProbe], /
        ) -> "InitContainer.Builder": ...

        @overload
        def startup_probe(
            self,
            value_or_callback: Callable[
                [StartupProbe.Builder], StartupProbe.Builder | StartupProbe
            ],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def startup_probe(
            self, value_or_callback: Never = ...
        ) -> "StartupProbe.BuilderContext": ...

        def startup_probe(self, value_or_callback=None, /):
            """
            StartupProbe indicates that the Pod has successfully initialized.
            If specified, no other probes are executed until this completes successfully.
            If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
            This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
            when it might take a long time to load data or warm a cache, than during steady-state operation.
            This cannot be updated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            if self._in_context and value_or_callback is None:
                context = StartupProbe.BuilderContext()
                context._parent_builder = self
                context._field_name = "startup_probe"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(StartupProbe.builder())
                if isinstance(output, StartupProbe.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("startup_probe", value)

        def stdin(self, value: Optional[bool], /) -> Self:
            """
            Whether this container should allocate a buffer for stdin in the container runtime. If this
            is not set, reads from stdin in the container will always result in EOF.
            Default is false.
            """
            return self._set("stdin", value)

        def stdin_once(self, value: Optional[bool], /) -> Self:
            """
            Whether the container runtime should close the stdin channel after it has been opened by
            a single attach. When stdin is true the stdin stream will remain open across multiple attach
            sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
            first client attaches to stdin, and then remains open and accepts data until the client disconnects,
            at which time stdin is closed and remains closed until the container is restarted. If this
            flag is false, a container processes that reads from stdin will never receive an EOF.
            Default is false
            """
            return self._set("stdin_once", value)

        def termination_message_path(self, value: Optional[str], /) -> Self:
            """
            Optional: Path at which the file to which the container's termination message
            will be written is mounted into the container's filesystem.
            Message written is intended to be brief final status, such as an assertion failure message.
            Will be truncated by the node if greater than 4096 bytes. The total message length across
            all containers will be limited to 12kb.
            Defaults to /dev/termination-log.
            Cannot be updated.
            """
            return self._set("termination_message_path", value)

        def termination_message_policy(self, value: Optional[str], /) -> Self:
            """
            Indicate how the termination message should be populated. File will use the contents of
            terminationMessagePath to populate the container status message on both success and failure.
            FallbackToLogsOnError will use the last chunk of container log output if the termination
            message file is empty and the container exited with an error.
            The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
            Defaults to File.
            Cannot be updated.
            """
            return self._set("termination_message_policy", value)

        def tty(self, value: Optional[bool], /) -> Self:
            """
            Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
            Default is false.
            """
            return self._set("tty", value)

        @overload
        def volume_devices(
            self, value_or_callback: List[VolumeDevice], /
        ) -> "InitContainer.Builder": ...

        @overload
        def volume_devices(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[VolumeDevice, VolumeDevice.Builder]],
                GenericListBuilder[VolumeDevice, VolumeDevice.Builder] | List[VolumeDevice],
            ],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def volume_devices(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[VolumeDevice.Builder]: ...

        def volume_devices(self, value_or_callback=None, /):
            """
            volumeDevices is the list of block devices to be used by the container.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[VolumeDevice.Builder]()
                context._parent_builder = self
                context._field_name = "volume_devices"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VolumeDevice.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("volume_devices", value)

        @overload
        def volume_mounts(
            self, value_or_callback: List[VolumeMount], /
        ) -> "InitContainer.Builder": ...

        @overload
        def volume_mounts(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[VolumeMount, VolumeMount.Builder]],
                GenericListBuilder[VolumeMount, VolumeMount.Builder] | List[VolumeMount],
            ],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def volume_mounts(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[VolumeMount.Builder]: ...

        def volume_mounts(self, value_or_callback=None, /):
            """
            Pod volumes to mount into the container's filesystem.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[VolumeMount.Builder]()
                context._parent_builder = self
                context._field_name = "volume_mounts"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VolumeMount.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("volume_mounts", value)

        def working_dir(self, value: Optional[str], /) -> Self:
            """
            Container's working directory.
            If not specified, the container runtime's default will be used, which
            might be configured in the container image.
            Cannot be updated.
            """
            return self._set("working_dir", value)

    class BuilderContext(BuilderContextBase["InitContainer.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitContainer.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitContainer."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitContainer", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitContainer.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    args: Optional[List[str]] = None
    """
    Arguments to the entrypoint.
    The container image's CMD is used if this is not provided.
    Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    of whether the variable exists or not. Cannot be updated.
    More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
    """
    command: Optional[List[str]] = None
    """
    Entrypoint array. Not executed within a shell.
    The container image's ENTRYPOINT is used if this is not provided.
    Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    of whether the variable exists or not. Cannot be updated.
    More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
    """
    env: Optional[List[Env]] = None
    """
    List of environment variables to set in the container.
    Cannot be updated.
    """
    env_from: Annotated[Optional[List[EnvFrom]], Field(alias="envFrom")] = None
    """
    List of sources to populate environment variables in the container.
    The keys defined within a source must be a C_IDENTIFIER. All invalid keys
    will be reported as an event when the container is starting. When a key exists in multiple
    sources, the value associated with the last source will take precedence.
    Values defined by an Env with a duplicate key will take precedence.
    Cannot be updated.
    """
    image: Optional[str] = None
    """
    Container image name.
    More info: https://kubernetes.io/docs/concepts/containers/images
    This field is optional to allow higher level config management to default or override
    container images in workload controllers like Deployments and StatefulSets.
    """
    image_pull_policy: Annotated[Optional[str], Field(alias="imagePullPolicy")] = None
    """
    Image pull policy.
    One of Always, Never, IfNotPresent.
    Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    Cannot be updated.
    More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
    """
    lifecycle: Optional[Lifecycle] = None
    """
    Actions that the management system should take in response to container lifecycle events.
    Cannot be updated.
    """
    liveness_probe: Annotated[Optional[LivenessProbe], Field(alias="livenessProbe")] = None
    """
    Periodic probe of container liveness.
    Container will be restarted if the probe fails.
    Cannot be updated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    name: str
    """
    Name of the container specified as a DNS_LABEL.
    Each container in a pod must have a unique name (DNS_LABEL).
    Cannot be updated.
    """
    ports: Optional[List[Port]] = None
    """
    List of ports to expose from the container. Not specifying a port here
    DOES NOT prevent that port from being exposed. Any port which is
    listening on the default "0.0.0.0" address inside a container will be
    accessible from the network.
    Modifying this array with strategic merge patch may corrupt the data.
    For more information See https://github.com/kubernetes/kubernetes/issues/108255.
    Cannot be updated.
    """
    readiness_probe: Annotated[Optional[ReadinessProbe], Field(alias="readinessProbe")] = None
    """
    Periodic probe of container service readiness.
    Container will be removed from service endpoints if the probe fails.
    Cannot be updated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    resize_policy: Annotated[Optional[List[ResizePolicy]], Field(alias="resizePolicy")] = None
    """
    Resources resize policy for the container.
    """
    resources: Optional[Resources] = None
    """
    Compute Resources required by this container.
    Cannot be updated.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """
    restart_policy: Annotated[Optional[str], Field(alias="restartPolicy")] = None
    """
    RestartPolicy defines the restart behavior of individual containers in a pod.
    This field may only be set for init containers, and the only allowed value is "Always".
    For non-init containers or when this field is not specified,
    the restart behavior is defined by the Pod's restart policy and the container type.
    Setting the RestartPolicy as "Always" for the init container will have the following effect:
    this init container will be continually restarted on
    exit until all regular containers have terminated. Once all regular
    containers have completed, all init containers with restartPolicy "Always"
    will be shut down. This lifecycle differs from normal init containers and
    is often referred to as a "sidecar" container. Although this init
    container still starts in the init container sequence, it does not wait
    for the container to complete before proceeding to the next init
    container. Instead, the next init container starts immediately after this
    init container is started, or after any startupProbe has successfully
    completed.
    """
    security_context: Annotated[Optional[SecurityContext], Field(alias="securityContext")] = None
    """
    SecurityContext defines the security options the container should be run with.
    If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
    More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
    """
    startup_probe: Annotated[Optional[StartupProbe], Field(alias="startupProbe")] = None
    """
    StartupProbe indicates that the Pod has successfully initialized.
    If specified, no other probes are executed until this completes successfully.
    If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
    This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
    when it might take a long time to load data or warm a cache, than during steady-state operation.
    This cannot be updated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    stdin: Optional[bool] = None
    """
    Whether this container should allocate a buffer for stdin in the container runtime. If this
    is not set, reads from stdin in the container will always result in EOF.
    Default is false.
    """
    stdin_once: Annotated[Optional[bool], Field(alias="stdinOnce")] = None
    """
    Whether the container runtime should close the stdin channel after it has been opened by
    a single attach. When stdin is true the stdin stream will remain open across multiple attach
    sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
    first client attaches to stdin, and then remains open and accepts data until the client disconnects,
    at which time stdin is closed and remains closed until the container is restarted. If this
    flag is false, a container processes that reads from stdin will never receive an EOF.
    Default is false
    """
    termination_message_path: Annotated[Optional[str], Field(alias="terminationMessagePath")] = None
    """
    Optional: Path at which the file to which the container's termination message
    will be written is mounted into the container's filesystem.
    Message written is intended to be brief final status, such as an assertion failure message.
    Will be truncated by the node if greater than 4096 bytes. The total message length across
    all containers will be limited to 12kb.
    Defaults to /dev/termination-log.
    Cannot be updated.
    """
    termination_message_policy: Annotated[
        Optional[str], Field(alias="terminationMessagePolicy")
    ] = None
    """
    Indicate how the termination message should be populated. File will use the contents of
    terminationMessagePath to populate the container status message on both success and failure.
    FallbackToLogsOnError will use the last chunk of container log output if the termination
    message file is empty and the container exited with an error.
    The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
    Defaults to File.
    Cannot be updated.
    """
    tty: Optional[bool] = None
    """
    Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
    Default is false.
    """
    volume_devices: Annotated[Optional[List[VolumeDevice]], Field(alias="volumeDevices")] = None
    """
    volumeDevices is the list of block devices to be used by the container.
    """
    volume_mounts: Annotated[Optional[List[VolumeMount]], Field(alias="volumeMounts")] = None
    """
    Pod volumes to mount into the container's filesystem.
    Cannot be updated.
    """
    working_dir: Annotated[Optional[str], Field(alias="workingDir")] = None
    """
    Container's working directory.
    If not specified, the container runtime's default will be used, which
    might be configured in the container image.
    Cannot be updated.
    """


class PromoteResourceAttribute(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "PromoteResourceAttribute":
            value = cast(str, self._value)
            return PromoteResourceAttribute(value)

    root: Annotated[str, Field(min_length=1)]

    class BuilderContext(BuilderContextBase["PromoteResourceAttribute.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PromoteResourceAttribute.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PromoteResourceAttribute."""
        return cls.BuilderContext()


class Otlp(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Otlp"]:
            return Otlp

        def build(self) -> "Otlp":
            return Otlp(**self._attrs)

        def keep_identifying_resource_attributes(self, value: Optional[bool], /) -> Self:
            """
            Enables adding `service.name`, `service.namespace` and `service.instance.id`
            resource attributes to the `target_info` metric, on top of converting them into the `instance` and `job` labels.

            It requires Prometheus >= v3.1.0.
            """
            return self._set("keep_identifying_resource_attributes", value)

        @overload
        def promote_resource_attributes(
            self, value_or_callback: List[PromoteResourceAttribute], /
        ) -> "Otlp.Builder": ...

        @overload
        def promote_resource_attributes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PromoteResourceAttribute, PromoteResourceAttribute.Builder]],
                GenericListBuilder[PromoteResourceAttribute, PromoteResourceAttribute.Builder]
                | List[PromoteResourceAttribute],
            ],
            /,
        ) -> "Otlp.Builder": ...

        @overload
        def promote_resource_attributes(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PromoteResourceAttribute.Builder]: ...

        def promote_resource_attributes(self, value_or_callback=None, /):
            """
            List of OpenTelemetry Attributes that should be promoted to metric labels, defaults to none.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PromoteResourceAttribute.Builder]()
                context._parent_builder = self
                context._field_name = "promote_resource_attributes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PromoteResourceAttribute.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("promote_resource_attributes", value)

        def translation_strategy(
            self,
            value: Optional[
                Literal["NoUTF8EscapingWithSuffixes", "UnderscoreEscapingWithSuffixes"]
            ],
            /,
        ) -> Self:
            """
            Configures how the OTLP receiver endpoint translates the incoming metrics.

            It requires Prometheus >= v3.0.0.
            """
            return self._set("translation_strategy", value)

    class BuilderContext(BuilderContextBase["Otlp.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Otlp.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Otlp."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Otlp", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Otlp.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    keep_identifying_resource_attributes: Annotated[
        Optional[bool], Field(alias="keepIdentifyingResourceAttributes")
    ] = None
    """
    Enables adding `service.name`, `service.namespace` and `service.instance.id`
    resource attributes to the `target_info` metric, on top of converting them into the `instance` and `job` labels.

    It requires Prometheus >= v3.1.0.
    """
    promote_resource_attributes: Annotated[
        Optional[List[PromoteResourceAttribute]],
        Field(alias="promoteResourceAttributes", min_length=1),
    ] = None
    """
    List of OpenTelemetry Attributes that should be promoted to metric labels, defaults to none.
    """
    translation_strategy: Annotated[
        Optional[Literal["NoUTF8EscapingWithSuffixes", "UnderscoreEscapingWithSuffixes"]],
        Field(alias="translationStrategy"),
    ] = None
    """
    Configures how the OTLP receiver endpoint translates the incoming metrics.

    It requires Prometheus >= v3.0.0.
    """


class PersistentVolumeClaimRetentionPolicy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PersistentVolumeClaimRetentionPolicy"]:
            return PersistentVolumeClaimRetentionPolicy

        def build(self) -> "PersistentVolumeClaimRetentionPolicy":
            return PersistentVolumeClaimRetentionPolicy(**self._attrs)

        def when_deleted(self, value: Optional[str], /) -> Self:
            """
            WhenDeleted specifies what happens to PVCs created from StatefulSet
            VolumeClaimTemplates when the StatefulSet is deleted. The default policy
            of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
            `Delete` policy causes those PVCs to be deleted.
            """
            return self._set("when_deleted", value)

        def when_scaled(self, value: Optional[str], /) -> Self:
            """
            WhenScaled specifies what happens to PVCs created from StatefulSet
            VolumeClaimTemplates when the StatefulSet is scaled down. The default
            policy of `Retain` causes PVCs to not be affected by a scaledown. The
            `Delete` policy causes the associated PVCs for any excess pods above
            the replica count to be deleted.
            """
            return self._set("when_scaled", value)

    class BuilderContext(BuilderContextBase["PersistentVolumeClaimRetentionPolicy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PersistentVolumeClaimRetentionPolicy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PersistentVolumeClaimRetentionPolicy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PersistentVolumeClaimRetentionPolicy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PersistentVolumeClaimRetentionPolicy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    when_deleted: Annotated[Optional[str], Field(alias="whenDeleted")] = None
    """
    WhenDeleted specifies what happens to PVCs created from StatefulSet
    VolumeClaimTemplates when the StatefulSet is deleted. The default policy
    of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
    `Delete` policy causes those PVCs to be deleted.
    """
    when_scaled: Annotated[Optional[str], Field(alias="whenScaled")] = None
    """
    WhenScaled specifies what happens to PVCs created from StatefulSet
    VolumeClaimTemplates when the StatefulSet is scaled down. The default
    policy of `Retain` causes PVCs to not be affected by a scaledown. The
    `Delete` policy causes the associated PVCs for any excess pods above
    the replica count to be deleted.
    """


class PodMetadata(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodMetadata"]:
            return PodMetadata

        def build(self) -> "PodMetadata":
            return PodMetadata(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations is an unstructured key value map stored with a resource that may be
            set by external tools to store and retrieve arbitrary metadata. They are not
            queryable and should be preserved when modifying objects.
            More info: http://kubernetes.io/docs/user-guide/annotations
            """
            return self._set("annotations", value)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Map of string keys and values that can be used to organize and categorize
            (scope and select) objects. May match selectors of replication controllers
            and services.
            More info: http://kubernetes.io/docs/user-guide/labels
            """
            return self._set("labels", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name must be unique within a namespace. Is required when creating resources, although
            some resources may allow a client to request the generation of an appropriate name
            automatically. Name is primarily intended for creation idempotence and configuration
            definition.
            Cannot be updated.
            More info: http://kubernetes.io/docs/user-guide/identifiers#names
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["PodMetadata.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodMetadata.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodMetadata."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodMetadata", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodMetadata.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, str]] = None
    """
    Annotations is an unstructured key value map stored with a resource that may be
    set by external tools to store and retrieve arbitrary metadata. They are not
    queryable and should be preserved when modifying objects.
    More info: http://kubernetes.io/docs/user-guide/annotations
    """
    labels: Optional[Dict[str, str]] = None
    """
    Map of string keys and values that can be used to organize and categorize
    (scope and select) objects. May match selectors of replication controllers
    and services.
    More info: http://kubernetes.io/docs/user-guide/labels
    """
    name: Optional[str] = None
    """
    Name must be unique within a namespace. Is required when creating resources, although
    some resources may allow a client to request the generation of an appropriate name
    automatically. Name is primarily intended for creation idempotence and configuration
    definition.
    Cannot be updated.
    More info: http://kubernetes.io/docs/user-guide/identifiers#names
    """


class PodMonitorNamespaceSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodMonitorNamespaceSelector"]:
            return PodMonitorNamespaceSelector

        def build(self) -> "PodMonitorNamespaceSelector":
            return PodMonitorNamespaceSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel], /
        ) -> "PodMonitorNamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]],
                GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]
                | List[MatchExpressionModel],
            ],
            /,
        ) -> "PodMonitorNamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["PodMonitorNamespaceSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodMonitorNamespaceSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodMonitorNamespaceSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodMonitorNamespaceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodMonitorNamespaceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class PodMonitorSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodMonitorSelector"]:
            return PodMonitorSelector

        def build(self) -> "PodMonitorSelector":
            return PodMonitorSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel], /
        ) -> "PodMonitorSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]],
                GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]
                | List[MatchExpressionModel],
            ],
            /,
        ) -> "PodMonitorSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["PodMonitorSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodMonitorSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodMonitorSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodMonitorSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodMonitorSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class ProbeNamespaceSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProbeNamespaceSelector"]:
            return ProbeNamespaceSelector

        def build(self) -> "ProbeNamespaceSelector":
            return ProbeNamespaceSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel], /
        ) -> "ProbeNamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]],
                GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]
                | List[MatchExpressionModel],
            ],
            /,
        ) -> "ProbeNamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["ProbeNamespaceSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProbeNamespaceSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProbeNamespaceSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProbeNamespaceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProbeNamespaceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class ProbeSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProbeSelector"]:
            return ProbeSelector

        def build(self) -> "ProbeSelector":
            return ProbeSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel], /
        ) -> "ProbeSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]],
                GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]
                | List[MatchExpressionModel],
            ],
            /,
        ) -> "ProbeSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["ProbeSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProbeSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProbeSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProbeSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProbeSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class ManagedIdentity(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ManagedIdentity"]:
            return ManagedIdentity

        def build(self) -> "ManagedIdentity":
            return ManagedIdentity(**self._attrs)

        def client_id(self, value: str, /) -> Self:
            """
            The client id
            """
            return self._set("client_id", value)

    class BuilderContext(BuilderContextBase["ManagedIdentity.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ManagedIdentity.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ManagedIdentity."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ManagedIdentity", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ManagedIdentity.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    client_id: Annotated[str, Field(alias="clientId")]
    """
    The client id
    """


class Oauth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Oauth"]:
            return Oauth

        def build(self) -> "Oauth":
            return Oauth(**self._attrs)

        def client_id(self, value: str, /) -> Self:
            """
            `clientID` is the clientId of the Azure Active Directory application that is being used to authenticate.
            """
            return self._set("client_id", value)

        @overload
        def client_secret(self, value_or_callback: ClientSecret, /) -> "Oauth.Builder": ...

        @overload
        def client_secret(
            self,
            value_or_callback: Callable[
                [ClientSecret.Builder], ClientSecret.Builder | ClientSecret
            ],
            /,
        ) -> "Oauth.Builder": ...

        @overload
        def client_secret(
            self, value_or_callback: Never = ...
        ) -> "ClientSecret.BuilderContext": ...

        def client_secret(self, value_or_callback=None, /):
            """
            `clientSecret` specifies a key of a Secret containing the client secret of the Azure Active Directory application that is being used to authenticate.
            """
            if self._in_context and value_or_callback is None:
                context = ClientSecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "client_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClientSecret.builder())
                if isinstance(output, ClientSecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("client_secret", value)

        def tenant_id(self, value: str, /) -> Self:
            """
            `tenantId` is the tenant ID of the Azure Active Directory application that is being used to authenticate.
            """
            return self._set("tenant_id", value)

    class BuilderContext(BuilderContextBase["Oauth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Oauth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Oauth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Oauth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Oauth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    client_id: Annotated[str, Field(alias="clientId", min_length=1)]
    """
    `clientID` is the clientId of the Azure Active Directory application that is being used to authenticate.
    """
    client_secret: Annotated[ClientSecret, Field(alias="clientSecret")]
    """
    `clientSecret` specifies a key of a Secret containing the client secret of the Azure Active Directory application that is being used to authenticate.
    """
    tenant_id: Annotated[str, Field(alias="tenantId", min_length=1, pattern="^[0-9a-zA-Z-.]+$")]
    """
    `tenantId` is the tenant ID of the Azure Active Directory application that is being used to authenticate.
    """


class Sdk(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Sdk"]:
            return Sdk

        def build(self) -> "Sdk":
            return Sdk(**self._attrs)

        def tenant_id(self, value: Optional[str], /) -> Self:
            """
            `tenantId` is the tenant ID of the azure active directory application that is being used to authenticate.
            """
            return self._set("tenant_id", value)

    class BuilderContext(BuilderContextBase["Sdk.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Sdk.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Sdk."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Sdk", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Sdk.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    tenant_id: Annotated[Optional[str], Field(alias="tenantId", pattern="^[0-9a-zA-Z-.]+$")] = None
    """
    `tenantId` is the tenant ID of the azure active directory application that is being used to authenticate.
    """


class AzureAd(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AzureAd"]:
            return AzureAd

        def build(self) -> "AzureAd":
            return AzureAd(**self._attrs)

        def cloud(
            self,
            value: Optional[Literal["AzureChina", "AzureGovernment", "AzurePublic"]],
            /,
        ) -> Self:
            """
            The Azure Cloud. Options are 'AzurePublic', 'AzureChina', or 'AzureGovernment'.
            """
            return self._set("cloud", value)

        @overload
        def managed_identity(
            self, value_or_callback: Optional[ManagedIdentity], /
        ) -> "AzureAd.Builder": ...

        @overload
        def managed_identity(
            self,
            value_or_callback: Callable[
                [ManagedIdentity.Builder], ManagedIdentity.Builder | ManagedIdentity
            ],
            /,
        ) -> "AzureAd.Builder": ...

        @overload
        def managed_identity(
            self, value_or_callback: Never = ...
        ) -> "ManagedIdentity.BuilderContext": ...

        def managed_identity(self, value_or_callback=None, /):
            """
            ManagedIdentity defines the Azure User-assigned Managed identity.
            Cannot be set at the same time as `oauth` or `sdk`.
            """
            if self._in_context and value_or_callback is None:
                context = ManagedIdentity.BuilderContext()
                context._parent_builder = self
                context._field_name = "managed_identity"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ManagedIdentity.builder())
                if isinstance(output, ManagedIdentity.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("managed_identity", value)

        @overload
        def oauth(self, value_or_callback: Optional[Oauth], /) -> "AzureAd.Builder": ...

        @overload
        def oauth(
            self, value_or_callback: Callable[[Oauth.Builder], Oauth.Builder | Oauth], /
        ) -> "AzureAd.Builder": ...

        @overload
        def oauth(self, value_or_callback: Never = ...) -> "Oauth.BuilderContext": ...

        def oauth(self, value_or_callback=None, /):
            """
            OAuth defines the oauth config that is being used to authenticate.
            Cannot be set at the same time as `managedIdentity` or `sdk`.

            It requires Prometheus >= v2.48.0.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth.builder())
                if isinstance(output, Oauth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth", value)

        @overload
        def sdk(self, value_or_callback: Optional[Sdk], /) -> "AzureAd.Builder": ...

        @overload
        def sdk(
            self, value_or_callback: Callable[[Sdk.Builder], Sdk.Builder | Sdk], /
        ) -> "AzureAd.Builder": ...

        @overload
        def sdk(self, value_or_callback: Never = ...) -> "Sdk.BuilderContext": ...

        def sdk(self, value_or_callback=None, /):
            """
            SDK defines the Azure SDK config that is being used to authenticate.
            See https://learn.microsoft.com/en-us/azure/developer/go/azure-sdk-authentication
            Cannot be set at the same time as `oauth` or `managedIdentity`.

            It requires Prometheus >= 2.52.0.
            """
            if self._in_context and value_or_callback is None:
                context = Sdk.BuilderContext()
                context._parent_builder = self
                context._field_name = "sdk"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sdk.builder())
                if isinstance(output, Sdk.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sdk", value)

    class BuilderContext(BuilderContextBase["AzureAd.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AzureAd.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AzureAd."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AzureAd", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AzureAd.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cloud: Optional[Literal["AzureChina", "AzureGovernment", "AzurePublic"]] = None
    """
    The Azure Cloud. Options are 'AzurePublic', 'AzureChina', or 'AzureGovernment'.
    """
    managed_identity: Annotated[Optional[ManagedIdentity], Field(alias="managedIdentity")] = None
    """
    ManagedIdentity defines the Azure User-assigned Managed identity.
    Cannot be set at the same time as `oauth` or `sdk`.
    """
    oauth: Optional[Oauth] = None
    """
    OAuth defines the oauth config that is being used to authenticate.
    Cannot be set at the same time as `managedIdentity` or `sdk`.

    It requires Prometheus >= v2.48.0.
    """
    sdk: Optional[Sdk] = None
    """
    SDK defines the Azure SDK config that is being used to authenticate.
    See https://learn.microsoft.com/en-us/azure/developer/go/azure-sdk-authentication
    Cannot be set at the same time as `oauth` or `managedIdentity`.

    It requires Prometheus >= 2.52.0.
    """


class MetadataConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MetadataConfig"]:
            return MetadataConfig

        def build(self) -> "MetadataConfig":
            return MetadataConfig(**self._attrs)

        def send(self, value: Optional[bool], /) -> Self:
            """
            Defines whether metric metadata is sent to the remote storage or not.
            """
            return self._set("send", value)

        def send_interval(self, value: Optional[str], /) -> Self:
            """
            Defines how frequently metric metadata is sent to the remote storage.
            """
            return self._set("send_interval", value)

    class BuilderContext(BuilderContextBase["MetadataConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MetadataConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MetadataConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MetadataConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MetadataConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    send: Optional[bool] = None
    """
    Defines whether metric metadata is sent to the remote storage or not.
    """
    send_interval: Annotated[
        Optional[str],
        Field(
            alias="sendInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Defines how frequently metric metadata is sent to the remote storage.
    """


class TlsConfigModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsConfigModel1"]:
            return TlsConfigModel1

        def build(self) -> "TlsConfigModel1":
            return TlsConfigModel1(**self._attrs)

        @overload
        def ca(self, value_or_callback: Optional[Ca], /) -> "TlsConfigModel1.Builder": ...

        @overload
        def ca(
            self, value_or_callback: Callable[[Ca.Builder], Ca.Builder | Ca], /
        ) -> "TlsConfigModel1.Builder": ...

        @overload
        def ca(self, value_or_callback: Never = ...) -> "Ca.BuilderContext": ...

        def ca(self, value_or_callback=None, /):
            """
            Certificate authority used when verifying server certificates.
            """
            if self._in_context and value_or_callback is None:
                context = Ca.BuilderContext()
                context._parent_builder = self
                context._field_name = "ca"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ca.builder())
                if isinstance(output, Ca.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ca", value)

        @overload
        def cert(self, value_or_callback: Optional[Cert], /) -> "TlsConfigModel1.Builder": ...

        @overload
        def cert(
            self, value_or_callback: Callable[[Cert.Builder], Cert.Builder | Cert], /
        ) -> "TlsConfigModel1.Builder": ...

        @overload
        def cert(self, value_or_callback: Never = ...) -> "Cert.BuilderContext": ...

        def cert(self, value_or_callback=None, /):
            """
            Client certificate to present when doing client-authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Cert.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cert.builder())
                if isinstance(output, Cert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert", value)

        def insecure_skip_verify(self, value: Optional[bool], /) -> Self:
            """
            Disable target certificate validation.
            """
            return self._set("insecure_skip_verify", value)

        @overload
        def key_secret(
            self, value_or_callback: Optional[KeySecret], /
        ) -> "TlsConfigModel1.Builder": ...

        @overload
        def key_secret(
            self,
            value_or_callback: Callable[[KeySecret.Builder], KeySecret.Builder | KeySecret],
            /,
        ) -> "TlsConfigModel1.Builder": ...

        @overload
        def key_secret(self, value_or_callback: Never = ...) -> "KeySecret.BuilderContext": ...

        def key_secret(self, value_or_callback=None, /):
            """
            Secret containing the client key file for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = KeySecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "key_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KeySecret.builder())
                if isinstance(output, KeySecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("key_secret", value)

        def max_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Maximum acceptable TLS version.

            It requires Prometheus >= v2.41.0.
            """
            return self._set("max_version", value)

        def min_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Minimum acceptable TLS version.

            It requires Prometheus >= v2.35.0.
            """
            return self._set("min_version", value)

        def server_name(self, value: Optional[str], /) -> Self:
            """
            Used to verify the hostname for the targets.
            """
            return self._set("server_name", value)

    class BuilderContext(BuilderContextBase["TlsConfigModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsConfigModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsConfigModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsConfigModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsConfigModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca: Optional[Ca] = None
    """
    Certificate authority used when verifying server certificates.
    """
    cert: Optional[Cert] = None
    """
    Client certificate to present when doing client-authentication.
    """
    insecure_skip_verify: Annotated[Optional[bool], Field(alias="insecureSkipVerify")] = None
    """
    Disable target certificate validation.
    """
    key_secret: Annotated[Optional[KeySecret], Field(alias="keySecret")] = None
    """
    Secret containing the client key file for the targets.
    """
    max_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="maxVersion")
    ] = None
    """
    Maximum acceptable TLS version.

    It requires Prometheus >= v2.41.0.
    """
    min_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="minVersion")
    ] = None
    """
    Minimum acceptable TLS version.

    It requires Prometheus >= v2.35.0.
    """
    server_name: Annotated[Optional[str], Field(alias="serverName")] = None
    """
    Used to verify the hostname for the targets.
    """


class QueueConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["QueueConfig"]:
            return QueueConfig

        def build(self) -> "QueueConfig":
            return QueueConfig(**self._attrs)

        def batch_send_deadline(self, value: Optional[str], /) -> Self:
            """
            BatchSendDeadline is the maximum time a sample will wait in buffer.
            """
            return self._set("batch_send_deadline", value)

        def capacity(self, value: Optional[int], /) -> Self:
            """
            Capacity is the number of samples to buffer per shard before we start
            dropping them.
            """
            return self._set("capacity", value)

        def max_backoff(self, value: Optional[str], /) -> Self:
            """
            MaxBackoff is the maximum retry delay.
            """
            return self._set("max_backoff", value)

        def max_retries(self, value: Optional[int], /) -> Self:
            """
            MaxRetries is the maximum number of times to retry a batch on recoverable errors.
            """
            return self._set("max_retries", value)

        def max_samples_per_send(self, value: Optional[int], /) -> Self:
            """
            MaxSamplesPerSend is the maximum number of samples per send.
            """
            return self._set("max_samples_per_send", value)

        def max_shards(self, value: Optional[int], /) -> Self:
            """
            MaxShards is the maximum number of shards, i.e. amount of concurrency.
            """
            return self._set("max_shards", value)

        def min_backoff(self, value: Optional[str], /) -> Self:
            """
            MinBackoff is the initial retry delay. Gets doubled for every retry.
            """
            return self._set("min_backoff", value)

        def min_shards(self, value: Optional[int], /) -> Self:
            """
            MinShards is the minimum number of shards, i.e. amount of concurrency.
            """
            return self._set("min_shards", value)

        def retry_on_rate_limit(self, value: Optional[bool], /) -> Self:
            """
            Retry upon receiving a 429 status code from the remote-write storage.

            This is an *experimental feature*, it may change in any upcoming release
            in a breaking way.
            """
            return self._set("retry_on_rate_limit", value)

        def sample_age_limit(self, value: Optional[str], /) -> Self:
            """
            SampleAgeLimit drops samples older than the limit.
            It requires Prometheus >= v2.50.0.
            """
            return self._set("sample_age_limit", value)

    class BuilderContext(BuilderContextBase["QueueConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = QueueConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for QueueConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["QueueConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use QueueConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    batch_send_deadline: Annotated[
        Optional[str],
        Field(
            alias="batchSendDeadline",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    BatchSendDeadline is the maximum time a sample will wait in buffer.
    """
    capacity: Optional[int] = None
    """
    Capacity is the number of samples to buffer per shard before we start
    dropping them.
    """
    max_backoff: Annotated[
        Optional[str],
        Field(
            alias="maxBackoff",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    MaxBackoff is the maximum retry delay.
    """
    max_retries: Annotated[Optional[int], Field(alias="maxRetries")] = None
    """
    MaxRetries is the maximum number of times to retry a batch on recoverable errors.
    """
    max_samples_per_send: Annotated[Optional[int], Field(alias="maxSamplesPerSend")] = None
    """
    MaxSamplesPerSend is the maximum number of samples per send.
    """
    max_shards: Annotated[Optional[int], Field(alias="maxShards")] = None
    """
    MaxShards is the maximum number of shards, i.e. amount of concurrency.
    """
    min_backoff: Annotated[
        Optional[str],
        Field(
            alias="minBackoff",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    MinBackoff is the initial retry delay. Gets doubled for every retry.
    """
    min_shards: Annotated[Optional[int], Field(alias="minShards")] = None
    """
    MinShards is the minimum number of shards, i.e. amount of concurrency.
    """
    retry_on_rate_limit: Annotated[Optional[bool], Field(alias="retryOnRateLimit")] = None
    """
    Retry upon receiving a 429 status code from the remote-write storage.

    This is an *experimental feature*, it may change in any upcoming release
    in a breaking way.
    """
    sample_age_limit: Annotated[
        Optional[str],
        Field(
            alias="sampleAgeLimit",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    SampleAgeLimit drops samples older than the limit.
    It requires Prometheus >= v2.50.0.
    """


class TlsConfigModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsConfigModel2"]:
            return TlsConfigModel2

        def build(self) -> "TlsConfigModel2":
            return TlsConfigModel2(**self._attrs)

        @overload
        def ca(self, value_or_callback: Optional[Ca], /) -> "TlsConfigModel2.Builder": ...

        @overload
        def ca(
            self, value_or_callback: Callable[[Ca.Builder], Ca.Builder | Ca], /
        ) -> "TlsConfigModel2.Builder": ...

        @overload
        def ca(self, value_or_callback: Never = ...) -> "Ca.BuilderContext": ...

        def ca(self, value_or_callback=None, /):
            """
            Certificate authority used when verifying server certificates.
            """
            if self._in_context and value_or_callback is None:
                context = Ca.BuilderContext()
                context._parent_builder = self
                context._field_name = "ca"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ca.builder())
                if isinstance(output, Ca.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ca", value)

        def ca_file(self, value: Optional[str], /) -> Self:
            """
            Path to the CA cert in the Prometheus container to use for the targets.
            """
            return self._set("ca_file", value)

        @overload
        def cert(self, value_or_callback: Optional[Cert], /) -> "TlsConfigModel2.Builder": ...

        @overload
        def cert(
            self, value_or_callback: Callable[[Cert.Builder], Cert.Builder | Cert], /
        ) -> "TlsConfigModel2.Builder": ...

        @overload
        def cert(self, value_or_callback: Never = ...) -> "Cert.BuilderContext": ...

        def cert(self, value_or_callback=None, /):
            """
            Client certificate to present when doing client-authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Cert.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cert.builder())
                if isinstance(output, Cert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert", value)

        def cert_file(self, value: Optional[str], /) -> Self:
            """
            Path to the client cert file in the Prometheus container for the targets.
            """
            return self._set("cert_file", value)

        def insecure_skip_verify(self, value: Optional[bool], /) -> Self:
            """
            Disable target certificate validation.
            """
            return self._set("insecure_skip_verify", value)

        def key_file(self, value: Optional[str], /) -> Self:
            """
            Path to the client key file in the Prometheus container for the targets.
            """
            return self._set("key_file", value)

        @overload
        def key_secret(
            self, value_or_callback: Optional[KeySecret], /
        ) -> "TlsConfigModel2.Builder": ...

        @overload
        def key_secret(
            self,
            value_or_callback: Callable[[KeySecret.Builder], KeySecret.Builder | KeySecret],
            /,
        ) -> "TlsConfigModel2.Builder": ...

        @overload
        def key_secret(self, value_or_callback: Never = ...) -> "KeySecret.BuilderContext": ...

        def key_secret(self, value_or_callback=None, /):
            """
            Secret containing the client key file for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = KeySecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "key_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KeySecret.builder())
                if isinstance(output, KeySecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("key_secret", value)

        def max_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Maximum acceptable TLS version.

            It requires Prometheus >= v2.41.0.
            """
            return self._set("max_version", value)

        def min_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Minimum acceptable TLS version.

            It requires Prometheus >= v2.35.0.
            """
            return self._set("min_version", value)

        def server_name(self, value: Optional[str], /) -> Self:
            """
            Used to verify the hostname for the targets.
            """
            return self._set("server_name", value)

    class BuilderContext(BuilderContextBase["TlsConfigModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsConfigModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsConfigModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsConfigModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsConfigModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca: Optional[Ca] = None
    """
    Certificate authority used when verifying server certificates.
    """
    ca_file: Annotated[Optional[str], Field(alias="caFile")] = None
    """
    Path to the CA cert in the Prometheus container to use for the targets.
    """
    cert: Optional[Cert] = None
    """
    Client certificate to present when doing client-authentication.
    """
    cert_file: Annotated[Optional[str], Field(alias="certFile")] = None
    """
    Path to the client cert file in the Prometheus container for the targets.
    """
    insecure_skip_verify: Annotated[Optional[bool], Field(alias="insecureSkipVerify")] = None
    """
    Disable target certificate validation.
    """
    key_file: Annotated[Optional[str], Field(alias="keyFile")] = None
    """
    Path to the client key file in the Prometheus container for the targets.
    """
    key_secret: Annotated[Optional[KeySecret], Field(alias="keySecret")] = None
    """
    Secret containing the client key file for the targets.
    """
    max_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="maxVersion")
    ] = None
    """
    Maximum acceptable TLS version.

    It requires Prometheus >= v2.41.0.
    """
    min_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="minVersion")
    ] = None
    """
    Minimum acceptable TLS version.

    It requires Prometheus >= v2.35.0.
    """
    server_name: Annotated[Optional[str], Field(alias="serverName")] = None
    """
    Used to verify the hostname for the targets.
    """


class SourceLabel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            LabelName is a valid Prometheus label name which may only contain ASCII
            letters, numbers, as well as underscores.
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            LabelName is a valid Prometheus label name which may only contain ASCII
            letters, numbers, as well as underscores.
            """
            self._value = value
            return self

        def build(self) -> "SourceLabel":
            value = cast(str, self._value)
            return SourceLabel(value)

    root: Annotated[str, Field(pattern="^[a-zA-Z_][a-zA-Z0-9_]*$")]
    """
    LabelName is a valid Prometheus label name which may only contain ASCII
    letters, numbers, as well as underscores.
    """

    class BuilderContext(BuilderContextBase["SourceLabel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SourceLabel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SourceLabel."""
        return cls.BuilderContext()


class WriteRelabelConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WriteRelabelConfig"]:
            return WriteRelabelConfig

        def build(self) -> "WriteRelabelConfig":
            return WriteRelabelConfig(**self._attrs)

        def action(
            self,
            value: Optional[
                Literal[
                    "replace",
                    "Replace",
                    "keep",
                    "Keep",
                    "drop",
                    "Drop",
                    "hashmod",
                    "HashMod",
                    "labelmap",
                    "LabelMap",
                    "labeldrop",
                    "LabelDrop",
                    "labelkeep",
                    "LabelKeep",
                    "lowercase",
                    "Lowercase",
                    "uppercase",
                    "Uppercase",
                    "keepequal",
                    "KeepEqual",
                    "dropequal",
                    "DropEqual",
                ]
            ],
            /,
        ) -> Self:
            """
            Action to perform based on the regex matching.

            `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
            `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.

            Default: "Replace"
            """
            return self._set("action", value)

        def modulus(self, value: Optional[int], /) -> Self:
            """
            Modulus to take of the hash of the source label values.

            Only applicable when the action is `HashMod`.
            """
            return self._set("modulus", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            Regular expression against which the extracted value is matched.
            """
            return self._set("regex", value)

        def replacement(self, value: Optional[str], /) -> Self:
            """
            Replacement value against which a Replace action is performed if the
            regular expression matches.

            Regex capture groups are available.
            """
            return self._set("replacement", value)

        def separator(self, value: Optional[str], /) -> Self:
            """
            Separator is the string between concatenated SourceLabels.
            """
            return self._set("separator", value)

        @overload
        def source_labels(
            self, value_or_callback: List[SourceLabel], /
        ) -> "WriteRelabelConfig.Builder": ...

        @overload
        def source_labels(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[SourceLabel, SourceLabel.Builder]],
                GenericListBuilder[SourceLabel, SourceLabel.Builder] | List[SourceLabel],
            ],
            /,
        ) -> "WriteRelabelConfig.Builder": ...

        @overload
        def source_labels(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[SourceLabel.Builder]: ...

        def source_labels(self, value_or_callback=None, /):
            """
            The source labels select values from existing labels. Their content is
            concatenated using the configured Separator and matched against the
            configured regular expression.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[SourceLabel.Builder]()
                context._parent_builder = self
                context._field_name = "source_labels"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SourceLabel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("source_labels", value)

        def target_label(self, value: Optional[str], /) -> Self:
            """
            Label to which the resulting string is written in a replacement.

            It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
            `KeepEqual` and `DropEqual` actions.

            Regex capture groups are available.
            """
            return self._set("target_label", value)

    class BuilderContext(BuilderContextBase["WriteRelabelConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WriteRelabelConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WriteRelabelConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WriteRelabelConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WriteRelabelConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    action: Optional[
        Literal[
            "replace",
            "Replace",
            "keep",
            "Keep",
            "drop",
            "Drop",
            "hashmod",
            "HashMod",
            "labelmap",
            "LabelMap",
            "labeldrop",
            "LabelDrop",
            "labelkeep",
            "LabelKeep",
            "lowercase",
            "Lowercase",
            "uppercase",
            "Uppercase",
            "keepequal",
            "KeepEqual",
            "dropequal",
            "DropEqual",
        ]
    ] = "replace"
    """
    Action to perform based on the regex matching.

    `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
    `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.

    Default: "Replace"
    """
    modulus: Optional[int] = None
    """
    Modulus to take of the hash of the source label values.

    Only applicable when the action is `HashMod`.
    """
    regex: Optional[str] = None
    """
    Regular expression against which the extracted value is matched.
    """
    replacement: Optional[str] = None
    """
    Replacement value against which a Replace action is performed if the
    regular expression matches.

    Regex capture groups are available.
    """
    separator: Optional[str] = None
    """
    Separator is the string between concatenated SourceLabels.
    """
    source_labels: Annotated[Optional[List[SourceLabel]], Field(alias="sourceLabels")] = None
    """
    The source labels select values from existing labels. Their content is
    concatenated using the configured Separator and matched against the
    configured regular expression.
    """
    target_label: Annotated[Optional[str], Field(alias="targetLabel")] = None
    """
    Label to which the resulting string is written in a replacement.

    It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
    `KeepEqual` and `DropEqual` actions.

    Regex capture groups are available.
    """


class RemoteWrite(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RemoteWrite"]:
            return RemoteWrite

        def build(self) -> "RemoteWrite":
            return RemoteWrite(**self._attrs)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel], /
        ) -> "RemoteWrite.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel.Builder],
                AuthorizationModel.Builder | AuthorizationModel,
            ],
            /,
        ) -> "RemoteWrite.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization section for the URL.

            It requires Prometheus >= v2.26.0.

            Cannot be set at the same time as `sigv4`, `basicAuth`, `oauth2`, or `azureAd`.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel.builder())
                if isinstance(output, AuthorizationModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def azure_ad(self, value_or_callback: Optional[AzureAd], /) -> "RemoteWrite.Builder": ...

        @overload
        def azure_ad(
            self,
            value_or_callback: Callable[[AzureAd.Builder], AzureAd.Builder | AzureAd],
            /,
        ) -> "RemoteWrite.Builder": ...

        @overload
        def azure_ad(self, value_or_callback: Never = ...) -> "AzureAd.BuilderContext": ...

        def azure_ad(self, value_or_callback=None, /):
            """
            AzureAD for the URL.

            It requires Prometheus >= v2.45.0.

            Cannot be set at the same time as `authorization`, `basicAuth`, `oauth2`, or `sigv4`.
            """
            if self._in_context and value_or_callback is None:
                context = AzureAd.BuilderContext()
                context._parent_builder = self
                context._field_name = "azure_ad"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AzureAd.builder())
                if isinstance(output, AzureAd.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("azure_ad", value)

        @overload
        def basic_auth(
            self, value_or_callback: Optional[BasicAuth], /
        ) -> "RemoteWrite.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "RemoteWrite.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            BasicAuth configuration for the URL.

            Cannot be set at the same time as `sigv4`, `authorization`, `oauth2`, or `azureAd`.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        def bearer_token(self, value: Optional[str], /) -> Self:
            """
            *Warning: this field shouldn't be used because the token value appears
            in clear-text. Prefer using `authorization`.*

            Deprecated: this will be removed in a future release.
            """
            return self._set("bearer_token", value)

        def bearer_token_file(self, value: Optional[str], /) -> Self:
            """
            File from which to read bearer token for the URL.

            Deprecated: this will be removed in a future release. Prefer using `authorization`.
            """
            return self._set("bearer_token_file", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            Whether to enable HTTP2.
            """
            return self._set("enable_http2", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            Configure whether HTTP requests follow HTTP 3xx redirects.

            It requires Prometheus >= v2.26.0.
            """
            return self._set("follow_redirects", value)

        def headers(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Custom HTTP headers to be sent along with each remote write request.
            Be aware that headers that are set by Prometheus itself can't be overwritten.

            It requires Prometheus >= v2.25.0.
            """
            return self._set("headers", value)

        def message_version(self, value: Optional[Literal["V1.0", "V2.0"]], /) -> Self:
            """
            The Remote Write message's version to use when writing to the endpoint.

            `Version1.0` corresponds to the `prometheus.WriteRequest` protobuf message introduced in Remote Write 1.0.
            `Version2.0` corresponds to the `io.prometheus.write.v2.Request` protobuf message introduced in Remote Write 2.0.

            When `Version2.0` is selected, Prometheus will automatically be
            configured to append the metadata of scraped metrics to the WAL.

            Before setting this field, consult with your remote storage provider
            what message version it supports.

            It requires Prometheus >= v2.54.0.
            """
            return self._set("message_version", value)

        @overload
        def metadata_config(
            self, value_or_callback: Optional[MetadataConfig], /
        ) -> "RemoteWrite.Builder": ...

        @overload
        def metadata_config(
            self,
            value_or_callback: Callable[
                [MetadataConfig.Builder], MetadataConfig.Builder | MetadataConfig
            ],
            /,
        ) -> "RemoteWrite.Builder": ...

        @overload
        def metadata_config(
            self, value_or_callback: Never = ...
        ) -> "MetadataConfig.BuilderContext": ...

        def metadata_config(self, value_or_callback=None, /):
            """
            MetadataConfig configures the sending of series metadata to the remote storage.
            """
            if self._in_context and value_or_callback is None:
                context = MetadataConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MetadataConfig.builder())
                if isinstance(output, MetadataConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata_config", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the remote write queue, it must be unique if specified. The
            name is used in metrics and logging in order to differentiate queues.

            It requires Prometheus >= v2.15.0.
            """
            return self._set("name", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        @overload
        def oauth2(self, value_or_callback: Optional[Oauth2], /) -> "RemoteWrite.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "RemoteWrite.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            OAuth2 configuration for the URL.

            It requires Prometheus >= v2.27.0.

            Cannot be set at the same time as `sigv4`, `authorization`, `basicAuth`, or `azureAd`.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        @overload
        def queue_config(
            self, value_or_callback: Optional[QueueConfig], /
        ) -> "RemoteWrite.Builder": ...

        @overload
        def queue_config(
            self,
            value_or_callback: Callable[[QueueConfig.Builder], QueueConfig.Builder | QueueConfig],
            /,
        ) -> "RemoteWrite.Builder": ...

        @overload
        def queue_config(self, value_or_callback: Never = ...) -> "QueueConfig.BuilderContext": ...

        def queue_config(self, value_or_callback=None, /):
            """
            QueueConfig allows tuning of the remote write queue parameters.
            """
            if self._in_context and value_or_callback is None:
                context = QueueConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "queue_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(QueueConfig.builder())
                if isinstance(output, QueueConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("queue_config", value)

        def remote_timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout for requests to the remote write endpoint.
            """
            return self._set("remote_timeout", value)

        def send_exemplars(self, value: Optional[bool], /) -> Self:
            """
            Enables sending of exemplars over remote write. Note that
            exemplar-storage itself must be enabled using the `spec.enableFeatures`
            option for exemplars to be scraped in the first place.

            It requires Prometheus >= v2.27.0.
            """
            return self._set("send_exemplars", value)

        def send_native_histograms(self, value: Optional[bool], /) -> Self:
            """
            Enables sending of native histograms, also known as sparse histograms
            over remote write.

            It requires Prometheus >= v2.40.0.
            """
            return self._set("send_native_histograms", value)

        @overload
        def sigv4(self, value_or_callback: Optional[Sigv4], /) -> "RemoteWrite.Builder": ...

        @overload
        def sigv4(
            self, value_or_callback: Callable[[Sigv4.Builder], Sigv4.Builder | Sigv4], /
        ) -> "RemoteWrite.Builder": ...

        @overload
        def sigv4(self, value_or_callback: Never = ...) -> "Sigv4.BuilderContext": ...

        def sigv4(self, value_or_callback=None, /):
            """
            Sigv4 allows to configures AWS's Signature Verification 4 for the URL.

            It requires Prometheus >= v2.26.0.

            Cannot be set at the same time as `authorization`, `basicAuth`, `oauth2`, or `azureAd`.
            """
            if self._in_context and value_or_callback is None:
                context = Sigv4.BuilderContext()
                context._parent_builder = self
                context._field_name = "sigv4"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sigv4.builder())
                if isinstance(output, Sigv4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sigv4", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel2], /
        ) -> "RemoteWrite.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel2.Builder], TlsConfigModel2.Builder | TlsConfigModel2
            ],
            /,
        ) -> "RemoteWrite.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel2.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS Config to use for the URL.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel2.builder())
                if isinstance(output, TlsConfigModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

        def url(self, value: str, /) -> Self:
            """
            The URL of the endpoint to send samples to.
            """
            return self._set("url", value)

        @overload
        def write_relabel_configs(
            self, value_or_callback: List[WriteRelabelConfig], /
        ) -> "RemoteWrite.Builder": ...

        @overload
        def write_relabel_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[WriteRelabelConfig, WriteRelabelConfig.Builder]],
                GenericListBuilder[WriteRelabelConfig, WriteRelabelConfig.Builder]
                | List[WriteRelabelConfig],
            ],
            /,
        ) -> "RemoteWrite.Builder": ...

        @overload
        def write_relabel_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[WriteRelabelConfig.Builder]: ...

        def write_relabel_configs(self, value_or_callback=None, /):
            """
            The list of remote write relabel configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[WriteRelabelConfig.Builder]()
                context._parent_builder = self
                context._field_name = "write_relabel_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteRelabelConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_relabel_configs", value)

    class BuilderContext(BuilderContextBase["RemoteWrite.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RemoteWrite.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RemoteWrite."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RemoteWrite", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RemoteWrite.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authorization: Optional[AuthorizationModel] = None
    """
    Authorization section for the URL.

    It requires Prometheus >= v2.26.0.

    Cannot be set at the same time as `sigv4`, `basicAuth`, `oauth2`, or `azureAd`.
    """
    azure_ad: Annotated[Optional[AzureAd], Field(alias="azureAd")] = None
    """
    AzureAD for the URL.

    It requires Prometheus >= v2.45.0.

    Cannot be set at the same time as `authorization`, `basicAuth`, `oauth2`, or `sigv4`.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    BasicAuth configuration for the URL.

    Cannot be set at the same time as `sigv4`, `authorization`, `oauth2`, or `azureAd`.
    """
    bearer_token: Annotated[Optional[str], Field(alias="bearerToken")] = None
    """
    *Warning: this field shouldn't be used because the token value appears
    in clear-text. Prefer using `authorization`.*

    Deprecated: this will be removed in a future release.
    """
    bearer_token_file: Annotated[Optional[str], Field(alias="bearerTokenFile")] = None
    """
    File from which to read bearer token for the URL.

    Deprecated: this will be removed in a future release. Prefer using `authorization`.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHTTP2")] = None
    """
    Whether to enable HTTP2.
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    Configure whether HTTP requests follow HTTP 3xx redirects.

    It requires Prometheus >= v2.26.0.
    """
    headers: Optional[Dict[str, str]] = None
    """
    Custom HTTP headers to be sent along with each remote write request.
    Be aware that headers that are set by Prometheus itself can't be overwritten.

    It requires Prometheus >= v2.25.0.
    """
    message_version: Annotated[Optional[Literal["V1.0", "V2.0"]], Field(alias="messageVersion")] = (
        None
    )
    """
    The Remote Write message's version to use when writing to the endpoint.

    `Version1.0` corresponds to the `prometheus.WriteRequest` protobuf message introduced in Remote Write 1.0.
    `Version2.0` corresponds to the `io.prometheus.write.v2.Request` protobuf message introduced in Remote Write 2.0.

    When `Version2.0` is selected, Prometheus will automatically be
    configured to append the metadata of scraped metrics to the WAL.

    Before setting this field, consult with your remote storage provider
    what message version it supports.

    It requires Prometheus >= v2.54.0.
    """
    metadata_config: Annotated[Optional[MetadataConfig], Field(alias="metadataConfig")] = None
    """
    MetadataConfig configures the sending of series metadata to the remote storage.
    """
    name: Optional[str] = None
    """
    The name of the remote write queue, it must be unique if specified. The
    name is used in metrics and logging in order to differentiate queues.

    It requires Prometheus >= v2.15.0.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    oauth2: Optional[Oauth2] = None
    """
    OAuth2 configuration for the URL.

    It requires Prometheus >= v2.27.0.

    Cannot be set at the same time as `sigv4`, `authorization`, `basicAuth`, or `azureAd`.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    queue_config: Annotated[Optional[QueueConfig], Field(alias="queueConfig")] = None
    """
    QueueConfig allows tuning of the remote write queue parameters.
    """
    remote_timeout: Annotated[
        Optional[str],
        Field(
            alias="remoteTimeout",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Timeout for requests to the remote write endpoint.
    """
    send_exemplars: Annotated[Optional[bool], Field(alias="sendExemplars")] = None
    """
    Enables sending of exemplars over remote write. Note that
    exemplar-storage itself must be enabled using the `spec.enableFeatures`
    option for exemplars to be scraped in the first place.

    It requires Prometheus >= v2.27.0.
    """
    send_native_histograms: Annotated[Optional[bool], Field(alias="sendNativeHistograms")] = None
    """
    Enables sending of native histograms, also known as sparse histograms
    over remote write.

    It requires Prometheus >= v2.40.0.
    """
    sigv4: Optional[Sigv4] = None
    """
    Sigv4 allows to configures AWS's Signature Verification 4 for the URL.

    It requires Prometheus >= v2.26.0.

    Cannot be set at the same time as `authorization`, `basicAuth`, `oauth2`, or `azureAd`.
    """
    tls_config: Annotated[Optional[TlsConfigModel2], Field(alias="tlsConfig")] = None
    """
    TLS Config to use for the URL.
    """
    url: Annotated[str, Field(min_length=1)]
    """
    The URL of the endpoint to send samples to.
    """
    write_relabel_configs: Annotated[
        Optional[List[WriteRelabelConfig]], Field(alias="writeRelabelConfigs")
    ] = None
    """
    The list of remote write relabel configurations.
    """


class LimitsModel3(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel3":
            value = cast(int, self._value)
            return LimitsModel3(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel3.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel3."""
        return cls.BuilderContext()


class LimitsModel4(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel4":
            value = cast(str, self._value)
            return LimitsModel4(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel4.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel4."""
        return cls.BuilderContext()


class RequestsModel3(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel3":
            value = cast(int, self._value)
            return RequestsModel3(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel3.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel3."""
        return cls.BuilderContext()


class RequestsModel4(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel4":
            value = cast(str, self._value)
            return RequestsModel4(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel4.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel4."""
        return cls.BuilderContext()


class Runtime(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Runtime"]:
            return Runtime

        def build(self) -> "Runtime":
            return Runtime(**self._attrs)

        def go_gc(self, value: Optional[int], /) -> Self:
            """
            The Go garbage collection target percentage. Lowering this number may increase the CPU usage.
            See: https://tip.golang.org/doc/gc-guide#GOGC
            """
            return self._set("go_gc", value)

    class BuilderContext(BuilderContextBase["Runtime.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Runtime.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Runtime."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Runtime", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Runtime.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    go_gc: Annotated[Optional[int], Field(alias="goGC", ge=-1)] = None
    """
    The Go garbage collection target percentage. Lowering this number may increase the CPU usage.
    See: https://tip.golang.org/doc/gc-guide#GOGC
    """


class AttachMetadata(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AttachMetadata"]:
            return AttachMetadata

        def build(self) -> "AttachMetadata":
            return AttachMetadata(**self._attrs)

        def node(self, value: Optional[bool], /) -> Self:
            """
            When set to true, Prometheus attaches node metadata to the discovered
            targets.

            The Prometheus service account must have the `list` and `watch`
            permissions on the `Nodes` objects.
            """
            return self._set("node", value)

    class BuilderContext(BuilderContextBase["AttachMetadata.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AttachMetadata.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AttachMetadata."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AttachMetadata", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AttachMetadata.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    node: Optional[bool] = None
    """
    When set to true, Prometheus attaches node metadata to the discovered
    targets.

    The Prometheus service account must have the `list` and `watch`
    permissions on the `Nodes` objects.
    """


class MetricRelabeling(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MetricRelabeling"]:
            return MetricRelabeling

        def build(self) -> "MetricRelabeling":
            return MetricRelabeling(**self._attrs)

        def action(
            self,
            value: Optional[
                Literal[
                    "replace",
                    "Replace",
                    "keep",
                    "Keep",
                    "drop",
                    "Drop",
                    "hashmod",
                    "HashMod",
                    "labelmap",
                    "LabelMap",
                    "labeldrop",
                    "LabelDrop",
                    "labelkeep",
                    "LabelKeep",
                    "lowercase",
                    "Lowercase",
                    "uppercase",
                    "Uppercase",
                    "keepequal",
                    "KeepEqual",
                    "dropequal",
                    "DropEqual",
                ]
            ],
            /,
        ) -> Self:
            """
            Action to perform based on the regex matching.

            `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
            `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.

            Default: "Replace"
            """
            return self._set("action", value)

        def modulus(self, value: Optional[int], /) -> Self:
            """
            Modulus to take of the hash of the source label values.

            Only applicable when the action is `HashMod`.
            """
            return self._set("modulus", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            Regular expression against which the extracted value is matched.
            """
            return self._set("regex", value)

        def replacement(self, value: Optional[str], /) -> Self:
            """
            Replacement value against which a Replace action is performed if the
            regular expression matches.

            Regex capture groups are available.
            """
            return self._set("replacement", value)

        def separator(self, value: Optional[str], /) -> Self:
            """
            Separator is the string between concatenated SourceLabels.
            """
            return self._set("separator", value)

        @overload
        def source_labels(
            self, value_or_callback: List[SourceLabel], /
        ) -> "MetricRelabeling.Builder": ...

        @overload
        def source_labels(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[SourceLabel, SourceLabel.Builder]],
                GenericListBuilder[SourceLabel, SourceLabel.Builder] | List[SourceLabel],
            ],
            /,
        ) -> "MetricRelabeling.Builder": ...

        @overload
        def source_labels(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[SourceLabel.Builder]: ...

        def source_labels(self, value_or_callback=None, /):
            """
            The source labels select values from existing labels. Their content is
            concatenated using the configured Separator and matched against the
            configured regular expression.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[SourceLabel.Builder]()
                context._parent_builder = self
                context._field_name = "source_labels"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SourceLabel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("source_labels", value)

        def target_label(self, value: Optional[str], /) -> Self:
            """
            Label to which the resulting string is written in a replacement.

            It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
            `KeepEqual` and `DropEqual` actions.

            Regex capture groups are available.
            """
            return self._set("target_label", value)

    class BuilderContext(BuilderContextBase["MetricRelabeling.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MetricRelabeling.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MetricRelabeling."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MetricRelabeling", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MetricRelabeling.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    action: Optional[
        Literal[
            "replace",
            "Replace",
            "keep",
            "Keep",
            "drop",
            "Drop",
            "hashmod",
            "HashMod",
            "labelmap",
            "LabelMap",
            "labeldrop",
            "LabelDrop",
            "labelkeep",
            "LabelKeep",
            "lowercase",
            "Lowercase",
            "uppercase",
            "Uppercase",
            "keepequal",
            "KeepEqual",
            "dropequal",
            "DropEqual",
        ]
    ] = "replace"
    """
    Action to perform based on the regex matching.

    `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
    `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.

    Default: "Replace"
    """
    modulus: Optional[int] = None
    """
    Modulus to take of the hash of the source label values.

    Only applicable when the action is `HashMod`.
    """
    regex: Optional[str] = None
    """
    Regular expression against which the extracted value is matched.
    """
    replacement: Optional[str] = None
    """
    Replacement value against which a Replace action is performed if the
    regular expression matches.

    Regex capture groups are available.
    """
    separator: Optional[str] = None
    """
    Separator is the string between concatenated SourceLabels.
    """
    source_labels: Annotated[Optional[List[SourceLabel]], Field(alias="sourceLabels")] = None
    """
    The source labels select values from existing labels. Their content is
    concatenated using the configured Separator and matched against the
    configured regular expression.
    """
    target_label: Annotated[Optional[str], Field(alias="targetLabel")] = None
    """
    Label to which the resulting string is written in a replacement.

    It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
    `KeepEqual` and `DropEqual` actions.

    Regex capture groups are available.
    """


class Relabeling(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Relabeling"]:
            return Relabeling

        def build(self) -> "Relabeling":
            return Relabeling(**self._attrs)

        def action(
            self,
            value: Optional[
                Literal[
                    "replace",
                    "Replace",
                    "keep",
                    "Keep",
                    "drop",
                    "Drop",
                    "hashmod",
                    "HashMod",
                    "labelmap",
                    "LabelMap",
                    "labeldrop",
                    "LabelDrop",
                    "labelkeep",
                    "LabelKeep",
                    "lowercase",
                    "Lowercase",
                    "uppercase",
                    "Uppercase",
                    "keepequal",
                    "KeepEqual",
                    "dropequal",
                    "DropEqual",
                ]
            ],
            /,
        ) -> Self:
            """
            Action to perform based on the regex matching.

            `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
            `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.

            Default: "Replace"
            """
            return self._set("action", value)

        def modulus(self, value: Optional[int], /) -> Self:
            """
            Modulus to take of the hash of the source label values.

            Only applicable when the action is `HashMod`.
            """
            return self._set("modulus", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            Regular expression against which the extracted value is matched.
            """
            return self._set("regex", value)

        def replacement(self, value: Optional[str], /) -> Self:
            """
            Replacement value against which a Replace action is performed if the
            regular expression matches.

            Regex capture groups are available.
            """
            return self._set("replacement", value)

        def separator(self, value: Optional[str], /) -> Self:
            """
            Separator is the string between concatenated SourceLabels.
            """
            return self._set("separator", value)

        @overload
        def source_labels(
            self, value_or_callback: List[SourceLabel], /
        ) -> "Relabeling.Builder": ...

        @overload
        def source_labels(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[SourceLabel, SourceLabel.Builder]],
                GenericListBuilder[SourceLabel, SourceLabel.Builder] | List[SourceLabel],
            ],
            /,
        ) -> "Relabeling.Builder": ...

        @overload
        def source_labels(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[SourceLabel.Builder]: ...

        def source_labels(self, value_or_callback=None, /):
            """
            The source labels select values from existing labels. Their content is
            concatenated using the configured Separator and matched against the
            configured regular expression.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[SourceLabel.Builder]()
                context._parent_builder = self
                context._field_name = "source_labels"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SourceLabel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("source_labels", value)

        def target_label(self, value: Optional[str], /) -> Self:
            """
            Label to which the resulting string is written in a replacement.

            It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
            `KeepEqual` and `DropEqual` actions.

            Regex capture groups are available.
            """
            return self._set("target_label", value)

    class BuilderContext(BuilderContextBase["Relabeling.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Relabeling.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Relabeling."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Relabeling", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Relabeling.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    action: Optional[
        Literal[
            "replace",
            "Replace",
            "keep",
            "Keep",
            "drop",
            "Drop",
            "hashmod",
            "HashMod",
            "labelmap",
            "LabelMap",
            "labeldrop",
            "LabelDrop",
            "labelkeep",
            "LabelKeep",
            "lowercase",
            "Lowercase",
            "uppercase",
            "Uppercase",
            "keepequal",
            "KeepEqual",
            "dropequal",
            "DropEqual",
        ]
    ] = "replace"
    """
    Action to perform based on the regex matching.

    `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
    `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.

    Default: "Replace"
    """
    modulus: Optional[int] = None
    """
    Modulus to take of the hash of the source label values.

    Only applicable when the action is `HashMod`.
    """
    regex: Optional[str] = None
    """
    Regular expression against which the extracted value is matched.
    """
    replacement: Optional[str] = None
    """
    Replacement value against which a Replace action is performed if the
    regular expression matches.

    Regex capture groups are available.
    """
    separator: Optional[str] = None
    """
    Separator is the string between concatenated SourceLabels.
    """
    source_labels: Annotated[Optional[List[SourceLabel]], Field(alias="sourceLabels")] = None
    """
    The source labels select values from existing labels. Their content is
    concatenated using the configured Separator and matched against the
    configured regular expression.
    """
    target_label: Annotated[Optional[str], Field(alias="targetLabel")] = None
    """
    Label to which the resulting string is written in a replacement.

    It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
    `KeepEqual` and `DropEqual` actions.

    Regex capture groups are available.
    """


class ScrapeClass(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ScrapeClass"]:
            return ScrapeClass

        def build(self) -> "ScrapeClass":
            return ScrapeClass(**self._attrs)

        @overload
        def attach_metadata(
            self, value_or_callback: Optional[AttachMetadata], /
        ) -> "ScrapeClass.Builder": ...

        @overload
        def attach_metadata(
            self,
            value_or_callback: Callable[
                [AttachMetadata.Builder], AttachMetadata.Builder | AttachMetadata
            ],
            /,
        ) -> "ScrapeClass.Builder": ...

        @overload
        def attach_metadata(
            self, value_or_callback: Never = ...
        ) -> "AttachMetadata.BuilderContext": ...

        def attach_metadata(self, value_or_callback=None, /):
            """
            AttachMetadata configures additional metadata to the discovered targets.
            When the scrape object defines its own configuration, it takes
            precedence over the scrape class configuration.
            """
            if self._in_context and value_or_callback is None:
                context = AttachMetadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "attach_metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AttachMetadata.builder())
                if isinstance(output, AttachMetadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("attach_metadata", value)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel], /
        ) -> "ScrapeClass.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel.Builder],
                AuthorizationModel.Builder | AuthorizationModel,
            ],
            /,
        ) -> "ScrapeClass.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization section for the ScrapeClass.
            It will only apply if the scrape resource doesn't specify any Authorization.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel.builder())
                if isinstance(output, AuthorizationModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        def default(self, value: Optional[bool], /) -> Self:
            """
            Default indicates that the scrape applies to all scrape objects that
            don't configure an explicit scrape class name.

            Only one scrape class can be set as the default.
            """
            return self._set("default", value)

        def fallback_scrape_protocol(
            self,
            value: Optional[
                Literal[
                    "PrometheusProto",
                    "OpenMetricsText0.0.1",
                    "OpenMetricsText1.0.0",
                    "PrometheusText0.0.4",
                    "PrometheusText1.0.0",
                ]
            ],
            /,
        ) -> Self:
            """
            The protocol to use if a scrape returns blank, unparseable, or otherwise invalid Content-Type.
            It will only apply if the scrape resource doesn't specify any FallbackScrapeProtocol

            It requires Prometheus >= v3.0.0.
            """
            return self._set("fallback_scrape_protocol", value)

        @overload
        def metric_relabelings(
            self, value_or_callback: List[MetricRelabeling], /
        ) -> "ScrapeClass.Builder": ...

        @overload
        def metric_relabelings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MetricRelabeling, MetricRelabeling.Builder]],
                GenericListBuilder[MetricRelabeling, MetricRelabeling.Builder]
                | List[MetricRelabeling],
            ],
            /,
        ) -> "ScrapeClass.Builder": ...

        @overload
        def metric_relabelings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MetricRelabeling.Builder]: ...

        def metric_relabelings(self, value_or_callback=None, /):
            """
            MetricRelabelings configures the relabeling rules to apply to all samples before ingestion.

            The Operator adds the scrape class metric relabelings defined here.
            Then the Operator adds the target-specific metric relabelings defined in ServiceMonitors, PodMonitors, Probes and ScrapeConfigs.
            Then the Operator adds namespace enforcement relabeling rule, specified in '.spec.enforcedNamespaceLabel'.

            More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MetricRelabeling.Builder]()
                context._parent_builder = self
                context._field_name = "metric_relabelings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MetricRelabeling.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("metric_relabelings", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the scrape class.
            """
            return self._set("name", value)

        @overload
        def relabelings(self, value_or_callback: List[Relabeling], /) -> "ScrapeClass.Builder": ...

        @overload
        def relabelings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Relabeling, Relabeling.Builder]],
                GenericListBuilder[Relabeling, Relabeling.Builder] | List[Relabeling],
            ],
            /,
        ) -> "ScrapeClass.Builder": ...

        @overload
        def relabelings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Relabeling.Builder]: ...

        def relabelings(self, value_or_callback=None, /):
            """
            Relabelings configures the relabeling rules to apply to all scrape targets.

            The Operator automatically adds relabelings for a few standard Kubernetes fields
            like `__meta_kubernetes_namespace` and `__meta_kubernetes_service_name`.
            Then the Operator adds the scrape class relabelings defined here.
            Then the Operator adds the target-specific relabelings defined in the scrape object.

            More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Relabeling.Builder]()
                context._parent_builder = self
                context._field_name = "relabelings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Relabeling.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("relabelings", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel2], /
        ) -> "ScrapeClass.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel2.Builder], TlsConfigModel2.Builder | TlsConfigModel2
            ],
            /,
        ) -> "ScrapeClass.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel2.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLSConfig defines the TLS settings to use for the scrape. When the
            scrape objects define their own CA, certificate and/or key, they take
            precedence over the corresponding scrape class fields.

            For now only the `caFile`, `certFile` and `keyFile` fields are supported.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel2.builder())
                if isinstance(output, TlsConfigModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["ScrapeClass.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ScrapeClass.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ScrapeClass."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ScrapeClass", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ScrapeClass.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    attach_metadata: Annotated[Optional[AttachMetadata], Field(alias="attachMetadata")] = None
    """
    AttachMetadata configures additional metadata to the discovered targets.
    When the scrape object defines its own configuration, it takes
    precedence over the scrape class configuration.
    """
    authorization: Optional[AuthorizationModel] = None
    """
    Authorization section for the ScrapeClass.
    It will only apply if the scrape resource doesn't specify any Authorization.
    """
    default: Optional[bool] = None
    """
    Default indicates that the scrape applies to all scrape objects that
    don't configure an explicit scrape class name.

    Only one scrape class can be set as the default.
    """
    fallback_scrape_protocol: Annotated[
        Optional[
            Literal[
                "PrometheusProto",
                "OpenMetricsText0.0.1",
                "OpenMetricsText1.0.0",
                "PrometheusText0.0.4",
                "PrometheusText1.0.0",
            ]
        ],
        Field(alias="fallbackScrapeProtocol"),
    ] = None
    """
    The protocol to use if a scrape returns blank, unparseable, or otherwise invalid Content-Type.
    It will only apply if the scrape resource doesn't specify any FallbackScrapeProtocol

    It requires Prometheus >= v3.0.0.
    """
    metric_relabelings: Annotated[
        Optional[List[MetricRelabeling]], Field(alias="metricRelabelings")
    ] = None
    """
    MetricRelabelings configures the relabeling rules to apply to all samples before ingestion.

    The Operator adds the scrape class metric relabelings defined here.
    Then the Operator adds the target-specific metric relabelings defined in ServiceMonitors, PodMonitors, Probes and ScrapeConfigs.
    Then the Operator adds namespace enforcement relabeling rule, specified in '.spec.enforcedNamespaceLabel'.

    More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs
    """
    name: Annotated[str, Field(min_length=1)]
    """
    Name of the scrape class.
    """
    relabelings: Optional[List[Relabeling]] = None
    """
    Relabelings configures the relabeling rules to apply to all scrape targets.

    The Operator automatically adds relabelings for a few standard Kubernetes fields
    like `__meta_kubernetes_namespace` and `__meta_kubernetes_service_name`.
    Then the Operator adds the scrape class relabelings defined here.
    Then the Operator adds the target-specific relabelings defined in the scrape object.

    More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
    """
    tls_config: Annotated[Optional[TlsConfigModel2], Field(alias="tlsConfig")] = None
    """
    TLSConfig defines the TLS settings to use for the scrape. When the
    scrape objects define their own CA, certificate and/or key, they take
    precedence over the corresponding scrape class fields.

    For now only the `caFile`, `certFile` and `keyFile` fields are supported.
    """


class ScrapeConfigNamespaceSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ScrapeConfigNamespaceSelector"]:
            return ScrapeConfigNamespaceSelector

        def build(self) -> "ScrapeConfigNamespaceSelector":
            return ScrapeConfigNamespaceSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel], /
        ) -> "ScrapeConfigNamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]],
                GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]
                | List[MatchExpressionModel],
            ],
            /,
        ) -> "ScrapeConfigNamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["ScrapeConfigNamespaceSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ScrapeConfigNamespaceSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ScrapeConfigNamespaceSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ScrapeConfigNamespaceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ScrapeConfigNamespaceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class ScrapeConfigSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ScrapeConfigSelector"]:
            return ScrapeConfigSelector

        def build(self) -> "ScrapeConfigSelector":
            return ScrapeConfigSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel], /
        ) -> "ScrapeConfigSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]],
                GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]
                | List[MatchExpressionModel],
            ],
            /,
        ) -> "ScrapeConfigSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["ScrapeConfigSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ScrapeConfigSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ScrapeConfigSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ScrapeConfigSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ScrapeConfigSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class Sysctl(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Sysctl"]:
            return Sysctl

        def build(self) -> "Sysctl":
            return Sysctl(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of a property to set
            """
            return self._set("name", value)

        def value(self, value: str, /) -> Self:
            """
            Value of a property to set
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["Sysctl.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Sysctl.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Sysctl."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Sysctl", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Sysctl.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of a property to set
    """
    value: str
    """
    Value of a property to set
    """


class SecurityContextModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecurityContextModel"]:
            return SecurityContextModel

        def build(self) -> "SecurityContextModel":
            return SecurityContextModel(**self._attrs)

        @overload
        def app_armor_profile(
            self, value_or_callback: Optional[AppArmorProfile], /
        ) -> "SecurityContextModel.Builder": ...

        @overload
        def app_armor_profile(
            self,
            value_or_callback: Callable[
                [AppArmorProfile.Builder], AppArmorProfile.Builder | AppArmorProfile
            ],
            /,
        ) -> "SecurityContextModel.Builder": ...

        @overload
        def app_armor_profile(
            self, value_or_callback: Never = ...
        ) -> "AppArmorProfile.BuilderContext": ...

        def app_armor_profile(self, value_or_callback=None, /):
            """
            appArmorProfile is the AppArmor options to use by the containers in this pod.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = AppArmorProfile.BuilderContext()
                context._parent_builder = self
                context._field_name = "app_armor_profile"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AppArmorProfile.builder())
                if isinstance(output, AppArmorProfile.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("app_armor_profile", value)

        def fs_group(self, value: Optional[int], /) -> Self:
            """
            A special supplemental group that applies to all containers in a pod.
            Some volume types allow the Kubelet to change the ownership of that volume
            to be owned by the pod:

            1. The owning GID will be the FSGroup
            2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
            3. The permission bits are OR'd with rw-rw----

            If unset, the Kubelet will not modify the ownership and permissions of any volume.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("fs_group", value)

        def fs_group_change_policy(self, value: Optional[str], /) -> Self:
            """
            fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
            before being exposed inside Pod. This field will only apply to
            volume types which support fsGroup based ownership(and permissions).
            It will have no effect on ephemeral volume types such as: secret, configmaps
            and emptydir.
            Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("fs_group_change_policy", value)

        def run_as_group(self, value: Optional[int], /) -> Self:
            """
            The GID to run the entrypoint of the container process.
            Uses runtime default if unset.
            May also be set in SecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence
            for that container.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("run_as_group", value)

        def run_as_non_root(self, value: Optional[bool], /) -> Self:
            """
            Indicates that the container must run as a non-root user.
            If true, the Kubelet will validate the image at runtime to ensure that it
            does not run as UID 0 (root) and fail to start the container if it does.
            If unset or false, no such validation will be performed.
            May also be set in SecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            """
            return self._set("run_as_non_root", value)

        def run_as_user(self, value: Optional[int], /) -> Self:
            """
            The UID to run the entrypoint of the container process.
            Defaults to user specified in image metadata if unspecified.
            May also be set in SecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence
            for that container.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("run_as_user", value)

        def se_linux_change_policy(self, value: Optional[str], /) -> Self:
            """
            seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
            It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
            Valid values are "MountOption" and "Recursive".

            "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
            This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.

            "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
            This requires all Pods that share the same volume to use the same SELinux label.
            It is not possible to share the same volume among privileged and unprivileged Pods.
            Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
            whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
            CSIDriver instance. Other volumes are always re-labelled recursively.
            "MountOption" value is allowed only when SELinuxMount feature gate is enabled.

            If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
            If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
            and "Recursive" for all other volumes.

            This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.

            All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("se_linux_change_policy", value)

        @overload
        def se_linux_options(
            self, value_or_callback: Optional[SeLinuxOptions], /
        ) -> "SecurityContextModel.Builder": ...

        @overload
        def se_linux_options(
            self,
            value_or_callback: Callable[
                [SeLinuxOptions.Builder], SeLinuxOptions.Builder | SeLinuxOptions
            ],
            /,
        ) -> "SecurityContextModel.Builder": ...

        @overload
        def se_linux_options(
            self, value_or_callback: Never = ...
        ) -> "SeLinuxOptions.BuilderContext": ...

        def se_linux_options(self, value_or_callback=None, /):
            """
            The SELinux context to be applied to all containers.
            If unspecified, the container runtime will allocate a random SELinux context for each
            container.  May also be set in SecurityContext.  If set in
            both SecurityContext and PodSecurityContext, the value specified in SecurityContext
            takes precedence for that container.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = SeLinuxOptions.BuilderContext()
                context._parent_builder = self
                context._field_name = "se_linux_options"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SeLinuxOptions.builder())
                if isinstance(output, SeLinuxOptions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("se_linux_options", value)

        @overload
        def seccomp_profile(
            self, value_or_callback: Optional[SeccompProfile], /
        ) -> "SecurityContextModel.Builder": ...

        @overload
        def seccomp_profile(
            self,
            value_or_callback: Callable[
                [SeccompProfile.Builder], SeccompProfile.Builder | SeccompProfile
            ],
            /,
        ) -> "SecurityContextModel.Builder": ...

        @overload
        def seccomp_profile(
            self, value_or_callback: Never = ...
        ) -> "SeccompProfile.BuilderContext": ...

        def seccomp_profile(self, value_or_callback=None, /):
            """
            The seccomp options to use by the containers in this pod.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = SeccompProfile.BuilderContext()
                context._parent_builder = self
                context._field_name = "seccomp_profile"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SeccompProfile.builder())
                if isinstance(output, SeccompProfile.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("seccomp_profile", value)

        def supplemental_groups(self, value: Optional[List[int]], /) -> Self:
            """
            A list of groups applied to the first process run in each container, in
            addition to the container's primary GID and fsGroup (if specified).  If
            the SupplementalGroupsPolicy feature is enabled, the
            supplementalGroupsPolicy field determines whether these are in addition
            to or instead of any group memberships defined in the container image.
            If unspecified, no additional groups are added, though group memberships
            defined in the container image may still be used, depending on the
            supplementalGroupsPolicy field.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("supplemental_groups", value)

        def supplemental_groups_policy(self, value: Optional[str], /) -> Self:
            """
            Defines how supplemental groups of the first container processes are calculated.
            Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
            (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
            and the container runtime must implement support for this feature.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("supplemental_groups_policy", value)

        @overload
        def sysctls(self, value_or_callback: List[Sysctl], /) -> "SecurityContextModel.Builder": ...

        @overload
        def sysctls(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Sysctl, Sysctl.Builder]],
                GenericListBuilder[Sysctl, Sysctl.Builder] | List[Sysctl],
            ],
            /,
        ) -> "SecurityContextModel.Builder": ...

        @overload
        def sysctls(self, value_or_callback: Never = ...) -> ListBuilderContext[Sysctl.Builder]: ...

        def sysctls(self, value_or_callback=None, /):
            """
            Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
            sysctls (by the container runtime) might fail to launch.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Sysctl.Builder]()
                context._parent_builder = self
                context._field_name = "sysctls"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sysctl.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("sysctls", value)

        @overload
        def windows_options(
            self, value_or_callback: Optional[WindowsOptions], /
        ) -> "SecurityContextModel.Builder": ...

        @overload
        def windows_options(
            self,
            value_or_callback: Callable[
                [WindowsOptions.Builder], WindowsOptions.Builder | WindowsOptions
            ],
            /,
        ) -> "SecurityContextModel.Builder": ...

        @overload
        def windows_options(
            self, value_or_callback: Never = ...
        ) -> "WindowsOptions.BuilderContext": ...

        def windows_options(self, value_or_callback=None, /):
            """
            The Windows specific settings applied to all containers.
            If unspecified, the options within a container's SecurityContext will be used.
            If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
            Note that this field cannot be set when spec.os.name is linux.
            """
            if self._in_context and value_or_callback is None:
                context = WindowsOptions.BuilderContext()
                context._parent_builder = self
                context._field_name = "windows_options"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WindowsOptions.builder())
                if isinstance(output, WindowsOptions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("windows_options", value)

    class BuilderContext(BuilderContextBase["SecurityContextModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecurityContextModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecurityContextModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecurityContextModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecurityContextModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    app_armor_profile: Annotated[Optional[AppArmorProfile], Field(alias="appArmorProfile")] = None
    """
    appArmorProfile is the AppArmor options to use by the containers in this pod.
    Note that this field cannot be set when spec.os.name is windows.
    """
    fs_group: Annotated[Optional[int], Field(alias="fsGroup")] = None
    """
    A special supplemental group that applies to all containers in a pod.
    Some volume types allow the Kubelet to change the ownership of that volume
    to be owned by the pod:

    1. The owning GID will be the FSGroup
    2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
    3. The permission bits are OR'd with rw-rw----

    If unset, the Kubelet will not modify the ownership and permissions of any volume.
    Note that this field cannot be set when spec.os.name is windows.
    """
    fs_group_change_policy: Annotated[Optional[str], Field(alias="fsGroupChangePolicy")] = None
    """
    fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
    before being exposed inside Pod. This field will only apply to
    volume types which support fsGroup based ownership(and permissions).
    It will have no effect on ephemeral volume types such as: secret, configmaps
    and emptydir.
    Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
    Note that this field cannot be set when spec.os.name is windows.
    """
    run_as_group: Annotated[Optional[int], Field(alias="runAsGroup")] = None
    """
    The GID to run the entrypoint of the container process.
    Uses runtime default if unset.
    May also be set in SecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence
    for that container.
    Note that this field cannot be set when spec.os.name is windows.
    """
    run_as_non_root: Annotated[Optional[bool], Field(alias="runAsNonRoot")] = None
    """
    Indicates that the container must run as a non-root user.
    If true, the Kubelet will validate the image at runtime to ensure that it
    does not run as UID 0 (root) and fail to start the container if it does.
    If unset or false, no such validation will be performed.
    May also be set in SecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    """
    run_as_user: Annotated[Optional[int], Field(alias="runAsUser")] = None
    """
    The UID to run the entrypoint of the container process.
    Defaults to user specified in image metadata if unspecified.
    May also be set in SecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence
    for that container.
    Note that this field cannot be set when spec.os.name is windows.
    """
    se_linux_change_policy: Annotated[Optional[str], Field(alias="seLinuxChangePolicy")] = None
    """
    seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
    It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
    Valid values are "MountOption" and "Recursive".

    "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
    This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.

    "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
    This requires all Pods that share the same volume to use the same SELinux label.
    It is not possible to share the same volume among privileged and unprivileged Pods.
    Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
    whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
    CSIDriver instance. Other volumes are always re-labelled recursively.
    "MountOption" value is allowed only when SELinuxMount feature gate is enabled.

    If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
    If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
    and "Recursive" for all other volumes.

    This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.

    All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
    Note that this field cannot be set when spec.os.name is windows.
    """
    se_linux_options: Annotated[Optional[SeLinuxOptions], Field(alias="seLinuxOptions")] = None
    """
    The SELinux context to be applied to all containers.
    If unspecified, the container runtime will allocate a random SELinux context for each
    container.  May also be set in SecurityContext.  If set in
    both SecurityContext and PodSecurityContext, the value specified in SecurityContext
    takes precedence for that container.
    Note that this field cannot be set when spec.os.name is windows.
    """
    seccomp_profile: Annotated[Optional[SeccompProfile], Field(alias="seccompProfile")] = None
    """
    The seccomp options to use by the containers in this pod.
    Note that this field cannot be set when spec.os.name is windows.
    """
    supplemental_groups: Annotated[Optional[List[int]], Field(alias="supplementalGroups")] = None
    """
    A list of groups applied to the first process run in each container, in
    addition to the container's primary GID and fsGroup (if specified).  If
    the SupplementalGroupsPolicy feature is enabled, the
    supplementalGroupsPolicy field determines whether these are in addition
    to or instead of any group memberships defined in the container image.
    If unspecified, no additional groups are added, though group memberships
    defined in the container image may still be used, depending on the
    supplementalGroupsPolicy field.
    Note that this field cannot be set when spec.os.name is windows.
    """
    supplemental_groups_policy: Annotated[
        Optional[str], Field(alias="supplementalGroupsPolicy")
    ] = None
    """
    Defines how supplemental groups of the first container processes are calculated.
    Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
    (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
    and the container runtime must implement support for this feature.
    Note that this field cannot be set when spec.os.name is windows.
    """
    sysctls: Optional[List[Sysctl]] = None
    """
    Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
    sysctls (by the container runtime) might fail to launch.
    Note that this field cannot be set when spec.os.name is windows.
    """
    windows_options: Annotated[Optional[WindowsOptions], Field(alias="windowsOptions")] = None
    """
    The Windows specific settings applied to all containers.
    If unspecified, the options within a container's SecurityContext will be used.
    If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
    Note that this field cannot be set when spec.os.name is linux.
    """


class ServiceMonitorNamespaceSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceMonitorNamespaceSelector"]:
            return ServiceMonitorNamespaceSelector

        def build(self) -> "ServiceMonitorNamespaceSelector":
            return ServiceMonitorNamespaceSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel], /
        ) -> "ServiceMonitorNamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]],
                GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]
                | List[MatchExpressionModel],
            ],
            /,
        ) -> "ServiceMonitorNamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["ServiceMonitorNamespaceSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceMonitorNamespaceSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceMonitorNamespaceSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceMonitorNamespaceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceMonitorNamespaceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class ServiceMonitorSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceMonitorSelector"]:
            return ServiceMonitorSelector

        def build(self) -> "ServiceMonitorSelector":
            return ServiceMonitorSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel], /
        ) -> "ServiceMonitorSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]],
                GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]
                | List[MatchExpressionModel],
            ],
            /,
        ) -> "ServiceMonitorSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["ServiceMonitorSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceMonitorSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceMonitorSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceMonitorSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceMonitorSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class SizeLimit(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def build(self) -> "SizeLimit":
            value = cast(int, self._value)
            return SizeLimit(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    sizeLimit is the total amount of local storage required for this EmptyDir volume.
    The size limit is also applicable for memory medium.
    The maximum usage on memory medium EmptyDir would be the minimum value between
    the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    The default is nil which means that the limit is undefined.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    """

    class BuilderContext(BuilderContextBase["SizeLimit.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SizeLimit.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SizeLimit."""
        return cls.BuilderContext()


class SizeLimitModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def build(self) -> "SizeLimitModel":
            value = cast(str, self._value)
            return SizeLimitModel(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    sizeLimit is the total amount of local storage required for this EmptyDir volume.
    The size limit is also applicable for memory medium.
    The maximum usage on memory medium EmptyDir would be the minimum value between
    the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    The default is nil which means that the limit is undefined.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    """

    class BuilderContext(BuilderContextBase["SizeLimitModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SizeLimitModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SizeLimitModel."""
        return cls.BuilderContext()


class EmptyDir(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["EmptyDir"]:
            return EmptyDir

        def build(self) -> "EmptyDir":
            return EmptyDir(**self._attrs)

        def medium(self, value: Optional[str], /) -> Self:
            """
            medium represents what type of storage medium should back this directory.
            The default is "" which means to use the node's default medium.
            Must be an empty string (default) or Memory.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            return self._set("medium", value)

        def size_limit(self, value: Optional[Union[SizeLimit, SizeLimitModel]], /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            return self._set("size_limit", value)

    class BuilderContext(BuilderContextBase["EmptyDir.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = EmptyDir.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for EmptyDir."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["EmptyDir", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use EmptyDir.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    medium: Optional[str] = None
    """
    medium represents what type of storage medium should back this directory.
    The default is "" which means to use the node's default medium.
    Must be an empty string (default) or Memory.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    """
    size_limit: Annotated[Optional[Union[SizeLimit, SizeLimitModel]], Field(alias="sizeLimit")] = (
        None
    )
    """
    sizeLimit is the total amount of local storage required for this EmptyDir volume.
    The size limit is also applicable for memory medium.
    The maximum usage on memory medium EmptyDir would be the minimum value between
    the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    The default is nil which means that the limit is undefined.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    """


class DataSource(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DataSource"]:
            return DataSource

        def build(self) -> "DataSource":
            return DataSource(**self._attrs)

        def api_group(self, value: Optional[str], /) -> Self:
            """
            APIGroup is the group for the resource being referenced.
            If APIGroup is not specified, the specified Kind must be in the core API group.
            For any other third-party types, APIGroup is required.
            """
            return self._set("api_group", value)

        def kind(self, value: str, /) -> Self:
            """
            Kind is the type of resource being referenced
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of resource being referenced
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["DataSource.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DataSource.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DataSource."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DataSource", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DataSource.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_group: Annotated[Optional[str], Field(alias="apiGroup")] = None
    """
    APIGroup is the group for the resource being referenced.
    If APIGroup is not specified, the specified Kind must be in the core API group.
    For any other third-party types, APIGroup is required.
    """
    kind: str
    """
    Kind is the type of resource being referenced
    """
    name: str
    """
    Name is the name of resource being referenced
    """


class DataSourceRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DataSourceRef"]:
            return DataSourceRef

        def build(self) -> "DataSourceRef":
            return DataSourceRef(**self._attrs)

        def api_group(self, value: Optional[str], /) -> Self:
            """
            APIGroup is the group for the resource being referenced.
            If APIGroup is not specified, the specified Kind must be in the core API group.
            For any other third-party types, APIGroup is required.
            """
            return self._set("api_group", value)

        def kind(self, value: str, /) -> Self:
            """
            Kind is the type of resource being referenced
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of resource being referenced
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace is the namespace of resource being referenced
            Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
            (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["DataSourceRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DataSourceRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DataSourceRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DataSourceRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DataSourceRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_group: Annotated[Optional[str], Field(alias="apiGroup")] = None
    """
    APIGroup is the group for the resource being referenced.
    If APIGroup is not specified, the specified Kind must be in the core API group.
    For any other third-party types, APIGroup is required.
    """
    kind: str
    """
    Kind is the type of resource being referenced
    """
    name: str
    """
    Name is the name of resource being referenced
    """
    namespace: Optional[str] = None
    """
    Namespace is the namespace of resource being referenced
    Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
    (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    """


class LimitsModel5(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel5":
            value = cast(int, self._value)
            return LimitsModel5(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel5.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel5."""
        return cls.BuilderContext()


class LimitsModel6(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel6":
            value = cast(str, self._value)
            return LimitsModel6(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel6.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel6.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel6."""
        return cls.BuilderContext()


class RequestsModel5(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel5":
            value = cast(int, self._value)
            return RequestsModel5(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel5.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel5."""
        return cls.BuilderContext()


class RequestsModel6(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel6":
            value = cast(str, self._value)
            return RequestsModel6(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel6.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel6.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel6."""
        return cls.BuilderContext()


class ResourcesModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourcesModel"]:
            return ResourcesModel

        def build(self) -> "ResourcesModel":
            return ResourcesModel(**self._attrs)

        def limits(self, value: Optional[Dict[str, Union[LimitsModel5, LimitsModel6]]], /) -> Self:
            """
            Limits describes the maximum amount of compute resources allowed.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            return self._set("limits", value)

        def requests(
            self, value: Optional[Dict[str, Union[RequestsModel5, RequestsModel6]]], /
        ) -> Self:
            """
            Requests describes the minimum amount of compute resources required.
            If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
            otherwise to an implementation-defined value. Requests cannot exceed Limits.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            return self._set("requests", value)

    class BuilderContext(BuilderContextBase["ResourcesModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourcesModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourcesModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourcesModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourcesModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    limits: Optional[Dict[str, Union[LimitsModel5, LimitsModel6]]] = None
    """
    Limits describes the maximum amount of compute resources allowed.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """
    requests: Optional[Dict[str, Union[RequestsModel5, RequestsModel6]]] = None
    """
    Requests describes the minimum amount of compute resources required.
    If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    otherwise to an implementation-defined value. Requests cannot exceed Limits.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """


class Selector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Selector"]:
            return Selector

        def build(self) -> "Selector":
            return Selector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel], /
        ) -> "Selector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]],
                GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]
                | List[MatchExpressionModel],
            ],
            /,
        ) -> "Selector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["Selector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Selector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Selector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Selector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Selector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class Spec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Spec"]:
            return Spec

        def build(self) -> "Spec":
            return Spec(**self._attrs)

        def access_modes(self, value: Optional[List[str]], /) -> Self:
            """
            accessModes contains the desired access modes the volume should have.
            More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
            """
            return self._set("access_modes", value)

        @overload
        def data_source(self, value_or_callback: Optional[DataSource], /) -> "Spec.Builder": ...

        @overload
        def data_source(
            self,
            value_or_callback: Callable[[DataSource.Builder], DataSource.Builder | DataSource],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def data_source(self, value_or_callback: Never = ...) -> "DataSource.BuilderContext": ...

        def data_source(self, value_or_callback=None, /):
            """
            dataSource field can be used to specify either:
            * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
            * An existing PVC (PersistentVolumeClaim)
            If the provisioner or an external controller can support the specified data source,
            it will create a new volume based on the contents of the specified data source.
            When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
            and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
            If the namespace is specified, then dataSourceRef will not be copied to dataSource.
            """
            if self._in_context and value_or_callback is None:
                context = DataSource.BuilderContext()
                context._parent_builder = self
                context._field_name = "data_source"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DataSource.builder())
                if isinstance(output, DataSource.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("data_source", value)

        @overload
        def data_source_ref(
            self, value_or_callback: Optional[DataSourceRef], /
        ) -> "Spec.Builder": ...

        @overload
        def data_source_ref(
            self,
            value_or_callback: Callable[
                [DataSourceRef.Builder], DataSourceRef.Builder | DataSourceRef
            ],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def data_source_ref(
            self, value_or_callback: Never = ...
        ) -> "DataSourceRef.BuilderContext": ...

        def data_source_ref(self, value_or_callback=None, /):
            """
            dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
            volume is desired. This may be any object from a non-empty API group (non
            core object) or a PersistentVolumeClaim object.
            When this field is specified, volume binding will only succeed if the type of
            the specified object matches some installed volume populator or dynamic
            provisioner.
            This field will replace the functionality of the dataSource field and as such
            if both fields are non-empty, they must have the same value. For backwards
            compatibility, when namespace isn't specified in dataSourceRef,
            both fields (dataSource and dataSourceRef) will be set to the same
            value automatically if one of them is empty and the other is non-empty.
            When namespace is specified in dataSourceRef,
            dataSource isn't set to the same value and must be empty.
            There are three important differences between dataSource and dataSourceRef:
            * While dataSource only allows two specific types of objects, dataSourceRef
              allows any non-core object, as well as PersistentVolumeClaim objects.
            * While dataSource ignores disallowed values (dropping them), dataSourceRef
              preserves all values, and generates an error if a disallowed value is
              specified.
            * While dataSource only allows local objects, dataSourceRef allows objects
              in any namespaces.
            (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
            (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
            """
            if self._in_context and value_or_callback is None:
                context = DataSourceRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "data_source_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DataSourceRef.builder())
                if isinstance(output, DataSourceRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("data_source_ref", value)

        @overload
        def resources(self, value_or_callback: Optional[ResourcesModel], /) -> "Spec.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[
                [ResourcesModel.Builder], ResourcesModel.Builder | ResourcesModel
            ],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "ResourcesModel.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            resources represents the minimum resources the volume should have.
            If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
            that are lower than previous value but must still be higher than capacity recorded in the
            status field of the claim.
            More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
            """
            if self._in_context and value_or_callback is None:
                context = ResourcesModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourcesModel.builder())
                if isinstance(output, ResourcesModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        @overload
        def selector(self, value_or_callback: Optional[Selector], /) -> "Spec.Builder": ...

        @overload
        def selector(
            self,
            value_or_callback: Callable[[Selector.Builder], Selector.Builder | Selector],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def selector(self, value_or_callback: Never = ...) -> "Selector.BuilderContext": ...

        def selector(self, value_or_callback=None, /):
            """
            selector is a label query over volumes to consider for binding.
            """
            if self._in_context and value_or_callback is None:
                context = Selector.BuilderContext()
                context._parent_builder = self
                context._field_name = "selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Selector.builder())
                if isinstance(output, Selector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("selector", value)

        def storage_class_name(self, value: Optional[str], /) -> Self:
            """
            storageClassName is the name of the StorageClass required by the claim.
            More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
            """
            return self._set("storage_class_name", value)

        def volume_attributes_class_name(self, value: Optional[str], /) -> Self:
            """
            volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
            If specified, the CSI driver will create or update the volume with the attributes defined
            in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
            it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
            will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
            If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
            will be set by the persistentvolume controller if it exists.
            If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
            set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
            exists.
            More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
            (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
            """
            return self._set("volume_attributes_class_name", value)

        def volume_mode(self, value: Optional[str], /) -> Self:
            """
            volumeMode defines what type of volume is required by the claim.
            Value of Filesystem is implied when not included in claim spec.
            """
            return self._set("volume_mode", value)

        def volume_name(self, value: Optional[str], /) -> Self:
            """
            volumeName is the binding reference to the PersistentVolume backing this claim.
            """
            return self._set("volume_name", value)

    class BuilderContext(BuilderContextBase["Spec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Spec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Spec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Spec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Spec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_modes: Annotated[Optional[List[str]], Field(alias="accessModes")] = None
    """
    accessModes contains the desired access modes the volume should have.
    More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
    """
    data_source: Annotated[Optional[DataSource], Field(alias="dataSource")] = None
    """
    dataSource field can be used to specify either:
    * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
    * An existing PVC (PersistentVolumeClaim)
    If the provisioner or an external controller can support the specified data source,
    it will create a new volume based on the contents of the specified data source.
    When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
    and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
    If the namespace is specified, then dataSourceRef will not be copied to dataSource.
    """
    data_source_ref: Annotated[Optional[DataSourceRef], Field(alias="dataSourceRef")] = None
    """
    dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
    volume is desired. This may be any object from a non-empty API group (non
    core object) or a PersistentVolumeClaim object.
    When this field is specified, volume binding will only succeed if the type of
    the specified object matches some installed volume populator or dynamic
    provisioner.
    This field will replace the functionality of the dataSource field and as such
    if both fields are non-empty, they must have the same value. For backwards
    compatibility, when namespace isn't specified in dataSourceRef,
    both fields (dataSource and dataSourceRef) will be set to the same
    value automatically if one of them is empty and the other is non-empty.
    When namespace is specified in dataSourceRef,
    dataSource isn't set to the same value and must be empty.
    There are three important differences between dataSource and dataSourceRef:
    * While dataSource only allows two specific types of objects, dataSourceRef
      allows any non-core object, as well as PersistentVolumeClaim objects.
    * While dataSource ignores disallowed values (dropping them), dataSourceRef
      preserves all values, and generates an error if a disallowed value is
      specified.
    * While dataSource only allows local objects, dataSourceRef allows objects
      in any namespaces.
    (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    """
    resources: Optional[ResourcesModel] = None
    """
    resources represents the minimum resources the volume should have.
    If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
    that are lower than previous value but must still be higher than capacity recorded in the
    status field of the claim.
    More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
    """
    selector: Optional[Selector] = None
    """
    selector is a label query over volumes to consider for binding.
    """
    storage_class_name: Annotated[Optional[str], Field(alias="storageClassName")] = None
    """
    storageClassName is the name of the StorageClass required by the claim.
    More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
    """
    volume_attributes_class_name: Annotated[
        Optional[str], Field(alias="volumeAttributesClassName")
    ] = None
    """
    volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
    If specified, the CSI driver will create or update the volume with the attributes defined
    in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
    it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
    will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
    If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
    will be set by the persistentvolume controller if it exists.
    If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
    set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
    exists.
    More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
    (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
    """
    volume_mode: Annotated[Optional[str], Field(alias="volumeMode")] = None
    """
    volumeMode defines what type of volume is required by the claim.
    Value of Filesystem is implied when not included in claim spec.
    """
    volume_name: Annotated[Optional[str], Field(alias="volumeName")] = None
    """
    volumeName is the binding reference to the PersistentVolume backing this claim.
    """


class VolumeClaimTemplate(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VolumeClaimTemplate"]:
            return VolumeClaimTemplate

        def build(self) -> "VolumeClaimTemplate":
            return VolumeClaimTemplate(**self._attrs)

        def metadata(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            May contain labels and annotations that will be copied into the PVC
            when creating it. No other fields are allowed and will be rejected during
            validation.
            """
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Spec, /) -> "VolumeClaimTemplate.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Callable[[Spec.Builder], Spec.Builder | Spec], /
        ) -> "VolumeClaimTemplate.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "Spec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            """
            The specification for the PersistentVolumeClaim. The entire content is
            copied unchanged into the PVC that gets created from this
            template. The same fields as in a PersistentVolumeClaim
            are also valid here.
            """
            if self._in_context and value_or_callback is None:
                context = Spec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Spec.builder())
                if isinstance(output, Spec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["VolumeClaimTemplate.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VolumeClaimTemplate.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VolumeClaimTemplate."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VolumeClaimTemplate", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VolumeClaimTemplate.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    metadata: Optional[Dict[str, Any]] = None
    """
    May contain labels and annotations that will be copied into the PVC
    when creating it. No other fields are allowed and will be rejected during
    validation.
    """
    spec: Spec
    """
    The specification for the PersistentVolumeClaim. The entire content is
    copied unchanged into the PVC that gets created from this
    template. The same fields as in a PersistentVolumeClaim
    are also valid here.
    """


class Ephemeral(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ephemeral"]:
            return Ephemeral

        def build(self) -> "Ephemeral":
            return Ephemeral(**self._attrs)

        @overload
        def volume_claim_template(
            self, value_or_callback: Optional[VolumeClaimTemplate], /
        ) -> "Ephemeral.Builder": ...

        @overload
        def volume_claim_template(
            self,
            value_or_callback: Callable[
                [VolumeClaimTemplate.Builder],
                VolumeClaimTemplate.Builder | VolumeClaimTemplate,
            ],
            /,
        ) -> "Ephemeral.Builder": ...

        @overload
        def volume_claim_template(
            self, value_or_callback: Never = ...
        ) -> "VolumeClaimTemplate.BuilderContext": ...

        def volume_claim_template(self, value_or_callback=None, /):
            """
            Will be used to create a stand-alone PVC to provision the volume.
            The pod in which this EphemeralVolumeSource is embedded will be the
            owner of the PVC, i.e. the PVC will be deleted together with the
            pod.  The name of the PVC will be `<pod name>-<volume name>` where
            `<volume name>` is the name from the `PodSpec.Volumes` array
            entry. Pod validation will reject the pod if the concatenated name
            is not valid for a PVC (for example, too long).

            An existing PVC with that name that is not owned by the pod
            will *not* be used for the pod to avoid using an unrelated
            volume by mistake. Starting the pod is then blocked until
            the unrelated PVC is removed. If such a pre-created PVC is
            meant to be used by the pod, the PVC has to updated with an
            owner reference to the pod once the pod exists. Normally
            this should not be necessary, but it may be useful when
            manually reconstructing a broken cluster.

            This field is read-only and no changes will be made by Kubernetes
            to the PVC after it has been created.

            Required, must not be nil.
            """
            if self._in_context and value_or_callback is None:
                context = VolumeClaimTemplate.BuilderContext()
                context._parent_builder = self
                context._field_name = "volume_claim_template"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VolumeClaimTemplate.builder())
                if isinstance(output, VolumeClaimTemplate.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("volume_claim_template", value)

    class BuilderContext(BuilderContextBase["Ephemeral.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ephemeral.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ephemeral."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ephemeral", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ephemeral.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    volume_claim_template: Annotated[
        Optional[VolumeClaimTemplate], Field(alias="volumeClaimTemplate")
    ] = None
    """
    Will be used to create a stand-alone PVC to provision the volume.
    The pod in which this EphemeralVolumeSource is embedded will be the
    owner of the PVC, i.e. the PVC will be deleted together with the
    pod.  The name of the PVC will be `<pod name>-<volume name>` where
    `<volume name>` is the name from the `PodSpec.Volumes` array
    entry. Pod validation will reject the pod if the concatenated name
    is not valid for a PVC (for example, too long).

    An existing PVC with that name that is not owned by the pod
    will *not* be used for the pod to avoid using an unrelated
    volume by mistake. Starting the pod is then blocked until
    the unrelated PVC is removed. If such a pre-created PVC is
    meant to be used by the pod, the PVC has to updated with an
    owner reference to the pod once the pod exists. Normally
    this should not be necessary, but it may be useful when
    manually reconstructing a broken cluster.

    This field is read-only and no changes will be made by Kubernetes
    to the PVC after it has been created.

    Required, must not be nil.
    """


class Metadata(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Metadata"]:
            return Metadata

        def build(self) -> "Metadata":
            return Metadata(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations is an unstructured key value map stored with a resource that may be
            set by external tools to store and retrieve arbitrary metadata. They are not
            queryable and should be preserved when modifying objects.
            More info: http://kubernetes.io/docs/user-guide/annotations
            """
            return self._set("annotations", value)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Map of string keys and values that can be used to organize and categorize
            (scope and select) objects. May match selectors of replication controllers
            and services.
            More info: http://kubernetes.io/docs/user-guide/labels
            """
            return self._set("labels", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name must be unique within a namespace. Is required when creating resources, although
            some resources may allow a client to request the generation of an appropriate name
            automatically. Name is primarily intended for creation idempotence and configuration
            definition.
            Cannot be updated.
            More info: http://kubernetes.io/docs/user-guide/identifiers#names
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["Metadata.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Metadata.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Metadata."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Metadata", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Metadata.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, str]] = None
    """
    Annotations is an unstructured key value map stored with a resource that may be
    set by external tools to store and retrieve arbitrary metadata. They are not
    queryable and should be preserved when modifying objects.
    More info: http://kubernetes.io/docs/user-guide/annotations
    """
    labels: Optional[Dict[str, str]] = None
    """
    Map of string keys and values that can be used to organize and categorize
    (scope and select) objects. May match selectors of replication controllers
    and services.
    More info: http://kubernetes.io/docs/user-guide/labels
    """
    name: Optional[str] = None
    """
    Name must be unique within a namespace. Is required when creating resources, although
    some resources may allow a client to request the generation of an appropriate name
    automatically. Name is primarily intended for creation idempotence and configuration
    definition.
    Cannot be updated.
    More info: http://kubernetes.io/docs/user-guide/identifiers#names
    """


class LimitsModel7(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel7":
            value = cast(int, self._value)
            return LimitsModel7(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel7.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel7.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel7."""
        return cls.BuilderContext()


class LimitsModel8(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel8":
            value = cast(str, self._value)
            return LimitsModel8(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel8.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel8.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel8."""
        return cls.BuilderContext()


class RequestsModel7(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel7":
            value = cast(int, self._value)
            return RequestsModel7(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel7.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel7.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel7."""
        return cls.BuilderContext()


class RequestsModel8(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel8":
            value = cast(str, self._value)
            return RequestsModel8(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel8.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel8.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel8."""
        return cls.BuilderContext()


class AllocatedResources(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "AllocatedResources":
            value = cast(int, self._value)
            return AllocatedResources(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["AllocatedResources.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllocatedResources.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllocatedResources."""
        return cls.BuilderContext()


class AllocatedResourcesModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "AllocatedResourcesModel":
            value = cast(str, self._value)
            return AllocatedResourcesModel(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["AllocatedResourcesModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllocatedResourcesModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllocatedResourcesModel."""
        return cls.BuilderContext()


class Capacity(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "Capacity":
            value = cast(int, self._value)
            return Capacity(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["Capacity.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Capacity.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Capacity."""
        return cls.BuilderContext()


class CapacityModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "CapacityModel":
            value = cast(str, self._value)
            return CapacityModel(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["CapacityModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CapacityModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CapacityModel."""
        return cls.BuilderContext()


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_probe_time(self, value: Optional[datetime], /) -> Self:
            """
            lastProbeTime is the time we probed the condition.
            """
            return self._set("last_probe_time", value)

        def last_transition_time(self, value: Optional[datetime], /) -> Self:
            """
            lastTransitionTime is the time the condition transitioned from one status to another.
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            message is the human-readable message indicating details about last transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            reason is a unique, this should be a short, machine understandable string that gives the reason
            for condition's last transition. If it reports "Resizing" that means the underlying
            persistent volume is being resized.
            """
            return self._set("reason", value)

        def status(self, value: str, /) -> Self:
            """
            Status is the status of the condition.
            Can be True, False, Unknown.
            More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type is the type of the condition.
            More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_probe_time: Annotated[Optional[datetime], Field(alias="lastProbeTime")] = None
    """
    lastProbeTime is the time we probed the condition.
    """
    last_transition_time: Annotated[Optional[datetime], Field(alias="lastTransitionTime")] = None
    """
    lastTransitionTime is the time the condition transitioned from one status to another.
    """
    message: Optional[str] = None
    """
    message is the human-readable message indicating details about last transition.
    """
    reason: Optional[str] = None
    """
    reason is a unique, this should be a short, machine understandable string that gives the reason
    for condition's last transition. If it reports "Resizing" that means the underlying
    persistent volume is being resized.
    """
    status: str
    """
    Status is the status of the condition.
    Can be True, False, Unknown.
    More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required
    """
    type: str
    """
    Type is the type of the condition.
    More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about
    """


class ModifyVolumeStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ModifyVolumeStatus"]:
            return ModifyVolumeStatus

        def build(self) -> "ModifyVolumeStatus":
            return ModifyVolumeStatus(**self._attrs)

        def status(self, value: str, /) -> Self:
            """
            status is the status of the ControllerModifyVolume operation. It can be in any of following states:
             - Pending
               Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
               the specified VolumeAttributesClass not existing.
             - InProgress
               InProgress indicates that the volume is being modified.
             - Infeasible
              Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
                  resolve the error, a valid VolumeAttributesClass needs to be specified.
            Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
            """
            return self._set("status", value)

        def target_volume_attributes_class_name(self, value: Optional[str], /) -> Self:
            """
            targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
            """
            return self._set("target_volume_attributes_class_name", value)

    class BuilderContext(BuilderContextBase["ModifyVolumeStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ModifyVolumeStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ModifyVolumeStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ModifyVolumeStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ModifyVolumeStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    status: str
    """
    status is the status of the ControllerModifyVolume operation. It can be in any of following states:
     - Pending
       Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
       the specified VolumeAttributesClass not existing.
     - InProgress
       InProgress indicates that the volume is being modified.
     - Infeasible
      Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
          resolve the error, a valid VolumeAttributesClass needs to be specified.
    Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
    """
    target_volume_attributes_class_name: Annotated[
        Optional[str], Field(alias="targetVolumeAttributesClassName")
    ] = None
    """
    targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
    """


class Status(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Status"]:
            return Status

        def build(self) -> "Status":
            return Status(**self._attrs)

        def access_modes(self, value: Optional[List[str]], /) -> Self:
            """
            accessModes contains the actual access modes the volume backing the PVC has.
            More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
            """
            return self._set("access_modes", value)

        def allocated_resource_statuses(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            allocatedResourceStatuses stores status of resource being resized for the given PVC.
            Key names follow standard Kubernetes label syntax. Valid values are either:
                * Un-prefixed keys:
                    - storage - the capacity of the volume.
                * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
            Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
            reserved and hence may not be used.

            ClaimResourceStatus can be in any of following states:
                - ControllerResizeInProgress:
                    State set when resize controller starts resizing the volume in control-plane.
                - ControllerResizeFailed:
                    State set when resize has failed in resize controller with a terminal error.
                - NodeResizePending:
                    State set when resize controller has finished resizing the volume but further resizing of
                    volume is needed on the node.
                - NodeResizeInProgress:
                    State set when kubelet starts resizing the volume.
                - NodeResizeFailed:
                    State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
                    NodeResizeFailed.
            For example: if expanding a PVC for more capacity - this field can be one of the following states:
                - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
                 - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
                 - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
                 - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
                 - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
            When this field is not set, it means that no resize operation is in progress for the given PVC.

            A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
            should ignore the update for the purpose it was designed. For example - a controller that
            only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
            resources associated with PVC.

            This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
            """
            return self._set("allocated_resource_statuses", value)

        def allocated_resources(
            self,
            value: Optional[Dict[str, Union[AllocatedResources, AllocatedResourcesModel]]],
            /,
        ) -> Self:
            """
            allocatedResources tracks the resources allocated to a PVC including its capacity.
            Key names follow standard Kubernetes label syntax. Valid values are either:
                * Un-prefixed keys:
                    - storage - the capacity of the volume.
                * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
            Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
            reserved and hence may not be used.

            Capacity reported here may be larger than the actual capacity when a volume expansion operation
            is requested.
            For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
            If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
            If a volume expansion capacity request is lowered, allocatedResources is only
            lowered if there are no expansion operations in progress and if the actual volume capacity
            is equal or lower than the requested capacity.

            A controller that receives PVC update with previously unknown resourceName
            should ignore the update for the purpose it was designed. For example - a controller that
            only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
            resources associated with PVC.

            This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
            """
            return self._set("allocated_resources", value)

        def capacity(self, value: Optional[Dict[str, Union[Capacity, CapacityModel]]], /) -> Self:
            """
            capacity represents the actual resources of the underlying volume.
            """
            return self._set("capacity", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "Status.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "Status.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
            resized then the Condition will be set to 'Resizing'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def current_volume_attributes_class_name(self, value: Optional[str], /) -> Self:
            """
            currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
            When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
            This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
            """
            return self._set("current_volume_attributes_class_name", value)

        @overload
        def modify_volume_status(
            self, value_or_callback: Optional[ModifyVolumeStatus], /
        ) -> "Status.Builder": ...

        @overload
        def modify_volume_status(
            self,
            value_or_callback: Callable[
                [ModifyVolumeStatus.Builder],
                ModifyVolumeStatus.Builder | ModifyVolumeStatus,
            ],
            /,
        ) -> "Status.Builder": ...

        @overload
        def modify_volume_status(
            self, value_or_callback: Never = ...
        ) -> "ModifyVolumeStatus.BuilderContext": ...

        def modify_volume_status(self, value_or_callback=None, /):
            """
            ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
            When this is unset, there is no ModifyVolume operation being attempted.
            This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
            """
            if self._in_context and value_or_callback is None:
                context = ModifyVolumeStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "modify_volume_status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ModifyVolumeStatus.builder())
                if isinstance(output, ModifyVolumeStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("modify_volume_status", value)

        def phase(self, value: Optional[str], /) -> Self:
            """
            phase represents the current phase of PersistentVolumeClaim.
            """
            return self._set("phase", value)

    class BuilderContext(BuilderContextBase["Status.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Status.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Status."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Status", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Status.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_modes: Annotated[Optional[List[str]], Field(alias="accessModes")] = None
    """
    accessModes contains the actual access modes the volume backing the PVC has.
    More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
    """
    allocated_resource_statuses: Annotated[
        Optional[Dict[str, str]], Field(alias="allocatedResourceStatuses")
    ] = None
    """
    allocatedResourceStatuses stores status of resource being resized for the given PVC.
    Key names follow standard Kubernetes label syntax. Valid values are either:
        * Un-prefixed keys:
            - storage - the capacity of the volume.
        * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
    Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
    reserved and hence may not be used.

    ClaimResourceStatus can be in any of following states:
        - ControllerResizeInProgress:
            State set when resize controller starts resizing the volume in control-plane.
        - ControllerResizeFailed:
            State set when resize has failed in resize controller with a terminal error.
        - NodeResizePending:
            State set when resize controller has finished resizing the volume but further resizing of
            volume is needed on the node.
        - NodeResizeInProgress:
            State set when kubelet starts resizing the volume.
        - NodeResizeFailed:
            State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
            NodeResizeFailed.
    For example: if expanding a PVC for more capacity - this field can be one of the following states:
        - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
         - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
         - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
         - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
         - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
    When this field is not set, it means that no resize operation is in progress for the given PVC.

    A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
    should ignore the update for the purpose it was designed. For example - a controller that
    only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
    resources associated with PVC.

    This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
    """
    allocated_resources: Annotated[
        Optional[Dict[str, Union[AllocatedResources, AllocatedResourcesModel]]],
        Field(alias="allocatedResources"),
    ] = None
    """
    allocatedResources tracks the resources allocated to a PVC including its capacity.
    Key names follow standard Kubernetes label syntax. Valid values are either:
        * Un-prefixed keys:
            - storage - the capacity of the volume.
        * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
    Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
    reserved and hence may not be used.

    Capacity reported here may be larger than the actual capacity when a volume expansion operation
    is requested.
    For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
    If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
    If a volume expansion capacity request is lowered, allocatedResources is only
    lowered if there are no expansion operations in progress and if the actual volume capacity
    is equal or lower than the requested capacity.

    A controller that receives PVC update with previously unknown resourceName
    should ignore the update for the purpose it was designed. For example - a controller that
    only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
    resources associated with PVC.

    This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
    """
    capacity: Optional[Dict[str, Union[Capacity, CapacityModel]]] = None
    """
    capacity represents the actual resources of the underlying volume.
    """
    conditions: Optional[List[Condition]] = None
    """
    conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
    resized then the Condition will be set to 'Resizing'.
    """
    current_volume_attributes_class_name: Annotated[
        Optional[str], Field(alias="currentVolumeAttributesClassName")
    ] = None
    """
    currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
    When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
    This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
    """
    modify_volume_status: Annotated[
        Optional[ModifyVolumeStatus], Field(alias="modifyVolumeStatus")
    ] = None
    """
    ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
    When this is unset, there is no ModifyVolume operation being attempted.
    This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
    """
    phase: Optional[str] = None
    """
    phase represents the current phase of PersistentVolumeClaim.
    """


class VolumeClaimTemplateModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VolumeClaimTemplateModel"]:
            return VolumeClaimTemplateModel

        def build(self) -> "VolumeClaimTemplateModel":
            return VolumeClaimTemplateModel(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[Metadata], /
        ) -> "VolumeClaimTemplateModel.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[[Metadata.Builder], Metadata.Builder | Metadata],
            /,
        ) -> "VolumeClaimTemplateModel.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "Metadata.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            """
            EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
            """
            if self._in_context and value_or_callback is None:
                context = Metadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Metadata.builder())
                if isinstance(output, Metadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[Spec], /
        ) -> "VolumeClaimTemplateModel.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Callable[[Spec.Builder], Spec.Builder | Spec], /
        ) -> "VolumeClaimTemplateModel.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "Spec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            """
            Defines the desired characteristics of a volume requested by a pod author.
            More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
            """
            if self._in_context and value_or_callback is None:
                context = Spec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Spec.builder())
                if isinstance(output, Spec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[Status], /
        ) -> "VolumeClaimTemplateModel.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[[Status.Builder], Status.Builder | Status],
            /,
        ) -> "VolumeClaimTemplateModel.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "Status.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            """
            Deprecated: this field is never set.
            """
            if self._in_context and value_or_callback is None:
                context = Status.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Status.builder())
                if isinstance(output, Status.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["VolumeClaimTemplateModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VolumeClaimTemplateModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VolumeClaimTemplateModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VolumeClaimTemplateModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VolumeClaimTemplateModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[str] = None
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[Metadata] = None
    """
    EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
    """
    spec: Optional[Spec] = None
    """
    Defines the desired characteristics of a volume requested by a pod author.
    More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
    """
    status: Optional[Status] = None
    """
    Deprecated: this field is never set.
    """


class Storage(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Storage"]:
            return Storage

        def build(self) -> "Storage":
            return Storage(**self._attrs)

        def disable_mount_sub_path(self, value: Optional[bool], /) -> Self:
            """
            Deprecated: subPath usage will be removed in a future release.
            """
            return self._set("disable_mount_sub_path", value)

        @overload
        def empty_dir(self, value_or_callback: Optional[EmptyDir], /) -> "Storage.Builder": ...

        @overload
        def empty_dir(
            self,
            value_or_callback: Callable[[EmptyDir.Builder], EmptyDir.Builder | EmptyDir],
            /,
        ) -> "Storage.Builder": ...

        @overload
        def empty_dir(self, value_or_callback: Never = ...) -> "EmptyDir.BuilderContext": ...

        def empty_dir(self, value_or_callback=None, /):
            """
            EmptyDirVolumeSource to be used by the StatefulSet.
            If specified, it takes precedence over `ephemeral` and `volumeClaimTemplate`.
            More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
            """
            if self._in_context and value_or_callback is None:
                context = EmptyDir.BuilderContext()
                context._parent_builder = self
                context._field_name = "empty_dir"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(EmptyDir.builder())
                if isinstance(output, EmptyDir.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("empty_dir", value)

        @overload
        def ephemeral(self, value_or_callback: Optional[Ephemeral], /) -> "Storage.Builder": ...

        @overload
        def ephemeral(
            self,
            value_or_callback: Callable[[Ephemeral.Builder], Ephemeral.Builder | Ephemeral],
            /,
        ) -> "Storage.Builder": ...

        @overload
        def ephemeral(self, value_or_callback: Never = ...) -> "Ephemeral.BuilderContext": ...

        def ephemeral(self, value_or_callback=None, /):
            """
            EphemeralVolumeSource to be used by the StatefulSet.
            This is a beta field in k8s 1.21 and GA in 1.15.
            For lower versions, starting with k8s 1.19, it requires enabling the GenericEphemeralVolume feature gate.
            More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
            """
            if self._in_context and value_or_callback is None:
                context = Ephemeral.BuilderContext()
                context._parent_builder = self
                context._field_name = "ephemeral"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ephemeral.builder())
                if isinstance(output, Ephemeral.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ephemeral", value)

        @overload
        def volume_claim_template(
            self, value_or_callback: Optional[VolumeClaimTemplateModel], /
        ) -> "Storage.Builder": ...

        @overload
        def volume_claim_template(
            self,
            value_or_callback: Callable[
                [VolumeClaimTemplateModel.Builder],
                VolumeClaimTemplateModel.Builder | VolumeClaimTemplateModel,
            ],
            /,
        ) -> "Storage.Builder": ...

        @overload
        def volume_claim_template(
            self, value_or_callback: Never = ...
        ) -> "VolumeClaimTemplateModel.BuilderContext": ...

        def volume_claim_template(self, value_or_callback=None, /):
            """
            Defines the PVC spec to be used by the Prometheus StatefulSets.
            The easiest way to use a volume that cannot be automatically provisioned
            is to use a label selector alongside manually created PersistentVolumes.
            """
            if self._in_context and value_or_callback is None:
                context = VolumeClaimTemplateModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "volume_claim_template"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VolumeClaimTemplateModel.builder())
                if isinstance(output, VolumeClaimTemplateModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("volume_claim_template", value)

    class BuilderContext(BuilderContextBase["Storage.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Storage.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Storage."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Storage", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Storage.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    disable_mount_sub_path: Annotated[Optional[bool], Field(alias="disableMountSubPath")] = None
    """
    Deprecated: subPath usage will be removed in a future release.
    """
    empty_dir: Annotated[Optional[EmptyDir], Field(alias="emptyDir")] = None
    """
    EmptyDirVolumeSource to be used by the StatefulSet.
    If specified, it takes precedence over `ephemeral` and `volumeClaimTemplate`.
    More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
    """
    ephemeral: Optional[Ephemeral] = None
    """
    EphemeralVolumeSource to be used by the StatefulSet.
    This is a beta field in k8s 1.21 and GA in 1.15.
    For lower versions, starting with k8s 1.19, it requires enabling the GenericEphemeralVolume feature gate.
    More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
    """
    volume_claim_template: Annotated[
        Optional[VolumeClaimTemplateModel], Field(alias="volumeClaimTemplate")
    ] = None
    """
    Defines the PVC spec to be used by the Prometheus StatefulSets.
    The easiest way to use a volume that cannot be automatically provisioned
    is to use a label selector alongside manually created PersistentVolumes.
    """


class Toleration(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Toleration"]:
            return Toleration

        def build(self) -> "Toleration":
            return Toleration(**self._attrs)

        def effect(self, value: Optional[str], /) -> Self:
            """
            Effect indicates the taint effect to match. Empty means match all taint effects.
            When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
            """
            return self._set("effect", value)

        def key(self, value: Optional[str], /) -> Self:
            """
            Key is the taint key that the toleration applies to. Empty means match all taint keys.
            If the key is empty, operator must be Exists; this combination means to match all values and all keys.
            """
            return self._set("key", value)

        def operator(self, value: Optional[str], /) -> Self:
            """
            Operator represents a key's relationship to the value.
            Valid operators are Exists and Equal. Defaults to Equal.
            Exists is equivalent to wildcard for value, so that a pod can
            tolerate all taints of a particular category.
            """
            return self._set("operator", value)

        def toleration_seconds(self, value: Optional[int], /) -> Self:
            """
            TolerationSeconds represents the period of time the toleration (which must be
            of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
            it is not set, which means tolerate the taint forever (do not evict). Zero and
            negative values will be treated as 0 (evict immediately) by the system.
            """
            return self._set("toleration_seconds", value)

        def value(self, value: Optional[str], /) -> Self:
            """
            Value is the taint value the toleration matches to.
            If the operator is Exists, the value should be empty, otherwise just a regular string.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["Toleration.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Toleration.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Toleration."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Toleration", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Toleration.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    effect: Optional[str] = None
    """
    Effect indicates the taint effect to match. Empty means match all taint effects.
    When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    """
    key: Optional[str] = None
    """
    Key is the taint key that the toleration applies to. Empty means match all taint keys.
    If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    """
    operator: Optional[str] = None
    """
    Operator represents a key's relationship to the value.
    Valid operators are Exists and Equal. Defaults to Equal.
    Exists is equivalent to wildcard for value, so that a pod can
    tolerate all taints of a particular category.
    """
    toleration_seconds: Annotated[Optional[int], Field(alias="tolerationSeconds")] = None
    """
    TolerationSeconds represents the period of time the toleration (which must be
    of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    it is not set, which means tolerate the taint forever (do not evict). Zero and
    negative values will be treated as 0 (evict immediately) by the system.
    """
    value: Optional[str] = None
    """
    Value is the taint value the toleration matches to.
    If the operator is Exists, the value should be empty, otherwise just a regular string.
    """


class TopologySpreadConstraint(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TopologySpreadConstraint"]:
            return TopologySpreadConstraint

        def build(self) -> "TopologySpreadConstraint":
            return TopologySpreadConstraint(**self._attrs)

        def additional_label_selectors(
            self, value: Optional[Literal["OnResource", "OnShard"]], /
        ) -> Self:
            """
            Defines what Prometheus Operator managed labels should be added to labelSelector on the topologySpreadConstraint.
            """
            return self._set("additional_label_selectors", value)

        @overload
        def label_selector(
            self, value_or_callback: Optional[LabelSelector], /
        ) -> "TopologySpreadConstraint.Builder": ...

        @overload
        def label_selector(
            self,
            value_or_callback: Callable[
                [LabelSelector.Builder], LabelSelector.Builder | LabelSelector
            ],
            /,
        ) -> "TopologySpreadConstraint.Builder": ...

        @overload
        def label_selector(
            self, value_or_callback: Never = ...
        ) -> "LabelSelector.BuilderContext": ...

        def label_selector(self, value_or_callback=None, /):
            """
            LabelSelector is used to find matching pods.
            Pods that match this label selector are counted to determine the number of pods
            in their corresponding topology domain.
            """
            if self._in_context and value_or_callback is None:
                context = LabelSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "label_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LabelSelector.builder())
                if isinstance(output, LabelSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("label_selector", value)

        def match_label_keys(self, value: Optional[List[str]], /) -> Self:
            """
            MatchLabelKeys is a set of pod label keys to select the pods over which
            spreading will be calculated. The keys are used to lookup values from the
            incoming pod labels, those key-value labels are ANDed with labelSelector
            to select the group of existing pods over which spreading will be calculated
            for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
            MatchLabelKeys cannot be set when LabelSelector isn't set.
            Keys that don't exist in the incoming pod labels will
            be ignored. A null or empty list means only match against labelSelector.

            This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
            """
            return self._set("match_label_keys", value)

        def max_skew(self, value: int, /) -> Self:
            """
            MaxSkew describes the degree to which pods may be unevenly distributed.
            When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
            between the number of matching pods in the target topology and the global minimum.
            The global minimum is the minimum number of matching pods in an eligible domain
            or zero if the number of eligible domains is less than MinDomains.
            For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
            labelSelector spread as 2/2/1:
            In this case, the global minimum is 1.
            | zone1 | zone2 | zone3 |
            |  P P  |  P P  |   P   |
            - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
            scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
            violate MaxSkew(1).
            - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
            When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
            to topologies that satisfy it.
            It's a required field. Default value is 1 and 0 is not allowed.
            """
            return self._set("max_skew", value)

        def min_domains(self, value: Optional[int], /) -> Self:
            """
            MinDomains indicates a minimum number of eligible domains.
            When the number of eligible domains with matching topology keys is less than minDomains,
            Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
            And when the number of eligible domains with matching topology keys equals or greater than minDomains,
            this value has no effect on scheduling.
            As a result, when the number of eligible domains is less than minDomains,
            scheduler won't schedule more than maxSkew Pods to those domains.
            If value is nil, the constraint behaves as if MinDomains is equal to 1.
            Valid values are integers greater than 0.
            When value is not nil, WhenUnsatisfiable must be DoNotSchedule.

            For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
            labelSelector spread as 2/2/2:
            | zone1 | zone2 | zone3 |
            |  P P  |  P P  |  P P  |
            The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
            In this situation, new pod with the same labelSelector cannot be scheduled,
            because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
            it will violate MaxSkew.
            """
            return self._set("min_domains", value)

        def node_affinity_policy(self, value: Optional[str], /) -> Self:
            """
            NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
            when calculating pod topology spread skew. Options are:
            - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
            - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.

            If this value is nil, the behavior is equivalent to the Honor policy.
            This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
            """
            return self._set("node_affinity_policy", value)

        def node_taints_policy(self, value: Optional[str], /) -> Self:
            """
            NodeTaintsPolicy indicates how we will treat node taints when calculating
            pod topology spread skew. Options are:
            - Honor: nodes without taints, along with tainted nodes for which the incoming pod
            has a toleration, are included.
            - Ignore: node taints are ignored. All nodes are included.

            If this value is nil, the behavior is equivalent to the Ignore policy.
            This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
            """
            return self._set("node_taints_policy", value)

        def topology_key(self, value: str, /) -> Self:
            """
            TopologyKey is the key of node labels. Nodes that have a label with this key
            and identical values are considered to be in the same topology.
            We consider each <key, value> as a "bucket", and try to put balanced number
            of pods into each bucket.
            We define a domain as a particular instance of a topology.
            Also, we define an eligible domain as a domain whose nodes meet the requirements of
            nodeAffinityPolicy and nodeTaintsPolicy.
            e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
            And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
            It's a required field.
            """
            return self._set("topology_key", value)

        def when_unsatisfiable(self, value: str, /) -> Self:
            """
            WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
            the spread constraint.
            - DoNotSchedule (default) tells the scheduler not to schedule it.
            - ScheduleAnyway tells the scheduler to schedule the pod in any location,
              but giving higher precedence to topologies that would help reduce the
              skew.
            A constraint is considered "Unsatisfiable" for an incoming pod
            if and only if every possible node assignment for that pod would violate
            "MaxSkew" on some topology.
            For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
            labelSelector spread as 3/1/1:
            | zone1 | zone2 | zone3 |
            | P P P |   P   |   P   |
            If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
            to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
            MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
            won't make it *more* imbalanced.
            It's a required field.
            """
            return self._set("when_unsatisfiable", value)

    class BuilderContext(BuilderContextBase["TopologySpreadConstraint.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TopologySpreadConstraint.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TopologySpreadConstraint."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TopologySpreadConstraint", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TopologySpreadConstraint.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    additional_label_selectors: Annotated[
        Optional[Literal["OnResource", "OnShard"]],
        Field(alias="additionalLabelSelectors"),
    ] = None
    """
    Defines what Prometheus Operator managed labels should be added to labelSelector on the topologySpreadConstraint.
    """
    label_selector: Annotated[Optional[LabelSelector], Field(alias="labelSelector")] = None
    """
    LabelSelector is used to find matching pods.
    Pods that match this label selector are counted to determine the number of pods
    in their corresponding topology domain.
    """
    match_label_keys: Annotated[Optional[List[str]], Field(alias="matchLabelKeys")] = None
    """
    MatchLabelKeys is a set of pod label keys to select the pods over which
    spreading will be calculated. The keys are used to lookup values from the
    incoming pod labels, those key-value labels are ANDed with labelSelector
    to select the group of existing pods over which spreading will be calculated
    for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
    MatchLabelKeys cannot be set when LabelSelector isn't set.
    Keys that don't exist in the incoming pod labels will
    be ignored. A null or empty list means only match against labelSelector.

    This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
    """
    max_skew: Annotated[int, Field(alias="maxSkew")]
    """
    MaxSkew describes the degree to which pods may be unevenly distributed.
    When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
    between the number of matching pods in the target topology and the global minimum.
    The global minimum is the minimum number of matching pods in an eligible domain
    or zero if the number of eligible domains is less than MinDomains.
    For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
    labelSelector spread as 2/2/1:
    In this case, the global minimum is 1.
    | zone1 | zone2 | zone3 |
    |  P P  |  P P  |   P   |
    - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
    scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
    violate MaxSkew(1).
    - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
    When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
    to topologies that satisfy it.
    It's a required field. Default value is 1 and 0 is not allowed.
    """
    min_domains: Annotated[Optional[int], Field(alias="minDomains")] = None
    """
    MinDomains indicates a minimum number of eligible domains.
    When the number of eligible domains with matching topology keys is less than minDomains,
    Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
    And when the number of eligible domains with matching topology keys equals or greater than minDomains,
    this value has no effect on scheduling.
    As a result, when the number of eligible domains is less than minDomains,
    scheduler won't schedule more than maxSkew Pods to those domains.
    If value is nil, the constraint behaves as if MinDomains is equal to 1.
    Valid values are integers greater than 0.
    When value is not nil, WhenUnsatisfiable must be DoNotSchedule.

    For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
    labelSelector spread as 2/2/2:
    | zone1 | zone2 | zone3 |
    |  P P  |  P P  |  P P  |
    The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
    In this situation, new pod with the same labelSelector cannot be scheduled,
    because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
    it will violate MaxSkew.
    """
    node_affinity_policy: Annotated[Optional[str], Field(alias="nodeAffinityPolicy")] = None
    """
    NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
    when calculating pod topology spread skew. Options are:
    - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
    - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.

    If this value is nil, the behavior is equivalent to the Honor policy.
    This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
    """
    node_taints_policy: Annotated[Optional[str], Field(alias="nodeTaintsPolicy")] = None
    """
    NodeTaintsPolicy indicates how we will treat node taints when calculating
    pod topology spread skew. Options are:
    - Honor: nodes without taints, along with tainted nodes for which the incoming pod
    has a toleration, are included.
    - Ignore: node taints are ignored. All nodes are included.

    If this value is nil, the behavior is equivalent to the Ignore policy.
    This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
    """
    topology_key: Annotated[str, Field(alias="topologyKey")]
    """
    TopologyKey is the key of node labels. Nodes that have a label with this key
    and identical values are considered to be in the same topology.
    We consider each <key, value> as a "bucket", and try to put balanced number
    of pods into each bucket.
    We define a domain as a particular instance of a topology.
    Also, we define an eligible domain as a domain whose nodes meet the requirements of
    nodeAffinityPolicy and nodeTaintsPolicy.
    e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
    And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
    It's a required field.
    """
    when_unsatisfiable: Annotated[str, Field(alias="whenUnsatisfiable")]
    """
    WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
    the spread constraint.
    - DoNotSchedule (default) tells the scheduler not to schedule it.
    - ScheduleAnyway tells the scheduler to schedule the pod in any location,
      but giving higher precedence to topologies that would help reduce the
      skew.
    A constraint is considered "Unsatisfiable" for an incoming pod
    if and only if every possible node assignment for that pod would violate
    "MaxSkew" on some topology.
    For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
    labelSelector spread as 3/1/1:
    | zone1 | zone2 | zone3 |
    | P P P |   P   |   P   |
    If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
    to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
    MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
    won't make it *more* imbalanced.
    It's a required field.
    """


class SamplingFraction(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
            """
            self._value = value
            return self

        def build(self) -> "SamplingFraction":
            value = cast(int, self._value)
            return SamplingFraction(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
    """

    class BuilderContext(BuilderContextBase["SamplingFraction.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SamplingFraction.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SamplingFraction."""
        return cls.BuilderContext()


class SamplingFractionModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
            """
            self._value = value
            return self

        def build(self) -> "SamplingFractionModel":
            value = cast(str, self._value)
            return SamplingFractionModel(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
    """

    class BuilderContext(BuilderContextBase["SamplingFractionModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SamplingFractionModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SamplingFractionModel."""
        return cls.BuilderContext()


class TracingConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TracingConfig"]:
            return TracingConfig

        def build(self) -> "TracingConfig":
            return TracingConfig(**self._attrs)

        def client_type(self, value: Optional[Literal["http", "grpc"]], /) -> Self:
            """
            Client used to export the traces. Supported values are `http` or `grpc`.
            """
            return self._set("client_type", value)

        def compression(self, value: Optional[Literal["gzip"]], /) -> Self:
            """
            Compression key for supported compression types. The only supported value is `gzip`.
            """
            return self._set("compression", value)

        def endpoint(self, value: str, /) -> Self:
            """
            Endpoint to send the traces to. Should be provided in format <host>:<port>.
            """
            return self._set("endpoint", value)

        def headers(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Key-value pairs to be used as headers associated with gRPC or HTTP requests.
            """
            return self._set("headers", value)

        def insecure(self, value: Optional[bool], /) -> Self:
            """
            If disabled, the client will use a secure connection.
            """
            return self._set("insecure", value)

        def sampling_fraction(
            self, value: Optional[Union[SamplingFraction, SamplingFractionModel]], /
        ) -> Self:
            """
            Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
            """
            return self._set("sampling_fraction", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            Maximum time the exporter will wait for each batch export.
            """
            return self._set("timeout", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel2], /
        ) -> "TracingConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel2.Builder], TlsConfigModel2.Builder | TlsConfigModel2
            ],
            /,
        ) -> "TracingConfig.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel2.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS Config to use when sending traces.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel2.builder())
                if isinstance(output, TlsConfigModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["TracingConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TracingConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TracingConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TracingConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TracingConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    client_type: Annotated[Optional[Literal["http", "grpc"]], Field(alias="clientType")] = None
    """
    Client used to export the traces. Supported values are `http` or `grpc`.
    """
    compression: Optional[Literal["gzip"]] = None
    """
    Compression key for supported compression types. The only supported value is `gzip`.
    """
    endpoint: Annotated[str, Field(min_length=1)]
    """
    Endpoint to send the traces to. Should be provided in format <host>:<port>.
    """
    headers: Optional[Dict[str, str]] = None
    """
    Key-value pairs to be used as headers associated with gRPC or HTTP requests.
    """
    insecure: Optional[bool] = None
    """
    If disabled, the client will use a secure connection.
    """
    sampling_fraction: Annotated[
        Optional[Union[SamplingFraction, SamplingFractionModel]],
        Field(alias="samplingFraction"),
    ] = None
    """
    Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
    """
    timeout: Annotated[
        Optional[str],
        Field(
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"
        ),
    ] = None
    """
    Maximum time the exporter will wait for each batch export.
    """
    tls_config: Annotated[Optional[TlsConfigModel2], Field(alias="tlsConfig")] = None
    """
    TLS Config to use when sending traces.
    """


class Tsdb(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Tsdb"]:
            return Tsdb

        def build(self) -> "Tsdb":
            return Tsdb(**self._attrs)

        def out_of_order_time_window(self, value: Optional[str], /) -> Self:
            """
            Configures how old an out-of-order/out-of-bounds sample can be with
            respect to the TSDB max time.

            An out-of-order/out-of-bounds sample is ingested into the TSDB as long as
            the timestamp of the sample is >= (TSDB.MaxTime - outOfOrderTimeWindow).

            This is an *experimental feature*, it may change in any upcoming release
            in a breaking way.

            It requires Prometheus >= v2.39.0 or PrometheusAgent >= v2.54.0.
            """
            return self._set("out_of_order_time_window", value)

    class BuilderContext(BuilderContextBase["Tsdb.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Tsdb.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Tsdb."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Tsdb", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Tsdb.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    out_of_order_time_window: Annotated[
        Optional[str],
        Field(
            alias="outOfOrderTimeWindow",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Configures how old an out-of-order/out-of-bounds sample can be with
    respect to the TSDB max time.

    An out-of-order/out-of-bounds sample is ingested into the TSDB as long as
    the timestamp of the sample is >= (TSDB.MaxTime - outOfOrderTimeWindow).

    This is an *experimental feature*, it may change in any upcoming release
    in a breaking way.

    It requires Prometheus >= v2.39.0 or PrometheusAgent >= v2.54.0.
    """


class AwsElasticBlockStore(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AwsElasticBlockStore"]:
            return AwsElasticBlockStore

        def build(self) -> "AwsElasticBlockStore":
            return AwsElasticBlockStore(**self._attrs)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is the filesystem type of the volume that you want to mount.
            Tip: Ensure that the filesystem type is supported by the host operating system.
            Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
            """
            return self._set("fs_type", value)

        def partition(self, value: Optional[int], /) -> Self:
            """
            partition is the partition in the volume that you want to mount.
            If omitted, the default is to mount by volume name.
            Examples: For volume /dev/sda1, you specify the partition as "1".
            Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
            """
            return self._set("partition", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly value true will force the readOnly setting in VolumeMounts.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
            """
            return self._set("read_only", value)

        def volume_id(self, value: str, /) -> Self:
            """
            volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
            More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
            """
            return self._set("volume_id", value)

    class BuilderContext(BuilderContextBase["AwsElasticBlockStore.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AwsElasticBlockStore.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AwsElasticBlockStore."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AwsElasticBlockStore", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AwsElasticBlockStore.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fsType is the filesystem type of the volume that you want to mount.
    Tip: Ensure that the filesystem type is supported by the host operating system.
    Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
    """
    partition: Optional[int] = None
    """
    partition is the partition in the volume that you want to mount.
    If omitted, the default is to mount by volume name.
    Examples: For volume /dev/sda1, you specify the partition as "1".
    Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly value true will force the readOnly setting in VolumeMounts.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
    """
    volume_id: Annotated[str, Field(alias="volumeID")]
    """
    volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
    More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
    """


class AzureDisk(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AzureDisk"]:
            return AzureDisk

        def build(self) -> "AzureDisk":
            return AzureDisk(**self._attrs)

        def caching_mode(self, value: Optional[str], /) -> Self:
            """
            cachingMode is the Host Caching mode: None, Read Only, Read Write.
            """
            return self._set("caching_mode", value)

        def disk_name(self, value: str, /) -> Self:
            """
            diskName is the Name of the data disk in the blob storage
            """
            return self._set("disk_name", value)

        def disk_uri(self, value: str, /) -> Self:
            """
            diskURI is the URI of data disk in the blob storage
            """
            return self._set("disk_uri", value)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is Filesystem type to mount.
            Must be a filesystem type supported by the host operating system.
            Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
            """
            return self._set("fs_type", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
            """
            return self._set("kind", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly Defaults to false (read/write). ReadOnly here will force
            the ReadOnly setting in VolumeMounts.
            """
            return self._set("read_only", value)

    class BuilderContext(BuilderContextBase["AzureDisk.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AzureDisk.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AzureDisk."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AzureDisk", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AzureDisk.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    caching_mode: Annotated[Optional[str], Field(alias="cachingMode")] = None
    """
    cachingMode is the Host Caching mode: None, Read Only, Read Write.
    """
    disk_name: Annotated[str, Field(alias="diskName")]
    """
    diskName is the Name of the data disk in the blob storage
    """
    disk_uri: Annotated[str, Field(alias="diskURI")]
    """
    diskURI is the URI of data disk in the blob storage
    """
    fs_type: Annotated[Optional[str], Field(alias="fsType")] = "ext4"
    """
    fsType is Filesystem type to mount.
    Must be a filesystem type supported by the host operating system.
    Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    """
    kind: Optional[str] = None
    """
    kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = False
    """
    readOnly Defaults to false (read/write). ReadOnly here will force
    the ReadOnly setting in VolumeMounts.
    """


class AzureFile(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AzureFile"]:
            return AzureFile

        def build(self) -> "AzureFile":
            return AzureFile(**self._attrs)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly defaults to false (read/write). ReadOnly here will force
            the ReadOnly setting in VolumeMounts.
            """
            return self._set("read_only", value)

        def secret_name(self, value: str, /) -> Self:
            """
            secretName is the  name of secret that contains Azure Storage Account Name and Key
            """
            return self._set("secret_name", value)

        def share_name(self, value: str, /) -> Self:
            """
            shareName is the azure share Name
            """
            return self._set("share_name", value)

    class BuilderContext(BuilderContextBase["AzureFile.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AzureFile.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AzureFile."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AzureFile", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AzureFile.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly defaults to false (read/write). ReadOnly here will force
    the ReadOnly setting in VolumeMounts.
    """
    secret_name: Annotated[str, Field(alias="secretName")]
    """
    secretName is the  name of secret that contains Azure Storage Account Name and Key
    """
    share_name: Annotated[str, Field(alias="shareName")]
    """
    shareName is the azure share Name
    """


class SecretRefModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretRefModel"]:
            return SecretRefModel

        def build(self) -> "SecretRefModel":
            return SecretRefModel(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["SecretRefModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretRefModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretRefModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretRefModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRefModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """


class Cephfs(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Cephfs"]:
            return Cephfs

        def build(self) -> "Cephfs":
            return Cephfs(**self._attrs)

        def monitors(self, value: List[str], /) -> Self:
            """
            monitors is Required: Monitors is a collection of Ceph monitors
            More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
            """
            return self._set("monitors", value)

        def path(self, value: Optional[str], /) -> Self:
            """
            path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
            """
            return self._set("path", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
            the ReadOnly setting in VolumeMounts.
            More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
            """
            return self._set("read_only", value)

        def secret_file(self, value: Optional[str], /) -> Self:
            """
            secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
            More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
            """
            return self._set("secret_file", value)

        @overload
        def secret_ref(
            self, value_or_callback: Optional[SecretRefModel], /
        ) -> "Cephfs.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[
                [SecretRefModel.Builder], SecretRefModel.Builder | SecretRefModel
            ],
            /,
        ) -> "Cephfs.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRefModel.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
            More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
            """
            if self._in_context and value_or_callback is None:
                context = SecretRefModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRefModel.builder())
                if isinstance(output, SecretRefModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def user(self, value: Optional[str], /) -> Self:
            """
            user is optional: User is the rados user name, default is admin
            More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
            """
            return self._set("user", value)

    class BuilderContext(BuilderContextBase["Cephfs.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Cephfs.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Cephfs."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Cephfs", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Cephfs.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    monitors: List[str]
    """
    monitors is Required: Monitors is a collection of Ceph monitors
    More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    """
    path: Optional[str] = None
    """
    path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
    the ReadOnly setting in VolumeMounts.
    More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    """
    secret_file: Annotated[Optional[str], Field(alias="secretFile")] = None
    """
    secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
    More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    """
    secret_ref: Annotated[Optional[SecretRefModel], Field(alias="secretRef")] = None
    """
    secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
    More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    """
    user: Optional[str] = None
    """
    user is optional: User is the rados user name, default is admin
    More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    """


class Cinder(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Cinder"]:
            return Cinder

        def build(self) -> "Cinder":
            return Cinder(**self._attrs)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is the filesystem type to mount.
            Must be a filesystem type supported by the host operating system.
            Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
            More info: https://examples.k8s.io/mysql-cinder-pd/README.md
            """
            return self._set("fs_type", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly defaults to false (read/write). ReadOnly here will force
            the ReadOnly setting in VolumeMounts.
            More info: https://examples.k8s.io/mysql-cinder-pd/README.md
            """
            return self._set("read_only", value)

        @overload
        def secret_ref(
            self, value_or_callback: Optional[SecretRefModel], /
        ) -> "Cinder.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[
                [SecretRefModel.Builder], SecretRefModel.Builder | SecretRefModel
            ],
            /,
        ) -> "Cinder.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRefModel.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            secretRef is optional: points to a secret object containing parameters used to connect
            to OpenStack.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRefModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRefModel.builder())
                if isinstance(output, SecretRefModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def volume_id(self, value: str, /) -> Self:
            """
            volumeID used to identify the volume in cinder.
            More info: https://examples.k8s.io/mysql-cinder-pd/README.md
            """
            return self._set("volume_id", value)

    class BuilderContext(BuilderContextBase["Cinder.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Cinder.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Cinder."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Cinder", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Cinder.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fsType is the filesystem type to mount.
    Must be a filesystem type supported by the host operating system.
    Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    More info: https://examples.k8s.io/mysql-cinder-pd/README.md
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly defaults to false (read/write). ReadOnly here will force
    the ReadOnly setting in VolumeMounts.
    More info: https://examples.k8s.io/mysql-cinder-pd/README.md
    """
    secret_ref: Annotated[Optional[SecretRefModel], Field(alias="secretRef")] = None
    """
    secretRef is optional: points to a secret object containing parameters used to connect
    to OpenStack.
    """
    volume_id: Annotated[str, Field(alias="volumeID")]
    """
    volumeID used to identify the volume in cinder.
    More info: https://examples.k8s.io/mysql-cinder-pd/README.md
    """


class Item(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Item"]:
            return Item

        def build(self) -> "Item":
            return Item(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key is the key to project.
            """
            return self._set("key", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            mode is Optional: mode bits used to set permissions on this file.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            path is the relative path of the file to map the key to.
            May not be an absolute path.
            May not contain the path element '..'.
            May not start with the string '..'.
            """
            return self._set("path", value)

    class BuilderContext(BuilderContextBase["Item.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Item.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Item."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Item", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Item.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key is the key to project.
    """
    mode: Optional[int] = None
    """
    mode is Optional: mode bits used to set permissions on this file.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    path is the relative path of the file to map the key to.
    May not be an absolute path.
    May not contain the path element '..'.
    May not start with the string '..'.
    """


class ConfigMapModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapModel"]:
            return ConfigMapModel

        def build(self) -> "ConfigMapModel":
            return ConfigMapModel(**self._attrs)

        def default_mode(self, value: Optional[int], /) -> Self:
            """
            defaultMode is optional: mode bits used to set permissions on created files by default.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            Defaults to 0644.
            Directories within the path are not affected by this setting.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("default_mode", value)

        @overload
        def items(self, value_or_callback: List[Item], /) -> "ConfigMapModel.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Item, Item.Builder]],
                GenericListBuilder[Item, Item.Builder] | List[Item],
            ],
            /,
        ) -> "ConfigMapModel.Builder": ...

        @overload
        def items(self, value_or_callback: Never = ...) -> ListBuilderContext[Item.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items if unspecified, each key-value pair in the Data field of the referenced
            ConfigMap will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the ConfigMap,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Item.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Item.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional specify whether the ConfigMap or its keys must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_mode: Annotated[Optional[int], Field(alias="defaultMode")] = None
    """
    defaultMode is optional: mode bits used to set permissions on created files by default.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    Defaults to 0644.
    Directories within the path are not affected by this setting.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    items: Optional[List[Item]] = None
    """
    items if unspecified, each key-value pair in the Data field of the referenced
    ConfigMap will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the ConfigMap,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    optional specify whether the ConfigMap or its keys must be defined
    """


class NodePublishSecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NodePublishSecretRef"]:
            return NodePublishSecretRef

        def build(self) -> "NodePublishSecretRef":
            return NodePublishSecretRef(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["NodePublishSecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NodePublishSecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NodePublishSecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NodePublishSecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NodePublishSecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """


class Csi(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Csi"]:
            return Csi

        def build(self) -> "Csi":
            return Csi(**self._attrs)

        def driver(self, value: str, /) -> Self:
            """
            driver is the name of the CSI driver that handles this volume.
            Consult with your admin for the correct name as registered in the cluster.
            """
            return self._set("driver", value)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType to mount. Ex. "ext4", "xfs", "ntfs".
            If not provided, the empty value is passed to the associated CSI driver
            which will determine the default filesystem to apply.
            """
            return self._set("fs_type", value)

        @overload
        def node_publish_secret_ref(
            self, value_or_callback: Optional[NodePublishSecretRef], /
        ) -> "Csi.Builder": ...

        @overload
        def node_publish_secret_ref(
            self,
            value_or_callback: Callable[
                [NodePublishSecretRef.Builder],
                NodePublishSecretRef.Builder | NodePublishSecretRef,
            ],
            /,
        ) -> "Csi.Builder": ...

        @overload
        def node_publish_secret_ref(
            self, value_or_callback: Never = ...
        ) -> "NodePublishSecretRef.BuilderContext": ...

        def node_publish_secret_ref(self, value_or_callback=None, /):
            """
            nodePublishSecretRef is a reference to the secret object containing
            sensitive information to pass to the CSI driver to complete the CSI
            NodePublishVolume and NodeUnpublishVolume calls.
            This field is optional, and  may be empty if no secret is required. If the
            secret object contains more than one secret, all secret references are passed.
            """
            if self._in_context and value_or_callback is None:
                context = NodePublishSecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "node_publish_secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NodePublishSecretRef.builder())
                if isinstance(output, NodePublishSecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("node_publish_secret_ref", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly specifies a read-only configuration for the volume.
            Defaults to false (read/write).
            """
            return self._set("read_only", value)

        def volume_attributes(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            volumeAttributes stores driver-specific properties that are passed to the CSI
            driver. Consult your driver's documentation for supported values.
            """
            return self._set("volume_attributes", value)

    class BuilderContext(BuilderContextBase["Csi.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Csi.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Csi."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Csi", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Csi.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    driver: str
    """
    driver is the name of the CSI driver that handles this volume.
    Consult with your admin for the correct name as registered in the cluster.
    """
    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fsType to mount. Ex. "ext4", "xfs", "ntfs".
    If not provided, the empty value is passed to the associated CSI driver
    which will determine the default filesystem to apply.
    """
    node_publish_secret_ref: Annotated[
        Optional[NodePublishSecretRef], Field(alias="nodePublishSecretRef")
    ] = None
    """
    nodePublishSecretRef is a reference to the secret object containing
    sensitive information to pass to the CSI driver to complete the CSI
    NodePublishVolume and NodeUnpublishVolume calls.
    This field is optional, and  may be empty if no secret is required. If the
    secret object contains more than one secret, all secret references are passed.
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly specifies a read-only configuration for the volume.
    Defaults to false (read/write).
    """
    volume_attributes: Annotated[Optional[Dict[str, str]], Field(alias="volumeAttributes")] = None
    """
    volumeAttributes stores driver-specific properties that are passed to the CSI
    driver. Consult your driver's documentation for supported values.
    """


class DivisorModel3(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel3":
            value = cast(int, self._value)
            return DivisorModel3(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel3.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel3."""
        return cls.BuilderContext()


class DivisorModel4(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel4":
            value = cast(str, self._value)
            return DivisorModel4(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel4.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel4."""
        return cls.BuilderContext()


class ItemModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ItemModel"]:
            return ItemModel

        def build(self) -> "ItemModel":
            return ItemModel(**self._attrs)

        @overload
        def field_ref(self, value_or_callback: Optional[FieldRef], /) -> "ItemModel.Builder": ...

        @overload
        def field_ref(
            self,
            value_or_callback: Callable[[FieldRef.Builder], FieldRef.Builder | FieldRef],
            /,
        ) -> "ItemModel.Builder": ...

        @overload
        def field_ref(self, value_or_callback: Never = ...) -> "FieldRef.BuilderContext": ...

        def field_ref(self, value_or_callback=None, /):
            """
            Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
            """
            if self._in_context and value_or_callback is None:
                context = FieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FieldRef.builder())
                if isinstance(output, FieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("field_ref", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            Optional: mode bits used to set permissions on this file, must be an octal value
            between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
            """
            return self._set("path", value)

        @overload
        def resource_field_ref(
            self, value_or_callback: Optional[ResourceFieldRef], /
        ) -> "ItemModel.Builder": ...

        @overload
        def resource_field_ref(
            self,
            value_or_callback: Callable[
                [ResourceFieldRef.Builder], ResourceFieldRef.Builder | ResourceFieldRef
            ],
            /,
        ) -> "ItemModel.Builder": ...

        @overload
        def resource_field_ref(
            self, value_or_callback: Never = ...
        ) -> "ResourceFieldRef.BuilderContext": ...

        def resource_field_ref(self, value_or_callback=None, /):
            """
            Selects a resource of the container: only resources limits and requests
            (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceFieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource_field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceFieldRef.builder())
                if isinstance(output, ResourceFieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_field_ref", value)

    class BuilderContext(BuilderContextBase["ItemModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ItemModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ItemModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ItemModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ItemModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    field_ref: Annotated[Optional[FieldRef], Field(alias="fieldRef")] = None
    """
    Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
    """
    mode: Optional[int] = None
    """
    Optional: mode bits used to set permissions on this file, must be an octal value
    between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    """
    resource_field_ref: Annotated[Optional[ResourceFieldRef], Field(alias="resourceFieldRef")] = (
        None
    )
    """
    Selects a resource of the container: only resources limits and requests
    (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    """


class DownwardApi(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DownwardApi"]:
            return DownwardApi

        def build(self) -> "DownwardApi":
            return DownwardApi(**self._attrs)

        def default_mode(self, value: Optional[int], /) -> Self:
            """
            Optional: mode bits to use on created files by default. Must be a
            Optional: mode bits used to set permissions on created files by default.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            Defaults to 0644.
            Directories within the path are not affected by this setting.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("default_mode", value)

        @overload
        def items(self, value_or_callback: List[ItemModel], /) -> "DownwardApi.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel, ItemModel.Builder]],
                GenericListBuilder[ItemModel, ItemModel.Builder] | List[ItemModel],
            ],
            /,
        ) -> "DownwardApi.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            Items is a list of downward API volume file
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

    class BuilderContext(BuilderContextBase["DownwardApi.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DownwardApi.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DownwardApi."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DownwardApi", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DownwardApi.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_mode: Annotated[Optional[int], Field(alias="defaultMode")] = None
    """
    Optional: mode bits to use on created files by default. Must be a
    Optional: mode bits used to set permissions on created files by default.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    Defaults to 0644.
    Directories within the path are not affected by this setting.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    items: Optional[List[ItemModel]] = None
    """
    Items is a list of downward API volume file
    """


class SizeLimitModel1(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def build(self) -> "SizeLimitModel1":
            value = cast(int, self._value)
            return SizeLimitModel1(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    sizeLimit is the total amount of local storage required for this EmptyDir volume.
    The size limit is also applicable for memory medium.
    The maximum usage on memory medium EmptyDir would be the minimum value between
    the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    The default is nil which means that the limit is undefined.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    """

    class BuilderContext(BuilderContextBase["SizeLimitModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SizeLimitModel1.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SizeLimitModel1."""
        return cls.BuilderContext()


class SizeLimitModel2(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def build(self) -> "SizeLimitModel2":
            value = cast(str, self._value)
            return SizeLimitModel2(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    sizeLimit is the total amount of local storage required for this EmptyDir volume.
    The size limit is also applicable for memory medium.
    The maximum usage on memory medium EmptyDir would be the minimum value between
    the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    The default is nil which means that the limit is undefined.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    """

    class BuilderContext(BuilderContextBase["SizeLimitModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SizeLimitModel2.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SizeLimitModel2."""
        return cls.BuilderContext()


class LimitsModel9(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel9":
            value = cast(int, self._value)
            return LimitsModel9(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel9.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel9.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel9."""
        return cls.BuilderContext()


class LimitsModel10(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel10":
            value = cast(str, self._value)
            return LimitsModel10(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel10.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel10.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel10."""
        return cls.BuilderContext()


class RequestsModel9(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel9":
            value = cast(int, self._value)
            return RequestsModel9(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel9.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel9.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel9."""
        return cls.BuilderContext()


class RequestsModel10(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel10":
            value = cast(str, self._value)
            return RequestsModel10(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel10.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel10.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel10."""
        return cls.BuilderContext()


class VolumeClaimTemplateModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VolumeClaimTemplateModel1"]:
            return VolumeClaimTemplateModel1

        def build(self) -> "VolumeClaimTemplateModel1":
            return VolumeClaimTemplateModel1(**self._attrs)

        def metadata(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            May contain labels and annotations that will be copied into the PVC
            when creating it. No other fields are allowed and will be rejected during
            validation.
            """
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Spec, /) -> "VolumeClaimTemplateModel1.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Callable[[Spec.Builder], Spec.Builder | Spec], /
        ) -> "VolumeClaimTemplateModel1.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "Spec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            """
            The specification for the PersistentVolumeClaim. The entire content is
            copied unchanged into the PVC that gets created from this
            template. The same fields as in a PersistentVolumeClaim
            are also valid here.
            """
            if self._in_context and value_or_callback is None:
                context = Spec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Spec.builder())
                if isinstance(output, Spec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["VolumeClaimTemplateModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VolumeClaimTemplateModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VolumeClaimTemplateModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VolumeClaimTemplateModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VolumeClaimTemplateModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    metadata: Optional[Dict[str, Any]] = None
    """
    May contain labels and annotations that will be copied into the PVC
    when creating it. No other fields are allowed and will be rejected during
    validation.
    """
    spec: Spec
    """
    The specification for the PersistentVolumeClaim. The entire content is
    copied unchanged into the PVC that gets created from this
    template. The same fields as in a PersistentVolumeClaim
    are also valid here.
    """


class Fc(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Fc"]:
            return Fc

        def build(self) -> "Fc":
            return Fc(**self._attrs)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is the filesystem type to mount.
            Must be a filesystem type supported by the host operating system.
            Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
            """
            return self._set("fs_type", value)

        def lun(self, value: Optional[int], /) -> Self:
            """
            lun is Optional: FC target lun number
            """
            return self._set("lun", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
            the ReadOnly setting in VolumeMounts.
            """
            return self._set("read_only", value)

        def target_ww_ns(self, value: Optional[List[str]], /) -> Self:
            """
            targetWWNs is Optional: FC target worldwide names (WWNs)
            """
            return self._set("target_ww_ns", value)

        def wwids(self, value: Optional[List[str]], /) -> Self:
            """
            wwids Optional: FC volume world wide identifiers (wwids)
            Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
            """
            return self._set("wwids", value)

    class BuilderContext(BuilderContextBase["Fc.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Fc.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Fc."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Fc", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Fc.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fsType is the filesystem type to mount.
    Must be a filesystem type supported by the host operating system.
    Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    """
    lun: Optional[int] = None
    """
    lun is Optional: FC target lun number
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
    the ReadOnly setting in VolumeMounts.
    """
    target_ww_ns: Annotated[Optional[List[str]], Field(alias="targetWWNs")] = None
    """
    targetWWNs is Optional: FC target worldwide names (WWNs)
    """
    wwids: Optional[List[str]] = None
    """
    wwids Optional: FC volume world wide identifiers (wwids)
    Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
    """


class FlexVolume(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FlexVolume"]:
            return FlexVolume

        def build(self) -> "FlexVolume":
            return FlexVolume(**self._attrs)

        def driver(self, value: str, /) -> Self:
            """
            driver is the name of the driver to use for this volume.
            """
            return self._set("driver", value)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is the filesystem type to mount.
            Must be a filesystem type supported by the host operating system.
            Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
            """
            return self._set("fs_type", value)

        def options(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            options is Optional: this field holds extra command options if any.
            """
            return self._set("options", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly is Optional: defaults to false (read/write). ReadOnly here will force
            the ReadOnly setting in VolumeMounts.
            """
            return self._set("read_only", value)

        @overload
        def secret_ref(
            self, value_or_callback: Optional[SecretRefModel], /
        ) -> "FlexVolume.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[
                [SecretRefModel.Builder], SecretRefModel.Builder | SecretRefModel
            ],
            /,
        ) -> "FlexVolume.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRefModel.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            secretRef is Optional: secretRef is reference to the secret object containing
            sensitive information to pass to the plugin scripts. This may be
            empty if no secret object is specified. If the secret object
            contains more than one secret, all secrets are passed to the plugin
            scripts.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRefModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRefModel.builder())
                if isinstance(output, SecretRefModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

    class BuilderContext(BuilderContextBase["FlexVolume.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FlexVolume.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FlexVolume."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FlexVolume", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FlexVolume.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    driver: str
    """
    driver is the name of the driver to use for this volume.
    """
    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fsType is the filesystem type to mount.
    Must be a filesystem type supported by the host operating system.
    Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
    """
    options: Optional[Dict[str, str]] = None
    """
    options is Optional: this field holds extra command options if any.
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly is Optional: defaults to false (read/write). ReadOnly here will force
    the ReadOnly setting in VolumeMounts.
    """
    secret_ref: Annotated[Optional[SecretRefModel], Field(alias="secretRef")] = None
    """
    secretRef is Optional: secretRef is reference to the secret object containing
    sensitive information to pass to the plugin scripts. This may be
    empty if no secret object is specified. If the secret object
    contains more than one secret, all secrets are passed to the plugin
    scripts.
    """


class Flocker(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Flocker"]:
            return Flocker

        def build(self) -> "Flocker":
            return Flocker(**self._attrs)

        def dataset_name(self, value: Optional[str], /) -> Self:
            """
            datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
            should be considered as deprecated
            """
            return self._set("dataset_name", value)

        def dataset_uuid(self, value: Optional[str], /) -> Self:
            """
            datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
            """
            return self._set("dataset_uuid", value)

    class BuilderContext(BuilderContextBase["Flocker.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Flocker.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Flocker."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Flocker", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Flocker.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    dataset_name: Annotated[Optional[str], Field(alias="datasetName")] = None
    """
    datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
    should be considered as deprecated
    """
    dataset_uuid: Annotated[Optional[str], Field(alias="datasetUUID")] = None
    """
    datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
    """


class GcePersistentDisk(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GcePersistentDisk"]:
            return GcePersistentDisk

        def build(self) -> "GcePersistentDisk":
            return GcePersistentDisk(**self._attrs)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is filesystem type of the volume that you want to mount.
            Tip: Ensure that the filesystem type is supported by the host operating system.
            Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
            """
            return self._set("fs_type", value)

        def partition(self, value: Optional[int], /) -> Self:
            """
            partition is the partition in the volume that you want to mount.
            If omitted, the default is to mount by volume name.
            Examples: For volume /dev/sda1, you specify the partition as "1".
            Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
            More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
            """
            return self._set("partition", value)

        def pd_name(self, value: str, /) -> Self:
            """
            pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
            """
            return self._set("pd_name", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly here will force the ReadOnly setting in VolumeMounts.
            Defaults to false.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
            """
            return self._set("read_only", value)

    class BuilderContext(BuilderContextBase["GcePersistentDisk.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GcePersistentDisk.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GcePersistentDisk."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GcePersistentDisk", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GcePersistentDisk.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fsType is filesystem type of the volume that you want to mount.
    Tip: Ensure that the filesystem type is supported by the host operating system.
    Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
    """
    partition: Optional[int] = None
    """
    partition is the partition in the volume that you want to mount.
    If omitted, the default is to mount by volume name.
    Examples: For volume /dev/sda1, you specify the partition as "1".
    Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
    More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
    """
    pd_name: Annotated[str, Field(alias="pdName")]
    """
    pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly here will force the ReadOnly setting in VolumeMounts.
    Defaults to false.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
    """


class GitRepo(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GitRepo"]:
            return GitRepo

        def build(self) -> "GitRepo":
            return GitRepo(**self._attrs)

        def directory(self, value: Optional[str], /) -> Self:
            """
            directory is the target directory name.
            Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
            git repository.  Otherwise, if specified, the volume will contain the git repository in
            the subdirectory with the given name.
            """
            return self._set("directory", value)

        def repository(self, value: str, /) -> Self:
            """
            repository is the URL
            """
            return self._set("repository", value)

        def revision(self, value: Optional[str], /) -> Self:
            """
            revision is the commit hash for the specified revision.
            """
            return self._set("revision", value)

    class BuilderContext(BuilderContextBase["GitRepo.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GitRepo.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GitRepo."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GitRepo", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GitRepo.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    directory: Optional[str] = None
    """
    directory is the target directory name.
    Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
    git repository.  Otherwise, if specified, the volume will contain the git repository in
    the subdirectory with the given name.
    """
    repository: str
    """
    repository is the URL
    """
    revision: Optional[str] = None
    """
    revision is the commit hash for the specified revision.
    """


class Glusterfs(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Glusterfs"]:
            return Glusterfs

        def build(self) -> "Glusterfs":
            return Glusterfs(**self._attrs)

        def endpoints(self, value: str, /) -> Self:
            """
            endpoints is the endpoint name that details Glusterfs topology.
            More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
            """
            return self._set("endpoints", value)

        def path(self, value: str, /) -> Self:
            """
            path is the Glusterfs volume path.
            More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
            """
            return self._set("path", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
            Defaults to false.
            More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
            """
            return self._set("read_only", value)

    class BuilderContext(BuilderContextBase["Glusterfs.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Glusterfs.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Glusterfs."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Glusterfs", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Glusterfs.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    endpoints: str
    """
    endpoints is the endpoint name that details Glusterfs topology.
    More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
    """
    path: str
    """
    path is the Glusterfs volume path.
    More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
    Defaults to false.
    More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
    """


class HostPath(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HostPath"]:
            return HostPath

        def build(self) -> "HostPath":
            return HostPath(**self._attrs)

        def path(self, value: str, /) -> Self:
            """
            path of the directory on the host.
            If the path is a symlink, it will follow the link to the real path.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
            """
            return self._set("path", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            type for HostPath Volume
            Defaults to ""
            More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["HostPath.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HostPath.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HostPath."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HostPath", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HostPath.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    path: str
    """
    path of the directory on the host.
    If the path is a symlink, it will follow the link to the real path.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
    """
    type: Optional[str] = None
    """
    type for HostPath Volume
    Defaults to ""
    More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
    """


class Image(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Image"]:
            return Image

        def build(self) -> "Image":
            return Image(**self._attrs)

        def pull_policy(self, value: Optional[str], /) -> Self:
            """
            Policy for pulling OCI objects. Possible values are:
            Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
            Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
            IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
            Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
            """
            return self._set("pull_policy", value)

        def reference(self, value: Optional[str], /) -> Self:
            """
            Required: Image or artifact reference to be used.
            Behaves in the same way as pod.spec.containers[*].image.
            Pull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.
            More info: https://kubernetes.io/docs/concepts/containers/images
            This field is optional to allow higher level config management to default or override
            container images in workload controllers like Deployments and StatefulSets.
            """
            return self._set("reference", value)

    class BuilderContext(BuilderContextBase["Image.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Image.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Image."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Image", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Image.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    pull_policy: Annotated[Optional[str], Field(alias="pullPolicy")] = None
    """
    Policy for pulling OCI objects. Possible values are:
    Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
    Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
    IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
    Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    """
    reference: Optional[str] = None
    """
    Required: Image or artifact reference to be used.
    Behaves in the same way as pod.spec.containers[*].image.
    Pull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.
    More info: https://kubernetes.io/docs/concepts/containers/images
    This field is optional to allow higher level config management to default or override
    container images in workload controllers like Deployments and StatefulSets.
    """


class Iscsi(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Iscsi"]:
            return Iscsi

        def build(self) -> "Iscsi":
            return Iscsi(**self._attrs)

        def chap_auth_discovery(self, value: Optional[bool], /) -> Self:
            """
            chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
            """
            return self._set("chap_auth_discovery", value)

        def chap_auth_session(self, value: Optional[bool], /) -> Self:
            """
            chapAuthSession defines whether support iSCSI Session CHAP authentication
            """
            return self._set("chap_auth_session", value)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is the filesystem type of the volume that you want to mount.
            Tip: Ensure that the filesystem type is supported by the host operating system.
            Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
            """
            return self._set("fs_type", value)

        def initiator_name(self, value: Optional[str], /) -> Self:
            """
            initiatorName is the custom iSCSI Initiator Name.
            If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
            <target portal>:<volume name> will be created for the connection.
            """
            return self._set("initiator_name", value)

        def iqn(self, value: str, /) -> Self:
            """
            iqn is the target iSCSI Qualified Name.
            """
            return self._set("iqn", value)

        def iscsi_interface(self, value: Optional[str], /) -> Self:
            """
            iscsiInterface is the interface Name that uses an iSCSI transport.
            Defaults to 'default' (tcp).
            """
            return self._set("iscsi_interface", value)

        def lun(self, value: int, /) -> Self:
            """
            lun represents iSCSI Target Lun number.
            """
            return self._set("lun", value)

        def portals(self, value: Optional[List[str]], /) -> Self:
            """
            portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
            is other than default (typically TCP ports 860 and 3260).
            """
            return self._set("portals", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly here will force the ReadOnly setting in VolumeMounts.
            Defaults to false.
            """
            return self._set("read_only", value)

        @overload
        def secret_ref(self, value_or_callback: Optional[SecretRefModel], /) -> "Iscsi.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[
                [SecretRefModel.Builder], SecretRefModel.Builder | SecretRefModel
            ],
            /,
        ) -> "Iscsi.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRefModel.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            secretRef is the CHAP Secret for iSCSI target and initiator authentication
            """
            if self._in_context and value_or_callback is None:
                context = SecretRefModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRefModel.builder())
                if isinstance(output, SecretRefModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def target_portal(self, value: str, /) -> Self:
            """
            targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
            is other than default (typically TCP ports 860 and 3260).
            """
            return self._set("target_portal", value)

    class BuilderContext(BuilderContextBase["Iscsi.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Iscsi.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Iscsi."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Iscsi", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Iscsi.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    chap_auth_discovery: Annotated[Optional[bool], Field(alias="chapAuthDiscovery")] = None
    """
    chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
    """
    chap_auth_session: Annotated[Optional[bool], Field(alias="chapAuthSession")] = None
    """
    chapAuthSession defines whether support iSCSI Session CHAP authentication
    """
    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fsType is the filesystem type of the volume that you want to mount.
    Tip: Ensure that the filesystem type is supported by the host operating system.
    Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
    """
    initiator_name: Annotated[Optional[str], Field(alias="initiatorName")] = None
    """
    initiatorName is the custom iSCSI Initiator Name.
    If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
    <target portal>:<volume name> will be created for the connection.
    """
    iqn: str
    """
    iqn is the target iSCSI Qualified Name.
    """
    iscsi_interface: Annotated[Optional[str], Field(alias="iscsiInterface")] = "default"
    """
    iscsiInterface is the interface Name that uses an iSCSI transport.
    Defaults to 'default' (tcp).
    """
    lun: int
    """
    lun represents iSCSI Target Lun number.
    """
    portals: Optional[List[str]] = None
    """
    portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
    is other than default (typically TCP ports 860 and 3260).
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly here will force the ReadOnly setting in VolumeMounts.
    Defaults to false.
    """
    secret_ref: Annotated[Optional[SecretRefModel], Field(alias="secretRef")] = None
    """
    secretRef is the CHAP Secret for iSCSI target and initiator authentication
    """
    target_portal: Annotated[str, Field(alias="targetPortal")]
    """
    targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
    is other than default (typically TCP ports 860 and 3260).
    """


class Nfs(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Nfs"]:
            return Nfs

        def build(self) -> "Nfs":
            return Nfs(**self._attrs)

        def path(self, value: str, /) -> Self:
            """
            path that is exported by the NFS server.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
            """
            return self._set("path", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly here will force the NFS export to be mounted with read-only permissions.
            Defaults to false.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
            """
            return self._set("read_only", value)

        def server(self, value: str, /) -> Self:
            """
            server is the hostname or IP address of the NFS server.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
            """
            return self._set("server", value)

    class BuilderContext(BuilderContextBase["Nfs.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Nfs.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Nfs."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Nfs", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Nfs.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    path: str
    """
    path that is exported by the NFS server.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly here will force the NFS export to be mounted with read-only permissions.
    Defaults to false.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
    """
    server: str
    """
    server is the hostname or IP address of the NFS server.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
    """


class PersistentVolumeClaim(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PersistentVolumeClaim"]:
            return PersistentVolumeClaim

        def build(self) -> "PersistentVolumeClaim":
            return PersistentVolumeClaim(**self._attrs)

        def claim_name(self, value: str, /) -> Self:
            """
            claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
            More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
            """
            return self._set("claim_name", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly Will force the ReadOnly setting in VolumeMounts.
            Default false.
            """
            return self._set("read_only", value)

    class BuilderContext(BuilderContextBase["PersistentVolumeClaim.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PersistentVolumeClaim.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PersistentVolumeClaim."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PersistentVolumeClaim", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PersistentVolumeClaim.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    claim_name: Annotated[str, Field(alias="claimName")]
    """
    claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
    More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly Will force the ReadOnly setting in VolumeMounts.
    Default false.
    """


class PhotonPersistentDisk(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PhotonPersistentDisk"]:
            return PhotonPersistentDisk

        def build(self) -> "PhotonPersistentDisk":
            return PhotonPersistentDisk(**self._attrs)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is the filesystem type to mount.
            Must be a filesystem type supported by the host operating system.
            Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
            """
            return self._set("fs_type", value)

        def pd_id(self, value: str, /) -> Self:
            """
            pdID is the ID that identifies Photon Controller persistent disk
            """
            return self._set("pd_id", value)

    class BuilderContext(BuilderContextBase["PhotonPersistentDisk.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PhotonPersistentDisk.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PhotonPersistentDisk."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PhotonPersistentDisk", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PhotonPersistentDisk.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fsType is the filesystem type to mount.
    Must be a filesystem type supported by the host operating system.
    Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    """
    pd_id: Annotated[str, Field(alias="pdID")]
    """
    pdID is the ID that identifies Photon Controller persistent disk
    """


class PortworxVolume(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PortworxVolume"]:
            return PortworxVolume

        def build(self) -> "PortworxVolume":
            return PortworxVolume(**self._attrs)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fSType represents the filesystem type to mount
            Must be a filesystem type supported by the host operating system.
            Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
            """
            return self._set("fs_type", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly defaults to false (read/write). ReadOnly here will force
            the ReadOnly setting in VolumeMounts.
            """
            return self._set("read_only", value)

        def volume_id(self, value: str, /) -> Self:
            """
            volumeID uniquely identifies a Portworx volume
            """
            return self._set("volume_id", value)

    class BuilderContext(BuilderContextBase["PortworxVolume.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PortworxVolume.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PortworxVolume."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PortworxVolume", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PortworxVolume.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fSType represents the filesystem type to mount
    Must be a filesystem type supported by the host operating system.
    Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly defaults to false (read/write). ReadOnly here will force
    the ReadOnly setting in VolumeMounts.
    """
    volume_id: Annotated[str, Field(alias="volumeID")]
    """
    volumeID uniquely identifies a Portworx volume
    """


class ClusterTrustBundle(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterTrustBundle"]:
            return ClusterTrustBundle

        def build(self) -> "ClusterTrustBundle":
            return ClusterTrustBundle(**self._attrs)

        @overload
        def label_selector(
            self, value_or_callback: Optional[LabelSelector], /
        ) -> "ClusterTrustBundle.Builder": ...

        @overload
        def label_selector(
            self,
            value_or_callback: Callable[
                [LabelSelector.Builder], LabelSelector.Builder | LabelSelector
            ],
            /,
        ) -> "ClusterTrustBundle.Builder": ...

        @overload
        def label_selector(
            self, value_or_callback: Never = ...
        ) -> "LabelSelector.BuilderContext": ...

        def label_selector(self, value_or_callback=None, /):
            """
            Select all ClusterTrustBundles that match this label selector.  Only has
            effect if signerName is set.  Mutually-exclusive with name.  If unset,
            interpreted as "match nothing".  If set but empty, interpreted as "match
            everything".
            """
            if self._in_context and value_or_callback is None:
                context = LabelSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "label_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LabelSelector.builder())
                if isinstance(output, LabelSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("label_selector", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Select a single ClusterTrustBundle by object name.  Mutually-exclusive
            with signerName and labelSelector.
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            If true, don't block pod startup if the referenced ClusterTrustBundle(s)
            aren't available.  If using name, then the named ClusterTrustBundle is
            allowed not to exist.  If using signerName, then the combination of
            signerName and labelSelector is allowed to match zero
            ClusterTrustBundles.
            """
            return self._set("optional", value)

        def path(self, value: str, /) -> Self:
            """
            Relative path from the volume root to write the bundle.
            """
            return self._set("path", value)

        def signer_name(self, value: Optional[str], /) -> Self:
            """
            Select all ClusterTrustBundles that match this signer name.
            Mutually-exclusive with name.  The contents of all selected
            ClusterTrustBundles will be unified and deduplicated.
            """
            return self._set("signer_name", value)

    class BuilderContext(BuilderContextBase["ClusterTrustBundle.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterTrustBundle.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterTrustBundle."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterTrustBundle", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterTrustBundle.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    label_selector: Annotated[Optional[LabelSelector], Field(alias="labelSelector")] = None
    """
    Select all ClusterTrustBundles that match this label selector.  Only has
    effect if signerName is set.  Mutually-exclusive with name.  If unset,
    interpreted as "match nothing".  If set but empty, interpreted as "match
    everything".
    """
    name: Optional[str] = None
    """
    Select a single ClusterTrustBundle by object name.  Mutually-exclusive
    with signerName and labelSelector.
    """
    optional: Optional[bool] = None
    """
    If true, don't block pod startup if the referenced ClusterTrustBundle(s)
    aren't available.  If using name, then the named ClusterTrustBundle is
    allowed not to exist.  If using signerName, then the combination of
    signerName and labelSelector is allowed to match zero
    ClusterTrustBundles.
    """
    path: str
    """
    Relative path from the volume root to write the bundle.
    """
    signer_name: Annotated[Optional[str], Field(alias="signerName")] = None
    """
    Select all ClusterTrustBundles that match this signer name.
    Mutually-exclusive with name.  The contents of all selected
    ClusterTrustBundles will be unified and deduplicated.
    """


class ItemModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ItemModel1"]:
            return ItemModel1

        def build(self) -> "ItemModel1":
            return ItemModel1(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key is the key to project.
            """
            return self._set("key", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            mode is Optional: mode bits used to set permissions on this file.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            path is the relative path of the file to map the key to.
            May not be an absolute path.
            May not contain the path element '..'.
            May not start with the string '..'.
            """
            return self._set("path", value)

    class BuilderContext(BuilderContextBase["ItemModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ItemModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ItemModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ItemModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ItemModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key is the key to project.
    """
    mode: Optional[int] = None
    """
    mode is Optional: mode bits used to set permissions on this file.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    path is the relative path of the file to map the key to.
    May not be an absolute path.
    May not contain the path element '..'.
    May not start with the string '..'.
    """


class ConfigMapModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapModel1"]:
            return ConfigMapModel1

        def build(self) -> "ConfigMapModel1":
            return ConfigMapModel1(**self._attrs)

        @overload
        def items(self, value_or_callback: List[ItemModel1], /) -> "ConfigMapModel1.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel1, ItemModel1.Builder]],
                GenericListBuilder[ItemModel1, ItemModel1.Builder] | List[ItemModel1],
            ],
            /,
        ) -> "ConfigMapModel1.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel1.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items if unspecified, each key-value pair in the Data field of the referenced
            ConfigMap will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the ConfigMap,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel1.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel1.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional specify whether the ConfigMap or its keys must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    items: Optional[List[ItemModel1]] = None
    """
    items if unspecified, each key-value pair in the Data field of the referenced
    ConfigMap will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the ConfigMap,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    optional specify whether the ConfigMap or its keys must be defined
    """


class DivisorModel5(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel5":
            value = cast(int, self._value)
            return DivisorModel5(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel5.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel5."""
        return cls.BuilderContext()


class DivisorModel6(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel6":
            value = cast(str, self._value)
            return DivisorModel6(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel6.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel6.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel6."""
        return cls.BuilderContext()


class ItemModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ItemModel2"]:
            return ItemModel2

        def build(self) -> "ItemModel2":
            return ItemModel2(**self._attrs)

        @overload
        def field_ref(self, value_or_callback: Optional[FieldRef], /) -> "ItemModel2.Builder": ...

        @overload
        def field_ref(
            self,
            value_or_callback: Callable[[FieldRef.Builder], FieldRef.Builder | FieldRef],
            /,
        ) -> "ItemModel2.Builder": ...

        @overload
        def field_ref(self, value_or_callback: Never = ...) -> "FieldRef.BuilderContext": ...

        def field_ref(self, value_or_callback=None, /):
            """
            Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
            """
            if self._in_context and value_or_callback is None:
                context = FieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FieldRef.builder())
                if isinstance(output, FieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("field_ref", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            Optional: mode bits used to set permissions on this file, must be an octal value
            between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
            """
            return self._set("path", value)

        @overload
        def resource_field_ref(
            self, value_or_callback: Optional[ResourceFieldRef], /
        ) -> "ItemModel2.Builder": ...

        @overload
        def resource_field_ref(
            self,
            value_or_callback: Callable[
                [ResourceFieldRef.Builder], ResourceFieldRef.Builder | ResourceFieldRef
            ],
            /,
        ) -> "ItemModel2.Builder": ...

        @overload
        def resource_field_ref(
            self, value_or_callback: Never = ...
        ) -> "ResourceFieldRef.BuilderContext": ...

        def resource_field_ref(self, value_or_callback=None, /):
            """
            Selects a resource of the container: only resources limits and requests
            (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceFieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource_field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceFieldRef.builder())
                if isinstance(output, ResourceFieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_field_ref", value)

    class BuilderContext(BuilderContextBase["ItemModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ItemModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ItemModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ItemModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ItemModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    field_ref: Annotated[Optional[FieldRef], Field(alias="fieldRef")] = None
    """
    Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
    """
    mode: Optional[int] = None
    """
    Optional: mode bits used to set permissions on this file, must be an octal value
    between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    """
    resource_field_ref: Annotated[Optional[ResourceFieldRef], Field(alias="resourceFieldRef")] = (
        None
    )
    """
    Selects a resource of the container: only resources limits and requests
    (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    """


class DownwardApiModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DownwardApiModel"]:
            return DownwardApiModel

        def build(self) -> "DownwardApiModel":
            return DownwardApiModel(**self._attrs)

        @overload
        def items(self, value_or_callback: List[ItemModel2], /) -> "DownwardApiModel.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel2, ItemModel2.Builder]],
                GenericListBuilder[ItemModel2, ItemModel2.Builder] | List[ItemModel2],
            ],
            /,
        ) -> "DownwardApiModel.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel2.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            Items is a list of DownwardAPIVolume file
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel2.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel2.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

    class BuilderContext(BuilderContextBase["DownwardApiModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DownwardApiModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DownwardApiModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DownwardApiModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DownwardApiModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    items: Optional[List[ItemModel2]] = None
    """
    Items is a list of DownwardAPIVolume file
    """


class ItemModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ItemModel3"]:
            return ItemModel3

        def build(self) -> "ItemModel3":
            return ItemModel3(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key is the key to project.
            """
            return self._set("key", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            mode is Optional: mode bits used to set permissions on this file.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            path is the relative path of the file to map the key to.
            May not be an absolute path.
            May not contain the path element '..'.
            May not start with the string '..'.
            """
            return self._set("path", value)

    class BuilderContext(BuilderContextBase["ItemModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ItemModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ItemModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ItemModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ItemModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key is the key to project.
    """
    mode: Optional[int] = None
    """
    mode is Optional: mode bits used to set permissions on this file.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    path is the relative path of the file to map the key to.
    May not be an absolute path.
    May not contain the path element '..'.
    May not start with the string '..'.
    """


class SecretModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretModel"]:
            return SecretModel

        def build(self) -> "SecretModel":
            return SecretModel(**self._attrs)

        @overload
        def items(self, value_or_callback: List[ItemModel3], /) -> "SecretModel.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel3, ItemModel3.Builder]],
                GenericListBuilder[ItemModel3, ItemModel3.Builder] | List[ItemModel3],
            ],
            /,
        ) -> "SecretModel.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel3.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items if unspecified, each key-value pair in the Data field of the referenced
            Secret will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the Secret,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel3.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel3.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional field specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["SecretModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    items: Optional[List[ItemModel3]] = None
    """
    items if unspecified, each key-value pair in the Data field of the referenced
    Secret will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the Secret,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    optional field specify whether the Secret or its key must be defined
    """


class ServiceAccountToken(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceAccountToken"]:
            return ServiceAccountToken

        def build(self) -> "ServiceAccountToken":
            return ServiceAccountToken(**self._attrs)

        def audience(self, value: Optional[str], /) -> Self:
            """
            audience is the intended audience of the token. A recipient of a token
            must identify itself with an identifier specified in the audience of the
            token, and otherwise should reject the token. The audience defaults to the
            identifier of the apiserver.
            """
            return self._set("audience", value)

        def expiration_seconds(self, value: Optional[int], /) -> Self:
            """
            expirationSeconds is the requested duration of validity of the service
            account token. As the token approaches expiration, the kubelet volume
            plugin will proactively rotate the service account token. The kubelet will
            start trying to rotate the token if the token is older than 80 percent of
            its time to live or if the token is older than 24 hours.Defaults to 1 hour
            and must be at least 10 minutes.
            """
            return self._set("expiration_seconds", value)

        def path(self, value: str, /) -> Self:
            """
            path is the path relative to the mount point of the file to project the
            token into.
            """
            return self._set("path", value)

    class BuilderContext(BuilderContextBase["ServiceAccountToken.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceAccountToken.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceAccountToken."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceAccountToken", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceAccountToken.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    audience: Optional[str] = None
    """
    audience is the intended audience of the token. A recipient of a token
    must identify itself with an identifier specified in the audience of the
    token, and otherwise should reject the token. The audience defaults to the
    identifier of the apiserver.
    """
    expiration_seconds: Annotated[Optional[int], Field(alias="expirationSeconds")] = None
    """
    expirationSeconds is the requested duration of validity of the service
    account token. As the token approaches expiration, the kubelet volume
    plugin will proactively rotate the service account token. The kubelet will
    start trying to rotate the token if the token is older than 80 percent of
    its time to live or if the token is older than 24 hours.Defaults to 1 hour
    and must be at least 10 minutes.
    """
    path: str
    """
    path is the path relative to the mount point of the file to project the
    token into.
    """


class Source(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Source"]:
            return Source

        def build(self) -> "Source":
            return Source(**self._attrs)

        @overload
        def cluster_trust_bundle(
            self, value_or_callback: Optional[ClusterTrustBundle], /
        ) -> "Source.Builder": ...

        @overload
        def cluster_trust_bundle(
            self,
            value_or_callback: Callable[
                [ClusterTrustBundle.Builder],
                ClusterTrustBundle.Builder | ClusterTrustBundle,
            ],
            /,
        ) -> "Source.Builder": ...

        @overload
        def cluster_trust_bundle(
            self, value_or_callback: Never = ...
        ) -> "ClusterTrustBundle.BuilderContext": ...

        def cluster_trust_bundle(self, value_or_callback=None, /):
            """
            ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
            of ClusterTrustBundle objects in an auto-updating file.

            Alpha, gated by the ClusterTrustBundleProjection feature gate.

            ClusterTrustBundle objects can either be selected by name, or by the
            combination of signer name and a label selector.

            Kubelet performs aggressive normalization of the PEM contents written
            into the pod filesystem.  Esoteric PEM features such as inter-block
            comments and block headers are stripped.  Certificates are deduplicated.
            The ordering of certificates within the file is arbitrary, and Kubelet
            may change the order over time.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterTrustBundle.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_trust_bundle"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterTrustBundle.builder())
                if isinstance(output, ClusterTrustBundle.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_trust_bundle", value)

        @overload
        def config_map(
            self, value_or_callback: Optional[ConfigMapModel1], /
        ) -> "Source.Builder": ...

        @overload
        def config_map(
            self,
            value_or_callback: Callable[
                [ConfigMapModel1.Builder], ConfigMapModel1.Builder | ConfigMapModel1
            ],
            /,
        ) -> "Source.Builder": ...

        @overload
        def config_map(
            self, value_or_callback: Never = ...
        ) -> "ConfigMapModel1.BuilderContext": ...

        def config_map(self, value_or_callback=None, /):
            """
            configMap information about the configMap data to project
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMapModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMapModel1.builder())
                if isinstance(output, ConfigMapModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map", value)

        @overload
        def downward_api(
            self, value_or_callback: Optional[DownwardApiModel], /
        ) -> "Source.Builder": ...

        @overload
        def downward_api(
            self,
            value_or_callback: Callable[
                [DownwardApiModel.Builder], DownwardApiModel.Builder | DownwardApiModel
            ],
            /,
        ) -> "Source.Builder": ...

        @overload
        def downward_api(
            self, value_or_callback: Never = ...
        ) -> "DownwardApiModel.BuilderContext": ...

        def downward_api(self, value_or_callback=None, /):
            """
            downwardAPI information about the downwardAPI data to project
            """
            if self._in_context and value_or_callback is None:
                context = DownwardApiModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "downward_api"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DownwardApiModel.builder())
                if isinstance(output, DownwardApiModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("downward_api", value)

        @overload
        def secret(self, value_or_callback: Optional[SecretModel], /) -> "Source.Builder": ...

        @overload
        def secret(
            self,
            value_or_callback: Callable[[SecretModel.Builder], SecretModel.Builder | SecretModel],
            /,
        ) -> "Source.Builder": ...

        @overload
        def secret(self, value_or_callback: Never = ...) -> "SecretModel.BuilderContext": ...

        def secret(self, value_or_callback=None, /):
            """
            secret information about the secret data to project
            """
            if self._in_context and value_or_callback is None:
                context = SecretModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretModel.builder())
                if isinstance(output, SecretModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret", value)

        @overload
        def service_account_token(
            self, value_or_callback: Optional[ServiceAccountToken], /
        ) -> "Source.Builder": ...

        @overload
        def service_account_token(
            self,
            value_or_callback: Callable[
                [ServiceAccountToken.Builder],
                ServiceAccountToken.Builder | ServiceAccountToken,
            ],
            /,
        ) -> "Source.Builder": ...

        @overload
        def service_account_token(
            self, value_or_callback: Never = ...
        ) -> "ServiceAccountToken.BuilderContext": ...

        def service_account_token(self, value_or_callback=None, /):
            """
            serviceAccountToken is information about the serviceAccountToken data to project
            """
            if self._in_context and value_or_callback is None:
                context = ServiceAccountToken.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_account_token"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceAccountToken.builder())
                if isinstance(output, ServiceAccountToken.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_account_token", value)

    class BuilderContext(BuilderContextBase["Source.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Source.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Source."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Source", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Source.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_trust_bundle: Annotated[
        Optional[ClusterTrustBundle], Field(alias="clusterTrustBundle")
    ] = None
    """
    ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
    of ClusterTrustBundle objects in an auto-updating file.

    Alpha, gated by the ClusterTrustBundleProjection feature gate.

    ClusterTrustBundle objects can either be selected by name, or by the
    combination of signer name and a label selector.

    Kubelet performs aggressive normalization of the PEM contents written
    into the pod filesystem.  Esoteric PEM features such as inter-block
    comments and block headers are stripped.  Certificates are deduplicated.
    The ordering of certificates within the file is arbitrary, and Kubelet
    may change the order over time.
    """
    config_map: Annotated[Optional[ConfigMapModel1], Field(alias="configMap")] = None
    """
    configMap information about the configMap data to project
    """
    downward_api: Annotated[Optional[DownwardApiModel], Field(alias="downwardAPI")] = None
    """
    downwardAPI information about the downwardAPI data to project
    """
    secret: Optional[SecretModel] = None
    """
    secret information about the secret data to project
    """
    service_account_token: Annotated[
        Optional[ServiceAccountToken], Field(alias="serviceAccountToken")
    ] = None
    """
    serviceAccountToken is information about the serviceAccountToken data to project
    """


class Projected(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Projected"]:
            return Projected

        def build(self) -> "Projected":
            return Projected(**self._attrs)

        def default_mode(self, value: Optional[int], /) -> Self:
            """
            defaultMode are the mode bits used to set permissions on created files by default.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            Directories within the path are not affected by this setting.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("default_mode", value)

        @overload
        def sources(self, value_or_callback: List[Source], /) -> "Projected.Builder": ...

        @overload
        def sources(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Source, Source.Builder]],
                GenericListBuilder[Source, Source.Builder] | List[Source],
            ],
            /,
        ) -> "Projected.Builder": ...

        @overload
        def sources(self, value_or_callback: Never = ...) -> ListBuilderContext[Source.Builder]: ...

        def sources(self, value_or_callback=None, /):
            """
            sources is the list of volume projections. Each entry in this list
            handles one source.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Source.Builder]()
                context._parent_builder = self
                context._field_name = "sources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Source.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("sources", value)

    class BuilderContext(BuilderContextBase["Projected.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Projected.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Projected."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Projected", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Projected.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_mode: Annotated[Optional[int], Field(alias="defaultMode")] = None
    """
    defaultMode are the mode bits used to set permissions on created files by default.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    Directories within the path are not affected by this setting.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    sources: Optional[List[Source]] = None
    """
    sources is the list of volume projections. Each entry in this list
    handles one source.
    """


class Quobyte(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Quobyte"]:
            return Quobyte

        def build(self) -> "Quobyte":
            return Quobyte(**self._attrs)

        def group(self, value: Optional[str], /) -> Self:
            """
            group to map volume access to
            Default is no group
            """
            return self._set("group", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly here will force the Quobyte volume to be mounted with read-only permissions.
            Defaults to false.
            """
            return self._set("read_only", value)

        def registry(self, value: str, /) -> Self:
            """
            registry represents a single or multiple Quobyte Registry services
            specified as a string as host:port pair (multiple entries are separated with commas)
            which acts as the central registry for volumes
            """
            return self._set("registry", value)

        def tenant(self, value: Optional[str], /) -> Self:
            """
            tenant owning the given Quobyte volume in the Backend
            Used with dynamically provisioned Quobyte volumes, value is set by the plugin
            """
            return self._set("tenant", value)

        def user(self, value: Optional[str], /) -> Self:
            """
            user to map volume access to
            Defaults to serivceaccount user
            """
            return self._set("user", value)

        def volume(self, value: str, /) -> Self:
            """
            volume is a string that references an already created Quobyte volume by name.
            """
            return self._set("volume", value)

    class BuilderContext(BuilderContextBase["Quobyte.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Quobyte.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Quobyte."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Quobyte", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Quobyte.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    group: Optional[str] = None
    """
    group to map volume access to
    Default is no group
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly here will force the Quobyte volume to be mounted with read-only permissions.
    Defaults to false.
    """
    registry: str
    """
    registry represents a single or multiple Quobyte Registry services
    specified as a string as host:port pair (multiple entries are separated with commas)
    which acts as the central registry for volumes
    """
    tenant: Optional[str] = None
    """
    tenant owning the given Quobyte volume in the Backend
    Used with dynamically provisioned Quobyte volumes, value is set by the plugin
    """
    user: Optional[str] = None
    """
    user to map volume access to
    Defaults to serivceaccount user
    """
    volume: str
    """
    volume is a string that references an already created Quobyte volume by name.
    """


class Rbd(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Rbd"]:
            return Rbd

        def build(self) -> "Rbd":
            return Rbd(**self._attrs)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is the filesystem type of the volume that you want to mount.
            Tip: Ensure that the filesystem type is supported by the host operating system.
            Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
            """
            return self._set("fs_type", value)

        def image(self, value: str, /) -> Self:
            """
            image is the rados image name.
            More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
            """
            return self._set("image", value)

        def keyring(self, value: Optional[str], /) -> Self:
            """
            keyring is the path to key ring for RBDUser.
            Default is /etc/ceph/keyring.
            More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
            """
            return self._set("keyring", value)

        def monitors(self, value: List[str], /) -> Self:
            """
            monitors is a collection of Ceph monitors.
            More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
            """
            return self._set("monitors", value)

        def pool(self, value: Optional[str], /) -> Self:
            """
            pool is the rados pool name.
            Default is rbd.
            More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
            """
            return self._set("pool", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly here will force the ReadOnly setting in VolumeMounts.
            Defaults to false.
            More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
            """
            return self._set("read_only", value)

        @overload
        def secret_ref(self, value_or_callback: Optional[SecretRefModel], /) -> "Rbd.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[
                [SecretRefModel.Builder], SecretRefModel.Builder | SecretRefModel
            ],
            /,
        ) -> "Rbd.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRefModel.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            secretRef is name of the authentication secret for RBDUser. If provided
            overrides keyring.
            Default is nil.
            More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
            """
            if self._in_context and value_or_callback is None:
                context = SecretRefModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRefModel.builder())
                if isinstance(output, SecretRefModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def user(self, value: Optional[str], /) -> Self:
            """
            user is the rados user name.
            Default is admin.
            More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
            """
            return self._set("user", value)

    class BuilderContext(BuilderContextBase["Rbd.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Rbd.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Rbd."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Rbd", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Rbd.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fsType is the filesystem type of the volume that you want to mount.
    Tip: Ensure that the filesystem type is supported by the host operating system.
    Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
    """
    image: str
    """
    image is the rados image name.
    More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    """
    keyring: Optional[str] = "/etc/ceph/keyring"
    """
    keyring is the path to key ring for RBDUser.
    Default is /etc/ceph/keyring.
    More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    """
    monitors: List[str]
    """
    monitors is a collection of Ceph monitors.
    More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    """
    pool: Optional[str] = "rbd"
    """
    pool is the rados pool name.
    Default is rbd.
    More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly here will force the ReadOnly setting in VolumeMounts.
    Defaults to false.
    More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    """
    secret_ref: Annotated[Optional[SecretRefModel], Field(alias="secretRef")] = None
    """
    secretRef is name of the authentication secret for RBDUser. If provided
    overrides keyring.
    Default is nil.
    More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    """
    user: Optional[str] = "admin"
    """
    user is the rados user name.
    Default is admin.
    More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    """


class ScaleIo(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ScaleIo"]:
            return ScaleIo

        def build(self) -> "ScaleIo":
            return ScaleIo(**self._attrs)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is the filesystem type to mount.
            Must be a filesystem type supported by the host operating system.
            Ex. "ext4", "xfs", "ntfs".
            Default is "xfs".
            """
            return self._set("fs_type", value)

        def gateway(self, value: str, /) -> Self:
            """
            gateway is the host address of the ScaleIO API Gateway.
            """
            return self._set("gateway", value)

        def protection_domain(self, value: Optional[str], /) -> Self:
            """
            protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
            """
            return self._set("protection_domain", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly Defaults to false (read/write). ReadOnly here will force
            the ReadOnly setting in VolumeMounts.
            """
            return self._set("read_only", value)

        @overload
        def secret_ref(self, value_or_callback: SecretRefModel, /) -> "ScaleIo.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[
                [SecretRefModel.Builder], SecretRefModel.Builder | SecretRefModel
            ],
            /,
        ) -> "ScaleIo.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRefModel.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            secretRef references to the secret for ScaleIO user and other
            sensitive information. If this is not provided, Login operation will fail.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRefModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRefModel.builder())
                if isinstance(output, SecretRefModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def ssl_enabled(self, value: Optional[bool], /) -> Self:
            """
            sslEnabled Flag enable/disable SSL communication with Gateway, default false
            """
            return self._set("ssl_enabled", value)

        def storage_mode(self, value: Optional[str], /) -> Self:
            """
            storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
            Default is ThinProvisioned.
            """
            return self._set("storage_mode", value)

        def storage_pool(self, value: Optional[str], /) -> Self:
            """
            storagePool is the ScaleIO Storage Pool associated with the protection domain.
            """
            return self._set("storage_pool", value)

        def system(self, value: str, /) -> Self:
            """
            system is the name of the storage system as configured in ScaleIO.
            """
            return self._set("system", value)

        def volume_name(self, value: Optional[str], /) -> Self:
            """
            volumeName is the name of a volume already created in the ScaleIO system
            that is associated with this volume source.
            """
            return self._set("volume_name", value)

    class BuilderContext(BuilderContextBase["ScaleIo.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ScaleIo.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ScaleIo."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ScaleIo", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ScaleIo.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fs_type: Annotated[Optional[str], Field(alias="fsType")] = "xfs"
    """
    fsType is the filesystem type to mount.
    Must be a filesystem type supported by the host operating system.
    Ex. "ext4", "xfs", "ntfs".
    Default is "xfs".
    """
    gateway: str
    """
    gateway is the host address of the ScaleIO API Gateway.
    """
    protection_domain: Annotated[Optional[str], Field(alias="protectionDomain")] = None
    """
    protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly Defaults to false (read/write). ReadOnly here will force
    the ReadOnly setting in VolumeMounts.
    """
    secret_ref: Annotated[SecretRefModel, Field(alias="secretRef")]
    """
    secretRef references to the secret for ScaleIO user and other
    sensitive information. If this is not provided, Login operation will fail.
    """
    ssl_enabled: Annotated[Optional[bool], Field(alias="sslEnabled")] = None
    """
    sslEnabled Flag enable/disable SSL communication with Gateway, default false
    """
    storage_mode: Annotated[Optional[str], Field(alias="storageMode")] = "ThinProvisioned"
    """
    storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
    Default is ThinProvisioned.
    """
    storage_pool: Annotated[Optional[str], Field(alias="storagePool")] = None
    """
    storagePool is the ScaleIO Storage Pool associated with the protection domain.
    """
    system: str
    """
    system is the name of the storage system as configured in ScaleIO.
    """
    volume_name: Annotated[Optional[str], Field(alias="volumeName")] = None
    """
    volumeName is the name of a volume already created in the ScaleIO system
    that is associated with this volume source.
    """


class SecretModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretModel1"]:
            return SecretModel1

        def build(self) -> "SecretModel1":
            return SecretModel1(**self._attrs)

        def default_mode(self, value: Optional[int], /) -> Self:
            """
            defaultMode is Optional: mode bits used to set permissions on created files by default.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values
            for mode bits. Defaults to 0644.
            Directories within the path are not affected by this setting.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("default_mode", value)

        @overload
        def items(self, value_or_callback: List[ItemModel3], /) -> "SecretModel1.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel3, ItemModel3.Builder]],
                GenericListBuilder[ItemModel3, ItemModel3.Builder] | List[ItemModel3],
            ],
            /,
        ) -> "SecretModel1.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel3.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items If unspecified, each key-value pair in the Data field of the referenced
            Secret will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the Secret,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel3.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel3.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional field specify whether the Secret or its keys must be defined
            """
            return self._set("optional", value)

        def secret_name(self, value: Optional[str], /) -> Self:
            """
            secretName is the name of the secret in the pod's namespace to use.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
            """
            return self._set("secret_name", value)

    class BuilderContext(BuilderContextBase["SecretModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_mode: Annotated[Optional[int], Field(alias="defaultMode")] = None
    """
    defaultMode is Optional: mode bits used to set permissions on created files by default.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values
    for mode bits. Defaults to 0644.
    Directories within the path are not affected by this setting.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    items: Optional[List[ItemModel3]] = None
    """
    items If unspecified, each key-value pair in the Data field of the referenced
    Secret will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the Secret,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    optional: Optional[bool] = None
    """
    optional field specify whether the Secret or its keys must be defined
    """
    secret_name: Annotated[Optional[str], Field(alias="secretName")] = None
    """
    secretName is the name of the secret in the pod's namespace to use.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
    """


class Storageos(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Storageos"]:
            return Storageos

        def build(self) -> "Storageos":
            return Storageos(**self._attrs)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is the filesystem type to mount.
            Must be a filesystem type supported by the host operating system.
            Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
            """
            return self._set("fs_type", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly defaults to false (read/write). ReadOnly here will force
            the ReadOnly setting in VolumeMounts.
            """
            return self._set("read_only", value)

        @overload
        def secret_ref(
            self, value_or_callback: Optional[SecretRefModel], /
        ) -> "Storageos.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[
                [SecretRefModel.Builder], SecretRefModel.Builder | SecretRefModel
            ],
            /,
        ) -> "Storageos.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRefModel.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            secretRef specifies the secret to use for obtaining the StorageOS API
            credentials.  If not specified, default values will be attempted.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRefModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRefModel.builder())
                if isinstance(output, SecretRefModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def volume_name(self, value: Optional[str], /) -> Self:
            """
            volumeName is the human-readable name of the StorageOS volume.  Volume
            names are only unique within a namespace.
            """
            return self._set("volume_name", value)

        def volume_namespace(self, value: Optional[str], /) -> Self:
            """
            volumeNamespace specifies the scope of the volume within StorageOS.  If no
            namespace is specified then the Pod's namespace will be used.  This allows the
            Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
            Set VolumeName to any name to override the default behaviour.
            Set to "default" if you are not using namespaces within StorageOS.
            Namespaces that do not pre-exist within StorageOS will be created.
            """
            return self._set("volume_namespace", value)

    class BuilderContext(BuilderContextBase["Storageos.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Storageos.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Storageos."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Storageos", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Storageos.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fsType is the filesystem type to mount.
    Must be a filesystem type supported by the host operating system.
    Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly defaults to false (read/write). ReadOnly here will force
    the ReadOnly setting in VolumeMounts.
    """
    secret_ref: Annotated[Optional[SecretRefModel], Field(alias="secretRef")] = None
    """
    secretRef specifies the secret to use for obtaining the StorageOS API
    credentials.  If not specified, default values will be attempted.
    """
    volume_name: Annotated[Optional[str], Field(alias="volumeName")] = None
    """
    volumeName is the human-readable name of the StorageOS volume.  Volume
    names are only unique within a namespace.
    """
    volume_namespace: Annotated[Optional[str], Field(alias="volumeNamespace")] = None
    """
    volumeNamespace specifies the scope of the volume within StorageOS.  If no
    namespace is specified then the Pod's namespace will be used.  This allows the
    Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
    Set VolumeName to any name to override the default behaviour.
    Set to "default" if you are not using namespaces within StorageOS.
    Namespaces that do not pre-exist within StorageOS will be created.
    """


class VsphereVolume(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VsphereVolume"]:
            return VsphereVolume

        def build(self) -> "VsphereVolume":
            return VsphereVolume(**self._attrs)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is filesystem type to mount.
            Must be a filesystem type supported by the host operating system.
            Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
            """
            return self._set("fs_type", value)

        def storage_policy_id(self, value: Optional[str], /) -> Self:
            """
            storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
            """
            return self._set("storage_policy_id", value)

        def storage_policy_name(self, value: Optional[str], /) -> Self:
            """
            storagePolicyName is the storage Policy Based Management (SPBM) profile name.
            """
            return self._set("storage_policy_name", value)

        def volume_path(self, value: str, /) -> Self:
            """
            volumePath is the path that identifies vSphere volume vmdk
            """
            return self._set("volume_path", value)

    class BuilderContext(BuilderContextBase["VsphereVolume.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VsphereVolume.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VsphereVolume."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VsphereVolume", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VsphereVolume.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fsType is filesystem type to mount.
    Must be a filesystem type supported by the host operating system.
    Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    """
    storage_policy_id: Annotated[Optional[str], Field(alias="storagePolicyID")] = None
    """
    storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
    """
    storage_policy_name: Annotated[Optional[str], Field(alias="storagePolicyName")] = None
    """
    storagePolicyName is the storage Policy Based Management (SPBM) profile name.
    """
    volume_path: Annotated[str, Field(alias="volumePath")]
    """
    volumePath is the path that identifies vSphere volume vmdk
    """


class Volume(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Volume"]:
            return Volume

        def build(self) -> "Volume":
            return Volume(**self._attrs)

        @overload
        def aws_elastic_block_store(
            self, value_or_callback: Optional[AwsElasticBlockStore], /
        ) -> "Volume.Builder": ...

        @overload
        def aws_elastic_block_store(
            self,
            value_or_callback: Callable[
                [AwsElasticBlockStore.Builder],
                AwsElasticBlockStore.Builder | AwsElasticBlockStore,
            ],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def aws_elastic_block_store(
            self, value_or_callback: Never = ...
        ) -> "AwsElasticBlockStore.BuilderContext": ...

        def aws_elastic_block_store(self, value_or_callback=None, /):
            """
            awsElasticBlockStore represents an AWS Disk resource that is attached to a
            kubelet's host machine and then exposed to the pod.
            Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
            awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
            """
            if self._in_context and value_or_callback is None:
                context = AwsElasticBlockStore.BuilderContext()
                context._parent_builder = self
                context._field_name = "aws_elastic_block_store"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AwsElasticBlockStore.builder())
                if isinstance(output, AwsElasticBlockStore.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("aws_elastic_block_store", value)

        @overload
        def azure_disk(self, value_or_callback: Optional[AzureDisk], /) -> "Volume.Builder": ...

        @overload
        def azure_disk(
            self,
            value_or_callback: Callable[[AzureDisk.Builder], AzureDisk.Builder | AzureDisk],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def azure_disk(self, value_or_callback: Never = ...) -> "AzureDisk.BuilderContext": ...

        def azure_disk(self, value_or_callback=None, /):
            """
            azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
            Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
            are redirected to the disk.csi.azure.com CSI driver.
            """
            if self._in_context and value_or_callback is None:
                context = AzureDisk.BuilderContext()
                context._parent_builder = self
                context._field_name = "azure_disk"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AzureDisk.builder())
                if isinstance(output, AzureDisk.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("azure_disk", value)

        @overload
        def azure_file(self, value_or_callback: Optional[AzureFile], /) -> "Volume.Builder": ...

        @overload
        def azure_file(
            self,
            value_or_callback: Callable[[AzureFile.Builder], AzureFile.Builder | AzureFile],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def azure_file(self, value_or_callback: Never = ...) -> "AzureFile.BuilderContext": ...

        def azure_file(self, value_or_callback=None, /):
            """
            azureFile represents an Azure File Service mount on the host and bind mount to the pod.
            Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
            are redirected to the file.csi.azure.com CSI driver.
            """
            if self._in_context and value_or_callback is None:
                context = AzureFile.BuilderContext()
                context._parent_builder = self
                context._field_name = "azure_file"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AzureFile.builder())
                if isinstance(output, AzureFile.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("azure_file", value)

        @overload
        def cephfs(self, value_or_callback: Optional[Cephfs], /) -> "Volume.Builder": ...

        @overload
        def cephfs(
            self,
            value_or_callback: Callable[[Cephfs.Builder], Cephfs.Builder | Cephfs],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def cephfs(self, value_or_callback: Never = ...) -> "Cephfs.BuilderContext": ...

        def cephfs(self, value_or_callback=None, /):
            """
            cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
            Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
            """
            if self._in_context and value_or_callback is None:
                context = Cephfs.BuilderContext()
                context._parent_builder = self
                context._field_name = "cephfs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cephfs.builder())
                if isinstance(output, Cephfs.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cephfs", value)

        @overload
        def cinder(self, value_or_callback: Optional[Cinder], /) -> "Volume.Builder": ...

        @overload
        def cinder(
            self,
            value_or_callback: Callable[[Cinder.Builder], Cinder.Builder | Cinder],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def cinder(self, value_or_callback: Never = ...) -> "Cinder.BuilderContext": ...

        def cinder(self, value_or_callback=None, /):
            """
            cinder represents a cinder volume attached and mounted on kubelets host machine.
            Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
            are redirected to the cinder.csi.openstack.org CSI driver.
            More info: https://examples.k8s.io/mysql-cinder-pd/README.md
            """
            if self._in_context and value_or_callback is None:
                context = Cinder.BuilderContext()
                context._parent_builder = self
                context._field_name = "cinder"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cinder.builder())
                if isinstance(output, Cinder.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cinder", value)

        @overload
        def config_map(
            self, value_or_callback: Optional[ConfigMapModel], /
        ) -> "Volume.Builder": ...

        @overload
        def config_map(
            self,
            value_or_callback: Callable[
                [ConfigMapModel.Builder], ConfigMapModel.Builder | ConfigMapModel
            ],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def config_map(self, value_or_callback: Never = ...) -> "ConfigMapModel.BuilderContext": ...

        def config_map(self, value_or_callback=None, /):
            """
            configMap represents a configMap that should populate this volume
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMapModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMapModel.builder())
                if isinstance(output, ConfigMapModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map", value)

        @overload
        def csi(self, value_or_callback: Optional[Csi], /) -> "Volume.Builder": ...

        @overload
        def csi(
            self, value_or_callback: Callable[[Csi.Builder], Csi.Builder | Csi], /
        ) -> "Volume.Builder": ...

        @overload
        def csi(self, value_or_callback: Never = ...) -> "Csi.BuilderContext": ...

        def csi(self, value_or_callback=None, /):
            """
            csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
            """
            if self._in_context and value_or_callback is None:
                context = Csi.BuilderContext()
                context._parent_builder = self
                context._field_name = "csi"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Csi.builder())
                if isinstance(output, Csi.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("csi", value)

        @overload
        def downward_api(self, value_or_callback: Optional[DownwardApi], /) -> "Volume.Builder": ...

        @overload
        def downward_api(
            self,
            value_or_callback: Callable[[DownwardApi.Builder], DownwardApi.Builder | DownwardApi],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def downward_api(self, value_or_callback: Never = ...) -> "DownwardApi.BuilderContext": ...

        def downward_api(self, value_or_callback=None, /):
            """
            downwardAPI represents downward API about the pod that should populate this volume
            """
            if self._in_context and value_or_callback is None:
                context = DownwardApi.BuilderContext()
                context._parent_builder = self
                context._field_name = "downward_api"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DownwardApi.builder())
                if isinstance(output, DownwardApi.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("downward_api", value)

        @overload
        def empty_dir(self, value_or_callback: Optional[EmptyDir], /) -> "Volume.Builder": ...

        @overload
        def empty_dir(
            self,
            value_or_callback: Callable[[EmptyDir.Builder], EmptyDir.Builder | EmptyDir],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def empty_dir(self, value_or_callback: Never = ...) -> "EmptyDir.BuilderContext": ...

        def empty_dir(self, value_or_callback=None, /):
            """
            emptyDir represents a temporary directory that shares a pod's lifetime.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            if self._in_context and value_or_callback is None:
                context = EmptyDir.BuilderContext()
                context._parent_builder = self
                context._field_name = "empty_dir"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(EmptyDir.builder())
                if isinstance(output, EmptyDir.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("empty_dir", value)

        @overload
        def ephemeral(self, value_or_callback: Optional[Ephemeral], /) -> "Volume.Builder": ...

        @overload
        def ephemeral(
            self,
            value_or_callback: Callable[[Ephemeral.Builder], Ephemeral.Builder | Ephemeral],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def ephemeral(self, value_or_callback: Never = ...) -> "Ephemeral.BuilderContext": ...

        def ephemeral(self, value_or_callback=None, /):
            """
            ephemeral represents a volume that is handled by a cluster storage driver.
            The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
            and deleted when the pod is removed.

            Use this if:
            a) the volume is only needed while the pod runs,
            b) features of normal volumes like restoring from snapshot or capacity
               tracking are needed,
            c) the storage driver is specified through a storage class, and
            d) the storage driver supports dynamic volume provisioning through
               a PersistentVolumeClaim (see EphemeralVolumeSource for more
               information on the connection between this volume type
               and PersistentVolumeClaim).

            Use PersistentVolumeClaim or one of the vendor-specific
            APIs for volumes that persist for longer than the lifecycle
            of an individual pod.

            Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
            be used that way - see the documentation of the driver for
            more information.

            A pod can use both types of ephemeral volumes and
            persistent volumes at the same time.
            """
            if self._in_context and value_or_callback is None:
                context = Ephemeral.BuilderContext()
                context._parent_builder = self
                context._field_name = "ephemeral"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ephemeral.builder())
                if isinstance(output, Ephemeral.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ephemeral", value)

        @overload
        def fc(self, value_or_callback: Optional[Fc], /) -> "Volume.Builder": ...

        @overload
        def fc(
            self, value_or_callback: Callable[[Fc.Builder], Fc.Builder | Fc], /
        ) -> "Volume.Builder": ...

        @overload
        def fc(self, value_or_callback: Never = ...) -> "Fc.BuilderContext": ...

        def fc(self, value_or_callback=None, /):
            """
            fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
            """
            if self._in_context and value_or_callback is None:
                context = Fc.BuilderContext()
                context._parent_builder = self
                context._field_name = "fc"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Fc.builder())
                if isinstance(output, Fc.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("fc", value)

        @overload
        def flex_volume(self, value_or_callback: Optional[FlexVolume], /) -> "Volume.Builder": ...

        @overload
        def flex_volume(
            self,
            value_or_callback: Callable[[FlexVolume.Builder], FlexVolume.Builder | FlexVolume],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def flex_volume(self, value_or_callback: Never = ...) -> "FlexVolume.BuilderContext": ...

        def flex_volume(self, value_or_callback=None, /):
            """
            flexVolume represents a generic volume resource that is
            provisioned/attached using an exec based plugin.
            Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
            """
            if self._in_context and value_or_callback is None:
                context = FlexVolume.BuilderContext()
                context._parent_builder = self
                context._field_name = "flex_volume"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FlexVolume.builder())
                if isinstance(output, FlexVolume.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("flex_volume", value)

        @overload
        def flocker(self, value_or_callback: Optional[Flocker], /) -> "Volume.Builder": ...

        @overload
        def flocker(
            self,
            value_or_callback: Callable[[Flocker.Builder], Flocker.Builder | Flocker],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def flocker(self, value_or_callback: Never = ...) -> "Flocker.BuilderContext": ...

        def flocker(self, value_or_callback=None, /):
            """
            flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
            Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
            """
            if self._in_context and value_or_callback is None:
                context = Flocker.BuilderContext()
                context._parent_builder = self
                context._field_name = "flocker"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Flocker.builder())
                if isinstance(output, Flocker.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("flocker", value)

        @overload
        def gce_persistent_disk(
            self, value_or_callback: Optional[GcePersistentDisk], /
        ) -> "Volume.Builder": ...

        @overload
        def gce_persistent_disk(
            self,
            value_or_callback: Callable[
                [GcePersistentDisk.Builder],
                GcePersistentDisk.Builder | GcePersistentDisk,
            ],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def gce_persistent_disk(
            self, value_or_callback: Never = ...
        ) -> "GcePersistentDisk.BuilderContext": ...

        def gce_persistent_disk(self, value_or_callback=None, /):
            """
            gcePersistentDisk represents a GCE Disk resource that is attached to a
            kubelet's host machine and then exposed to the pod.
            Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
            gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
            """
            if self._in_context and value_or_callback is None:
                context = GcePersistentDisk.BuilderContext()
                context._parent_builder = self
                context._field_name = "gce_persistent_disk"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GcePersistentDisk.builder())
                if isinstance(output, GcePersistentDisk.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("gce_persistent_disk", value)

        @overload
        def git_repo(self, value_or_callback: Optional[GitRepo], /) -> "Volume.Builder": ...

        @overload
        def git_repo(
            self,
            value_or_callback: Callable[[GitRepo.Builder], GitRepo.Builder | GitRepo],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def git_repo(self, value_or_callback: Never = ...) -> "GitRepo.BuilderContext": ...

        def git_repo(self, value_or_callback=None, /):
            """
            gitRepo represents a git repository at a particular revision.
            Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
            EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
            into the Pod's container.
            """
            if self._in_context and value_or_callback is None:
                context = GitRepo.BuilderContext()
                context._parent_builder = self
                context._field_name = "git_repo"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GitRepo.builder())
                if isinstance(output, GitRepo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("git_repo", value)

        @overload
        def glusterfs(self, value_or_callback: Optional[Glusterfs], /) -> "Volume.Builder": ...

        @overload
        def glusterfs(
            self,
            value_or_callback: Callable[[Glusterfs.Builder], Glusterfs.Builder | Glusterfs],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def glusterfs(self, value_or_callback: Never = ...) -> "Glusterfs.BuilderContext": ...

        def glusterfs(self, value_or_callback=None, /):
            """
            glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
            Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
            More info: https://examples.k8s.io/volumes/glusterfs/README.md
            """
            if self._in_context and value_or_callback is None:
                context = Glusterfs.BuilderContext()
                context._parent_builder = self
                context._field_name = "glusterfs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Glusterfs.builder())
                if isinstance(output, Glusterfs.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("glusterfs", value)

        @overload
        def host_path(self, value_or_callback: Optional[HostPath], /) -> "Volume.Builder": ...

        @overload
        def host_path(
            self,
            value_or_callback: Callable[[HostPath.Builder], HostPath.Builder | HostPath],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def host_path(self, value_or_callback: Never = ...) -> "HostPath.BuilderContext": ...

        def host_path(self, value_or_callback=None, /):
            """
            hostPath represents a pre-existing file or directory on the host
            machine that is directly exposed to the container. This is generally
            used for system agents or other privileged things that are allowed
            to see the host machine. Most containers will NOT need this.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
            """
            if self._in_context and value_or_callback is None:
                context = HostPath.BuilderContext()
                context._parent_builder = self
                context._field_name = "host_path"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HostPath.builder())
                if isinstance(output, HostPath.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("host_path", value)

        @overload
        def image(self, value_or_callback: Optional[Image], /) -> "Volume.Builder": ...

        @overload
        def image(
            self, value_or_callback: Callable[[Image.Builder], Image.Builder | Image], /
        ) -> "Volume.Builder": ...

        @overload
        def image(self, value_or_callback: Never = ...) -> "Image.BuilderContext": ...

        def image(self, value_or_callback=None, /):
            """
            image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
            The volume is resolved at pod startup depending on which PullPolicy value is provided:

            - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
            - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
            - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.

            The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
            A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
            The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
            The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
            The volume will be mounted read-only (ro) and non-executable files (noexec).
            Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath).
            The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
            """
            if self._in_context and value_or_callback is None:
                context = Image.BuilderContext()
                context._parent_builder = self
                context._field_name = "image"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Image.builder())
                if isinstance(output, Image.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("image", value)

        @overload
        def iscsi(self, value_or_callback: Optional[Iscsi], /) -> "Volume.Builder": ...

        @overload
        def iscsi(
            self, value_or_callback: Callable[[Iscsi.Builder], Iscsi.Builder | Iscsi], /
        ) -> "Volume.Builder": ...

        @overload
        def iscsi(self, value_or_callback: Never = ...) -> "Iscsi.BuilderContext": ...

        def iscsi(self, value_or_callback=None, /):
            """
            iscsi represents an ISCSI Disk resource that is attached to a
            kubelet's host machine and then exposed to the pod.
            More info: https://examples.k8s.io/volumes/iscsi/README.md
            """
            if self._in_context and value_or_callback is None:
                context = Iscsi.BuilderContext()
                context._parent_builder = self
                context._field_name = "iscsi"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Iscsi.builder())
                if isinstance(output, Iscsi.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("iscsi", value)

        def name(self, value: str, /) -> Self:
            """
            name of the volume.
            Must be a DNS_LABEL and unique within the pod.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        @overload
        def nfs(self, value_or_callback: Optional[Nfs], /) -> "Volume.Builder": ...

        @overload
        def nfs(
            self, value_or_callback: Callable[[Nfs.Builder], Nfs.Builder | Nfs], /
        ) -> "Volume.Builder": ...

        @overload
        def nfs(self, value_or_callback: Never = ...) -> "Nfs.BuilderContext": ...

        def nfs(self, value_or_callback=None, /):
            """
            nfs represents an NFS mount on the host that shares a pod's lifetime
            More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
            """
            if self._in_context and value_or_callback is None:
                context = Nfs.BuilderContext()
                context._parent_builder = self
                context._field_name = "nfs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Nfs.builder())
                if isinstance(output, Nfs.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("nfs", value)

        @overload
        def persistent_volume_claim(
            self, value_or_callback: Optional[PersistentVolumeClaim], /
        ) -> "Volume.Builder": ...

        @overload
        def persistent_volume_claim(
            self,
            value_or_callback: Callable[
                [PersistentVolumeClaim.Builder],
                PersistentVolumeClaim.Builder | PersistentVolumeClaim,
            ],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def persistent_volume_claim(
            self, value_or_callback: Never = ...
        ) -> "PersistentVolumeClaim.BuilderContext": ...

        def persistent_volume_claim(self, value_or_callback=None, /):
            """
            persistentVolumeClaimVolumeSource represents a reference to a
            PersistentVolumeClaim in the same namespace.
            More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
            """
            if self._in_context and value_or_callback is None:
                context = PersistentVolumeClaim.BuilderContext()
                context._parent_builder = self
                context._field_name = "persistent_volume_claim"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PersistentVolumeClaim.builder())
                if isinstance(output, PersistentVolumeClaim.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("persistent_volume_claim", value)

        @overload
        def photon_persistent_disk(
            self, value_or_callback: Optional[PhotonPersistentDisk], /
        ) -> "Volume.Builder": ...

        @overload
        def photon_persistent_disk(
            self,
            value_or_callback: Callable[
                [PhotonPersistentDisk.Builder],
                PhotonPersistentDisk.Builder | PhotonPersistentDisk,
            ],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def photon_persistent_disk(
            self, value_or_callback: Never = ...
        ) -> "PhotonPersistentDisk.BuilderContext": ...

        def photon_persistent_disk(self, value_or_callback=None, /):
            """
            photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
            Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
            """
            if self._in_context and value_or_callback is None:
                context = PhotonPersistentDisk.BuilderContext()
                context._parent_builder = self
                context._field_name = "photon_persistent_disk"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PhotonPersistentDisk.builder())
                if isinstance(output, PhotonPersistentDisk.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("photon_persistent_disk", value)

        @overload
        def portworx_volume(
            self, value_or_callback: Optional[PortworxVolume], /
        ) -> "Volume.Builder": ...

        @overload
        def portworx_volume(
            self,
            value_or_callback: Callable[
                [PortworxVolume.Builder], PortworxVolume.Builder | PortworxVolume
            ],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def portworx_volume(
            self, value_or_callback: Never = ...
        ) -> "PortworxVolume.BuilderContext": ...

        def portworx_volume(self, value_or_callback=None, /):
            """
            portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
            Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
            are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
            is on.
            """
            if self._in_context and value_or_callback is None:
                context = PortworxVolume.BuilderContext()
                context._parent_builder = self
                context._field_name = "portworx_volume"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PortworxVolume.builder())
                if isinstance(output, PortworxVolume.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("portworx_volume", value)

        @overload
        def projected(self, value_or_callback: Optional[Projected], /) -> "Volume.Builder": ...

        @overload
        def projected(
            self,
            value_or_callback: Callable[[Projected.Builder], Projected.Builder | Projected],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def projected(self, value_or_callback: Never = ...) -> "Projected.BuilderContext": ...

        def projected(self, value_or_callback=None, /):
            """
            projected items for all in one resources secrets, configmaps, and downward API
            """
            if self._in_context and value_or_callback is None:
                context = Projected.BuilderContext()
                context._parent_builder = self
                context._field_name = "projected"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Projected.builder())
                if isinstance(output, Projected.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("projected", value)

        @overload
        def quobyte(self, value_or_callback: Optional[Quobyte], /) -> "Volume.Builder": ...

        @overload
        def quobyte(
            self,
            value_or_callback: Callable[[Quobyte.Builder], Quobyte.Builder | Quobyte],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def quobyte(self, value_or_callback: Never = ...) -> "Quobyte.BuilderContext": ...

        def quobyte(self, value_or_callback=None, /):
            """
            quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
            Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
            """
            if self._in_context and value_or_callback is None:
                context = Quobyte.BuilderContext()
                context._parent_builder = self
                context._field_name = "quobyte"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Quobyte.builder())
                if isinstance(output, Quobyte.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("quobyte", value)

        @overload
        def rbd(self, value_or_callback: Optional[Rbd], /) -> "Volume.Builder": ...

        @overload
        def rbd(
            self, value_or_callback: Callable[[Rbd.Builder], Rbd.Builder | Rbd], /
        ) -> "Volume.Builder": ...

        @overload
        def rbd(self, value_or_callback: Never = ...) -> "Rbd.BuilderContext": ...

        def rbd(self, value_or_callback=None, /):
            """
            rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
            Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
            More info: https://examples.k8s.io/volumes/rbd/README.md
            """
            if self._in_context and value_or_callback is None:
                context = Rbd.BuilderContext()
                context._parent_builder = self
                context._field_name = "rbd"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Rbd.builder())
                if isinstance(output, Rbd.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("rbd", value)

        @overload
        def scale_io(self, value_or_callback: Optional[ScaleIo], /) -> "Volume.Builder": ...

        @overload
        def scale_io(
            self,
            value_or_callback: Callable[[ScaleIo.Builder], ScaleIo.Builder | ScaleIo],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def scale_io(self, value_or_callback: Never = ...) -> "ScaleIo.BuilderContext": ...

        def scale_io(self, value_or_callback=None, /):
            """
            scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
            Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
            """
            if self._in_context and value_or_callback is None:
                context = ScaleIo.BuilderContext()
                context._parent_builder = self
                context._field_name = "scale_io"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ScaleIo.builder())
                if isinstance(output, ScaleIo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("scale_io", value)

        @overload
        def secret(self, value_or_callback: Optional[SecretModel1], /) -> "Volume.Builder": ...

        @overload
        def secret(
            self,
            value_or_callback: Callable[
                [SecretModel1.Builder], SecretModel1.Builder | SecretModel1
            ],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def secret(self, value_or_callback: Never = ...) -> "SecretModel1.BuilderContext": ...

        def secret(self, value_or_callback=None, /):
            """
            secret represents a secret that should populate this volume.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
            """
            if self._in_context and value_or_callback is None:
                context = SecretModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretModel1.builder())
                if isinstance(output, SecretModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret", value)

        @overload
        def storageos(self, value_or_callback: Optional[Storageos], /) -> "Volume.Builder": ...

        @overload
        def storageos(
            self,
            value_or_callback: Callable[[Storageos.Builder], Storageos.Builder | Storageos],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def storageos(self, value_or_callback: Never = ...) -> "Storageos.BuilderContext": ...

        def storageos(self, value_or_callback=None, /):
            """
            storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
            Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
            """
            if self._in_context and value_or_callback is None:
                context = Storageos.BuilderContext()
                context._parent_builder = self
                context._field_name = "storageos"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Storageos.builder())
                if isinstance(output, Storageos.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("storageos", value)

        @overload
        def vsphere_volume(
            self, value_or_callback: Optional[VsphereVolume], /
        ) -> "Volume.Builder": ...

        @overload
        def vsphere_volume(
            self,
            value_or_callback: Callable[
                [VsphereVolume.Builder], VsphereVolume.Builder | VsphereVolume
            ],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def vsphere_volume(
            self, value_or_callback: Never = ...
        ) -> "VsphereVolume.BuilderContext": ...

        def vsphere_volume(self, value_or_callback=None, /):
            """
            vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
            Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
            are redirected to the csi.vsphere.vmware.com CSI driver.
            """
            if self._in_context and value_or_callback is None:
                context = VsphereVolume.BuilderContext()
                context._parent_builder = self
                context._field_name = "vsphere_volume"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VsphereVolume.builder())
                if isinstance(output, VsphereVolume.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("vsphere_volume", value)

    class BuilderContext(BuilderContextBase["Volume.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Volume.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Volume."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Volume", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Volume.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    aws_elastic_block_store: Annotated[
        Optional[AwsElasticBlockStore], Field(alias="awsElasticBlockStore")
    ] = None
    """
    awsElasticBlockStore represents an AWS Disk resource that is attached to a
    kubelet's host machine and then exposed to the pod.
    Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
    awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
    """
    azure_disk: Annotated[Optional[AzureDisk], Field(alias="azureDisk")] = None
    """
    azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
    Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
    are redirected to the disk.csi.azure.com CSI driver.
    """
    azure_file: Annotated[Optional[AzureFile], Field(alias="azureFile")] = None
    """
    azureFile represents an Azure File Service mount on the host and bind mount to the pod.
    Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
    are redirected to the file.csi.azure.com CSI driver.
    """
    cephfs: Optional[Cephfs] = None
    """
    cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
    Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
    """
    cinder: Optional[Cinder] = None
    """
    cinder represents a cinder volume attached and mounted on kubelets host machine.
    Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
    are redirected to the cinder.csi.openstack.org CSI driver.
    More info: https://examples.k8s.io/mysql-cinder-pd/README.md
    """
    config_map: Annotated[Optional[ConfigMapModel], Field(alias="configMap")] = None
    """
    configMap represents a configMap that should populate this volume
    """
    csi: Optional[Csi] = None
    """
    csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
    """
    downward_api: Annotated[Optional[DownwardApi], Field(alias="downwardAPI")] = None
    """
    downwardAPI represents downward API about the pod that should populate this volume
    """
    empty_dir: Annotated[Optional[EmptyDir], Field(alias="emptyDir")] = None
    """
    emptyDir represents a temporary directory that shares a pod's lifetime.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    """
    ephemeral: Optional[Ephemeral] = None
    """
    ephemeral represents a volume that is handled by a cluster storage driver.
    The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
    and deleted when the pod is removed.

    Use this if:
    a) the volume is only needed while the pod runs,
    b) features of normal volumes like restoring from snapshot or capacity
       tracking are needed,
    c) the storage driver is specified through a storage class, and
    d) the storage driver supports dynamic volume provisioning through
       a PersistentVolumeClaim (see EphemeralVolumeSource for more
       information on the connection between this volume type
       and PersistentVolumeClaim).

    Use PersistentVolumeClaim or one of the vendor-specific
    APIs for volumes that persist for longer than the lifecycle
    of an individual pod.

    Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
    be used that way - see the documentation of the driver for
    more information.

    A pod can use both types of ephemeral volumes and
    persistent volumes at the same time.
    """
    fc: Optional[Fc] = None
    """
    fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
    """
    flex_volume: Annotated[Optional[FlexVolume], Field(alias="flexVolume")] = None
    """
    flexVolume represents a generic volume resource that is
    provisioned/attached using an exec based plugin.
    Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
    """
    flocker: Optional[Flocker] = None
    """
    flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
    Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
    """
    gce_persistent_disk: Annotated[
        Optional[GcePersistentDisk], Field(alias="gcePersistentDisk")
    ] = None
    """
    gcePersistentDisk represents a GCE Disk resource that is attached to a
    kubelet's host machine and then exposed to the pod.
    Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
    gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
    """
    git_repo: Annotated[Optional[GitRepo], Field(alias="gitRepo")] = None
    """
    gitRepo represents a git repository at a particular revision.
    Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
    EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
    into the Pod's container.
    """
    glusterfs: Optional[Glusterfs] = None
    """
    glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
    Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
    More info: https://examples.k8s.io/volumes/glusterfs/README.md
    """
    host_path: Annotated[Optional[HostPath], Field(alias="hostPath")] = None
    """
    hostPath represents a pre-existing file or directory on the host
    machine that is directly exposed to the container. This is generally
    used for system agents or other privileged things that are allowed
    to see the host machine. Most containers will NOT need this.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
    """
    image: Optional[Image] = None
    """
    image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
    The volume is resolved at pod startup depending on which PullPolicy value is provided:

    - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
    - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
    - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.

    The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
    A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
    The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
    The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
    The volume will be mounted read-only (ro) and non-executable files (noexec).
    Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath).
    The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
    """
    iscsi: Optional[Iscsi] = None
    """
    iscsi represents an ISCSI Disk resource that is attached to a
    kubelet's host machine and then exposed to the pod.
    More info: https://examples.k8s.io/volumes/iscsi/README.md
    """
    name: str
    """
    name of the volume.
    Must be a DNS_LABEL and unique within the pod.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    nfs: Optional[Nfs] = None
    """
    nfs represents an NFS mount on the host that shares a pod's lifetime
    More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
    """
    persistent_volume_claim: Annotated[
        Optional[PersistentVolumeClaim], Field(alias="persistentVolumeClaim")
    ] = None
    """
    persistentVolumeClaimVolumeSource represents a reference to a
    PersistentVolumeClaim in the same namespace.
    More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
    """
    photon_persistent_disk: Annotated[
        Optional[PhotonPersistentDisk], Field(alias="photonPersistentDisk")
    ] = None
    """
    photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
    Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
    """
    portworx_volume: Annotated[Optional[PortworxVolume], Field(alias="portworxVolume")] = None
    """
    portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
    Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
    are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
    is on.
    """
    projected: Optional[Projected] = None
    """
    projected items for all in one resources secrets, configmaps, and downward API
    """
    quobyte: Optional[Quobyte] = None
    """
    quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
    Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
    """
    rbd: Optional[Rbd] = None
    """
    rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
    Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
    More info: https://examples.k8s.io/volumes/rbd/README.md
    """
    scale_io: Annotated[Optional[ScaleIo], Field(alias="scaleIO")] = None
    """
    scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
    Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
    """
    secret: Optional[SecretModel1] = None
    """
    secret represents a secret that should populate this volume.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
    """
    storageos: Optional[Storageos] = None
    """
    storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
    Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
    """
    vsphere_volume: Annotated[Optional[VsphereVolume], Field(alias="vsphereVolume")] = None
    """
    vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
    Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
    are redirected to the csi.vsphere.vmware.com CSI driver.
    """


class Headers(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Headers"]:
            return Headers

        def build(self) -> "Headers":
            return Headers(**self._attrs)

        def content_security_policy(self, value: Optional[str], /) -> Self:
            """
            Set the Content-Security-Policy header to HTTP responses.
            Unset if blank.
            """
            return self._set("content_security_policy", value)

        def strict_transport_security(self, value: Optional[str], /) -> Self:
            """
            Set the Strict-Transport-Security header to HTTP responses.
            Unset if blank.
            Please make sure that you use this with care as this header might force
            browsers to load Prometheus and the other applications hosted on the same
            domain and subdomains over HTTPS.
            https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security
            """
            return self._set("strict_transport_security", value)

        def x_content_type_options(self, value: Optional[Literal["", "NoSniff"]], /) -> Self:
            """
            Set the X-Content-Type-Options header to HTTP responses.
            Unset if blank. Accepted value is nosniff.
            https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
            """
            return self._set("x_content_type_options", value)

        def x_frame_options(self, value: Optional[Literal["", "Deny", "SameOrigin"]], /) -> Self:
            """
            Set the X-Frame-Options header to HTTP responses.
            Unset if blank. Accepted values are deny and sameorigin.
            https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
            """
            return self._set("x_frame_options", value)

        def x_xss_protection(self, value: Optional[str], /) -> Self:
            """
            Set the X-XSS-Protection header to all responses.
            Unset if blank.
            https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection
            """
            return self._set("x_xss_protection", value)

    class BuilderContext(BuilderContextBase["Headers.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Headers.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Headers."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Headers", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Headers.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    content_security_policy: Annotated[Optional[str], Field(alias="contentSecurityPolicy")] = None
    """
    Set the Content-Security-Policy header to HTTP responses.
    Unset if blank.
    """
    strict_transport_security: Annotated[Optional[str], Field(alias="strictTransportSecurity")] = (
        None
    )
    """
    Set the Strict-Transport-Security header to HTTP responses.
    Unset if blank.
    Please make sure that you use this with care as this header might force
    browsers to load Prometheus and the other applications hosted on the same
    domain and subdomains over HTTPS.
    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security
    """
    x_content_type_options: Annotated[
        Optional[Literal["", "NoSniff"]], Field(alias="xContentTypeOptions")
    ] = None
    """
    Set the X-Content-Type-Options header to HTTP responses.
    Unset if blank. Accepted value is nosniff.
    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
    """
    x_frame_options: Annotated[
        Optional[Literal["", "Deny", "SameOrigin"]], Field(alias="xFrameOptions")
    ] = None
    """
    Set the X-Frame-Options header to HTTP responses.
    Unset if blank. Accepted values are deny and sameorigin.
    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
    """
    x_xss_protection: Annotated[Optional[str], Field(alias="xXSSProtection")] = None
    """
    Set the X-XSS-Protection header to all responses.
    Unset if blank.
    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection
    """


class HttpConfigModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HttpConfigModel"]:
            return HttpConfigModel

        def build(self) -> "HttpConfigModel":
            return HttpConfigModel(**self._attrs)

        @overload
        def headers(self, value_or_callback: Optional[Headers], /) -> "HttpConfigModel.Builder": ...

        @overload
        def headers(
            self,
            value_or_callback: Callable[[Headers.Builder], Headers.Builder | Headers],
            /,
        ) -> "HttpConfigModel.Builder": ...

        @overload
        def headers(self, value_or_callback: Never = ...) -> "Headers.BuilderContext": ...

        def headers(self, value_or_callback=None, /):
            """
            List of headers that can be added to HTTP responses.
            """
            if self._in_context and value_or_callback is None:
                context = Headers.BuilderContext()
                context._parent_builder = self
                context._field_name = "headers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Headers.builder())
                if isinstance(output, Headers.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("headers", value)

        def http2(self, value: Optional[bool], /) -> Self:
            """
            Enable HTTP/2 support. Note that HTTP/2 is only supported with TLS.
            When TLSConfig is not configured, HTTP/2 will be disabled.
            Whenever the value of the field changes, a rolling update will be triggered.
            """
            return self._set("http2", value)

    class BuilderContext(BuilderContextBase["HttpConfigModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HttpConfigModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HttpConfigModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HttpConfigModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HttpConfigModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    headers: Optional[Headers] = None
    """
    List of headers that can be added to HTTP responses.
    """
    http2: Optional[bool] = None
    """
    Enable HTTP/2 support. Note that HTTP/2 is only supported with TLS.
    When TLSConfig is not configured, HTTP/2 will be disabled.
    Whenever the value of the field changes, a rolling update will be triggered.
    """


class ConfigMapModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapModel2"]:
            return ConfigMapModel2

        def build(self) -> "ConfigMapModel2":
            return ConfigMapModel2(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key to select.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the ConfigMap or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key to select.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the ConfigMap or its key must be defined
    """


class SecretModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretModel2"]:
            return SecretModel2

        def build(self) -> "SecretModel2":
            return SecretModel2(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["SecretModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class ClientCa(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClientCa"]:
            return ClientCa

        def build(self) -> "ClientCa":
            return ClientCa(**self._attrs)

        @overload
        def config_map(
            self, value_or_callback: Optional[ConfigMapModel2], /
        ) -> "ClientCa.Builder": ...

        @overload
        def config_map(
            self,
            value_or_callback: Callable[
                [ConfigMapModel2.Builder], ConfigMapModel2.Builder | ConfigMapModel2
            ],
            /,
        ) -> "ClientCa.Builder": ...

        @overload
        def config_map(
            self, value_or_callback: Never = ...
        ) -> "ConfigMapModel2.BuilderContext": ...

        def config_map(self, value_or_callback=None, /):
            """
            ConfigMap containing data to use for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMapModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMapModel2.builder())
                if isinstance(output, ConfigMapModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map", value)

        @overload
        def secret(self, value_or_callback: Optional[SecretModel2], /) -> "ClientCa.Builder": ...

        @overload
        def secret(
            self,
            value_or_callback: Callable[
                [SecretModel2.Builder], SecretModel2.Builder | SecretModel2
            ],
            /,
        ) -> "ClientCa.Builder": ...

        @overload
        def secret(self, value_or_callback: Never = ...) -> "SecretModel2.BuilderContext": ...

        def secret(self, value_or_callback=None, /):
            """
            Secret containing data to use for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = SecretModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretModel2.builder())
                if isinstance(output, SecretModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret", value)

    class BuilderContext(BuilderContextBase["ClientCa.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClientCa.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClientCa."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClientCa", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClientCa.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_map: Annotated[Optional[ConfigMapModel2], Field(alias="configMap")] = None
    """
    ConfigMap containing data to use for the targets.
    """
    secret: Optional[SecretModel2] = None
    """
    Secret containing data to use for the targets.
    """


class TlsConfigModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsConfigModel3"]:
            return TlsConfigModel3

        def build(self) -> "TlsConfigModel3":
            return TlsConfigModel3(**self._attrs)

        @overload
        def cert(self, value_or_callback: Optional[Cert], /) -> "TlsConfigModel3.Builder": ...

        @overload
        def cert(
            self, value_or_callback: Callable[[Cert.Builder], Cert.Builder | Cert], /
        ) -> "TlsConfigModel3.Builder": ...

        @overload
        def cert(self, value_or_callback: Never = ...) -> "Cert.BuilderContext": ...

        def cert(self, value_or_callback=None, /):
            """
            Secret or ConfigMap containing the TLS certificate for the web server.

            Either `keySecret` or `keyFile` must be defined.

            It is mutually exclusive with `certFile`.
            """
            if self._in_context and value_or_callback is None:
                context = Cert.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cert.builder())
                if isinstance(output, Cert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert", value)

        def cert_file(self, value: Optional[str], /) -> Self:
            """
            Path to the TLS certificate file in the container for the web server.

            Either `keySecret` or `keyFile` must be defined.

            It is mutually exclusive with `cert`.
            """
            return self._set("cert_file", value)

        def cipher_suites(self, value: Optional[List[str]], /) -> Self:
            """
            List of supported cipher suites for TLS versions up to TLS 1.2.

            If not defined, the Go default cipher suites are used.
            Available cipher suites are documented in the Go documentation:
            https://golang.org/pkg/crypto/tls/#pkg-constants
            """
            return self._set("cipher_suites", value)

        @overload
        def client_ca(
            self, value_or_callback: Optional[ClientCa], /
        ) -> "TlsConfigModel3.Builder": ...

        @overload
        def client_ca(
            self,
            value_or_callback: Callable[[ClientCa.Builder], ClientCa.Builder | ClientCa],
            /,
        ) -> "TlsConfigModel3.Builder": ...

        @overload
        def client_ca(self, value_or_callback: Never = ...) -> "ClientCa.BuilderContext": ...

        def client_ca(self, value_or_callback=None, /):
            """
            Secret or ConfigMap containing the CA certificate for client certificate
            authentication to the server.

            It is mutually exclusive with `clientCAFile`.
            """
            if self._in_context and value_or_callback is None:
                context = ClientCa.BuilderContext()
                context._parent_builder = self
                context._field_name = "client_ca"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClientCa.builder())
                if isinstance(output, ClientCa.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("client_ca", value)

        def client_auth_type(self, value: Optional[str], /) -> Self:
            """
            The server policy for client TLS authentication.

            For more detail on clientAuth options:
            https://golang.org/pkg/crypto/tls/#ClientAuthType
            """
            return self._set("client_auth_type", value)

        def client_ca_file(self, value: Optional[str], /) -> Self:
            """
            Path to the CA certificate file for client certificate authentication to
            the server.

            It is mutually exclusive with `client_ca`.
            """
            return self._set("client_ca_file", value)

        def curve_preferences(self, value: Optional[List[str]], /) -> Self:
            """
            Elliptic curves that will be used in an ECDHE handshake, in preference
            order.

            Available curves are documented in the Go documentation:
            https://golang.org/pkg/crypto/tls/#CurveID
            """
            return self._set("curve_preferences", value)

        def key_file(self, value: Optional[str], /) -> Self:
            """
            Path to the TLS private key file in the container for the web server.

            If defined, either `cert` or `certFile` must be defined.

            It is mutually exclusive with `keySecret`.
            """
            return self._set("key_file", value)

        @overload
        def key_secret(
            self, value_or_callback: Optional[KeySecret], /
        ) -> "TlsConfigModel3.Builder": ...

        @overload
        def key_secret(
            self,
            value_or_callback: Callable[[KeySecret.Builder], KeySecret.Builder | KeySecret],
            /,
        ) -> "TlsConfigModel3.Builder": ...

        @overload
        def key_secret(self, value_or_callback: Never = ...) -> "KeySecret.BuilderContext": ...

        def key_secret(self, value_or_callback=None, /):
            """
            Secret containing the TLS private key for the web server.

            Either `cert` or `certFile` must be defined.

            It is mutually exclusive with `keyFile`.
            """
            if self._in_context and value_or_callback is None:
                context = KeySecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "key_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KeySecret.builder())
                if isinstance(output, KeySecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("key_secret", value)

        def max_version(self, value: Optional[str], /) -> Self:
            """
            Maximum TLS version that is acceptable.
            """
            return self._set("max_version", value)

        def min_version(self, value: Optional[str], /) -> Self:
            """
            Minimum TLS version that is acceptable.
            """
            return self._set("min_version", value)

        def prefer_server_cipher_suites(self, value: Optional[bool], /) -> Self:
            """
            Controls whether the server selects the client's most preferred cipher
            suite, or the server's most preferred cipher suite.

            If true then the server's preference, as expressed in
            the order of elements in cipherSuites, is used.
            """
            return self._set("prefer_server_cipher_suites", value)

    class BuilderContext(BuilderContextBase["TlsConfigModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsConfigModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsConfigModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsConfigModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsConfigModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cert: Optional[Cert] = None
    """
    Secret or ConfigMap containing the TLS certificate for the web server.

    Either `keySecret` or `keyFile` must be defined.

    It is mutually exclusive with `certFile`.
    """
    cert_file: Annotated[Optional[str], Field(alias="certFile")] = None
    """
    Path to the TLS certificate file in the container for the web server.

    Either `keySecret` or `keyFile` must be defined.

    It is mutually exclusive with `cert`.
    """
    cipher_suites: Annotated[Optional[List[str]], Field(alias="cipherSuites")] = None
    """
    List of supported cipher suites for TLS versions up to TLS 1.2.

    If not defined, the Go default cipher suites are used.
    Available cipher suites are documented in the Go documentation:
    https://golang.org/pkg/crypto/tls/#pkg-constants
    """
    client_ca: Optional[ClientCa] = None
    """
    Secret or ConfigMap containing the CA certificate for client certificate
    authentication to the server.

    It is mutually exclusive with `clientCAFile`.
    """
    client_auth_type: Annotated[Optional[str], Field(alias="clientAuthType")] = None
    """
    The server policy for client TLS authentication.

    For more detail on clientAuth options:
    https://golang.org/pkg/crypto/tls/#ClientAuthType
    """
    client_ca_file: Annotated[Optional[str], Field(alias="clientCAFile")] = None
    """
    Path to the CA certificate file for client certificate authentication to
    the server.

    It is mutually exclusive with `client_ca`.
    """
    curve_preferences: Annotated[Optional[List[str]], Field(alias="curvePreferences")] = None
    """
    Elliptic curves that will be used in an ECDHE handshake, in preference
    order.

    Available curves are documented in the Go documentation:
    https://golang.org/pkg/crypto/tls/#CurveID
    """
    key_file: Annotated[Optional[str], Field(alias="keyFile")] = None
    """
    Path to the TLS private key file in the container for the web server.

    If defined, either `cert` or `certFile` must be defined.

    It is mutually exclusive with `keySecret`.
    """
    key_secret: Annotated[Optional[KeySecret], Field(alias="keySecret")] = None
    """
    Secret containing the TLS private key for the web server.

    Either `cert` or `certFile` must be defined.

    It is mutually exclusive with `keyFile`.
    """
    max_version: Annotated[Optional[str], Field(alias="maxVersion")] = None
    """
    Maximum TLS version that is acceptable.
    """
    min_version: Annotated[Optional[str], Field(alias="minVersion")] = None
    """
    Minimum TLS version that is acceptable.
    """
    prefer_server_cipher_suites: Annotated[
        Optional[bool], Field(alias="preferServerCipherSuites")
    ] = None
    """
    Controls whether the server selects the client's most preferred cipher
    suite, or the server's most preferred cipher suite.

    If true then the server's preference, as expressed in
    the order of elements in cipherSuites, is used.
    """


class Web(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Web"]:
            return Web

        def build(self) -> "Web":
            return Web(**self._attrs)

        @overload
        def http_config(self, value_or_callback: Optional[HttpConfigModel], /) -> "Web.Builder": ...

        @overload
        def http_config(
            self,
            value_or_callback: Callable[
                [HttpConfigModel.Builder], HttpConfigModel.Builder | HttpConfigModel
            ],
            /,
        ) -> "Web.Builder": ...

        @overload
        def http_config(
            self, value_or_callback: Never = ...
        ) -> "HttpConfigModel.BuilderContext": ...

        def http_config(self, value_or_callback=None, /):
            """
            Defines HTTP parameters for web server.
            """
            if self._in_context and value_or_callback is None:
                context = HttpConfigModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpConfigModel.builder())
                if isinstance(output, HttpConfigModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_config", value)

        def max_connections(self, value: Optional[int], /) -> Self:
            """
            Defines the maximum number of simultaneous connections
            A zero value means that Prometheus doesn't accept any incoming connection.
            """
            return self._set("max_connections", value)

        def page_title(self, value: Optional[str], /) -> Self:
            """
            The prometheus web page title.
            """
            return self._set("page_title", value)

        @overload
        def tls_config(self, value_or_callback: Optional[TlsConfigModel3], /) -> "Web.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel3.Builder], TlsConfigModel3.Builder | TlsConfigModel3
            ],
            /,
        ) -> "Web.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel3.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            Defines the TLS parameters for HTTPS.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel3.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel3.builder())
                if isinstance(output, TlsConfigModel3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["Web.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Web.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Web."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Web", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Web.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    http_config: Annotated[Optional[HttpConfigModel], Field(alias="httpConfig")] = None
    """
    Defines HTTP parameters for web server.
    """
    max_connections: Annotated[Optional[int], Field(alias="maxConnections", ge=0)] = None
    """
    Defines the maximum number of simultaneous connections
    A zero value means that Prometheus doesn't accept any incoming connection.
    """
    page_title: Annotated[Optional[str], Field(alias="pageTitle")] = None
    """
    The prometheus web page title.
    """
    tls_config: Annotated[Optional[TlsConfigModel3], Field(alias="tlsConfig")] = None
    """
    Defines the TLS parameters for HTTPS.
    """


class PrometheusAgentSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PrometheusAgentSpec"]:
            return PrometheusAgentSpec

        def build(self) -> "PrometheusAgentSpec":
            return PrometheusAgentSpec(**self._attrs)

        @overload
        def additional_args(
            self, value_or_callback: List[AdditionalArg], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def additional_args(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AdditionalArg, AdditionalArg.Builder]],
                GenericListBuilder[AdditionalArg, AdditionalArg.Builder] | List[AdditionalArg],
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def additional_args(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[AdditionalArg.Builder]: ...

        def additional_args(self, value_or_callback=None, /):
            """
            AdditionalArgs allows setting additional arguments for the 'prometheus' container.

            It is intended for e.g. activating hidden flags which are not supported by
            the dedicated configuration options yet. The arguments are passed as-is to the
            Prometheus container which may cause issues if they are invalid or not supported
            by the given Prometheus version.

            In case of an argument conflict (e.g. an argument which is already set by the
            operator itself) or when providing an invalid argument, the reconciliation will
            fail and an error will be logged.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AdditionalArg.Builder]()
                context._parent_builder = self
                context._field_name = "additional_args"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AdditionalArg.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("additional_args", value)

        @overload
        def additional_scrape_configs(
            self, value_or_callback: Optional[AdditionalScrapeConfigs], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def additional_scrape_configs(
            self,
            value_or_callback: Callable[
                [AdditionalScrapeConfigs.Builder],
                AdditionalScrapeConfigs.Builder | AdditionalScrapeConfigs,
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def additional_scrape_configs(
            self, value_or_callback: Never = ...
        ) -> "AdditionalScrapeConfigs.BuilderContext": ...

        def additional_scrape_configs(self, value_or_callback=None, /):
            """
            AdditionalScrapeConfigs allows specifying a key of a Secret containing
            additional Prometheus scrape configurations. Scrape configurations
            specified are appended to the configurations generated by the Prometheus
            Operator. Job configurations specified must have the form as specified
            in the official Prometheus documentation:
            https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config.
            As scrape configs are appended, the user is responsible to make sure it
            is valid. Note that using this feature may expose the possibility to
            break upgrades of Prometheus. It is advised to review Prometheus release
            notes to ensure that no incompatible scrape configs are going to break
            Prometheus after the upgrade.
            """
            if self._in_context and value_or_callback is None:
                context = AdditionalScrapeConfigs.BuilderContext()
                context._parent_builder = self
                context._field_name = "additional_scrape_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AdditionalScrapeConfigs.builder())
                if isinstance(output, AdditionalScrapeConfigs.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("additional_scrape_configs", value)

        @overload
        def affinity(
            self, value_or_callback: Optional[Affinity], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def affinity(
            self,
            value_or_callback: Callable[[Affinity.Builder], Affinity.Builder | Affinity],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def affinity(self, value_or_callback: Never = ...) -> "Affinity.BuilderContext": ...

        def affinity(self, value_or_callback=None, /):
            """
            Defines the Pods' affinity scheduling rules if specified.
            """
            if self._in_context and value_or_callback is None:
                context = Affinity.BuilderContext()
                context._parent_builder = self
                context._field_name = "affinity"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Affinity.builder())
                if isinstance(output, Affinity.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("affinity", value)

        @overload
        def apiserver_config(
            self, value_or_callback: Optional[ApiserverConfig], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def apiserver_config(
            self,
            value_or_callback: Callable[
                [ApiserverConfig.Builder], ApiserverConfig.Builder | ApiserverConfig
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def apiserver_config(
            self, value_or_callback: Never = ...
        ) -> "ApiserverConfig.BuilderContext": ...

        def apiserver_config(self, value_or_callback=None, /):
            """
            APIServerConfig allows specifying a host and auth methods to access the
            Kuberntees API server.
            If null, Prometheus is assumed to run inside of the cluster: it will
            discover the API servers automatically and use the Pod's CA certificate
            and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
            """
            if self._in_context and value_or_callback is None:
                context = ApiserverConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "apiserver_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ApiserverConfig.builder())
                if isinstance(output, ApiserverConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("apiserver_config", value)

        @overload
        def arbitrary_fs_access_through_s_ms(
            self, value_or_callback: Optional[ArbitraryFsAccessThroughSMs], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def arbitrary_fs_access_through_s_ms(
            self,
            value_or_callback: Callable[
                [ArbitraryFsAccessThroughSMs.Builder],
                ArbitraryFsAccessThroughSMs.Builder | ArbitraryFsAccessThroughSMs,
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def arbitrary_fs_access_through_s_ms(
            self, value_or_callback: Never = ...
        ) -> "ArbitraryFsAccessThroughSMs.BuilderContext": ...

        def arbitrary_fs_access_through_s_ms(self, value_or_callback=None, /):
            """
            When true, ServiceMonitor, PodMonitor and Probe object are forbidden to
            reference arbitrary files on the file system of the 'prometheus'
            container.
            When a ServiceMonitor's endpoint specifies a `bearerTokenFile` value
            (e.g.  '/var/run/secrets/kubernetes.io/serviceaccount/token'), a
            malicious target can get access to the Prometheus service account's
            token in the Prometheus' scrape request. Setting
            `spec.arbitraryFSAccessThroughSM` to 'true' would prevent the attack.
            Users should instead provide the credentials using the
            `spec.bearerTokenSecret` field.
            """
            if self._in_context and value_or_callback is None:
                context = ArbitraryFsAccessThroughSMs.BuilderContext()
                context._parent_builder = self
                context._field_name = "arbitrary_fs_access_through_s_ms"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ArbitraryFsAccessThroughSMs.builder())
                if isinstance(output, ArbitraryFsAccessThroughSMs.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("arbitrary_fs_access_through_s_ms", value)

        def automount_service_account_token(self, value: Optional[bool], /) -> Self:
            """
            AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in the pod.
            If the field isn't set, the operator mounts the service account token by default.

            **Warning:** be aware that by default, Prometheus requires the service account token for Kubernetes service discovery.
            It is possible to use strategic merge patch to project the service account token into the 'prometheus' container.
            """
            return self._set("automount_service_account_token", value)

        def body_size_limit(self, value: Optional[str], /) -> Self:
            """
            BodySizeLimit defines per-scrape on response body size.
            Only valid in Prometheus versions 2.45.0 and newer.

            Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
            If you want to enforce a maximum limit for all scrape objects, refer to enforcedBodySizeLimit.
            """
            return self._set("body_size_limit", value)

        def config_maps(self, value: Optional[List[str]], /) -> Self:
            """
            ConfigMaps is a list of ConfigMaps in the same namespace as the Prometheus
            object, which shall be mounted into the Prometheus Pods.
            Each ConfigMap is added to the StatefulSet definition as a volume named `configmap-<configmap-name>`.
            The ConfigMaps are mounted into /etc/prometheus/configmaps/<configmap-name> in the 'prometheus' container.
            """
            return self._set("config_maps", value)

        @overload
        def containers(
            self, value_or_callback: List[Container], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def containers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Container, Container.Builder]],
                GenericListBuilder[Container, Container.Builder] | List[Container],
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def containers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Container.Builder]: ...

        def containers(self, value_or_callback=None, /):
            """
            Containers allows injecting additional containers or modifying operator
            generated containers. This can be used to allow adding an authentication
            proxy to the Pods or to change the behavior of an operator generated
            container. Containers described here modify an operator generated
            container if they share the same name and modifications are done via a
            strategic merge patch.

            The names of containers managed by the operator are:
            * `prometheus`
            * `config-reloader`
            * `thanos-sidecar`

            Overriding containers is entirely outside the scope of what the
            maintainers will support and by doing so, you accept that this behaviour
            may break at any time without notice.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Container.Builder]()
                context._parent_builder = self
                context._field_name = "containers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Container.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("containers", value)

        @overload
        def dns_config(
            self, value_or_callback: Optional[DnsConfig], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def dns_config(
            self,
            value_or_callback: Callable[[DnsConfig.Builder], DnsConfig.Builder | DnsConfig],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def dns_config(self, value_or_callback: Never = ...) -> "DnsConfig.BuilderContext": ...

        def dns_config(self, value_or_callback=None, /):
            """
            Defines the DNS configuration for the pods.
            """
            if self._in_context and value_or_callback is None:
                context = DnsConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "dns_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DnsConfig.builder())
                if isinstance(output, DnsConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("dns_config", value)

        def dns_policy(
            self,
            value: Optional[Literal["ClusterFirstWithHostNet", "ClusterFirst", "Default", "None"]],
            /,
        ) -> Self:
            """
            Defines the DNS policy for the pods.
            """
            return self._set("dns_policy", value)

        @overload
        def enable_features(
            self, value_or_callback: List[EnableFeature], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def enable_features(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[EnableFeature, EnableFeature.Builder]],
                GenericListBuilder[EnableFeature, EnableFeature.Builder] | List[EnableFeature],
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def enable_features(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[EnableFeature.Builder]: ...

        def enable_features(self, value_or_callback=None, /):
            """
            Enable access to Prometheus feature flags. By default, no features are enabled.

            Enabling features which are disabled by default is entirely outside the
            scope of what the maintainers will support and by doing so, you accept
            that this behaviour may break at any time without notice.

            For more information see https://prometheus.io/docs/prometheus/latest/feature_flags/
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[EnableFeature.Builder]()
                context._parent_builder = self
                context._field_name = "enable_features"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(EnableFeature.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("enable_features", value)

        def enable_otlp_receiver(self, value: Optional[bool], /) -> Self:
            """
            Enable Prometheus to be used as a receiver for the OTLP Metrics protocol.

            Note that the OTLP receiver endpoint is automatically enabled if `.spec.otlpConfig` is defined.

            It requires Prometheus >= v2.47.0.
            """
            return self._set("enable_otlp_receiver", value)

        def enable_remote_write_receiver(self, value: Optional[bool], /) -> Self:
            """
            Enable Prometheus to be used as a receiver for the Prometheus remote
            write protocol.

            WARNING: This is not considered an efficient way of ingesting samples.
            Use it with caution for specific low-volume use cases.
            It is not suitable for replacing the ingestion via scraping and turning
            Prometheus into a push-based metrics collection system.
            For more information see https://prometheus.io/docs/prometheus/latest/querying/api/#remote-write-receiver

            It requires Prometheus >= v2.33.0.
            """
            return self._set("enable_remote_write_receiver", value)

        def enforced_body_size_limit(self, value: Optional[str], /) -> Self:
            """
            When defined, enforcedBodySizeLimit specifies a global limit on the size
            of uncompressed response body that will be accepted by Prometheus.
            Targets responding with a body larger than this many bytes will cause
            the scrape to fail.

            It requires Prometheus >= v2.28.0.

            When both `enforcedBodySizeLimit` and `bodySizeLimit` are defined and greater than zero, the following rules apply:
            * Scrape objects without a defined bodySizeLimit value will inherit the global bodySizeLimit value (Prometheus >= 2.45.0) or the enforcedBodySizeLimit value (Prometheus < v2.45.0).
              If Prometheus version is >= 2.45.0 and the `enforcedBodySizeLimit` is greater than the `bodySizeLimit`, the `bodySizeLimit` will be set to `enforcedBodySizeLimit`.
            * Scrape objects with a bodySizeLimit value less than or equal to enforcedBodySizeLimit keep their specific value.
            * Scrape objects with a bodySizeLimit value greater than enforcedBodySizeLimit are set to enforcedBodySizeLimit.
            """
            return self._set("enforced_body_size_limit", value)

        def enforced_keep_dropped_targets(self, value: Optional[int], /) -> Self:
            """
            When defined, enforcedKeepDroppedTargets specifies a global limit on the number of targets
            dropped by relabeling that will be kept in memory. The value overrides
            any `spec.keepDroppedTargets` set by
            ServiceMonitor, PodMonitor, Probe objects unless `spec.keepDroppedTargets` is
            greater than zero and less than `spec.enforcedKeepDroppedTargets`.

            It requires Prometheus >= v2.47.0.

            When both `enforcedKeepDroppedTargets` and `keepDroppedTargets` are defined and greater than zero, the following rules apply:
            * Scrape objects without a defined keepDroppedTargets value will inherit the global keepDroppedTargets value (Prometheus >= 2.45.0) or the enforcedKeepDroppedTargets value (Prometheus < v2.45.0).
              If Prometheus version is >= 2.45.0 and the `enforcedKeepDroppedTargets` is greater than the `keepDroppedTargets`, the `keepDroppedTargets` will be set to `enforcedKeepDroppedTargets`.
            * Scrape objects with a keepDroppedTargets value less than or equal to enforcedKeepDroppedTargets keep their specific value.
            * Scrape objects with a keepDroppedTargets value greater than enforcedKeepDroppedTargets are set to enforcedKeepDroppedTargets.
            """
            return self._set("enforced_keep_dropped_targets", value)

        def enforced_label_limit(self, value: Optional[int], /) -> Self:
            """
            When defined, enforcedLabelLimit specifies a global limit on the number
            of labels per sample. The value overrides any `spec.labelLimit` set by
            ServiceMonitor, PodMonitor, Probe objects unless `spec.labelLimit` is
            greater than zero and less than `spec.enforcedLabelLimit`.

            It requires Prometheus >= v2.27.0.

            When both `enforcedLabelLimit` and `labelLimit` are defined and greater than zero, the following rules apply:
            * Scrape objects without a defined labelLimit value will inherit the global labelLimit value (Prometheus >= 2.45.0) or the enforcedLabelLimit value (Prometheus < v2.45.0).
              If Prometheus version is >= 2.45.0 and the `enforcedLabelLimit` is greater than the `labelLimit`, the `labelLimit` will be set to `enforcedLabelLimit`.
            * Scrape objects with a labelLimit value less than or equal to enforcedLabelLimit keep their specific value.
            * Scrape objects with a labelLimit value greater than enforcedLabelLimit are set to enforcedLabelLimit.
            """
            return self._set("enforced_label_limit", value)

        def enforced_label_name_length_limit(self, value: Optional[int], /) -> Self:
            """
            When defined, enforcedLabelNameLengthLimit specifies a global limit on the length
            of labels name per sample. The value overrides any `spec.labelNameLengthLimit` set by
            ServiceMonitor, PodMonitor, Probe objects unless `spec.labelNameLengthLimit` is
            greater than zero and less than `spec.enforcedLabelNameLengthLimit`.

            It requires Prometheus >= v2.27.0.

            When both `enforcedLabelNameLengthLimit` and `labelNameLengthLimit` are defined and greater than zero, the following rules apply:
            * Scrape objects without a defined labelNameLengthLimit value will inherit the global labelNameLengthLimit value (Prometheus >= 2.45.0) or the enforcedLabelNameLengthLimit value (Prometheus < v2.45.0).
              If Prometheus version is >= 2.45.0 and the `enforcedLabelNameLengthLimit` is greater than the `labelNameLengthLimit`, the `labelNameLengthLimit` will be set to `enforcedLabelNameLengthLimit`.
            * Scrape objects with a labelNameLengthLimit value less than or equal to enforcedLabelNameLengthLimit keep their specific value.
            * Scrape objects with a labelNameLengthLimit value greater than enforcedLabelNameLengthLimit are set to enforcedLabelNameLengthLimit.
            """
            return self._set("enforced_label_name_length_limit", value)

        def enforced_label_value_length_limit(self, value: Optional[int], /) -> Self:
            """
            When not null, enforcedLabelValueLengthLimit defines a global limit on the length
            of labels value per sample. The value overrides any `spec.labelValueLengthLimit` set by
            ServiceMonitor, PodMonitor, Probe objects unless `spec.labelValueLengthLimit` is
            greater than zero and less than `spec.enforcedLabelValueLengthLimit`.

            It requires Prometheus >= v2.27.0.

            When both `enforcedLabelValueLengthLimit` and `labelValueLengthLimit` are defined and greater than zero, the following rules apply:
            * Scrape objects without a defined labelValueLengthLimit value will inherit the global labelValueLengthLimit value (Prometheus >= 2.45.0) or the enforcedLabelValueLengthLimit value (Prometheus < v2.45.0).
              If Prometheus version is >= 2.45.0 and the `enforcedLabelValueLengthLimit` is greater than the `labelValueLengthLimit`, the `labelValueLengthLimit` will be set to `enforcedLabelValueLengthLimit`.
            * Scrape objects with a labelValueLengthLimit value less than or equal to enforcedLabelValueLengthLimit keep their specific value.
            * Scrape objects with a labelValueLengthLimit value greater than enforcedLabelValueLengthLimit are set to enforcedLabelValueLengthLimit.
            """
            return self._set("enforced_label_value_length_limit", value)

        def enforced_namespace_label(self, value: Optional[str], /) -> Self:
            """
            When not empty, a label will be added to:

            1. All metrics scraped from `ServiceMonitor`, `PodMonitor`, `Probe` and `ScrapeConfig` objects.
            2. All metrics generated from recording rules defined in `PrometheusRule` objects.
            3. All alerts generated from alerting rules defined in `PrometheusRule` objects.
            4. All vector selectors of PromQL expressions defined in `PrometheusRule` objects.

            The label will not added for objects referenced in `spec.excludedFromEnforcement`.

            The label's name is this field's value.
            The label's value is the namespace of the `ServiceMonitor`,
            `PodMonitor`, `Probe`, `PrometheusRule` or `ScrapeConfig` object.
            """
            return self._set("enforced_namespace_label", value)

        def enforced_sample_limit(self, value: Optional[int], /) -> Self:
            """
            When defined, enforcedSampleLimit specifies a global limit on the number
            of scraped samples that will be accepted. This overrides any
            `spec.sampleLimit` set by ServiceMonitor, PodMonitor, Probe objects
            unless `spec.sampleLimit` is greater than zero and less than
            `spec.enforcedSampleLimit`.

            It is meant to be used by admins to keep the overall number of
            samples/series under a desired limit.

            When both `enforcedSampleLimit` and `sampleLimit` are defined and greater than zero, the following rules apply:
            * Scrape objects without a defined sampleLimit value will inherit the global sampleLimit value (Prometheus >= 2.45.0) or the enforcedSampleLimit value (Prometheus < v2.45.0).
              If Prometheus version is >= 2.45.0 and the `enforcedSampleLimit` is greater than the `sampleLimit`, the `sampleLimit` will be set to `enforcedSampleLimit`.
            * Scrape objects with a sampleLimit value less than or equal to enforcedSampleLimit keep their specific value.
            * Scrape objects with a sampleLimit value greater than enforcedSampleLimit are set to enforcedSampleLimit.
            """
            return self._set("enforced_sample_limit", value)

        def enforced_target_limit(self, value: Optional[int], /) -> Self:
            """
            When defined, enforcedTargetLimit specifies a global limit on the number
            of scraped targets. The value overrides any `spec.targetLimit` set by
            ServiceMonitor, PodMonitor, Probe objects unless `spec.targetLimit` is
            greater than zero and less than `spec.enforcedTargetLimit`.

            It is meant to be used by admins to to keep the overall number of
            targets under a desired limit.

            When both `enforcedTargetLimit` and `targetLimit` are defined and greater than zero, the following rules apply:
            * Scrape objects without a defined targetLimit value will inherit the global targetLimit value (Prometheus >= 2.45.0) or the enforcedTargetLimit value (Prometheus < v2.45.0).
              If Prometheus version is >= 2.45.0 and the `enforcedTargetLimit` is greater than the `targetLimit`, the `targetLimit` will be set to `enforcedTargetLimit`.
            * Scrape objects with a targetLimit value less than or equal to enforcedTargetLimit keep their specific value.
            * Scrape objects with a targetLimit value greater than enforcedTargetLimit are set to enforcedTargetLimit.
            """
            return self._set("enforced_target_limit", value)

        @overload
        def excluded_from_enforcement(
            self, value_or_callback: List[ExcludedFromEnforcement], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def excluded_from_enforcement(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ExcludedFromEnforcement, ExcludedFromEnforcement.Builder]],
                GenericListBuilder[ExcludedFromEnforcement, ExcludedFromEnforcement.Builder]
                | List[ExcludedFromEnforcement],
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def excluded_from_enforcement(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ExcludedFromEnforcement.Builder]: ...

        def excluded_from_enforcement(self, value_or_callback=None, /):
            """
            List of references to PodMonitor, ServiceMonitor, Probe and PrometheusRule objects
            to be excluded from enforcing a namespace label of origin.

            It is only applicable if `spec.enforcedNamespaceLabel` set to true.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ExcludedFromEnforcement.Builder]()
                context._parent_builder = self
                context._field_name = "excluded_from_enforcement"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ExcludedFromEnforcement.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("excluded_from_enforcement", value)

        def external_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            The labels to add to any time series or alerts when communicating with
            external systems (federation, remote storage, Alertmanager).
            Labels defined by `spec.replicaExternalLabelName` and
            `spec.prometheusExternalLabelName` take precedence over this list.
            """
            return self._set("external_labels", value)

        def external_url(self, value: Optional[str], /) -> Self:
            """
            The external URL under which the Prometheus service is externally
            available. This is necessary to generate correct URLs (for instance if
            Prometheus is accessible behind an Ingress resource).
            """
            return self._set("external_url", value)

        @overload
        def host_aliases(
            self, value_or_callback: List[HostAliase], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def host_aliases(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[HostAliase, HostAliase.Builder]],
                GenericListBuilder[HostAliase, HostAliase.Builder] | List[HostAliase],
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def host_aliases(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[HostAliase.Builder]: ...

        def host_aliases(self, value_or_callback=None, /):
            """
            Optional list of hosts and IPs that will be injected into the Pod's
            hosts file if specified.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[HostAliase.Builder]()
                context._parent_builder = self
                context._field_name = "host_aliases"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HostAliase.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("host_aliases", value)

        def host_network(self, value: Optional[bool], /) -> Self:
            """
            Use the host's network namespace if true.

            Make sure to understand the security implications if you want to enable
            it (https://kubernetes.io/docs/concepts/configuration/overview/).

            When hostNetwork is enabled, this will set the DNS policy to
            `ClusterFirstWithHostNet` automatically (unless `.spec.DNSPolicy` is set
            to a different value).
            """
            return self._set("host_network", value)

        def ignore_namespace_selectors(self, value: Optional[bool], /) -> Self:
            """
            When true, `spec.namespaceSelector` from all PodMonitor, ServiceMonitor
            and Probe objects will be ignored. They will only discover targets
            within the namespace of the PodMonitor, ServiceMonitor and Probe
            object.
            """
            return self._set("ignore_namespace_selectors", value)

        def image(self, value: Optional[str], /) -> Self:
            """
            Container image name for Prometheus. If specified, it takes precedence
            over the `spec.baseImage`, `spec.tag` and `spec.sha` fields.

            Specifying `spec.version` is still necessary to ensure the Prometheus
            Operator knows which version of Prometheus is being configured.

            If neither `spec.image` nor `spec.baseImage` are defined, the operator
            will use the latest upstream version of Prometheus available at the time
            when the operator was released.
            """
            return self._set("image", value)

        def image_pull_policy(
            self, value: Optional[Literal["", "Always", "Never", "IfNotPresent"]], /
        ) -> Self:
            """
            Image pull policy for the 'prometheus', 'init-config-reloader' and 'config-reloader' containers.
            See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
            """
            return self._set("image_pull_policy", value)

        @overload
        def image_pull_secrets(
            self, value_or_callback: List[ImagePullSecret], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def image_pull_secrets(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ImagePullSecret, ImagePullSecret.Builder]],
                GenericListBuilder[ImagePullSecret, ImagePullSecret.Builder]
                | List[ImagePullSecret],
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def image_pull_secrets(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ImagePullSecret.Builder]: ...

        def image_pull_secrets(self, value_or_callback=None, /):
            """
            An optional list of references to Secrets in the same namespace
            to use for pulling images from registries.
            See http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ImagePullSecret.Builder]()
                context._parent_builder = self
                context._field_name = "image_pull_secrets"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImagePullSecret.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("image_pull_secrets", value)

        @overload
        def init_containers(
            self, value_or_callback: List[InitContainer], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def init_containers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[InitContainer, InitContainer.Builder]],
                GenericListBuilder[InitContainer, InitContainer.Builder] | List[InitContainer],
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def init_containers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[InitContainer.Builder]: ...

        def init_containers(self, value_or_callback=None, /):
            """
            InitContainers allows injecting initContainers to the Pod definition. Those
            can be used to e.g.  fetch secrets for injection into the Prometheus
            configuration from external sources. Any errors during the execution of
            an initContainer will lead to a restart of the Pod. More info:
            https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
            InitContainers described here modify an operator generated init
            containers if they share the same name and modifications are done via a
            strategic merge patch.

            The names of init container name managed by the operator are:
            * `init-config-reloader`.

            Overriding init containers is entirely outside the scope of what the
            maintainers will support and by doing so, you accept that this behaviour
            may break at any time without notice.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[InitContainer.Builder]()
                context._parent_builder = self
                context._field_name = "init_containers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitContainer.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_containers", value)

        def keep_dropped_targets(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on the number of targets dropped by relabeling
            that will be kept in memory. 0 means no limit.

            It requires Prometheus >= v2.47.0.

            Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
            If you want to enforce a maximum limit for all scrape objects, refer to enforcedKeepDroppedTargets.
            """
            return self._set("keep_dropped_targets", value)

        def label_limit(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on number of labels that will be accepted for a sample.
            Only valid in Prometheus versions 2.45.0 and newer.

            Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
            If you want to enforce a maximum limit for all scrape objects, refer to enforcedLabelLimit.
            """
            return self._set("label_limit", value)

        def label_name_length_limit(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on length of labels name that will be accepted for a sample.
            Only valid in Prometheus versions 2.45.0 and newer.

            Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
            If you want to enforce a maximum limit for all scrape objects, refer to enforcedLabelNameLengthLimit.
            """
            return self._set("label_name_length_limit", value)

        def label_value_length_limit(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on length of labels value that will be accepted for a sample.
            Only valid in Prometheus versions 2.45.0 and newer.

            Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
            If you want to enforce a maximum limit for all scrape objects, refer to enforcedLabelValueLengthLimit.
            """
            return self._set("label_value_length_limit", value)

        def listen_local(self, value: Optional[bool], /) -> Self:
            """
            When true, the Prometheus server listens on the loopback address
            instead of the Pod IP's address.
            """
            return self._set("listen_local", value)

        def log_format(self, value: Optional[Literal["", "logfmt", "json"]], /) -> Self:
            """
            Log format for Log level for Prometheus and the config-reloader sidecar.
            """
            return self._set("log_format", value)

        def log_level(
            self, value: Optional[Literal["", "debug", "info", "warn", "error"]], /
        ) -> Self:
            """
            Log level for Prometheus and the config-reloader sidecar.
            """
            return self._set("log_level", value)

        def maximum_startup_duration_seconds(self, value: Optional[int], /) -> Self:
            """
            Defines the maximum time that the `prometheus` container's startup probe will wait before being considered failed. The startup probe will return success after the WAL replay is complete.
            If set, the value should be greater than 60 (seconds). Otherwise it will be equal to 600 seconds (15 minutes).
            """
            return self._set("maximum_startup_duration_seconds", value)

        def min_ready_seconds(self, value: Optional[int], /) -> Self:
            """
            Minimum number of seconds for which a newly created Pod should be ready
            without any of its container crashing for it to be considered available.
            Defaults to 0 (pod will be considered available as soon as it is ready)

            This is an alpha field from kubernetes 1.22 until 1.24 which requires
            enabling the StatefulSetMinReadySeconds feature gate.
            """
            return self._set("min_ready_seconds", value)

        def mode(self, value: Optional[Literal["StatefulSet", "DaemonSet"]], /) -> Self:
            """
            Mode defines how the Prometheus operator deploys the PrometheusAgent pod(s).

            (Alpha) Using this field requires the `PrometheusAgentDaemonSet` feature gate to be enabled.
            """
            return self._set("mode", value)

        def name_validation_scheme(self, value: Optional[Literal["UTF8", "Legacy"]], /) -> Self:
            """
            Specifies the validation scheme for metric and label names.
            """
            return self._set("name_validation_scheme", value)

        def node_selector(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Defines on which Nodes the Pods are scheduled.
            """
            return self._set("node_selector", value)

        @overload
        def otlp(self, value_or_callback: Optional[Otlp], /) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def otlp(
            self, value_or_callback: Callable[[Otlp.Builder], Otlp.Builder | Otlp], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def otlp(self, value_or_callback: Never = ...) -> "Otlp.BuilderContext": ...

        def otlp(self, value_or_callback=None, /):
            """
            Settings related to the OTLP receiver feature.
            It requires Prometheus >= v2.55.0.
            """
            if self._in_context and value_or_callback is None:
                context = Otlp.BuilderContext()
                context._parent_builder = self
                context._field_name = "otlp"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Otlp.builder())
                if isinstance(output, Otlp.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("otlp", value)

        def override_honor_labels(self, value: Optional[bool], /) -> Self:
            """
            When true, Prometheus resolves label conflicts by renaming the labels in the scraped data
             to exported_ for all targets created from ServiceMonitor, PodMonitor and
            ScrapeConfig objects. Otherwise the HonorLabels field of the service or pod monitor applies.
            In practice,`overrideHonorLaels:true` enforces `honorLabels:false`
            for all ServiceMonitor, PodMonitor and ScrapeConfig objects.
            """
            return self._set("override_honor_labels", value)

        def override_honor_timestamps(self, value: Optional[bool], /) -> Self:
            """
            When true, Prometheus ignores the timestamps for all the targets created
            from service and pod monitors.
            Otherwise the HonorTimestamps field of the service or pod monitor applies.
            """
            return self._set("override_honor_timestamps", value)

        def paused(self, value: Optional[bool], /) -> Self:
            """
            When a Prometheus deployment is paused, no actions except for deletion
            will be performed on the underlying objects.
            """
            return self._set("paused", value)

        @overload
        def persistent_volume_claim_retention_policy(
            self, value_or_callback: Optional[PersistentVolumeClaimRetentionPolicy], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def persistent_volume_claim_retention_policy(
            self,
            value_or_callback: Callable[
                [PersistentVolumeClaimRetentionPolicy.Builder],
                PersistentVolumeClaimRetentionPolicy.Builder | PersistentVolumeClaimRetentionPolicy,
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def persistent_volume_claim_retention_policy(
            self, value_or_callback: Never = ...
        ) -> "PersistentVolumeClaimRetentionPolicy.BuilderContext": ...

        def persistent_volume_claim_retention_policy(self, value_or_callback=None, /):
            """
            The field controls if and how PVCs are deleted during the lifecycle of a StatefulSet.
            The default behavior is all PVCs are retained.
            This is an alpha field from kubernetes 1.23 until 1.26 and a beta field from 1.26.
            It requires enabling the StatefulSetAutoDeletePVC feature gate.
            """
            if self._in_context and value_or_callback is None:
                context = PersistentVolumeClaimRetentionPolicy.BuilderContext()
                context._parent_builder = self
                context._field_name = "persistent_volume_claim_retention_policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PersistentVolumeClaimRetentionPolicy.builder())
                if isinstance(output, PersistentVolumeClaimRetentionPolicy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("persistent_volume_claim_retention_policy", value)

        @overload
        def pod_metadata(
            self, value_or_callback: Optional[PodMetadata], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def pod_metadata(
            self,
            value_or_callback: Callable[[PodMetadata.Builder], PodMetadata.Builder | PodMetadata],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def pod_metadata(self, value_or_callback: Never = ...) -> "PodMetadata.BuilderContext": ...

        def pod_metadata(self, value_or_callback=None, /):
            """
            PodMetadata configures labels and annotations which are propagated to the Prometheus pods.

            The following items are reserved and cannot be overridden:
            * "prometheus" label, set to the name of the Prometheus object.
            * "app.kubernetes.io/instance" label, set to the name of the Prometheus object.
            * "app.kubernetes.io/managed-by" label, set to "prometheus-operator".
            * "app.kubernetes.io/name" label, set to "prometheus".
            * "app.kubernetes.io/version" label, set to the Prometheus version.
            * "operator.prometheus.io/name" label, set to the name of the Prometheus object.
            * "operator.prometheus.io/shard" label, set to the shard number of the Prometheus object.
            * "kubectl.kubernetes.io/default-container" annotation, set to "prometheus".
            """
            if self._in_context and value_or_callback is None:
                context = PodMetadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "pod_metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodMetadata.builder())
                if isinstance(output, PodMetadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("pod_metadata", value)

        @overload
        def pod_monitor_namespace_selector(
            self, value_or_callback: Optional[PodMonitorNamespaceSelector], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def pod_monitor_namespace_selector(
            self,
            value_or_callback: Callable[
                [PodMonitorNamespaceSelector.Builder],
                PodMonitorNamespaceSelector.Builder | PodMonitorNamespaceSelector,
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def pod_monitor_namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "PodMonitorNamespaceSelector.BuilderContext": ...

        def pod_monitor_namespace_selector(self, value_or_callback=None, /):
            """
            Namespaces to match for PodMonitors discovery. An empty label selector
            matches all namespaces. A null label selector (default value) matches the current
            namespace only.
            """
            if self._in_context and value_or_callback is None:
                context = PodMonitorNamespaceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "pod_monitor_namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodMonitorNamespaceSelector.builder())
                if isinstance(output, PodMonitorNamespaceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("pod_monitor_namespace_selector", value)

        @overload
        def pod_monitor_selector(
            self, value_or_callback: Optional[PodMonitorSelector], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def pod_monitor_selector(
            self,
            value_or_callback: Callable[
                [PodMonitorSelector.Builder],
                PodMonitorSelector.Builder | PodMonitorSelector,
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def pod_monitor_selector(
            self, value_or_callback: Never = ...
        ) -> "PodMonitorSelector.BuilderContext": ...

        def pod_monitor_selector(self, value_or_callback=None, /):
            """
            PodMonitors to be selected for target discovery. An empty label selector
            matches all objects. A null label selector matches no objects.

            If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
            and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
            The Prometheus operator will ensure that the Prometheus configuration's
            Secret exists, but it is the responsibility of the user to provide the raw
            gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
            This behavior is *deprecated* and will be removed in the next major version
            of the custom resource definition. It is recommended to use
            `spec.additionalScrapeConfigs` instead.
            """
            if self._in_context and value_or_callback is None:
                context = PodMonitorSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "pod_monitor_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodMonitorSelector.builder())
                if isinstance(output, PodMonitorSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("pod_monitor_selector", value)

        def pod_target_labels(self, value: Optional[List[str]], /) -> Self:
            """
            PodTargetLabels are appended to the `spec.podTargetLabels` field of all
            PodMonitor and ServiceMonitor objects.
            """
            return self._set("pod_target_labels", value)

        def port_name(self, value: Optional[str], /) -> Self:
            """
            Port name used for the pods and governing service.
            Default: "web"
            """
            return self._set("port_name", value)

        def priority_class_name(self, value: Optional[str], /) -> Self:
            """
            Priority class assigned to the Pods.
            """
            return self._set("priority_class_name", value)

        @overload
        def probe_namespace_selector(
            self, value_or_callback: Optional[ProbeNamespaceSelector], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def probe_namespace_selector(
            self,
            value_or_callback: Callable[
                [ProbeNamespaceSelector.Builder],
                ProbeNamespaceSelector.Builder | ProbeNamespaceSelector,
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def probe_namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "ProbeNamespaceSelector.BuilderContext": ...

        def probe_namespace_selector(self, value_or_callback=None, /):
            """
            Namespaces to match for Probe discovery. An empty label
            selector matches all namespaces. A null label selector matches the
            current namespace only.
            """
            if self._in_context and value_or_callback is None:
                context = ProbeNamespaceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "probe_namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProbeNamespaceSelector.builder())
                if isinstance(output, ProbeNamespaceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("probe_namespace_selector", value)

        @overload
        def probe_selector(
            self, value_or_callback: Optional[ProbeSelector], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def probe_selector(
            self,
            value_or_callback: Callable[
                [ProbeSelector.Builder], ProbeSelector.Builder | ProbeSelector
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def probe_selector(
            self, value_or_callback: Never = ...
        ) -> "ProbeSelector.BuilderContext": ...

        def probe_selector(self, value_or_callback=None, /):
            """
            Probes to be selected for target discovery. An empty label selector
            matches all objects. A null label selector matches no objects.

            If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
            and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
            The Prometheus operator will ensure that the Prometheus configuration's
            Secret exists, but it is the responsibility of the user to provide the raw
            gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
            This behavior is *deprecated* and will be removed in the next major version
            of the custom resource definition. It is recommended to use
            `spec.additionalScrapeConfigs` instead.
            """
            if self._in_context and value_or_callback is None:
                context = ProbeSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "probe_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProbeSelector.builder())
                if isinstance(output, ProbeSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("probe_selector", value)

        def prometheus_external_label_name(self, value: Optional[str], /) -> Self:
            """
            Name of Prometheus external label used to denote the Prometheus instance
            name. The external label will _not_ be added when the field is set to
            the empty string (`""`).

            Default: "prometheus"
            """
            return self._set("prometheus_external_label_name", value)

        def reload_strategy(self, value: Optional[Literal["HTTP", "ProcessSignal"]], /) -> Self:
            """
            Defines the strategy used to reload the Prometheus configuration.
            If not specified, the configuration is reloaded using the /-/reload HTTP endpoint.
            """
            return self._set("reload_strategy", value)

        @overload
        def remote_write(
            self, value_or_callback: List[RemoteWrite], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def remote_write(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[RemoteWrite, RemoteWrite.Builder]],
                GenericListBuilder[RemoteWrite, RemoteWrite.Builder] | List[RemoteWrite],
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def remote_write(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[RemoteWrite.Builder]: ...

        def remote_write(self, value_or_callback=None, /):
            """
            Defines the list of remote write configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[RemoteWrite.Builder]()
                context._parent_builder = self
                context._field_name = "remote_write"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RemoteWrite.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("remote_write", value)

        def remote_write_receiver_message_versions(
            self, value: Optional[List[Literal["V1.0", "V2.0"]]], /
        ) -> Self:
            """
            List of the protobuf message versions to accept when receiving the
            remote writes.

            It requires Prometheus >= v2.54.0.
            """
            return self._set("remote_write_receiver_message_versions", value)

        def replica_external_label_name(self, value: Optional[str], /) -> Self:
            """
            Name of Prometheus external label used to denote the replica name.
            The external label will _not_ be added when the field is set to the
            empty string (`""`).

            Default: "prometheus_replica"
            """
            return self._set("replica_external_label_name", value)

        def replicas(self, value: Optional[int], /) -> Self:
            """
            Number of replicas of each shard to deploy for a Prometheus deployment.
            `spec.replicas` multiplied by `spec.shards` is the total number of Pods
            created.

            Default: 1
            """
            return self._set("replicas", value)

        @overload
        def resources(
            self, value_or_callback: Optional[Resources], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            Defines the resources requests and limits of the 'prometheus' container.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def route_prefix(self, value: Optional[str], /) -> Self:
            """
            The route prefix Prometheus registers HTTP handlers for.

            This is useful when using `spec.externalURL`, and a proxy is rewriting
            HTTP routes of a request, and the actual ExternalURL is still true, but
            the server serves requests under a different route prefix. For example
            for use with `kubectl proxy`.
            """
            return self._set("route_prefix", value)

        @overload
        def runtime(
            self, value_or_callback: Optional[Runtime], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def runtime(
            self,
            value_or_callback: Callable[[Runtime.Builder], Runtime.Builder | Runtime],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def runtime(self, value_or_callback: Never = ...) -> "Runtime.BuilderContext": ...

        def runtime(self, value_or_callback=None, /):
            """
            RuntimeConfig configures the values for the Prometheus process behavior
            """
            if self._in_context and value_or_callback is None:
                context = Runtime.BuilderContext()
                context._parent_builder = self
                context._field_name = "runtime"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Runtime.builder())
                if isinstance(output, Runtime.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("runtime", value)

        def sample_limit(self, value: Optional[int], /) -> Self:
            """
            SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
            Only valid in Prometheus versions 2.45.0 and newer.

            Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
            If you want to enforce a maximum limit for all scrape objects, refer to enforcedSampleLimit.
            """
            return self._set("sample_limit", value)

        @overload
        def scrape_classes(
            self, value_or_callback: List[ScrapeClass], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def scrape_classes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ScrapeClass, ScrapeClass.Builder]],
                GenericListBuilder[ScrapeClass, ScrapeClass.Builder] | List[ScrapeClass],
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def scrape_classes(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ScrapeClass.Builder]: ...

        def scrape_classes(self, value_or_callback=None, /):
            """
            List of scrape classes to expose to scraping objects such as
            PodMonitors, ServiceMonitors, Probes and ScrapeConfigs.

            This is an *experimental feature*, it may change in any upcoming release
            in a breaking way.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ScrapeClass.Builder]()
                context._parent_builder = self
                context._field_name = "scrape_classes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ScrapeClass.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("scrape_classes", value)

        @overload
        def scrape_config_namespace_selector(
            self, value_or_callback: Optional[ScrapeConfigNamespaceSelector], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def scrape_config_namespace_selector(
            self,
            value_or_callback: Callable[
                [ScrapeConfigNamespaceSelector.Builder],
                ScrapeConfigNamespaceSelector.Builder | ScrapeConfigNamespaceSelector,
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def scrape_config_namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "ScrapeConfigNamespaceSelector.BuilderContext": ...

        def scrape_config_namespace_selector(self, value_or_callback=None, /):
            """
            Namespaces to match for ScrapeConfig discovery. An empty label selector
            matches all namespaces. A null label selector matches the current
            namespace only.

            Note that the ScrapeConfig custom resource definition is currently at Alpha level.
            """
            if self._in_context and value_or_callback is None:
                context = ScrapeConfigNamespaceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "scrape_config_namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ScrapeConfigNamespaceSelector.builder())
                if isinstance(output, ScrapeConfigNamespaceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("scrape_config_namespace_selector", value)

        @overload
        def scrape_config_selector(
            self, value_or_callback: Optional[ScrapeConfigSelector], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def scrape_config_selector(
            self,
            value_or_callback: Callable[
                [ScrapeConfigSelector.Builder],
                ScrapeConfigSelector.Builder | ScrapeConfigSelector,
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def scrape_config_selector(
            self, value_or_callback: Never = ...
        ) -> "ScrapeConfigSelector.BuilderContext": ...

        def scrape_config_selector(self, value_or_callback=None, /):
            """
            ScrapeConfigs to be selected for target discovery. An empty label
            selector matches all objects. A null label selector matches no objects.

            If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
            and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
            The Prometheus operator will ensure that the Prometheus configuration's
            Secret exists, but it is the responsibility of the user to provide the raw
            gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
            This behavior is *deprecated* and will be removed in the next major version
            of the custom resource definition. It is recommended to use
            `spec.additionalScrapeConfigs` instead.

            Note that the ScrapeConfig custom resource definition is currently at Alpha level.
            """
            if self._in_context and value_or_callback is None:
                context = ScrapeConfigSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "scrape_config_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ScrapeConfigSelector.builder())
                if isinstance(output, ScrapeConfigSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("scrape_config_selector", value)

        def scrape_failure_log_file(self, value: Optional[str], /) -> Self:
            """
            File to which scrape failures are logged.
            Reloading the configuration will reopen the file.

            If the filename has an empty path, e.g. 'file.log', The Prometheus Pods
            will mount the file into an emptyDir volume at `/var/log/prometheus`.
            If a full path is provided, e.g. '/var/log/prometheus/file.log', you
            must mount a volume in the specified directory and it must be writable.
            It requires Prometheus >= v2.55.0.
            """
            return self._set("scrape_failure_log_file", value)

        def scrape_interval(self, value: Optional[str], /) -> Self:
            """
            Interval between consecutive scrapes.

            Default: "30s"
            """
            return self._set("scrape_interval", value)

        def scrape_protocols(
            self,
            value: Optional[
                List[
                    Literal[
                        "PrometheusProto",
                        "OpenMetricsText0.0.1",
                        "OpenMetricsText1.0.0",
                        "PrometheusText0.0.4",
                        "PrometheusText1.0.0",
                    ]
                ]
            ],
            /,
        ) -> Self:
            """
            The protocols to negotiate during a scrape. It tells clients the
            protocols supported by Prometheus in order of preference (from most to least preferred).

            If unset, Prometheus uses its default value.

            It requires Prometheus >= v2.49.0.

            `PrometheusText1.0.0` requires Prometheus >= v3.0.0.
            """
            return self._set("scrape_protocols", value)

        def scrape_timeout(self, value: Optional[str], /) -> Self:
            """
            Number of seconds to wait until a scrape request times out.
            The value cannot be greater than the scrape interval otherwise the operator will reject the resource.
            """
            return self._set("scrape_timeout", value)

        def secrets(self, value: Optional[List[str]], /) -> Self:
            """
            Secrets is a list of Secrets in the same namespace as the Prometheus
            object, which shall be mounted into the Prometheus Pods.
            Each Secret is added to the StatefulSet definition as a volume named `secret-<secret-name>`.
            The Secrets are mounted into /etc/prometheus/secrets/<secret-name> in the 'prometheus' container.
            """
            return self._set("secrets", value)

        @overload
        def security_context(
            self, value_or_callback: Optional[SecurityContextModel], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def security_context(
            self,
            value_or_callback: Callable[
                [SecurityContextModel.Builder],
                SecurityContextModel.Builder | SecurityContextModel,
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def security_context(
            self, value_or_callback: Never = ...
        ) -> "SecurityContextModel.BuilderContext": ...

        def security_context(self, value_or_callback=None, /):
            """
            SecurityContext holds pod-level security attributes and common container settings.
            This defaults to the default PodSecurityContext.
            """
            if self._in_context and value_or_callback is None:
                context = SecurityContextModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "security_context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecurityContextModel.builder())
                if isinstance(output, SecurityContextModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("security_context", value)

        def service_account_name(self, value: Optional[str], /) -> Self:
            """
            ServiceAccountName is the name of the ServiceAccount to use to run the
            Prometheus Pods.
            """
            return self._set("service_account_name", value)

        def service_discovery_role(
            self, value: Optional[Literal["Endpoints", "EndpointSlice"]], /
        ) -> Self:
            """
            Defines the service discovery role used to discover targets from
            `ServiceMonitor` objects and Alertmanager endpoints.

            If set, the value should be either "Endpoints" or "EndpointSlice".
            If unset, the operator assumes the "Endpoints" role.
            """
            return self._set("service_discovery_role", value)

        @overload
        def service_monitor_namespace_selector(
            self, value_or_callback: Optional[ServiceMonitorNamespaceSelector], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def service_monitor_namespace_selector(
            self,
            value_or_callback: Callable[
                [ServiceMonitorNamespaceSelector.Builder],
                ServiceMonitorNamespaceSelector.Builder | ServiceMonitorNamespaceSelector,
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def service_monitor_namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "ServiceMonitorNamespaceSelector.BuilderContext": ...

        def service_monitor_namespace_selector(self, value_or_callback=None, /):
            """
            Namespaces to match for ServicedMonitors discovery. An empty label selector
            matches all namespaces. A null label selector (default value) matches the current
            namespace only.
            """
            if self._in_context and value_or_callback is None:
                context = ServiceMonitorNamespaceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_monitor_namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceMonitorNamespaceSelector.builder())
                if isinstance(output, ServiceMonitorNamespaceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_monitor_namespace_selector", value)

        @overload
        def service_monitor_selector(
            self, value_or_callback: Optional[ServiceMonitorSelector], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def service_monitor_selector(
            self,
            value_or_callback: Callable[
                [ServiceMonitorSelector.Builder],
                ServiceMonitorSelector.Builder | ServiceMonitorSelector,
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def service_monitor_selector(
            self, value_or_callback: Never = ...
        ) -> "ServiceMonitorSelector.BuilderContext": ...

        def service_monitor_selector(self, value_or_callback=None, /):
            """
            ServiceMonitors to be selected for target discovery. An empty label
            selector matches all objects. A null label selector matches no objects.

            If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
            and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
            The Prometheus operator will ensure that the Prometheus configuration's
            Secret exists, but it is the responsibility of the user to provide the raw
            gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
            This behavior is *deprecated* and will be removed in the next major version
            of the custom resource definition. It is recommended to use
            `spec.additionalScrapeConfigs` instead.
            """
            if self._in_context and value_or_callback is None:
                context = ServiceMonitorSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_monitor_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceMonitorSelector.builder())
                if isinstance(output, ServiceMonitorSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_monitor_selector", value)

        def service_name(self, value: Optional[str], /) -> Self:
            """
            The name of the service name used by the underlying StatefulSet(s) as the governing service.
            If defined, the Service  must be created before the Prometheus/PrometheusAgent resource in the same namespace and it must define a selector that matches the pod labels.
            If empty, the operator will create and manage a headless service named `prometheus-operated` for Prometheus resources,
            or `prometheus-agent-operated` for PrometheusAgent resources.
            When deploying multiple Prometheus/PrometheusAgent resources in the same namespace, it is recommended to specify a different value for each.
            See https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#stable-network-id for more details.
            """
            return self._set("service_name", value)

        def shards(self, value: Optional[int], /) -> Self:
            """
            Number of shards to distribute scraped targets onto.

            `spec.replicas` multiplied by `spec.shards` is the total number of Pods
            being created.

            When not defined, the operator assumes only one shard.

            Note that scaling down shards will not reshard data onto the remaining
            instances, it must be manually moved. Increasing shards will not reshard
            data either but it will continue to be available from the same
            instances. To query globally, use Thanos sidecar and Thanos querier or
            remote write data to a central location.
            Alerting and recording rules

            By default, the sharding is performed on:
            * The `__address__` target's metadata label for PodMonitor,
            ServiceMonitor and ScrapeConfig resources.
            * The `__param_target__` label for Probe resources.

            Users can define their own sharding implementation by setting the
            `__tmp_hash` label during the target discovery with relabeling
            configuration (either in the monitoring resources or via scrape class).
            """
            return self._set("shards", value)

        @overload
        def storage(
            self, value_or_callback: Optional[Storage], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def storage(
            self,
            value_or_callback: Callable[[Storage.Builder], Storage.Builder | Storage],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def storage(self, value_or_callback: Never = ...) -> "Storage.BuilderContext": ...

        def storage(self, value_or_callback=None, /):
            """
            Storage defines the storage used by Prometheus.
            """
            if self._in_context and value_or_callback is None:
                context = Storage.BuilderContext()
                context._parent_builder = self
                context._field_name = "storage"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Storage.builder())
                if isinstance(output, Storage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("storage", value)

        def target_limit(self, value: Optional[int], /) -> Self:
            """
            TargetLimit defines a limit on the number of scraped targets that will be accepted.
            Only valid in Prometheus versions 2.45.0 and newer.

            Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
            If you want to enforce a maximum limit for all scrape objects, refer to enforcedTargetLimit.
            """
            return self._set("target_limit", value)

        @overload
        def tolerations(
            self, value_or_callback: List[Toleration], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def tolerations(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Toleration, Toleration.Builder]],
                GenericListBuilder[Toleration, Toleration.Builder] | List[Toleration],
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def tolerations(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Toleration.Builder]: ...

        def tolerations(self, value_or_callback=None, /):
            """
            Defines the Pods' tolerations if specified.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Toleration.Builder]()
                context._parent_builder = self
                context._field_name = "tolerations"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Toleration.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("tolerations", value)

        @overload
        def topology_spread_constraints(
            self, value_or_callback: List[TopologySpreadConstraint], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def topology_spread_constraints(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[TopologySpreadConstraint, TopologySpreadConstraint.Builder]],
                GenericListBuilder[TopologySpreadConstraint, TopologySpreadConstraint.Builder]
                | List[TopologySpreadConstraint],
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def topology_spread_constraints(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[TopologySpreadConstraint.Builder]: ...

        def topology_spread_constraints(self, value_or_callback=None, /):
            """
            Defines the pod's topology spread constraints if specified.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[TopologySpreadConstraint.Builder]()
                context._parent_builder = self
                context._field_name = "topology_spread_constraints"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TopologySpreadConstraint.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("topology_spread_constraints", value)

        @overload
        def tracing_config(
            self, value_or_callback: Optional[TracingConfig], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def tracing_config(
            self,
            value_or_callback: Callable[
                [TracingConfig.Builder], TracingConfig.Builder | TracingConfig
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def tracing_config(
            self, value_or_callback: Never = ...
        ) -> "TracingConfig.BuilderContext": ...

        def tracing_config(self, value_or_callback=None, /):
            """
            TracingConfig configures tracing in Prometheus.

            This is an *experimental feature*, it may change in any upcoming release
            in a breaking way.
            """
            if self._in_context and value_or_callback is None:
                context = TracingConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "tracing_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TracingConfig.builder())
                if isinstance(output, TracingConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tracing_config", value)

        @overload
        def tsdb(self, value_or_callback: Optional[Tsdb], /) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def tsdb(
            self, value_or_callback: Callable[[Tsdb.Builder], Tsdb.Builder | Tsdb], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def tsdb(self, value_or_callback: Never = ...) -> "Tsdb.BuilderContext": ...

        def tsdb(self, value_or_callback=None, /):
            """
            Defines the runtime reloadable configuration of the timeseries database(TSDB).
            It requires Prometheus >= v2.39.0 or PrometheusAgent >= v2.54.0.
            """
            if self._in_context and value_or_callback is None:
                context = Tsdb.BuilderContext()
                context._parent_builder = self
                context._field_name = "tsdb"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Tsdb.builder())
                if isinstance(output, Tsdb.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tsdb", value)

        def version(self, value: Optional[str], /) -> Self:
            """
            Version of Prometheus being deployed. The operator uses this information
            to generate the Prometheus StatefulSet + configuration files.

            If not specified, the operator assumes the latest upstream version of
            Prometheus available at the time when the version of the operator was
            released.
            """
            return self._set("version", value)

        @overload
        def volume_mounts(
            self, value_or_callback: List[VolumeMount], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def volume_mounts(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[VolumeMount, VolumeMount.Builder]],
                GenericListBuilder[VolumeMount, VolumeMount.Builder] | List[VolumeMount],
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def volume_mounts(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[VolumeMount.Builder]: ...

        def volume_mounts(self, value_or_callback=None, /):
            """
            VolumeMounts allows the configuration of additional VolumeMounts.

            VolumeMounts will be appended to other VolumeMounts in the 'prometheus'
            container, that are generated as a result of StorageSpec objects.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[VolumeMount.Builder]()
                context._parent_builder = self
                context._field_name = "volume_mounts"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VolumeMount.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("volume_mounts", value)

        @overload
        def volumes(self, value_or_callback: List[Volume], /) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def volumes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Volume, Volume.Builder]],
                GenericListBuilder[Volume, Volume.Builder] | List[Volume],
            ],
            /,
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def volumes(self, value_or_callback: Never = ...) -> ListBuilderContext[Volume.Builder]: ...

        def volumes(self, value_or_callback=None, /):
            """
            Volumes allows the configuration of additional volumes on the output
            StatefulSet definition. Volumes specified will be appended to other
            volumes that are generated as a result of StorageSpec objects.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Volume.Builder]()
                context._parent_builder = self
                context._field_name = "volumes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Volume.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("volumes", value)

        def wal_compression(self, value: Optional[bool], /) -> Self:
            """
            Configures compression of the write-ahead log (WAL) using Snappy.

            WAL compression is enabled by default for Prometheus >= 2.20.0

            Requires Prometheus v2.11.0 and above.
            """
            return self._set("wal_compression", value)

        @overload
        def web(self, value_or_callback: Optional[Web], /) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def web(
            self, value_or_callback: Callable[[Web.Builder], Web.Builder | Web], /
        ) -> "PrometheusAgentSpec.Builder": ...

        @overload
        def web(self, value_or_callback: Never = ...) -> "Web.BuilderContext": ...

        def web(self, value_or_callback=None, /):
            """
            Defines the configuration of the Prometheus web server.
            """
            if self._in_context and value_or_callback is None:
                context = Web.BuilderContext()
                context._parent_builder = self
                context._field_name = "web"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Web.builder())
                if isinstance(output, Web.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("web", value)

    class BuilderContext(BuilderContextBase["PrometheusAgentSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PrometheusAgentSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PrometheusAgentSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PrometheusAgentSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PrometheusAgentSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    additional_args: Annotated[Optional[List[AdditionalArg]], Field(alias="additionalArgs")] = None
    """
    AdditionalArgs allows setting additional arguments for the 'prometheus' container.

    It is intended for e.g. activating hidden flags which are not supported by
    the dedicated configuration options yet. The arguments are passed as-is to the
    Prometheus container which may cause issues if they are invalid or not supported
    by the given Prometheus version.

    In case of an argument conflict (e.g. an argument which is already set by the
    operator itself) or when providing an invalid argument, the reconciliation will
    fail and an error will be logged.
    """
    additional_scrape_configs: Annotated[
        Optional[AdditionalScrapeConfigs], Field(alias="additionalScrapeConfigs")
    ] = None
    """
    AdditionalScrapeConfigs allows specifying a key of a Secret containing
    additional Prometheus scrape configurations. Scrape configurations
    specified are appended to the configurations generated by the Prometheus
    Operator. Job configurations specified must have the form as specified
    in the official Prometheus documentation:
    https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config.
    As scrape configs are appended, the user is responsible to make sure it
    is valid. Note that using this feature may expose the possibility to
    break upgrades of Prometheus. It is advised to review Prometheus release
    notes to ensure that no incompatible scrape configs are going to break
    Prometheus after the upgrade.
    """
    affinity: Optional[Affinity] = None
    """
    Defines the Pods' affinity scheduling rules if specified.
    """
    apiserver_config: Annotated[Optional[ApiserverConfig], Field(alias="apiserverConfig")] = None
    """
    APIServerConfig allows specifying a host and auth methods to access the
    Kuberntees API server.
    If null, Prometheus is assumed to run inside of the cluster: it will
    discover the API servers automatically and use the Pod's CA certificate
    and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
    """
    arbitrary_fs_access_through_s_ms: Annotated[
        Optional[ArbitraryFsAccessThroughSMs],
        Field(alias="arbitraryFSAccessThroughSMs"),
    ] = None
    """
    When true, ServiceMonitor, PodMonitor and Probe object are forbidden to
    reference arbitrary files on the file system of the 'prometheus'
    container.
    When a ServiceMonitor's endpoint specifies a `bearerTokenFile` value
    (e.g.  '/var/run/secrets/kubernetes.io/serviceaccount/token'), a
    malicious target can get access to the Prometheus service account's
    token in the Prometheus' scrape request. Setting
    `spec.arbitraryFSAccessThroughSM` to 'true' would prevent the attack.
    Users should instead provide the credentials using the
    `spec.bearerTokenSecret` field.
    """
    automount_service_account_token: Annotated[
        Optional[bool], Field(alias="automountServiceAccountToken")
    ] = None
    """
    AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in the pod.
    If the field isn't set, the operator mounts the service account token by default.

    **Warning:** be aware that by default, Prometheus requires the service account token for Kubernetes service discovery.
    It is possible to use strategic merge patch to project the service account token into the 'prometheus' container.
    """
    body_size_limit: Annotated[
        Optional[str],
        Field(alias="bodySizeLimit", pattern="(^0|([0-9]*[.])?[0-9]+((K|M|G|T|E|P)i?)?B)$"),
    ] = None
    """
    BodySizeLimit defines per-scrape on response body size.
    Only valid in Prometheus versions 2.45.0 and newer.

    Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
    If you want to enforce a maximum limit for all scrape objects, refer to enforcedBodySizeLimit.
    """
    config_maps: Annotated[Optional[List[str]], Field(alias="configMaps")] = None
    """
    ConfigMaps is a list of ConfigMaps in the same namespace as the Prometheus
    object, which shall be mounted into the Prometheus Pods.
    Each ConfigMap is added to the StatefulSet definition as a volume named `configmap-<configmap-name>`.
    The ConfigMaps are mounted into /etc/prometheus/configmaps/<configmap-name> in the 'prometheus' container.
    """
    containers: Optional[List[Container]] = None
    """
    Containers allows injecting additional containers or modifying operator
    generated containers. This can be used to allow adding an authentication
    proxy to the Pods or to change the behavior of an operator generated
    container. Containers described here modify an operator generated
    container if they share the same name and modifications are done via a
    strategic merge patch.

    The names of containers managed by the operator are:
    * `prometheus`
    * `config-reloader`
    * `thanos-sidecar`

    Overriding containers is entirely outside the scope of what the
    maintainers will support and by doing so, you accept that this behaviour
    may break at any time without notice.
    """
    dns_config: Annotated[Optional[DnsConfig], Field(alias="dnsConfig")] = None
    """
    Defines the DNS configuration for the pods.
    """
    dns_policy: Annotated[
        Optional[Literal["ClusterFirstWithHostNet", "ClusterFirst", "Default", "None"]],
        Field(alias="dnsPolicy"),
    ] = None
    """
    Defines the DNS policy for the pods.
    """
    enable_features: Annotated[Optional[List[EnableFeature]], Field(alias="enableFeatures")] = None
    """
    Enable access to Prometheus feature flags. By default, no features are enabled.

    Enabling features which are disabled by default is entirely outside the
    scope of what the maintainers will support and by doing so, you accept
    that this behaviour may break at any time without notice.

    For more information see https://prometheus.io/docs/prometheus/latest/feature_flags/
    """
    enable_otlp_receiver: Annotated[Optional[bool], Field(alias="enableOTLPReceiver")] = None
    """
    Enable Prometheus to be used as a receiver for the OTLP Metrics protocol.

    Note that the OTLP receiver endpoint is automatically enabled if `.spec.otlpConfig` is defined.

    It requires Prometheus >= v2.47.0.
    """
    enable_remote_write_receiver: Annotated[
        Optional[bool], Field(alias="enableRemoteWriteReceiver")
    ] = None
    """
    Enable Prometheus to be used as a receiver for the Prometheus remote
    write protocol.

    WARNING: This is not considered an efficient way of ingesting samples.
    Use it with caution for specific low-volume use cases.
    It is not suitable for replacing the ingestion via scraping and turning
    Prometheus into a push-based metrics collection system.
    For more information see https://prometheus.io/docs/prometheus/latest/querying/api/#remote-write-receiver

    It requires Prometheus >= v2.33.0.
    """
    enforced_body_size_limit: Annotated[
        Optional[str],
        Field(
            alias="enforcedBodySizeLimit",
            pattern="(^0|([0-9]*[.])?[0-9]+((K|M|G|T|E|P)i?)?B)$",
        ),
    ] = None
    """
    When defined, enforcedBodySizeLimit specifies a global limit on the size
    of uncompressed response body that will be accepted by Prometheus.
    Targets responding with a body larger than this many bytes will cause
    the scrape to fail.

    It requires Prometheus >= v2.28.0.

    When both `enforcedBodySizeLimit` and `bodySizeLimit` are defined and greater than zero, the following rules apply:
    * Scrape objects without a defined bodySizeLimit value will inherit the global bodySizeLimit value (Prometheus >= 2.45.0) or the enforcedBodySizeLimit value (Prometheus < v2.45.0).
      If Prometheus version is >= 2.45.0 and the `enforcedBodySizeLimit` is greater than the `bodySizeLimit`, the `bodySizeLimit` will be set to `enforcedBodySizeLimit`.
    * Scrape objects with a bodySizeLimit value less than or equal to enforcedBodySizeLimit keep their specific value.
    * Scrape objects with a bodySizeLimit value greater than enforcedBodySizeLimit are set to enforcedBodySizeLimit.
    """
    enforced_keep_dropped_targets: Annotated[
        Optional[int], Field(alias="enforcedKeepDroppedTargets")
    ] = None
    """
    When defined, enforcedKeepDroppedTargets specifies a global limit on the number of targets
    dropped by relabeling that will be kept in memory. The value overrides
    any `spec.keepDroppedTargets` set by
    ServiceMonitor, PodMonitor, Probe objects unless `spec.keepDroppedTargets` is
    greater than zero and less than `spec.enforcedKeepDroppedTargets`.

    It requires Prometheus >= v2.47.0.

    When both `enforcedKeepDroppedTargets` and `keepDroppedTargets` are defined and greater than zero, the following rules apply:
    * Scrape objects without a defined keepDroppedTargets value will inherit the global keepDroppedTargets value (Prometheus >= 2.45.0) or the enforcedKeepDroppedTargets value (Prometheus < v2.45.0).
      If Prometheus version is >= 2.45.0 and the `enforcedKeepDroppedTargets` is greater than the `keepDroppedTargets`, the `keepDroppedTargets` will be set to `enforcedKeepDroppedTargets`.
    * Scrape objects with a keepDroppedTargets value less than or equal to enforcedKeepDroppedTargets keep their specific value.
    * Scrape objects with a keepDroppedTargets value greater than enforcedKeepDroppedTargets are set to enforcedKeepDroppedTargets.
    """
    enforced_label_limit: Annotated[Optional[int], Field(alias="enforcedLabelLimit")] = None
    """
    When defined, enforcedLabelLimit specifies a global limit on the number
    of labels per sample. The value overrides any `spec.labelLimit` set by
    ServiceMonitor, PodMonitor, Probe objects unless `spec.labelLimit` is
    greater than zero and less than `spec.enforcedLabelLimit`.

    It requires Prometheus >= v2.27.0.

    When both `enforcedLabelLimit` and `labelLimit` are defined and greater than zero, the following rules apply:
    * Scrape objects without a defined labelLimit value will inherit the global labelLimit value (Prometheus >= 2.45.0) or the enforcedLabelLimit value (Prometheus < v2.45.0).
      If Prometheus version is >= 2.45.0 and the `enforcedLabelLimit` is greater than the `labelLimit`, the `labelLimit` will be set to `enforcedLabelLimit`.
    * Scrape objects with a labelLimit value less than or equal to enforcedLabelLimit keep their specific value.
    * Scrape objects with a labelLimit value greater than enforcedLabelLimit are set to enforcedLabelLimit.
    """
    enforced_label_name_length_limit: Annotated[
        Optional[int], Field(alias="enforcedLabelNameLengthLimit")
    ] = None
    """
    When defined, enforcedLabelNameLengthLimit specifies a global limit on the length
    of labels name per sample. The value overrides any `spec.labelNameLengthLimit` set by
    ServiceMonitor, PodMonitor, Probe objects unless `spec.labelNameLengthLimit` is
    greater than zero and less than `spec.enforcedLabelNameLengthLimit`.

    It requires Prometheus >= v2.27.0.

    When both `enforcedLabelNameLengthLimit` and `labelNameLengthLimit` are defined and greater than zero, the following rules apply:
    * Scrape objects without a defined labelNameLengthLimit value will inherit the global labelNameLengthLimit value (Prometheus >= 2.45.0) or the enforcedLabelNameLengthLimit value (Prometheus < v2.45.0).
      If Prometheus version is >= 2.45.0 and the `enforcedLabelNameLengthLimit` is greater than the `labelNameLengthLimit`, the `labelNameLengthLimit` will be set to `enforcedLabelNameLengthLimit`.
    * Scrape objects with a labelNameLengthLimit value less than or equal to enforcedLabelNameLengthLimit keep their specific value.
    * Scrape objects with a labelNameLengthLimit value greater than enforcedLabelNameLengthLimit are set to enforcedLabelNameLengthLimit.
    """
    enforced_label_value_length_limit: Annotated[
        Optional[int], Field(alias="enforcedLabelValueLengthLimit")
    ] = None
    """
    When not null, enforcedLabelValueLengthLimit defines a global limit on the length
    of labels value per sample. The value overrides any `spec.labelValueLengthLimit` set by
    ServiceMonitor, PodMonitor, Probe objects unless `spec.labelValueLengthLimit` is
    greater than zero and less than `spec.enforcedLabelValueLengthLimit`.

    It requires Prometheus >= v2.27.0.

    When both `enforcedLabelValueLengthLimit` and `labelValueLengthLimit` are defined and greater than zero, the following rules apply:
    * Scrape objects without a defined labelValueLengthLimit value will inherit the global labelValueLengthLimit value (Prometheus >= 2.45.0) or the enforcedLabelValueLengthLimit value (Prometheus < v2.45.0).
      If Prometheus version is >= 2.45.0 and the `enforcedLabelValueLengthLimit` is greater than the `labelValueLengthLimit`, the `labelValueLengthLimit` will be set to `enforcedLabelValueLengthLimit`.
    * Scrape objects with a labelValueLengthLimit value less than or equal to enforcedLabelValueLengthLimit keep their specific value.
    * Scrape objects with a labelValueLengthLimit value greater than enforcedLabelValueLengthLimit are set to enforcedLabelValueLengthLimit.
    """
    enforced_namespace_label: Annotated[Optional[str], Field(alias="enforcedNamespaceLabel")] = None
    """
    When not empty, a label will be added to:

    1. All metrics scraped from `ServiceMonitor`, `PodMonitor`, `Probe` and `ScrapeConfig` objects.
    2. All metrics generated from recording rules defined in `PrometheusRule` objects.
    3. All alerts generated from alerting rules defined in `PrometheusRule` objects.
    4. All vector selectors of PromQL expressions defined in `PrometheusRule` objects.

    The label will not added for objects referenced in `spec.excludedFromEnforcement`.

    The label's name is this field's value.
    The label's value is the namespace of the `ServiceMonitor`,
    `PodMonitor`, `Probe`, `PrometheusRule` or `ScrapeConfig` object.
    """
    enforced_sample_limit: Annotated[Optional[int], Field(alias="enforcedSampleLimit")] = None
    """
    When defined, enforcedSampleLimit specifies a global limit on the number
    of scraped samples that will be accepted. This overrides any
    `spec.sampleLimit` set by ServiceMonitor, PodMonitor, Probe objects
    unless `spec.sampleLimit` is greater than zero and less than
    `spec.enforcedSampleLimit`.

    It is meant to be used by admins to keep the overall number of
    samples/series under a desired limit.

    When both `enforcedSampleLimit` and `sampleLimit` are defined and greater than zero, the following rules apply:
    * Scrape objects without a defined sampleLimit value will inherit the global sampleLimit value (Prometheus >= 2.45.0) or the enforcedSampleLimit value (Prometheus < v2.45.0).
      If Prometheus version is >= 2.45.0 and the `enforcedSampleLimit` is greater than the `sampleLimit`, the `sampleLimit` will be set to `enforcedSampleLimit`.
    * Scrape objects with a sampleLimit value less than or equal to enforcedSampleLimit keep their specific value.
    * Scrape objects with a sampleLimit value greater than enforcedSampleLimit are set to enforcedSampleLimit.
    """
    enforced_target_limit: Annotated[Optional[int], Field(alias="enforcedTargetLimit")] = None
    """
    When defined, enforcedTargetLimit specifies a global limit on the number
    of scraped targets. The value overrides any `spec.targetLimit` set by
    ServiceMonitor, PodMonitor, Probe objects unless `spec.targetLimit` is
    greater than zero and less than `spec.enforcedTargetLimit`.

    It is meant to be used by admins to to keep the overall number of
    targets under a desired limit.

    When both `enforcedTargetLimit` and `targetLimit` are defined and greater than zero, the following rules apply:
    * Scrape objects without a defined targetLimit value will inherit the global targetLimit value (Prometheus >= 2.45.0) or the enforcedTargetLimit value (Prometheus < v2.45.0).
      If Prometheus version is >= 2.45.0 and the `enforcedTargetLimit` is greater than the `targetLimit`, the `targetLimit` will be set to `enforcedTargetLimit`.
    * Scrape objects with a targetLimit value less than or equal to enforcedTargetLimit keep their specific value.
    * Scrape objects with a targetLimit value greater than enforcedTargetLimit are set to enforcedTargetLimit.
    """
    excluded_from_enforcement: Annotated[
        Optional[List[ExcludedFromEnforcement]], Field(alias="excludedFromEnforcement")
    ] = None
    """
    List of references to PodMonitor, ServiceMonitor, Probe and PrometheusRule objects
    to be excluded from enforcing a namespace label of origin.

    It is only applicable if `spec.enforcedNamespaceLabel` set to true.
    """
    external_labels: Annotated[Optional[Dict[str, str]], Field(alias="externalLabels")] = None
    """
    The labels to add to any time series or alerts when communicating with
    external systems (federation, remote storage, Alertmanager).
    Labels defined by `spec.replicaExternalLabelName` and
    `spec.prometheusExternalLabelName` take precedence over this list.
    """
    external_url: Annotated[Optional[str], Field(alias="externalUrl")] = None
    """
    The external URL under which the Prometheus service is externally
    available. This is necessary to generate correct URLs (for instance if
    Prometheus is accessible behind an Ingress resource).
    """
    host_aliases: Annotated[Optional[List[HostAliase]], Field(alias="hostAliases")] = None
    """
    Optional list of hosts and IPs that will be injected into the Pod's
    hosts file if specified.
    """
    host_network: Annotated[Optional[bool], Field(alias="hostNetwork")] = None
    """
    Use the host's network namespace if true.

    Make sure to understand the security implications if you want to enable
    it (https://kubernetes.io/docs/concepts/configuration/overview/).

    When hostNetwork is enabled, this will set the DNS policy to
    `ClusterFirstWithHostNet` automatically (unless `.spec.DNSPolicy` is set
    to a different value).
    """
    ignore_namespace_selectors: Annotated[
        Optional[bool], Field(alias="ignoreNamespaceSelectors")
    ] = None
    """
    When true, `spec.namespaceSelector` from all PodMonitor, ServiceMonitor
    and Probe objects will be ignored. They will only discover targets
    within the namespace of the PodMonitor, ServiceMonitor and Probe
    object.
    """
    image: Optional[str] = None
    """
    Container image name for Prometheus. If specified, it takes precedence
    over the `spec.baseImage`, `spec.tag` and `spec.sha` fields.

    Specifying `spec.version` is still necessary to ensure the Prometheus
    Operator knows which version of Prometheus is being configured.

    If neither `spec.image` nor `spec.baseImage` are defined, the operator
    will use the latest upstream version of Prometheus available at the time
    when the operator was released.
    """
    image_pull_policy: Annotated[
        Optional[Literal["", "Always", "Never", "IfNotPresent"]],
        Field(alias="imagePullPolicy"),
    ] = None
    """
    Image pull policy for the 'prometheus', 'init-config-reloader' and 'config-reloader' containers.
    See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
    """
    image_pull_secrets: Annotated[
        Optional[List[ImagePullSecret]], Field(alias="imagePullSecrets")
    ] = None
    """
    An optional list of references to Secrets in the same namespace
    to use for pulling images from registries.
    See http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
    """
    init_containers: Annotated[Optional[List[InitContainer]], Field(alias="initContainers")] = None
    """
    InitContainers allows injecting initContainers to the Pod definition. Those
    can be used to e.g.  fetch secrets for injection into the Prometheus
    configuration from external sources. Any errors during the execution of
    an initContainer will lead to a restart of the Pod. More info:
    https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
    InitContainers described here modify an operator generated init
    containers if they share the same name and modifications are done via a
    strategic merge patch.

    The names of init container name managed by the operator are:
    * `init-config-reloader`.

    Overriding init containers is entirely outside the scope of what the
    maintainers will support and by doing so, you accept that this behaviour
    may break at any time without notice.
    """
    keep_dropped_targets: Annotated[Optional[int], Field(alias="keepDroppedTargets")] = None
    """
    Per-scrape limit on the number of targets dropped by relabeling
    that will be kept in memory. 0 means no limit.

    It requires Prometheus >= v2.47.0.

    Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
    If you want to enforce a maximum limit for all scrape objects, refer to enforcedKeepDroppedTargets.
    """
    label_limit: Annotated[Optional[int], Field(alias="labelLimit")] = None
    """
    Per-scrape limit on number of labels that will be accepted for a sample.
    Only valid in Prometheus versions 2.45.0 and newer.

    Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
    If you want to enforce a maximum limit for all scrape objects, refer to enforcedLabelLimit.
    """
    label_name_length_limit: Annotated[Optional[int], Field(alias="labelNameLengthLimit")] = None
    """
    Per-scrape limit on length of labels name that will be accepted for a sample.
    Only valid in Prometheus versions 2.45.0 and newer.

    Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
    If you want to enforce a maximum limit for all scrape objects, refer to enforcedLabelNameLengthLimit.
    """
    label_value_length_limit: Annotated[Optional[int], Field(alias="labelValueLengthLimit")] = None
    """
    Per-scrape limit on length of labels value that will be accepted for a sample.
    Only valid in Prometheus versions 2.45.0 and newer.

    Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
    If you want to enforce a maximum limit for all scrape objects, refer to enforcedLabelValueLengthLimit.
    """
    listen_local: Annotated[Optional[bool], Field(alias="listenLocal")] = None
    """
    When true, the Prometheus server listens on the loopback address
    instead of the Pod IP's address.
    """
    log_format: Annotated[Optional[Literal["", "logfmt", "json"]], Field(alias="logFormat")] = None
    """
    Log format for Log level for Prometheus and the config-reloader sidecar.
    """
    log_level: Annotated[
        Optional[Literal["", "debug", "info", "warn", "error"]], Field(alias="logLevel")
    ] = None
    """
    Log level for Prometheus and the config-reloader sidecar.
    """
    maximum_startup_duration_seconds: Annotated[
        Optional[int], Field(alias="maximumStartupDurationSeconds", ge=60)
    ] = None
    """
    Defines the maximum time that the `prometheus` container's startup probe will wait before being considered failed. The startup probe will return success after the WAL replay is complete.
    If set, the value should be greater than 60 (seconds). Otherwise it will be equal to 600 seconds (15 minutes).
    """
    min_ready_seconds: Annotated[Optional[int], Field(alias="minReadySeconds")] = None
    """
    Minimum number of seconds for which a newly created Pod should be ready
    without any of its container crashing for it to be considered available.
    Defaults to 0 (pod will be considered available as soon as it is ready)

    This is an alpha field from kubernetes 1.22 until 1.24 which requires
    enabling the StatefulSetMinReadySeconds feature gate.
    """
    mode: Optional[Literal["StatefulSet", "DaemonSet"]] = None
    """
    Mode defines how the Prometheus operator deploys the PrometheusAgent pod(s).

    (Alpha) Using this field requires the `PrometheusAgentDaemonSet` feature gate to be enabled.
    """
    name_validation_scheme: Annotated[
        Optional[Literal["UTF8", "Legacy"]], Field(alias="nameValidationScheme")
    ] = None
    """
    Specifies the validation scheme for metric and label names.
    """
    node_selector: Annotated[Optional[Dict[str, str]], Field(alias="nodeSelector")] = None
    """
    Defines on which Nodes the Pods are scheduled.
    """
    otlp: Optional[Otlp] = None
    """
    Settings related to the OTLP receiver feature.
    It requires Prometheus >= v2.55.0.
    """
    override_honor_labels: Annotated[Optional[bool], Field(alias="overrideHonorLabels")] = None
    """
    When true, Prometheus resolves label conflicts by renaming the labels in the scraped data
     to exported_ for all targets created from ServiceMonitor, PodMonitor and
    ScrapeConfig objects. Otherwise the HonorLabels field of the service or pod monitor applies.
    In practice,`overrideHonorLaels:true` enforces `honorLabels:false`
    for all ServiceMonitor, PodMonitor and ScrapeConfig objects.
    """
    override_honor_timestamps: Annotated[Optional[bool], Field(alias="overrideHonorTimestamps")] = (
        None
    )
    """
    When true, Prometheus ignores the timestamps for all the targets created
    from service and pod monitors.
    Otherwise the HonorTimestamps field of the service or pod monitor applies.
    """
    paused: Optional[bool] = None
    """
    When a Prometheus deployment is paused, no actions except for deletion
    will be performed on the underlying objects.
    """
    persistent_volume_claim_retention_policy: Annotated[
        Optional[PersistentVolumeClaimRetentionPolicy],
        Field(alias="persistentVolumeClaimRetentionPolicy"),
    ] = None
    """
    The field controls if and how PVCs are deleted during the lifecycle of a StatefulSet.
    The default behavior is all PVCs are retained.
    This is an alpha field from kubernetes 1.23 until 1.26 and a beta field from 1.26.
    It requires enabling the StatefulSetAutoDeletePVC feature gate.
    """
    pod_metadata: Annotated[Optional[PodMetadata], Field(alias="podMetadata")] = None
    """
    PodMetadata configures labels and annotations which are propagated to the Prometheus pods.

    The following items are reserved and cannot be overridden:
    * "prometheus" label, set to the name of the Prometheus object.
    * "app.kubernetes.io/instance" label, set to the name of the Prometheus object.
    * "app.kubernetes.io/managed-by" label, set to "prometheus-operator".
    * "app.kubernetes.io/name" label, set to "prometheus".
    * "app.kubernetes.io/version" label, set to the Prometheus version.
    * "operator.prometheus.io/name" label, set to the name of the Prometheus object.
    * "operator.prometheus.io/shard" label, set to the shard number of the Prometheus object.
    * "kubectl.kubernetes.io/default-container" annotation, set to "prometheus".
    """
    pod_monitor_namespace_selector: Annotated[
        Optional[PodMonitorNamespaceSelector],
        Field(alias="podMonitorNamespaceSelector"),
    ] = None
    """
    Namespaces to match for PodMonitors discovery. An empty label selector
    matches all namespaces. A null label selector (default value) matches the current
    namespace only.
    """
    pod_monitor_selector: Annotated[
        Optional[PodMonitorSelector], Field(alias="podMonitorSelector")
    ] = None
    """
    PodMonitors to be selected for target discovery. An empty label selector
    matches all objects. A null label selector matches no objects.

    If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
    and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
    The Prometheus operator will ensure that the Prometheus configuration's
    Secret exists, but it is the responsibility of the user to provide the raw
    gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
    This behavior is *deprecated* and will be removed in the next major version
    of the custom resource definition. It is recommended to use
    `spec.additionalScrapeConfigs` instead.
    """
    pod_target_labels: Annotated[Optional[List[str]], Field(alias="podTargetLabels")] = None
    """
    PodTargetLabels are appended to the `spec.podTargetLabels` field of all
    PodMonitor and ServiceMonitor objects.
    """
    port_name: Annotated[Optional[str], Field(alias="portName")] = "web"
    """
    Port name used for the pods and governing service.
    Default: "web"
    """
    priority_class_name: Annotated[Optional[str], Field(alias="priorityClassName")] = None
    """
    Priority class assigned to the Pods.
    """
    probe_namespace_selector: Annotated[
        Optional[ProbeNamespaceSelector], Field(alias="probeNamespaceSelector")
    ] = None
    """
    Namespaces to match for Probe discovery. An empty label
    selector matches all namespaces. A null label selector matches the
    current namespace only.
    """
    probe_selector: Annotated[Optional[ProbeSelector], Field(alias="probeSelector")] = None
    """
    Probes to be selected for target discovery. An empty label selector
    matches all objects. A null label selector matches no objects.

    If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
    and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
    The Prometheus operator will ensure that the Prometheus configuration's
    Secret exists, but it is the responsibility of the user to provide the raw
    gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
    This behavior is *deprecated* and will be removed in the next major version
    of the custom resource definition. It is recommended to use
    `spec.additionalScrapeConfigs` instead.
    """
    prometheus_external_label_name: Annotated[
        Optional[str], Field(alias="prometheusExternalLabelName")
    ] = None
    """
    Name of Prometheus external label used to denote the Prometheus instance
    name. The external label will _not_ be added when the field is set to
    the empty string (`""`).

    Default: "prometheus"
    """
    reload_strategy: Annotated[
        Optional[Literal["HTTP", "ProcessSignal"]], Field(alias="reloadStrategy")
    ] = None
    """
    Defines the strategy used to reload the Prometheus configuration.
    If not specified, the configuration is reloaded using the /-/reload HTTP endpoint.
    """
    remote_write: Annotated[Optional[List[RemoteWrite]], Field(alias="remoteWrite")] = None
    """
    Defines the list of remote write configurations.
    """
    remote_write_receiver_message_versions: Annotated[
        Optional[List[Literal["V1.0", "V2.0"]]],
        Field(alias="remoteWriteReceiverMessageVersions", min_length=1),
    ] = None
    """
    List of the protobuf message versions to accept when receiving the
    remote writes.

    It requires Prometheus >= v2.54.0.
    """
    replica_external_label_name: Annotated[
        Optional[str], Field(alias="replicaExternalLabelName")
    ] = None
    """
    Name of Prometheus external label used to denote the replica name.
    The external label will _not_ be added when the field is set to the
    empty string (`""`).

    Default: "prometheus_replica"
    """
    replicas: Optional[int] = None
    """
    Number of replicas of each shard to deploy for a Prometheus deployment.
    `spec.replicas` multiplied by `spec.shards` is the total number of Pods
    created.

    Default: 1
    """
    resources: Optional[Resources] = None
    """
    Defines the resources requests and limits of the 'prometheus' container.
    """
    route_prefix: Annotated[Optional[str], Field(alias="routePrefix")] = None
    """
    The route prefix Prometheus registers HTTP handlers for.

    This is useful when using `spec.externalURL`, and a proxy is rewriting
    HTTP routes of a request, and the actual ExternalURL is still true, but
    the server serves requests under a different route prefix. For example
    for use with `kubectl proxy`.
    """
    runtime: Optional[Runtime] = None
    """
    RuntimeConfig configures the values for the Prometheus process behavior
    """
    sample_limit: Annotated[Optional[int], Field(alias="sampleLimit")] = None
    """
    SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
    Only valid in Prometheus versions 2.45.0 and newer.

    Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
    If you want to enforce a maximum limit for all scrape objects, refer to enforcedSampleLimit.
    """
    scrape_classes: Annotated[Optional[List[ScrapeClass]], Field(alias="scrapeClasses")] = None
    """
    List of scrape classes to expose to scraping objects such as
    PodMonitors, ServiceMonitors, Probes and ScrapeConfigs.

    This is an *experimental feature*, it may change in any upcoming release
    in a breaking way.
    """
    scrape_config_namespace_selector: Annotated[
        Optional[ScrapeConfigNamespaceSelector],
        Field(alias="scrapeConfigNamespaceSelector"),
    ] = None
    """
    Namespaces to match for ScrapeConfig discovery. An empty label selector
    matches all namespaces. A null label selector matches the current
    namespace only.

    Note that the ScrapeConfig custom resource definition is currently at Alpha level.
    """
    scrape_config_selector: Annotated[
        Optional[ScrapeConfigSelector], Field(alias="scrapeConfigSelector")
    ] = None
    """
    ScrapeConfigs to be selected for target discovery. An empty label
    selector matches all objects. A null label selector matches no objects.

    If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
    and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
    The Prometheus operator will ensure that the Prometheus configuration's
    Secret exists, but it is the responsibility of the user to provide the raw
    gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
    This behavior is *deprecated* and will be removed in the next major version
    of the custom resource definition. It is recommended to use
    `spec.additionalScrapeConfigs` instead.

    Note that the ScrapeConfig custom resource definition is currently at Alpha level.
    """
    scrape_failure_log_file: Annotated[
        Optional[str], Field(alias="scrapeFailureLogFile", min_length=1)
    ] = None
    """
    File to which scrape failures are logged.
    Reloading the configuration will reopen the file.

    If the filename has an empty path, e.g. 'file.log', The Prometheus Pods
    will mount the file into an emptyDir volume at `/var/log/prometheus`.
    If a full path is provided, e.g. '/var/log/prometheus/file.log', you
    must mount a volume in the specified directory and it must be writable.
    It requires Prometheus >= v2.55.0.
    """
    scrape_interval: Annotated[
        Optional[str],
        Field(
            alias="scrapeInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = "30s"
    """
    Interval between consecutive scrapes.

    Default: "30s"
    """
    scrape_protocols: Annotated[
        Optional[
            List[
                Literal[
                    "PrometheusProto",
                    "OpenMetricsText0.0.1",
                    "OpenMetricsText1.0.0",
                    "PrometheusText0.0.4",
                    "PrometheusText1.0.0",
                ]
            ]
        ],
        Field(alias="scrapeProtocols"),
    ] = None
    """
    The protocols to negotiate during a scrape. It tells clients the
    protocols supported by Prometheus in order of preference (from most to least preferred).

    If unset, Prometheus uses its default value.

    It requires Prometheus >= v2.49.0.

    `PrometheusText1.0.0` requires Prometheus >= v3.0.0.
    """
    scrape_timeout: Annotated[
        Optional[str],
        Field(
            alias="scrapeTimeout",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Number of seconds to wait until a scrape request times out.
    The value cannot be greater than the scrape interval otherwise the operator will reject the resource.
    """
    secrets: Optional[List[str]] = None
    """
    Secrets is a list of Secrets in the same namespace as the Prometheus
    object, which shall be mounted into the Prometheus Pods.
    Each Secret is added to the StatefulSet definition as a volume named `secret-<secret-name>`.
    The Secrets are mounted into /etc/prometheus/secrets/<secret-name> in the 'prometheus' container.
    """
    security_context: Annotated[Optional[SecurityContextModel], Field(alias="securityContext")] = (
        None
    )
    """
    SecurityContext holds pod-level security attributes and common container settings.
    This defaults to the default PodSecurityContext.
    """
    service_account_name: Annotated[Optional[str], Field(alias="serviceAccountName")] = None
    """
    ServiceAccountName is the name of the ServiceAccount to use to run the
    Prometheus Pods.
    """
    service_discovery_role: Annotated[
        Optional[Literal["Endpoints", "EndpointSlice"]],
        Field(alias="serviceDiscoveryRole"),
    ] = None
    """
    Defines the service discovery role used to discover targets from
    `ServiceMonitor` objects and Alertmanager endpoints.

    If set, the value should be either "Endpoints" or "EndpointSlice".
    If unset, the operator assumes the "Endpoints" role.
    """
    service_monitor_namespace_selector: Annotated[
        Optional[ServiceMonitorNamespaceSelector],
        Field(alias="serviceMonitorNamespaceSelector"),
    ] = None
    """
    Namespaces to match for ServicedMonitors discovery. An empty label selector
    matches all namespaces. A null label selector (default value) matches the current
    namespace only.
    """
    service_monitor_selector: Annotated[
        Optional[ServiceMonitorSelector], Field(alias="serviceMonitorSelector")
    ] = None
    """
    ServiceMonitors to be selected for target discovery. An empty label
    selector matches all objects. A null label selector matches no objects.

    If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
    and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
    The Prometheus operator will ensure that the Prometheus configuration's
    Secret exists, but it is the responsibility of the user to provide the raw
    gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
    This behavior is *deprecated* and will be removed in the next major version
    of the custom resource definition. It is recommended to use
    `spec.additionalScrapeConfigs` instead.
    """
    service_name: Annotated[Optional[str], Field(alias="serviceName", min_length=1)] = None
    """
    The name of the service name used by the underlying StatefulSet(s) as the governing service.
    If defined, the Service  must be created before the Prometheus/PrometheusAgent resource in the same namespace and it must define a selector that matches the pod labels.
    If empty, the operator will create and manage a headless service named `prometheus-operated` for Prometheus resources,
    or `prometheus-agent-operated` for PrometheusAgent resources.
    When deploying multiple Prometheus/PrometheusAgent resources in the same namespace, it is recommended to specify a different value for each.
    See https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#stable-network-id for more details.
    """
    shards: Optional[int] = None
    """
    Number of shards to distribute scraped targets onto.

    `spec.replicas` multiplied by `spec.shards` is the total number of Pods
    being created.

    When not defined, the operator assumes only one shard.

    Note that scaling down shards will not reshard data onto the remaining
    instances, it must be manually moved. Increasing shards will not reshard
    data either but it will continue to be available from the same
    instances. To query globally, use Thanos sidecar and Thanos querier or
    remote write data to a central location.
    Alerting and recording rules

    By default, the sharding is performed on:
    * The `__address__` target's metadata label for PodMonitor,
    ServiceMonitor and ScrapeConfig resources.
    * The `__param_target__` label for Probe resources.

    Users can define their own sharding implementation by setting the
    `__tmp_hash` label during the target discovery with relabeling
    configuration (either in the monitoring resources or via scrape class).
    """
    storage: Optional[Storage] = None
    """
    Storage defines the storage used by Prometheus.
    """
    target_limit: Annotated[Optional[int], Field(alias="targetLimit")] = None
    """
    TargetLimit defines a limit on the number of scraped targets that will be accepted.
    Only valid in Prometheus versions 2.45.0 and newer.

    Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
    If you want to enforce a maximum limit for all scrape objects, refer to enforcedTargetLimit.
    """
    tolerations: Optional[List[Toleration]] = None
    """
    Defines the Pods' tolerations if specified.
    """
    topology_spread_constraints: Annotated[
        Optional[List[TopologySpreadConstraint]],
        Field(alias="topologySpreadConstraints"),
    ] = None
    """
    Defines the pod's topology spread constraints if specified.
    """
    tracing_config: Annotated[Optional[TracingConfig], Field(alias="tracingConfig")] = None
    """
    TracingConfig configures tracing in Prometheus.

    This is an *experimental feature*, it may change in any upcoming release
    in a breaking way.
    """
    tsdb: Optional[Tsdb] = None
    """
    Defines the runtime reloadable configuration of the timeseries database(TSDB).
    It requires Prometheus >= v2.39.0 or PrometheusAgent >= v2.54.0.
    """
    version: Optional[str] = None
    """
    Version of Prometheus being deployed. The operator uses this information
    to generate the Prometheus StatefulSet + configuration files.

    If not specified, the operator assumes the latest upstream version of
    Prometheus available at the time when the version of the operator was
    released.
    """
    volume_mounts: Annotated[Optional[List[VolumeMount]], Field(alias="volumeMounts")] = None
    """
    VolumeMounts allows the configuration of additional VolumeMounts.

    VolumeMounts will be appended to other VolumeMounts in the 'prometheus'
    container, that are generated as a result of StorageSpec objects.
    """
    volumes: Optional[List[Volume]] = None
    """
    Volumes allows the configuration of additional volumes on the output
    StatefulSet definition. Volumes specified will be appended to other
    volumes that are generated as a result of StorageSpec objects.
    """
    wal_compression: Annotated[Optional[bool], Field(alias="walCompression")] = None
    """
    Configures compression of the write-ahead log (WAL) using Snappy.

    WAL compression is enabled by default for Prometheus >= 2.20.0

    Requires Prometheus v2.11.0 and above.
    """
    web: Optional[Web] = None
    """
    Defines the configuration of the Prometheus web server.
    """


class ConditionModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConditionModel"]:
            return ConditionModel

        def build(self) -> "ConditionModel":
            return ConditionModel(**self._attrs)

        def last_transition_time(self, value: datetime, /) -> Self:
            """
            lastTransitionTime is the time of the last update to the current status property.
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Human-readable message indicating details for the condition's last transition.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration represents the .metadata.generation that the
            condition was set based upon. For instance, if `.metadata.generation` is
            currently 12, but the `.status.conditions[].observedGeneration` is 9, the
            condition is out of date with respect to the current state of the
            instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            Reason for the condition's last transition.
            """
            return self._set("reason", value)

        def status(self, value: str, /) -> Self:
            """
            Status of the condition.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of the condition being reported.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["ConditionModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConditionModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConditionModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConditionModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConditionModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[datetime, Field(alias="lastTransitionTime")]
    """
    lastTransitionTime is the time of the last update to the current status property.
    """
    message: Optional[str] = None
    """
    Human-readable message indicating details for the condition's last transition.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration represents the .metadata.generation that the
    condition was set based upon. For instance, if `.metadata.generation` is
    currently 12, but the `.status.conditions[].observedGeneration` is 9, the
    condition is out of date with respect to the current state of the
    instance.
    """
    reason: Optional[str] = None
    """
    Reason for the condition's last transition.
    """
    status: Annotated[str, Field(min_length=1)]
    """
    Status of the condition.
    """
    type: Annotated[str, Field(min_length=1)]
    """
    Type of the condition being reported.
    """


class ShardStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ShardStatus"]:
            return ShardStatus

        def build(self) -> "ShardStatus":
            return ShardStatus(**self._attrs)

        def available_replicas(self, value: int, /) -> Self:
            """
            Total number of available pods (ready for at least minReadySeconds)
            targeted by this shard.
            """
            return self._set("available_replicas", value)

        def replicas(self, value: int, /) -> Self:
            """
            Total number of pods targeted by this shard.
            """
            return self._set("replicas", value)

        def shard_id(self, value: str, /) -> Self:
            """
            Identifier of the shard.
            """
            return self._set("shard_id", value)

        def unavailable_replicas(self, value: int, /) -> Self:
            """
            Total number of unavailable pods targeted by this shard.
            """
            return self._set("unavailable_replicas", value)

        def updated_replicas(self, value: int, /) -> Self:
            """
            Total number of non-terminated pods targeted by this shard
            that have the desired spec.
            """
            return self._set("updated_replicas", value)

    class BuilderContext(BuilderContextBase["ShardStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ShardStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ShardStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ShardStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ShardStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    available_replicas: Annotated[int, Field(alias="availableReplicas")]
    """
    Total number of available pods (ready for at least minReadySeconds)
    targeted by this shard.
    """
    replicas: int
    """
    Total number of pods targeted by this shard.
    """
    shard_id: Annotated[str, Field(alias="shardID")]
    """
    Identifier of the shard.
    """
    unavailable_replicas: Annotated[int, Field(alias="unavailableReplicas")]
    """
    Total number of unavailable pods targeted by this shard.
    """
    updated_replicas: Annotated[int, Field(alias="updatedReplicas")]
    """
    Total number of non-terminated pods targeted by this shard
    that have the desired spec.
    """


class PrometheusAgentStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PrometheusAgentStatus"]:
            return PrometheusAgentStatus

        def build(self) -> "PrometheusAgentStatus":
            return PrometheusAgentStatus(**self._attrs)

        def available_replicas(self, value: int, /) -> Self:
            """
            Total number of available pods (ready for at least minReadySeconds)
            targeted by this Prometheus deployment.
            """
            return self._set("available_replicas", value)

        @overload
        def conditions(
            self, value_or_callback: List[ConditionModel], /
        ) -> "PrometheusAgentStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ConditionModel, ConditionModel.Builder]],
                GenericListBuilder[ConditionModel, ConditionModel.Builder] | List[ConditionModel],
            ],
            /,
        ) -> "PrometheusAgentStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ConditionModel.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            The current state of the Prometheus deployment.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ConditionModel.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConditionModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def paused(self, value: bool, /) -> Self:
            """
            Represents whether any actions on the underlying managed objects are
            being performed. Only delete actions will be performed.
            """
            return self._set("paused", value)

        def replicas(self, value: int, /) -> Self:
            """
            Total number of non-terminated pods targeted by this Prometheus deployment
            (their labels match the selector).
            """
            return self._set("replicas", value)

        def selector(self, value: Optional[str], /) -> Self:
            """
            The selector used to match the pods targeted by this Prometheus resource.
            """
            return self._set("selector", value)

        @overload
        def shard_statuses(
            self, value_or_callback: List[ShardStatus], /
        ) -> "PrometheusAgentStatus.Builder": ...

        @overload
        def shard_statuses(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ShardStatus, ShardStatus.Builder]],
                GenericListBuilder[ShardStatus, ShardStatus.Builder] | List[ShardStatus],
            ],
            /,
        ) -> "PrometheusAgentStatus.Builder": ...

        @overload
        def shard_statuses(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ShardStatus.Builder]: ...

        def shard_statuses(self, value_or_callback=None, /):
            """
            The list has one entry per shard. Each entry provides a summary of the shard status.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ShardStatus.Builder]()
                context._parent_builder = self
                context._field_name = "shard_statuses"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ShardStatus.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("shard_statuses", value)

        def shards(self, value: Optional[int], /) -> Self:
            """
            Shards is the most recently observed number of shards.
            """
            return self._set("shards", value)

        def unavailable_replicas(self, value: int, /) -> Self:
            """
            Total number of unavailable pods targeted by this Prometheus deployment.
            """
            return self._set("unavailable_replicas", value)

        def updated_replicas(self, value: int, /) -> Self:
            """
            Total number of non-terminated pods targeted by this Prometheus deployment
            that have the desired version spec.
            """
            return self._set("updated_replicas", value)

    class BuilderContext(BuilderContextBase["PrometheusAgentStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PrometheusAgentStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PrometheusAgentStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PrometheusAgentStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PrometheusAgentStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    available_replicas: Annotated[int, Field(alias="availableReplicas")]
    """
    Total number of available pods (ready for at least minReadySeconds)
    targeted by this Prometheus deployment.
    """
    conditions: Optional[List[ConditionModel]] = None
    """
    The current state of the Prometheus deployment.
    """
    paused: bool
    """
    Represents whether any actions on the underlying managed objects are
    being performed. Only delete actions will be performed.
    """
    replicas: int
    """
    Total number of non-terminated pods targeted by this Prometheus deployment
    (their labels match the selector).
    """
    selector: Optional[str] = None
    """
    The selector used to match the pods targeted by this Prometheus resource.
    """
    shard_statuses: Annotated[Optional[List[ShardStatus]], Field(alias="shardStatuses")] = None
    """
    The list has one entry per shard. Each entry provides a summary of the shard status.
    """
    shards: Optional[int] = None
    """
    Shards is the most recently observed number of shards.
    """
    unavailable_replicas: Annotated[int, Field(alias="unavailableReplicas")]
    """
    Total number of unavailable pods targeted by this Prometheus deployment.
    """
    updated_replicas: Annotated[int, Field(alias="updatedReplicas")]
    """
    Total number of non-terminated pods targeted by this Prometheus deployment
    that have the desired version spec.
    """


class AuthorizationModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AuthorizationModel1"]:
            return AuthorizationModel1

        def build(self) -> "AuthorizationModel1":
            return AuthorizationModel1(**self._attrs)

        @overload
        def credentials(
            self, value_or_callback: Optional[Credentials], /
        ) -> "AuthorizationModel1.Builder": ...

        @overload
        def credentials(
            self,
            value_or_callback: Callable[[Credentials.Builder], Credentials.Builder | Credentials],
            /,
        ) -> "AuthorizationModel1.Builder": ...

        @overload
        def credentials(self, value_or_callback: Never = ...) -> "Credentials.BuilderContext": ...

        def credentials(self, value_or_callback=None, /):
            """
            Selects a key of a Secret in the namespace that contains the credentials for authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Credentials.BuilderContext()
                context._parent_builder = self
                context._field_name = "credentials"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Credentials.builder())
                if isinstance(output, Credentials.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("credentials", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Defines the authentication type. The value is case-insensitive.

            "Basic" is not a supported value.

            Default: "Bearer"
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["AuthorizationModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AuthorizationModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AuthorizationModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AuthorizationModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AuthorizationModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    credentials: Optional[Credentials] = None
    """
    Selects a key of a Secret in the namespace that contains the credentials for authentication.
    """
    type: Optional[str] = None
    """
    Defines the authentication type. The value is case-insensitive.

    "Basic" is not a supported value.

    Default: "Bearer"
    """


class TlsConfigModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsConfigModel4"]:
            return TlsConfigModel4

        def build(self) -> "TlsConfigModel4":
            return TlsConfigModel4(**self._attrs)

        @overload
        def ca(self, value_or_callback: Optional[Ca], /) -> "TlsConfigModel4.Builder": ...

        @overload
        def ca(
            self, value_or_callback: Callable[[Ca.Builder], Ca.Builder | Ca], /
        ) -> "TlsConfigModel4.Builder": ...

        @overload
        def ca(self, value_or_callback: Never = ...) -> "Ca.BuilderContext": ...

        def ca(self, value_or_callback=None, /):
            """
            Certificate authority used when verifying server certificates.
            """
            if self._in_context and value_or_callback is None:
                context = Ca.BuilderContext()
                context._parent_builder = self
                context._field_name = "ca"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ca.builder())
                if isinstance(output, Ca.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ca", value)

        @overload
        def cert(self, value_or_callback: Optional[Cert], /) -> "TlsConfigModel4.Builder": ...

        @overload
        def cert(
            self, value_or_callback: Callable[[Cert.Builder], Cert.Builder | Cert], /
        ) -> "TlsConfigModel4.Builder": ...

        @overload
        def cert(self, value_or_callback: Never = ...) -> "Cert.BuilderContext": ...

        def cert(self, value_or_callback=None, /):
            """
            Client certificate to present when doing client-authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Cert.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cert.builder())
                if isinstance(output, Cert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert", value)

        def insecure_skip_verify(self, value: Optional[bool], /) -> Self:
            """
            Disable target certificate validation.
            """
            return self._set("insecure_skip_verify", value)

        @overload
        def key_secret(
            self, value_or_callback: Optional[KeySecret], /
        ) -> "TlsConfigModel4.Builder": ...

        @overload
        def key_secret(
            self,
            value_or_callback: Callable[[KeySecret.Builder], KeySecret.Builder | KeySecret],
            /,
        ) -> "TlsConfigModel4.Builder": ...

        @overload
        def key_secret(self, value_or_callback: Never = ...) -> "KeySecret.BuilderContext": ...

        def key_secret(self, value_or_callback=None, /):
            """
            Secret containing the client key file for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = KeySecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "key_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KeySecret.builder())
                if isinstance(output, KeySecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("key_secret", value)

        def max_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Maximum acceptable TLS version.

            It requires Prometheus >= v2.41.0.
            """
            return self._set("max_version", value)

        def min_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Minimum acceptable TLS version.

            It requires Prometheus >= v2.35.0.
            """
            return self._set("min_version", value)

        def server_name(self, value: Optional[str], /) -> Self:
            """
            Used to verify the hostname for the targets.
            """
            return self._set("server_name", value)

    class BuilderContext(BuilderContextBase["TlsConfigModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsConfigModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsConfigModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsConfigModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsConfigModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca: Optional[Ca] = None
    """
    Certificate authority used when verifying server certificates.
    """
    cert: Optional[Cert] = None
    """
    Client certificate to present when doing client-authentication.
    """
    insecure_skip_verify: Annotated[Optional[bool], Field(alias="insecureSkipVerify")] = None
    """
    Disable target certificate validation.
    """
    key_secret: Annotated[Optional[KeySecret], Field(alias="keySecret")] = None
    """
    Secret containing the client key file for the targets.
    """
    max_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="maxVersion")
    ] = None
    """
    Maximum acceptable TLS version.

    It requires Prometheus >= v2.41.0.
    """
    min_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="minVersion")
    ] = None
    """
    Minimum acceptable TLS version.

    It requires Prometheus >= v2.35.0.
    """
    server_name: Annotated[Optional[str], Field(alias="serverName")] = None
    """
    Used to verify the hostname for the targets.
    """


class AzureSdConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AzureSdConfig"]:
            return AzureSdConfig

        def build(self) -> "AzureSdConfig":
            return AzureSdConfig(**self._attrs)

        def authentication_method(
            self, value: Optional[Literal["OAuth", "ManagedIdentity", "SDK"]], /
        ) -> Self:
            """
            # The authentication method, either `OAuth` or `ManagedIdentity` or `SDK`.
            See https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview
            SDK authentication method uses environment variables by default.
            See https://learn.microsoft.com/en-us/azure/developer/go/azure-sdk-authentication
            """
            return self._set("authentication_method", value)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel1], /
        ) -> "AzureSdConfig.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel1.Builder],
                AuthorizationModel1.Builder | AuthorizationModel1,
            ],
            /,
        ) -> "AzureSdConfig.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel1.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization header configuration to authenticate against the target HTTP endpoint.
            Cannot be set at the same time as `oAuth2`, or `basicAuth`.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel1.builder())
                if isinstance(output, AuthorizationModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def basic_auth(
            self, value_or_callback: Optional[BasicAuth], /
        ) -> "AzureSdConfig.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "AzureSdConfig.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            BasicAuth information to authenticate against the target HTTP endpoint.
            More info: https://prometheus.io/docs/operating/configuration/#endpoints
            Cannot be set at the same time as `authorization`, or `oAuth2`.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        def client_id(self, value: Optional[str], /) -> Self:
            """
            Optional client ID. Only required with the OAuth authentication method.
            """
            return self._set("client_id", value)

        @overload
        def client_secret(
            self, value_or_callback: Optional[ClientSecret], /
        ) -> "AzureSdConfig.Builder": ...

        @overload
        def client_secret(
            self,
            value_or_callback: Callable[
                [ClientSecret.Builder], ClientSecret.Builder | ClientSecret
            ],
            /,
        ) -> "AzureSdConfig.Builder": ...

        @overload
        def client_secret(
            self, value_or_callback: Never = ...
        ) -> "ClientSecret.BuilderContext": ...

        def client_secret(self, value_or_callback=None, /):
            """
            Optional client secret. Only required with the OAuth authentication method.
            """
            if self._in_context and value_or_callback is None:
                context = ClientSecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "client_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClientSecret.builder())
                if isinstance(output, ClientSecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("client_secret", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            Whether to enable HTTP2.
            """
            return self._set("enable_http2", value)

        def environment(self, value: Optional[str], /) -> Self:
            """
            The Azure environment.
            """
            return self._set("environment", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            Configure whether HTTP requests follow HTTP 3xx redirects.
            """
            return self._set("follow_redirects", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        @overload
        def oauth2(self, value_or_callback: Optional[Oauth2], /) -> "AzureSdConfig.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "AzureSdConfig.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            Optional OAuth 2.0 configuration to authenticate against the target HTTP endpoint.
            Cannot be set at the same time as `authorization`, or `basicAuth`.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        def port(self, value: Optional[int], /) -> Self:
            """
            The port to scrape metrics from. If using the public IP address, this must
            instead be specified in the relabeling rule.
            """
            return self._set("port", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        def refresh_interval(self, value: Optional[str], /) -> Self:
            """
            RefreshInterval configures the refresh interval at which Prometheus will re-read the instance list.
            """
            return self._set("refresh_interval", value)

        def resource_group(self, value: Optional[str], /) -> Self:
            """
            Optional resource group name. Limits discovery to this resource group.
            Requires  Prometheus v2.35.0 and above
            """
            return self._set("resource_group", value)

        def subscription_id(self, value: str, /) -> Self:
            """
            The subscription ID. Always required.
            """
            return self._set("subscription_id", value)

        def tenant_id(self, value: Optional[str], /) -> Self:
            """
            Optional tenant ID. Only required with the OAuth authentication method.
            """
            return self._set("tenant_id", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel4], /
        ) -> "AzureSdConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel4.Builder], TlsConfigModel4.Builder | TlsConfigModel4
            ],
            /,
        ) -> "AzureSdConfig.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel4.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration applying to the target HTTP endpoint.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel4.builder())
                if isinstance(output, TlsConfigModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["AzureSdConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AzureSdConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AzureSdConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AzureSdConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AzureSdConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authentication_method: Annotated[
        Optional[Literal["OAuth", "ManagedIdentity", "SDK"]],
        Field(alias="authenticationMethod"),
    ] = None
    """
    # The authentication method, either `OAuth` or `ManagedIdentity` or `SDK`.
    See https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview
    SDK authentication method uses environment variables by default.
    See https://learn.microsoft.com/en-us/azure/developer/go/azure-sdk-authentication
    """
    authorization: Optional[AuthorizationModel1] = None
    """
    Authorization header configuration to authenticate against the target HTTP endpoint.
    Cannot be set at the same time as `oAuth2`, or `basicAuth`.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    BasicAuth information to authenticate against the target HTTP endpoint.
    More info: https://prometheus.io/docs/operating/configuration/#endpoints
    Cannot be set at the same time as `authorization`, or `oAuth2`.
    """
    client_id: Annotated[Optional[str], Field(alias="clientID", min_length=1)] = None
    """
    Optional client ID. Only required with the OAuth authentication method.
    """
    client_secret: Annotated[Optional[ClientSecret], Field(alias="clientSecret")] = None
    """
    Optional client secret. Only required with the OAuth authentication method.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHTTP2")] = None
    """
    Whether to enable HTTP2.
    """
    environment: Annotated[Optional[str], Field(min_length=1)] = None
    """
    The Azure environment.
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    Configure whether HTTP requests follow HTTP 3xx redirects.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    oauth2: Optional[Oauth2] = None
    """
    Optional OAuth 2.0 configuration to authenticate against the target HTTP endpoint.
    Cannot be set at the same time as `authorization`, or `basicAuth`.
    """
    port: Annotated[Optional[int], Field(ge=0, le=65535)] = None
    """
    The port to scrape metrics from. If using the public IP address, this must
    instead be specified in the relabeling rule.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    refresh_interval: Annotated[
        Optional[str],
        Field(
            alias="refreshInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    RefreshInterval configures the refresh interval at which Prometheus will re-read the instance list.
    """
    resource_group: Annotated[Optional[str], Field(alias="resourceGroup", min_length=1)] = None
    """
    Optional resource group name. Limits discovery to this resource group.
    Requires  Prometheus v2.35.0 and above
    """
    subscription_id: Annotated[str, Field(alias="subscriptionID", min_length=1)]
    """
    The subscription ID. Always required.
    """
    tenant_id: Annotated[Optional[str], Field(alias="tenantID", min_length=1)] = None
    """
    Optional tenant ID. Only required with the OAuth authentication method.
    """
    tls_config: Annotated[Optional[TlsConfigModel4], Field(alias="tlsConfig")] = None
    """
    TLS configuration applying to the target HTTP endpoint.
    """


class TokenRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TokenRef"]:
            return TokenRef

        def build(self) -> "TokenRef":
            return TokenRef(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["TokenRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TokenRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TokenRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TokenRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TokenRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class ConsulSdConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConsulSdConfig"]:
            return ConsulSdConfig

        def build(self) -> "ConsulSdConfig":
            return ConsulSdConfig(**self._attrs)

        def allow_stale(self, value: Optional[bool], /) -> Self:
            """
            Allow stale Consul results (see https://www.consul.io/api/features/consistency.html). Will reduce load on Consul.
            If unset, Prometheus uses its default value.
            """
            return self._set("allow_stale", value)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel1], /
        ) -> "ConsulSdConfig.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel1.Builder],
                AuthorizationModel1.Builder | AuthorizationModel1,
            ],
            /,
        ) -> "ConsulSdConfig.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel1.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Optional Authorization header configuration to authenticate against the Consul Server.
            Cannot be set at the same time as `basicAuth`, or `oauth2`.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel1.builder())
                if isinstance(output, AuthorizationModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def basic_auth(
            self, value_or_callback: Optional[BasicAuth], /
        ) -> "ConsulSdConfig.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "ConsulSdConfig.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            Optional BasicAuth information to authenticate against the Consul Server.
            More info: https://prometheus.io/docs/operating/configuration/#endpoints
            Cannot be set at the same time as `authorization`, or `oauth2`.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        def datacenter(self, value: Optional[str], /) -> Self:
            """
            Consul Datacenter name, if not provided it will use the local Consul Agent Datacenter.
            """
            return self._set("datacenter", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            Whether to enable HTTP2.
            If unset, Prometheus uses its default value.
            """
            return self._set("enable_http2", value)

        def filter(self, value: Optional[str], /) -> Self:
            """
            Filter expression used to filter the catalog results.
            See https://www.consul.io/api-docs/catalog#list-services
            It requires Prometheus >= 3.0.0.
            """
            return self._set("filter", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            Configure whether HTTP requests follow HTTP 3xx redirects.
            If unset, Prometheus uses its default value.
            """
            return self._set("follow_redirects", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespaces are only supported in Consul Enterprise.

            It requires Prometheus >= 2.28.0.
            """
            return self._set("namespace", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        def node_meta(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Node metadata key/value pairs to filter nodes for a given service.
            Starting with Consul 1.14, it is recommended to use `filter` with the `NodeMeta` selector instead.
            """
            return self._set("node_meta", value)

        @overload
        def oauth2(self, value_or_callback: Optional[Oauth2], /) -> "ConsulSdConfig.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "ConsulSdConfig.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            Optional OAuth2.0 configuration.
            Cannot be set at the same time as `basicAuth`, or `authorization`.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        def partition(self, value: Optional[str], /) -> Self:
            """
            Admin Partitions are only supported in Consul Enterprise.
            """
            return self._set("partition", value)

        def path_prefix(self, value: Optional[str], /) -> Self:
            """
            Prefix for URIs for when consul is behind an API gateway (reverse proxy).

            It requires Prometheus >= 2.45.0.
            """
            return self._set("path_prefix", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        def refresh_interval(self, value: Optional[str], /) -> Self:
            """
            The time after which the provided names are refreshed.
            On large setup it might be a good idea to increase this value because the catalog will change all the time.
            If unset, Prometheus uses its default value.
            """
            return self._set("refresh_interval", value)

        def scheme(self, value: Optional[Literal["HTTP", "HTTPS"]], /) -> Self:
            """
            HTTP Scheme default "http"
            """
            return self._set("scheme", value)

        def server(self, value: str, /) -> Self:
            """
            Consul server address. A valid string consisting of a hostname or IP followed by an optional port number.
            """
            return self._set("server", value)

        def services(self, value: Optional[List[str]], /) -> Self:
            """
            A list of services for which targets are retrieved. If omitted, all services are scraped.
            """
            return self._set("services", value)

        def tag_separator(self, value: Optional[str], /) -> Self:
            """
            The string by which Consul tags are joined into the tag label.
            If unset, Prometheus uses its default value.
            """
            return self._set("tag_separator", value)

        def tags(self, value: Optional[List[str]], /) -> Self:
            """
            An optional list of tags used to filter nodes for a given service. Services must contain all tags in the list.
            Starting with Consul 1.14, it is recommended to use `filter` with the `ServiceTags` selector instead.
            """
            return self._set("tags", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel4], /
        ) -> "ConsulSdConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel4.Builder], TlsConfigModel4.Builder | TlsConfigModel4
            ],
            /,
        ) -> "ConsulSdConfig.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel4.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration to connect to the Consul API.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel4.builder())
                if isinstance(output, TlsConfigModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

        @overload
        def token_ref(
            self, value_or_callback: Optional[TokenRef], /
        ) -> "ConsulSdConfig.Builder": ...

        @overload
        def token_ref(
            self,
            value_or_callback: Callable[[TokenRef.Builder], TokenRef.Builder | TokenRef],
            /,
        ) -> "ConsulSdConfig.Builder": ...

        @overload
        def token_ref(self, value_or_callback: Never = ...) -> "TokenRef.BuilderContext": ...

        def token_ref(self, value_or_callback=None, /):
            """
            Consul ACL TokenRef, if not provided it will use the ACL from the local Consul Agent.
            """
            if self._in_context and value_or_callback is None:
                context = TokenRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "token_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TokenRef.builder())
                if isinstance(output, TokenRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("token_ref", value)

    class BuilderContext(BuilderContextBase["ConsulSdConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConsulSdConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConsulSdConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConsulSdConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConsulSdConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    allow_stale: Annotated[Optional[bool], Field(alias="allowStale")] = None
    """
    Allow stale Consul results (see https://www.consul.io/api/features/consistency.html). Will reduce load on Consul.
    If unset, Prometheus uses its default value.
    """
    authorization: Optional[AuthorizationModel1] = None
    """
    Optional Authorization header configuration to authenticate against the Consul Server.
    Cannot be set at the same time as `basicAuth`, or `oauth2`.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    Optional BasicAuth information to authenticate against the Consul Server.
    More info: https://prometheus.io/docs/operating/configuration/#endpoints
    Cannot be set at the same time as `authorization`, or `oauth2`.
    """
    datacenter: Annotated[Optional[str], Field(min_length=1)] = None
    """
    Consul Datacenter name, if not provided it will use the local Consul Agent Datacenter.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHTTP2")] = None
    """
    Whether to enable HTTP2.
    If unset, Prometheus uses its default value.
    """
    filter: Annotated[Optional[str], Field(min_length=1)] = None
    """
    Filter expression used to filter the catalog results.
    See https://www.consul.io/api-docs/catalog#list-services
    It requires Prometheus >= 3.0.0.
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    Configure whether HTTP requests follow HTTP 3xx redirects.
    If unset, Prometheus uses its default value.
    """
    namespace: Annotated[Optional[str], Field(min_length=1)] = None
    """
    Namespaces are only supported in Consul Enterprise.

    It requires Prometheus >= 2.28.0.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    node_meta: Annotated[Optional[Dict[str, str]], Field(alias="nodeMeta")] = None
    """
    Node metadata key/value pairs to filter nodes for a given service.
    Starting with Consul 1.14, it is recommended to use `filter` with the `NodeMeta` selector instead.
    """
    oauth2: Optional[Oauth2] = None
    """
    Optional OAuth2.0 configuration.
    Cannot be set at the same time as `basicAuth`, or `authorization`.
    """
    partition: Annotated[Optional[str], Field(min_length=1)] = None
    """
    Admin Partitions are only supported in Consul Enterprise.
    """
    path_prefix: Annotated[Optional[str], Field(alias="pathPrefix", min_length=1)] = None
    """
    Prefix for URIs for when consul is behind an API gateway (reverse proxy).

    It requires Prometheus >= 2.45.0.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    refresh_interval: Annotated[
        Optional[str],
        Field(
            alias="refreshInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    The time after which the provided names are refreshed.
    On large setup it might be a good idea to increase this value because the catalog will change all the time.
    If unset, Prometheus uses its default value.
    """
    scheme: Optional[Literal["HTTP", "HTTPS"]] = None
    """
    HTTP Scheme default "http"
    """
    server: Annotated[str, Field(min_length=1)]
    """
    Consul server address. A valid string consisting of a hostname or IP followed by an optional port number.
    """
    services: Optional[List[str]] = None
    """
    A list of services for which targets are retrieved. If omitted, all services are scraped.
    """
    tag_separator: Annotated[Optional[str], Field(alias="tagSeparator", min_length=1)] = None
    """
    The string by which Consul tags are joined into the tag label.
    If unset, Prometheus uses its default value.
    """
    tags: Optional[List[str]] = None
    """
    An optional list of tags used to filter nodes for a given service. Services must contain all tags in the list.
    Starting with Consul 1.14, it is recommended to use `filter` with the `ServiceTags` selector instead.
    """
    tls_config: Annotated[Optional[TlsConfigModel4], Field(alias="tlsConfig")] = None
    """
    TLS configuration to connect to the Consul API.
    """
    token_ref: Annotated[Optional[TokenRef], Field(alias="tokenRef")] = None
    """
    Consul ACL TokenRef, if not provided it will use the ACL from the local Consul Agent.
    """


class DigitalOceanSdConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DigitalOceanSdConfig"]:
            return DigitalOceanSdConfig

        def build(self) -> "DigitalOceanSdConfig":
            return DigitalOceanSdConfig(**self._attrs)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel1], /
        ) -> "DigitalOceanSdConfig.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel1.Builder],
                AuthorizationModel1.Builder | AuthorizationModel1,
            ],
            /,
        ) -> "DigitalOceanSdConfig.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel1.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization header configuration to authenticate against the DigitalOcean API.
            Cannot be set at the same time as `oauth2`.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel1.builder())
                if isinstance(output, AuthorizationModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            Whether to enable HTTP2.
            """
            return self._set("enable_http2", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            Configure whether HTTP requests follow HTTP 3xx redirects.
            """
            return self._set("follow_redirects", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        @overload
        def oauth2(
            self, value_or_callback: Optional[Oauth2], /
        ) -> "DigitalOceanSdConfig.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "DigitalOceanSdConfig.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            Optional OAuth 2.0 configuration.
            Cannot be set at the same time as `authorization`.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        def port(self, value: Optional[int], /) -> Self:
            """
            The port to scrape metrics from.
            """
            return self._set("port", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        def refresh_interval(self, value: Optional[str], /) -> Self:
            """
            Refresh interval to re-read the instance list.
            """
            return self._set("refresh_interval", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel4], /
        ) -> "DigitalOceanSdConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel4.Builder], TlsConfigModel4.Builder | TlsConfigModel4
            ],
            /,
        ) -> "DigitalOceanSdConfig.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel4.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration applying to the target HTTP endpoint.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel4.builder())
                if isinstance(output, TlsConfigModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["DigitalOceanSdConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DigitalOceanSdConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DigitalOceanSdConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DigitalOceanSdConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DigitalOceanSdConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authorization: Optional[AuthorizationModel1] = None
    """
    Authorization header configuration to authenticate against the DigitalOcean API.
    Cannot be set at the same time as `oauth2`.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHTTP2")] = None
    """
    Whether to enable HTTP2.
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    Configure whether HTTP requests follow HTTP 3xx redirects.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    oauth2: Optional[Oauth2] = None
    """
    Optional OAuth 2.0 configuration.
    Cannot be set at the same time as `authorization`.
    """
    port: Annotated[Optional[int], Field(ge=0, le=65535)] = None
    """
    The port to scrape metrics from.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    refresh_interval: Annotated[
        Optional[str],
        Field(
            alias="refreshInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Refresh interval to re-read the instance list.
    """
    tls_config: Annotated[Optional[TlsConfigModel4], Field(alias="tlsConfig")] = None
    """
    TLS configuration applying to the target HTTP endpoint.
    """


class Name(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "Name":
            value = cast(str, self._value)
            return Name(value)

    root: Annotated[str, Field(min_length=1)]

    class BuilderContext(BuilderContextBase["Name.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Name.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Name."""
        return cls.BuilderContext()


class DnsSdConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DnsSdConfig"]:
            return DnsSdConfig

        def build(self) -> "DnsSdConfig":
            return DnsSdConfig(**self._attrs)

        @overload
        def names(self, value_or_callback: List[Name], /) -> "DnsSdConfig.Builder": ...

        @overload
        def names(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Name, Name.Builder]],
                GenericListBuilder[Name, Name.Builder] | List[Name],
            ],
            /,
        ) -> "DnsSdConfig.Builder": ...

        @overload
        def names(self, value_or_callback: Never = ...) -> ListBuilderContext[Name.Builder]: ...

        def names(self, value_or_callback=None, /):
            """
            A list of DNS domain names to be queried.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Name.Builder]()
                context._parent_builder = self
                context._field_name = "names"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Name.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("names", value)

        def port(self, value: Optional[int], /) -> Self:
            """
            The port number used if the query type is not SRV
            Ignored for SRV records
            """
            return self._set("port", value)

        def refresh_interval(self, value: Optional[str], /) -> Self:
            """
            RefreshInterval configures the time after which the provided names are refreshed.
            If not set, Prometheus uses its default value.
            """
            return self._set("refresh_interval", value)

        def type(self, value: Optional[Literal["A", "AAAA", "MX", "NS", "SRV"]], /) -> Self:
            """
            The type of DNS query to perform. One of SRV, A, AAAA, MX or NS.
            If not set, Prometheus uses its default value.

            When set to NS, it requires Prometheus >= v2.49.0.
            When set to MX, it requires Prometheus >= v2.38.0
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["DnsSdConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DnsSdConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DnsSdConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DnsSdConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DnsSdConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    names: Annotated[List[Name], Field(min_length=1)]
    """
    A list of DNS domain names to be queried.
    """
    port: Annotated[Optional[int], Field(ge=0, le=65535)] = None
    """
    The port number used if the query type is not SRV
    Ignored for SRV records
    """
    refresh_interval: Annotated[
        Optional[str],
        Field(
            alias="refreshInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    RefreshInterval configures the time after which the provided names are refreshed.
    If not set, Prometheus uses its default value.
    """
    type: Optional[Literal["A", "AAAA", "MX", "NS", "SRV"]] = None
    """
    The type of DNS query to perform. One of SRV, A, AAAA, MX or NS.
    If not set, Prometheus uses its default value.

    When set to NS, it requires Prometheus >= v2.49.0.
    When set to MX, it requires Prometheus >= v2.38.0
    """


class Value(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "Value":
            value = cast(str, self._value)
            return Value(value)

    root: Annotated[str, Field(min_length=1)]

    class BuilderContext(BuilderContextBase["Value.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Value.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Value."""
        return cls.BuilderContext()


class Filter(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Filter"]:
            return Filter

        def build(self) -> "Filter":
            return Filter(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the Filter.
            """
            return self._set("name", value)

        @overload
        def values(self, value_or_callback: List[Value], /) -> "Filter.Builder": ...

        @overload
        def values(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Value, Value.Builder]],
                GenericListBuilder[Value, Value.Builder] | List[Value],
            ],
            /,
        ) -> "Filter.Builder": ...

        @overload
        def values(self, value_or_callback: Never = ...) -> ListBuilderContext[Value.Builder]: ...

        def values(self, value_or_callback=None, /):
            """
            Value to filter on.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Value.Builder]()
                context._parent_builder = self
                context._field_name = "values"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Value.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["Filter.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Filter.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Filter."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Filter", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Filter.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the Filter.
    """
    values: Annotated[List[Value], Field(min_length=1)]
    """
    Value to filter on.
    """


class DockerSdConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DockerSdConfig"]:
            return DockerSdConfig

        def build(self) -> "DockerSdConfig":
            return DockerSdConfig(**self._attrs)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel1], /
        ) -> "DockerSdConfig.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel1.Builder],
                AuthorizationModel1.Builder | AuthorizationModel1,
            ],
            /,
        ) -> "DockerSdConfig.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel1.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization header configuration to authenticate against the Docker API.
            Cannot be set at the same time as `oauth2`.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel1.builder())
                if isinstance(output, AuthorizationModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def basic_auth(
            self, value_or_callback: Optional[BasicAuth], /
        ) -> "DockerSdConfig.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "DockerSdConfig.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            BasicAuth information to use on every scrape request.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            Whether to enable HTTP2.
            """
            return self._set("enable_http2", value)

        @overload
        def filters(self, value_or_callback: List[Filter], /) -> "DockerSdConfig.Builder": ...

        @overload
        def filters(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Filter, Filter.Builder]],
                GenericListBuilder[Filter, Filter.Builder] | List[Filter],
            ],
            /,
        ) -> "DockerSdConfig.Builder": ...

        @overload
        def filters(self, value_or_callback: Never = ...) -> ListBuilderContext[Filter.Builder]: ...

        def filters(self, value_or_callback=None, /):
            """
            Optional filters to limit the discovery process to a subset of the available resources.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Filter.Builder]()
                context._parent_builder = self
                context._field_name = "filters"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Filter.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("filters", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            Configure whether HTTP requests follow HTTP 3xx redirects.
            """
            return self._set("follow_redirects", value)

        def host(self, value: str, /) -> Self:
            """
            Address of the docker daemon
            """
            return self._set("host", value)

        def host_networking_host(self, value: Optional[str], /) -> Self:
            """
            The host to use if the container is in host networking mode.
            """
            return self._set("host_networking_host", value)

        def match_first_network(self, value: Optional[bool], /) -> Self:
            """
            Configure whether to match the first network if the container has multiple networks defined.
            If unset, Prometheus uses true by default.
            It requires Prometheus >= v2.54.1.
            """
            return self._set("match_first_network", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        @overload
        def oauth2(self, value_or_callback: Optional[Oauth2], /) -> "DockerSdConfig.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "DockerSdConfig.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            Optional OAuth 2.0 configuration.
            Cannot be set at the same time as `authorization`.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        def port(self, value: Optional[int], /) -> Self:
            """
            The port to scrape metrics from.
            """
            return self._set("port", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        def refresh_interval(self, value: Optional[str], /) -> Self:
            """
            Time after which the container is refreshed.
            """
            return self._set("refresh_interval", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel4], /
        ) -> "DockerSdConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel4.Builder], TlsConfigModel4.Builder | TlsConfigModel4
            ],
            /,
        ) -> "DockerSdConfig.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel4.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration applying to the target HTTP endpoint.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel4.builder())
                if isinstance(output, TlsConfigModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["DockerSdConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DockerSdConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DockerSdConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DockerSdConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DockerSdConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authorization: Optional[AuthorizationModel1] = None
    """
    Authorization header configuration to authenticate against the Docker API.
    Cannot be set at the same time as `oauth2`.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    BasicAuth information to use on every scrape request.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHTTP2")] = None
    """
    Whether to enable HTTP2.
    """
    filters: Optional[List[Filter]] = None
    """
    Optional filters to limit the discovery process to a subset of the available resources.
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    Configure whether HTTP requests follow HTTP 3xx redirects.
    """
    host: Annotated[str, Field(min_length=1)]
    """
    Address of the docker daemon
    """
    host_networking_host: Annotated[Optional[str], Field(alias="hostNetworkingHost")] = None
    """
    The host to use if the container is in host networking mode.
    """
    match_first_network: Annotated[Optional[bool], Field(alias="matchFirstNetwork")] = None
    """
    Configure whether to match the first network if the container has multiple networks defined.
    If unset, Prometheus uses true by default.
    It requires Prometheus >= v2.54.1.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    oauth2: Optional[Oauth2] = None
    """
    Optional OAuth 2.0 configuration.
    Cannot be set at the same time as `authorization`.
    """
    port: Optional[int] = None
    """
    The port to scrape metrics from.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    refresh_interval: Annotated[
        Optional[str],
        Field(
            alias="refreshInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Time after which the container is refreshed.
    """
    tls_config: Annotated[Optional[TlsConfigModel4], Field(alias="tlsConfig")] = None
    """
    TLS configuration applying to the target HTTP endpoint.
    """


class DockerSwarmSdConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DockerSwarmSdConfig"]:
            return DockerSwarmSdConfig

        def build(self) -> "DockerSwarmSdConfig":
            return DockerSwarmSdConfig(**self._attrs)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel1], /
        ) -> "DockerSwarmSdConfig.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel1.Builder],
                AuthorizationModel1.Builder | AuthorizationModel1,
            ],
            /,
        ) -> "DockerSwarmSdConfig.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel1.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization header configuration to authenticate against the target HTTP endpoint.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel1.builder())
                if isinstance(output, AuthorizationModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def basic_auth(
            self, value_or_callback: Optional[BasicAuth], /
        ) -> "DockerSwarmSdConfig.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "DockerSwarmSdConfig.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            Optional HTTP basic authentication information.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            Whether to enable HTTP2.
            """
            return self._set("enable_http2", value)

        @overload
        def filters(self, value_or_callback: List[Filter], /) -> "DockerSwarmSdConfig.Builder": ...

        @overload
        def filters(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Filter, Filter.Builder]],
                GenericListBuilder[Filter, Filter.Builder] | List[Filter],
            ],
            /,
        ) -> "DockerSwarmSdConfig.Builder": ...

        @overload
        def filters(self, value_or_callback: Never = ...) -> ListBuilderContext[Filter.Builder]: ...

        def filters(self, value_or_callback=None, /):
            """
            Optional filters to limit the discovery process to a subset of available
            resources.
            The available filters are listed in the upstream documentation:
            Services: https://docs.docker.com/engine/api/v1.40/#operation/ServiceList
            Tasks: https://docs.docker.com/engine/api/v1.40/#operation/TaskList
            Nodes: https://docs.docker.com/engine/api/v1.40/#operation/NodeList
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Filter.Builder]()
                context._parent_builder = self
                context._field_name = "filters"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Filter.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("filters", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            Configure whether HTTP requests follow HTTP 3xx redirects.
            """
            return self._set("follow_redirects", value)

        def host(self, value: str, /) -> Self:
            """
            Address of the Docker daemon
            """
            return self._set("host", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        @overload
        def oauth2(
            self, value_or_callback: Optional[Oauth2], /
        ) -> "DockerSwarmSdConfig.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "DockerSwarmSdConfig.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            Optional OAuth 2.0 configuration.
            Cannot be set at the same time as `authorization`, or `basicAuth`.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        def port(self, value: Optional[int], /) -> Self:
            """
            The port to scrape metrics from, when `role` is nodes, and for discovered
            tasks and services that don't have published ports.
            """
            return self._set("port", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        def refresh_interval(self, value: Optional[str], /) -> Self:
            """
            The time after which the service discovery data is refreshed.
            """
            return self._set("refresh_interval", value)

        def role(self, value: Literal["Services", "Tasks", "Nodes"], /) -> Self:
            """
            Role of the targets to retrieve. Must be `Services`, `Tasks`, or `Nodes`.
            """
            return self._set("role", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel4], /
        ) -> "DockerSwarmSdConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel4.Builder], TlsConfigModel4.Builder | TlsConfigModel4
            ],
            /,
        ) -> "DockerSwarmSdConfig.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel4.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration to use on every scrape request
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel4.builder())
                if isinstance(output, TlsConfigModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["DockerSwarmSdConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DockerSwarmSdConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DockerSwarmSdConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DockerSwarmSdConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DockerSwarmSdConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authorization: Optional[AuthorizationModel1] = None
    """
    Authorization header configuration to authenticate against the target HTTP endpoint.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    Optional HTTP basic authentication information.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHTTP2")] = None
    """
    Whether to enable HTTP2.
    """
    filters: Optional[List[Filter]] = None
    """
    Optional filters to limit the discovery process to a subset of available
    resources.
    The available filters are listed in the upstream documentation:
    Services: https://docs.docker.com/engine/api/v1.40/#operation/ServiceList
    Tasks: https://docs.docker.com/engine/api/v1.40/#operation/TaskList
    Nodes: https://docs.docker.com/engine/api/v1.40/#operation/NodeList
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    Configure whether HTTP requests follow HTTP 3xx redirects.
    """
    host: Annotated[str, Field(pattern="^[a-zA-Z][a-zA-Z0-9+.-]*://.+$")]
    """
    Address of the Docker daemon
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    oauth2: Optional[Oauth2] = None
    """
    Optional OAuth 2.0 configuration.
    Cannot be set at the same time as `authorization`, or `basicAuth`.
    """
    port: Annotated[Optional[int], Field(ge=0, le=65535)] = None
    """
    The port to scrape metrics from, when `role` is nodes, and for discovered
    tasks and services that don't have published ports.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    refresh_interval: Annotated[
        Optional[str],
        Field(
            alias="refreshInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    The time after which the service discovery data is refreshed.
    """
    role: Literal["Services", "Tasks", "Nodes"]
    """
    Role of the targets to retrieve. Must be `Services`, `Tasks`, or `Nodes`.
    """
    tls_config: Annotated[Optional[TlsConfigModel4], Field(alias="tlsConfig")] = None
    """
    TLS configuration to use on every scrape request
    """


class Ec2SdConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ec2SdConfig"]:
            return Ec2SdConfig

        def build(self) -> "Ec2SdConfig":
            return Ec2SdConfig(**self._attrs)

        @overload
        def access_key(
            self, value_or_callback: Optional[AccessKey], /
        ) -> "Ec2SdConfig.Builder": ...

        @overload
        def access_key(
            self,
            value_or_callback: Callable[[AccessKey.Builder], AccessKey.Builder | AccessKey],
            /,
        ) -> "Ec2SdConfig.Builder": ...

        @overload
        def access_key(self, value_or_callback: Never = ...) -> "AccessKey.BuilderContext": ...

        def access_key(self, value_or_callback=None, /):
            """
            AccessKey is the AWS API key.
            """
            if self._in_context and value_or_callback is None:
                context = AccessKey.BuilderContext()
                context._parent_builder = self
                context._field_name = "access_key"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AccessKey.builder())
                if isinstance(output, AccessKey.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("access_key", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            Whether to enable HTTP2.
            It requires Prometheus >= v2.41.0
            """
            return self._set("enable_http2", value)

        @overload
        def filters(self, value_or_callback: List[Filter], /) -> "Ec2SdConfig.Builder": ...

        @overload
        def filters(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Filter, Filter.Builder]],
                GenericListBuilder[Filter, Filter.Builder] | List[Filter],
            ],
            /,
        ) -> "Ec2SdConfig.Builder": ...

        @overload
        def filters(self, value_or_callback: Never = ...) -> ListBuilderContext[Filter.Builder]: ...

        def filters(self, value_or_callback=None, /):
            """
            Filters can be used optionally to filter the instance list by other criteria.
            Available filter criteria can be found here:
            https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html
            Filter API documentation: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Filter.html
            It requires Prometheus >= v2.3.0
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Filter.Builder]()
                context._parent_builder = self
                context._field_name = "filters"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Filter.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("filters", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            Configure whether HTTP requests follow HTTP 3xx redirects.
            It requires Prometheus >= v2.41.0
            """
            return self._set("follow_redirects", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        def port(self, value: Optional[int], /) -> Self:
            """
            The port to scrape metrics from. If using the public IP address, this must
            instead be specified in the relabeling rule.
            """
            return self._set("port", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        def refresh_interval(self, value: Optional[str], /) -> Self:
            """
            RefreshInterval configures the refresh interval at which Prometheus will re-read the instance list.
            """
            return self._set("refresh_interval", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The AWS region.
            """
            return self._set("region", value)

        def role_arn(self, value: Optional[str], /) -> Self:
            """
            AWS Role ARN, an alternative to using AWS API keys.
            """
            return self._set("role_arn", value)

        @overload
        def secret_key(
            self, value_or_callback: Optional[SecretKey], /
        ) -> "Ec2SdConfig.Builder": ...

        @overload
        def secret_key(
            self,
            value_or_callback: Callable[[SecretKey.Builder], SecretKey.Builder | SecretKey],
            /,
        ) -> "Ec2SdConfig.Builder": ...

        @overload
        def secret_key(self, value_or_callback: Never = ...) -> "SecretKey.BuilderContext": ...

        def secret_key(self, value_or_callback=None, /):
            """
            SecretKey is the AWS API secret.
            """
            if self._in_context and value_or_callback is None:
                context = SecretKey.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_key"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretKey.builder())
                if isinstance(output, SecretKey.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_key", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel4], /
        ) -> "Ec2SdConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel4.Builder], TlsConfigModel4.Builder | TlsConfigModel4
            ],
            /,
        ) -> "Ec2SdConfig.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel4.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration to connect to the AWS EC2 API.
            It requires Prometheus >= v2.41.0
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel4.builder())
                if isinstance(output, TlsConfigModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["Ec2SdConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ec2SdConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ec2SdConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ec2SdConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ec2SdConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_key: Annotated[Optional[AccessKey], Field(alias="accessKey")] = None
    """
    AccessKey is the AWS API key.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHTTP2")] = None
    """
    Whether to enable HTTP2.
    It requires Prometheus >= v2.41.0
    """
    filters: Optional[List[Filter]] = None
    """
    Filters can be used optionally to filter the instance list by other criteria.
    Available filter criteria can be found here:
    https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html
    Filter API documentation: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_Filter.html
    It requires Prometheus >= v2.3.0
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    Configure whether HTTP requests follow HTTP 3xx redirects.
    It requires Prometheus >= v2.41.0
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    port: Annotated[Optional[int], Field(ge=0, le=65535)] = None
    """
    The port to scrape metrics from. If using the public IP address, this must
    instead be specified in the relabeling rule.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    refresh_interval: Annotated[
        Optional[str],
        Field(
            alias="refreshInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    RefreshInterval configures the refresh interval at which Prometheus will re-read the instance list.
    """
    region: Annotated[Optional[str], Field(min_length=1)] = None
    """
    The AWS region.
    """
    role_arn: Annotated[Optional[str], Field(alias="roleARN", min_length=1)] = None
    """
    AWS Role ARN, an alternative to using AWS API keys.
    """
    secret_key: Annotated[Optional[SecretKey], Field(alias="secretKey")] = None
    """
    SecretKey is the AWS API secret.
    """
    tls_config: Annotated[Optional[TlsConfigModel4], Field(alias="tlsConfig")] = None
    """
    TLS configuration to connect to the AWS EC2 API.
    It requires Prometheus >= v2.41.0
    """


class EurekaSdConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["EurekaSdConfig"]:
            return EurekaSdConfig

        def build(self) -> "EurekaSdConfig":
            return EurekaSdConfig(**self._attrs)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel1], /
        ) -> "EurekaSdConfig.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel1.Builder],
                AuthorizationModel1.Builder | AuthorizationModel1,
            ],
            /,
        ) -> "EurekaSdConfig.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel1.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization header to use on every scrape request.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel1.builder())
                if isinstance(output, AuthorizationModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def basic_auth(
            self, value_or_callback: Optional[BasicAuth], /
        ) -> "EurekaSdConfig.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "EurekaSdConfig.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            BasicAuth information to use on every scrape request.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            Whether to enable HTTP2.
            """
            return self._set("enable_http2", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            Configure whether HTTP requests follow HTTP 3xx redirects.
            """
            return self._set("follow_redirects", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        @overload
        def oauth2(self, value_or_callback: Optional[Oauth2], /) -> "EurekaSdConfig.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "EurekaSdConfig.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            Optional OAuth 2.0 configuration.
            Cannot be set at the same time as `authorization` or `basic_auth`.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        def refresh_interval(self, value: Optional[str], /) -> Self:
            """
            Refresh interval to re-read the instance list.
            """
            return self._set("refresh_interval", value)

        def server(self, value: str, /) -> Self:
            """
            The URL to connect to the Eureka server.
            """
            return self._set("server", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel4], /
        ) -> "EurekaSdConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel4.Builder], TlsConfigModel4.Builder | TlsConfigModel4
            ],
            /,
        ) -> "EurekaSdConfig.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel4.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration applying to the target HTTP endpoint.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel4.builder())
                if isinstance(output, TlsConfigModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["EurekaSdConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = EurekaSdConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for EurekaSdConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["EurekaSdConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use EurekaSdConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authorization: Optional[AuthorizationModel1] = None
    """
    Authorization header to use on every scrape request.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    BasicAuth information to use on every scrape request.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHTTP2")] = None
    """
    Whether to enable HTTP2.
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    Configure whether HTTP requests follow HTTP 3xx redirects.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    oauth2: Optional[Oauth2] = None
    """
    Optional OAuth 2.0 configuration.
    Cannot be set at the same time as `authorization` or `basic_auth`.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    refresh_interval: Annotated[
        Optional[str],
        Field(
            alias="refreshInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Refresh interval to re-read the instance list.
    """
    server: Annotated[str, Field(min_length=1)]
    """
    The URL to connect to the Eureka server.
    """
    tls_config: Annotated[Optional[TlsConfigModel4], Field(alias="tlsConfig")] = None
    """
    TLS configuration applying to the target HTTP endpoint.
    """


class File(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            SDFile represents a file used for service discovery
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            SDFile represents a file used for service discovery
            """
            self._value = value
            return self

        def build(self) -> "File":
            value = cast(str, self._value)
            return File(value)

    root: Annotated[str, Field(pattern="^[^*]*(\\*[^/]*)?\\.(json|yml|yaml|JSON|YML|YAML)$")]
    """
    SDFile represents a file used for service discovery
    """

    class BuilderContext(BuilderContextBase["File.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = File.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for File."""
        return cls.BuilderContext()


class FileSdConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FileSdConfig"]:
            return FileSdConfig

        def build(self) -> "FileSdConfig":
            return FileSdConfig(**self._attrs)

        @overload
        def files(self, value_or_callback: List[File], /) -> "FileSdConfig.Builder": ...

        @overload
        def files(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[File, File.Builder]],
                GenericListBuilder[File, File.Builder] | List[File],
            ],
            /,
        ) -> "FileSdConfig.Builder": ...

        @overload
        def files(self, value_or_callback: Never = ...) -> ListBuilderContext[File.Builder]: ...

        def files(self, value_or_callback=None, /):
            """
            List of files to be used for file discovery. Recommendation: use absolute paths. While relative paths work, the
            prometheus-operator project makes no guarantees about the working directory where the configuration file is
            stored.
            Files must be mounted using Prometheus.ConfigMaps or Prometheus.Secrets.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[File.Builder]()
                context._parent_builder = self
                context._field_name = "files"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(File.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("files", value)

        def refresh_interval(self, value: Optional[str], /) -> Self:
            """
            RefreshInterval configures the refresh interval at which Prometheus will reload the content of the files.
            """
            return self._set("refresh_interval", value)

    class BuilderContext(BuilderContextBase["FileSdConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FileSdConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FileSdConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FileSdConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FileSdConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    files: Annotated[List[File], Field(min_length=1)]
    """
    List of files to be used for file discovery. Recommendation: use absolute paths. While relative paths work, the
    prometheus-operator project makes no guarantees about the working directory where the configuration file is
    stored.
    Files must be mounted using Prometheus.ConfigMaps or Prometheus.Secrets.
    """
    refresh_interval: Annotated[
        Optional[str],
        Field(
            alias="refreshInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    RefreshInterval configures the refresh interval at which Prometheus will reload the content of the files.
    """


class GceSdConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GceSdConfig"]:
            return GceSdConfig

        def build(self) -> "GceSdConfig":
            return GceSdConfig(**self._attrs)

        def filter(self, value: Optional[str], /) -> Self:
            """
            Filter can be used optionally to filter the instance list by other criteria
            Syntax of this filter is described in the filter query parameter section:
            https://cloud.google.com/compute/docs/reference/latest/instances/list
            """
            return self._set("filter", value)

        def port(self, value: Optional[int], /) -> Self:
            """
            The port to scrape metrics from. If using the public IP address, this must
            instead be specified in the relabeling rule.
            """
            return self._set("port", value)

        def project(self, value: str, /) -> Self:
            """
            The Google Cloud Project ID
            """
            return self._set("project", value)

        def refresh_interval(self, value: Optional[str], /) -> Self:
            """
            RefreshInterval configures the refresh interval at which Prometheus will re-read the instance list.
            """
            return self._set("refresh_interval", value)

        def tag_separator(self, value: Optional[str], /) -> Self:
            """
            The tag separator is used to separate the tags on concatenation
            """
            return self._set("tag_separator", value)

        def zone(self, value: str, /) -> Self:
            """
            The zone of the scrape targets. If you need multiple zones use multiple GCESDConfigs.
            """
            return self._set("zone", value)

    class BuilderContext(BuilderContextBase["GceSdConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GceSdConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GceSdConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GceSdConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GceSdConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    filter: Annotated[Optional[str], Field(min_length=1)] = None
    """
    Filter can be used optionally to filter the instance list by other criteria
    Syntax of this filter is described in the filter query parameter section:
    https://cloud.google.com/compute/docs/reference/latest/instances/list
    """
    port: Annotated[Optional[int], Field(ge=0, le=65535)] = None
    """
    The port to scrape metrics from. If using the public IP address, this must
    instead be specified in the relabeling rule.
    """
    project: Annotated[str, Field(min_length=1)]
    """
    The Google Cloud Project ID
    """
    refresh_interval: Annotated[
        Optional[str],
        Field(
            alias="refreshInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    RefreshInterval configures the refresh interval at which Prometheus will re-read the instance list.
    """
    tag_separator: Annotated[Optional[str], Field(alias="tagSeparator", min_length=1)] = None
    """
    The tag separator is used to separate the tags on concatenation
    """
    zone: Annotated[str, Field(min_length=1)]
    """
    The zone of the scrape targets. If you need multiple zones use multiple GCESDConfigs.
    """


class HetznerSdConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HetznerSdConfig"]:
            return HetznerSdConfig

        def build(self) -> "HetznerSdConfig":
            return HetznerSdConfig(**self._attrs)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel1], /
        ) -> "HetznerSdConfig.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel1.Builder],
                AuthorizationModel1.Builder | AuthorizationModel1,
            ],
            /,
        ) -> "HetznerSdConfig.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel1.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization header configuration, required when role is hcloud.
            Role robot does not support bearer token authentication.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel1.builder())
                if isinstance(output, AuthorizationModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def basic_auth(
            self, value_or_callback: Optional[BasicAuth], /
        ) -> "HetznerSdConfig.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "HetznerSdConfig.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            BasicAuth information to use on every scrape request, required when role is robot.
            Role hcloud does not support basic auth.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            Whether to enable HTTP2.
            """
            return self._set("enable_http2", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            Configure whether HTTP requests follow HTTP 3xx redirects.
            """
            return self._set("follow_redirects", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        @overload
        def oauth2(self, value_or_callback: Optional[Oauth2], /) -> "HetznerSdConfig.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "HetznerSdConfig.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            Optional OAuth 2.0 configuration.
            Cannot be used at the same time as `basic_auth` or `authorization`.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        def port(self, value: Optional[int], /) -> Self:
            """
            The port to scrape metrics from.
            """
            return self._set("port", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        def refresh_interval(self, value: Optional[str], /) -> Self:
            """
            The time after which the servers are refreshed.
            """
            return self._set("refresh_interval", value)

        def role(self, value: Literal["hcloud", "Hcloud", "robot", "Robot"], /) -> Self:
            """
            The Hetzner role of entities that should be discovered.
            """
            return self._set("role", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel4], /
        ) -> "HetznerSdConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel4.Builder], TlsConfigModel4.Builder | TlsConfigModel4
            ],
            /,
        ) -> "HetznerSdConfig.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel4.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration to use on every scrape request.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel4.builder())
                if isinstance(output, TlsConfigModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["HetznerSdConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HetznerSdConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HetznerSdConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HetznerSdConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HetznerSdConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authorization: Optional[AuthorizationModel1] = None
    """
    Authorization header configuration, required when role is hcloud.
    Role robot does not support bearer token authentication.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    BasicAuth information to use on every scrape request, required when role is robot.
    Role hcloud does not support basic auth.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHTTP2")] = None
    """
    Whether to enable HTTP2.
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    Configure whether HTTP requests follow HTTP 3xx redirects.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    oauth2: Optional[Oauth2] = None
    """
    Optional OAuth 2.0 configuration.
    Cannot be used at the same time as `basic_auth` or `authorization`.
    """
    port: Optional[int] = None
    """
    The port to scrape metrics from.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    refresh_interval: Annotated[
        Optional[str],
        Field(
            alias="refreshInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    The time after which the servers are refreshed.
    """
    role: Literal["hcloud", "Hcloud", "robot", "Robot"]
    """
    The Hetzner role of entities that should be discovered.
    """
    tls_config: Annotated[Optional[TlsConfigModel4], Field(alias="tlsConfig")] = None
    """
    TLS configuration to use on every scrape request.
    """


class HttpSdConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HttpSdConfig"]:
            return HttpSdConfig

        def build(self) -> "HttpSdConfig":
            return HttpSdConfig(**self._attrs)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel1], /
        ) -> "HttpSdConfig.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel1.Builder],
                AuthorizationModel1.Builder | AuthorizationModel1,
            ],
            /,
        ) -> "HttpSdConfig.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel1.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization header configuration to authenticate against the target HTTP endpoint.
            Cannot be set at the same time as `oAuth2`, or `basicAuth`.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel1.builder())
                if isinstance(output, AuthorizationModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def basic_auth(
            self, value_or_callback: Optional[BasicAuth], /
        ) -> "HttpSdConfig.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "HttpSdConfig.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            BasicAuth information to authenticate against the target HTTP endpoint.
            More info: https://prometheus.io/docs/operating/configuration/#endpoints
            Cannot be set at the same time as `authorization`, or `oAuth2`.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            Whether to enable HTTP2.
            """
            return self._set("enable_http2", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            Configure whether HTTP requests follow HTTP 3xx redirects.
            """
            return self._set("follow_redirects", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        @overload
        def oauth2(self, value_or_callback: Optional[Oauth2], /) -> "HttpSdConfig.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "HttpSdConfig.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            Optional OAuth 2.0 configuration to authenticate against the target HTTP endpoint.
            Cannot be set at the same time as `authorization`, or `basicAuth`.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        def refresh_interval(self, value: Optional[str], /) -> Self:
            """
            RefreshInterval configures the refresh interval at which Prometheus will re-query the
            endpoint to update the target list.
            """
            return self._set("refresh_interval", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel4], /
        ) -> "HttpSdConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel4.Builder], TlsConfigModel4.Builder | TlsConfigModel4
            ],
            /,
        ) -> "HttpSdConfig.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel4.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration applying to the target HTTP endpoint.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel4.builder())
                if isinstance(output, TlsConfigModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

        def url(self, value: str, /) -> Self:
            """
            URL from which the targets are fetched.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["HttpSdConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HttpSdConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HttpSdConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HttpSdConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HttpSdConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authorization: Optional[AuthorizationModel1] = None
    """
    Authorization header configuration to authenticate against the target HTTP endpoint.
    Cannot be set at the same time as `oAuth2`, or `basicAuth`.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    BasicAuth information to authenticate against the target HTTP endpoint.
    More info: https://prometheus.io/docs/operating/configuration/#endpoints
    Cannot be set at the same time as `authorization`, or `oAuth2`.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHTTP2")] = None
    """
    Whether to enable HTTP2.
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    Configure whether HTTP requests follow HTTP 3xx redirects.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    oauth2: Optional[Oauth2] = None
    """
    Optional OAuth 2.0 configuration to authenticate against the target HTTP endpoint.
    Cannot be set at the same time as `authorization`, or `basicAuth`.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    refresh_interval: Annotated[
        Optional[str],
        Field(
            alias="refreshInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    RefreshInterval configures the refresh interval at which Prometheus will re-query the
    endpoint to update the target list.
    """
    tls_config: Annotated[Optional[TlsConfigModel4], Field(alias="tlsConfig")] = None
    """
    TLS configuration applying to the target HTTP endpoint.
    """
    url: Annotated[str, Field(min_length=1, pattern="^http(s)?://.+$")]
    """
    URL from which the targets are fetched.
    """


class IonosSdConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IonosSdConfig"]:
            return IonosSdConfig

        def build(self) -> "IonosSdConfig":
            return IonosSdConfig(**self._attrs)

        @overload
        def authorization(
            self, value_or_callback: AuthorizationModel1, /
        ) -> "IonosSdConfig.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel1.Builder],
                AuthorizationModel1.Builder | AuthorizationModel1,
            ],
            /,
        ) -> "IonosSdConfig.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel1.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization` header configuration, required when using IONOS.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel1.builder())
                if isinstance(output, AuthorizationModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        def datacenter_id(self, value: str, /) -> Self:
            """
            The unique ID of the IONOS data center.
            """
            return self._set("datacenter_id", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            Configure whether to enable HTTP2.
            """
            return self._set("enable_http2", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            Configure whether the HTTP requests should follow HTTP 3xx redirects.
            """
            return self._set("follow_redirects", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        @overload
        def oauth2(self, value_or_callback: Optional[Oauth2], /) -> "IonosSdConfig.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "IonosSdConfig.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            Configure whether to enable OAuth2.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        def port(self, value: Optional[int], /) -> Self:
            """
            Port to scrape the metrics from.
            """
            return self._set("port", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        def refresh_interval(self, value: Optional[str], /) -> Self:
            """
            Refresh interval to re-read the list of resources.
            """
            return self._set("refresh_interval", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel4], /
        ) -> "IonosSdConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel4.Builder], TlsConfigModel4.Builder | TlsConfigModel4
            ],
            /,
        ) -> "IonosSdConfig.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel4.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration to use when connecting to the IONOS API.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel4.builder())
                if isinstance(output, TlsConfigModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["IonosSdConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IonosSdConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IonosSdConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IonosSdConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IonosSdConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authorization: AuthorizationModel1
    """
    Authorization` header configuration, required when using IONOS.
    """
    datacenter_id: Annotated[str, Field(alias="datacenterID", min_length=1)]
    """
    The unique ID of the IONOS data center.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHTTP2")] = None
    """
    Configure whether to enable HTTP2.
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    Configure whether the HTTP requests should follow HTTP 3xx redirects.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    oauth2: Optional[Oauth2] = None
    """
    Configure whether to enable OAuth2.
    """
    port: Annotated[Optional[int], Field(ge=0, le=65535)] = None
    """
    Port to scrape the metrics from.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    refresh_interval: Annotated[
        Optional[str],
        Field(
            alias="refreshInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Refresh interval to re-read the list of resources.
    """
    tls_config: Annotated[Optional[TlsConfigModel4], Field(alias="tlsConfig")] = None
    """
    TLS configuration to use when connecting to the IONOS API.
    """


class AttachMetadataModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AttachMetadataModel"]:
            return AttachMetadataModel

        def build(self) -> "AttachMetadataModel":
            return AttachMetadataModel(**self._attrs)

        def node(self, value: Optional[bool], /) -> Self:
            """
            Attaches node metadata to discovered targets.
            When set to true, Prometheus must have the `get` permission on the
            `Nodes` objects.
            Only valid for Pod, Endpoint and Endpointslice roles.
            """
            return self._set("node", value)

    class BuilderContext(BuilderContextBase["AttachMetadataModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AttachMetadataModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AttachMetadataModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AttachMetadataModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AttachMetadataModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    node: Optional[bool] = None
    """
    Attaches node metadata to discovered targets.
    When set to true, Prometheus must have the `get` permission on the
    `Nodes` objects.
    Only valid for Pod, Endpoint and Endpointslice roles.
    """


class Namespaces(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Namespaces"]:
            return Namespaces

        def build(self) -> "Namespaces":
            return Namespaces(**self._attrs)

        def names(self, value: Optional[List[str]], /) -> Self:
            """
            List of namespaces where to watch for resources.
            If empty and `ownNamespace` isn't true, Prometheus watches for resources in all namespaces.
            """
            return self._set("names", value)

        def own_namespace(self, value: Optional[bool], /) -> Self:
            """
            Includes the namespace in which the Prometheus pod runs to the list of watched namespaces.
            """
            return self._set("own_namespace", value)

    class BuilderContext(BuilderContextBase["Namespaces.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Namespaces.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Namespaces."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Namespaces", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Namespaces.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    names: Optional[List[str]] = None
    """
    List of namespaces where to watch for resources.
    If empty and `ownNamespace` isn't true, Prometheus watches for resources in all namespaces.
    """
    own_namespace: Annotated[Optional[bool], Field(alias="ownNamespace")] = None
    """
    Includes the namespace in which the Prometheus pod runs to the list of watched namespaces.
    """


class SelectorModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SelectorModel"]:
            return SelectorModel

        def build(self) -> "SelectorModel":
            return SelectorModel(**self._attrs)

        def field(self, value: Optional[str], /) -> Self:
            """
            An optional field selector to limit the service discovery to resources which have fields with specific values.
            e.g: `metadata.name=foobar`
            """
            return self._set("field", value)

        def label(self, value: Optional[str], /) -> Self:
            """
            An optional label selector to limit the service discovery to resources with specific labels and label values.
            e.g: `node.kubernetes.io/instance-type=master`
            """
            return self._set("label", value)

        def role(
            self,
            value: Literal["Pod", "Endpoints", "Ingress", "Service", "Node", "EndpointSlice"],
            /,
        ) -> Self:
            """
            Role specifies the type of Kubernetes resource to limit the service discovery to.
            Accepted values are: Node, Pod, Endpoints, EndpointSlice, Service, Ingress.
            """
            return self._set("role", value)

    class BuilderContext(BuilderContextBase["SelectorModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SelectorModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SelectorModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SelectorModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SelectorModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    field: Annotated[Optional[str], Field(min_length=1)] = None
    """
    An optional field selector to limit the service discovery to resources which have fields with specific values.
    e.g: `metadata.name=foobar`
    """
    label: Annotated[Optional[str], Field(min_length=1)] = None
    """
    An optional label selector to limit the service discovery to resources with specific labels and label values.
    e.g: `node.kubernetes.io/instance-type=master`
    """
    role: Literal["Pod", "Endpoints", "Ingress", "Service", "Node", "EndpointSlice"]
    """
    Role specifies the type of Kubernetes resource to limit the service discovery to.
    Accepted values are: Node, Pod, Endpoints, EndpointSlice, Service, Ingress.
    """


class KubernetesSdConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["KubernetesSdConfig"]:
            return KubernetesSdConfig

        def build(self) -> "KubernetesSdConfig":
            return KubernetesSdConfig(**self._attrs)

        def api_server(self, value: Optional[str], /) -> Self:
            """
            The API server address consisting of a hostname or IP address followed
            by an optional port number.
            If left empty, Prometheus is assumed to run inside
            of the cluster. It will discover API servers automatically and use the pod's
            CA certificate and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
            """
            return self._set("api_server", value)

        @overload
        def attach_metadata(
            self, value_or_callback: Optional[AttachMetadataModel], /
        ) -> "KubernetesSdConfig.Builder": ...

        @overload
        def attach_metadata(
            self,
            value_or_callback: Callable[
                [AttachMetadataModel.Builder],
                AttachMetadataModel.Builder | AttachMetadataModel,
            ],
            /,
        ) -> "KubernetesSdConfig.Builder": ...

        @overload
        def attach_metadata(
            self, value_or_callback: Never = ...
        ) -> "AttachMetadataModel.BuilderContext": ...

        def attach_metadata(self, value_or_callback=None, /):
            """
            Optional metadata to attach to discovered targets.
            It requires Prometheus >= v2.35.0 when using the `Pod` role and
            Prometheus >= v2.37.0 for `Endpoints` and `Endpointslice` roles.
            """
            if self._in_context and value_or_callback is None:
                context = AttachMetadataModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "attach_metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AttachMetadataModel.builder())
                if isinstance(output, AttachMetadataModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("attach_metadata", value)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel1], /
        ) -> "KubernetesSdConfig.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel1.Builder],
                AuthorizationModel1.Builder | AuthorizationModel1,
            ],
            /,
        ) -> "KubernetesSdConfig.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel1.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization header to use on every scrape request.
            Cannot be set at the same time as `basicAuth`, or `oauth2`.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel1.builder())
                if isinstance(output, AuthorizationModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def basic_auth(
            self, value_or_callback: Optional[BasicAuth], /
        ) -> "KubernetesSdConfig.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "KubernetesSdConfig.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            BasicAuth information to use on every scrape request.
            Cannot be set at the same time as `authorization`, or `oauth2`.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            Whether to enable HTTP2.
            """
            return self._set("enable_http2", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            Configure whether HTTP requests follow HTTP 3xx redirects.
            """
            return self._set("follow_redirects", value)

        @overload
        def namespaces(
            self, value_or_callback: Optional[Namespaces], /
        ) -> "KubernetesSdConfig.Builder": ...

        @overload
        def namespaces(
            self,
            value_or_callback: Callable[[Namespaces.Builder], Namespaces.Builder | Namespaces],
            /,
        ) -> "KubernetesSdConfig.Builder": ...

        @overload
        def namespaces(self, value_or_callback: Never = ...) -> "Namespaces.BuilderContext": ...

        def namespaces(self, value_or_callback=None, /):
            """
            Optional namespace discovery. If omitted, Prometheus discovers targets across all namespaces.
            """
            if self._in_context and value_or_callback is None:
                context = Namespaces.BuilderContext()
                context._parent_builder = self
                context._field_name = "namespaces"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Namespaces.builder())
                if isinstance(output, Namespaces.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("namespaces", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        @overload
        def oauth2(
            self, value_or_callback: Optional[Oauth2], /
        ) -> "KubernetesSdConfig.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "KubernetesSdConfig.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            Optional OAuth 2.0 configuration.
            Cannot be set at the same time as `authorization`, or `basicAuth`.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        def role(
            self,
            value: Literal["Pod", "Endpoints", "Ingress", "Service", "Node", "EndpointSlice"],
            /,
        ) -> Self:
            """
            Role of the Kubernetes entities that should be discovered.
            Role `Endpointslice` requires Prometheus >= v2.21.0
            """
            return self._set("role", value)

        @overload
        def selectors(
            self, value_or_callback: List[SelectorModel], /
        ) -> "KubernetesSdConfig.Builder": ...

        @overload
        def selectors(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[SelectorModel, SelectorModel.Builder]],
                GenericListBuilder[SelectorModel, SelectorModel.Builder] | List[SelectorModel],
            ],
            /,
        ) -> "KubernetesSdConfig.Builder": ...

        @overload
        def selectors(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[SelectorModel.Builder]: ...

        def selectors(self, value_or_callback=None, /):
            """
            Selector to select objects.
            It requires Prometheus >= v2.17.0
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[SelectorModel.Builder]()
                context._parent_builder = self
                context._field_name = "selectors"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SelectorModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("selectors", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel4], /
        ) -> "KubernetesSdConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel4.Builder], TlsConfigModel4.Builder | TlsConfigModel4
            ],
            /,
        ) -> "KubernetesSdConfig.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel4.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration to connect to the Kubernetes API.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel4.builder())
                if isinstance(output, TlsConfigModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["KubernetesSdConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = KubernetesSdConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for KubernetesSdConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["KubernetesSdConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KubernetesSdConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_server: Annotated[Optional[str], Field(alias="apiServer", min_length=1)] = None
    """
    The API server address consisting of a hostname or IP address followed
    by an optional port number.
    If left empty, Prometheus is assumed to run inside
    of the cluster. It will discover API servers automatically and use the pod's
    CA certificate and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
    """
    attach_metadata: Annotated[Optional[AttachMetadataModel], Field(alias="attachMetadata")] = None
    """
    Optional metadata to attach to discovered targets.
    It requires Prometheus >= v2.35.0 when using the `Pod` role and
    Prometheus >= v2.37.0 for `Endpoints` and `Endpointslice` roles.
    """
    authorization: Optional[AuthorizationModel1] = None
    """
    Authorization header to use on every scrape request.
    Cannot be set at the same time as `basicAuth`, or `oauth2`.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    BasicAuth information to use on every scrape request.
    Cannot be set at the same time as `authorization`, or `oauth2`.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHTTP2")] = None
    """
    Whether to enable HTTP2.
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    Configure whether HTTP requests follow HTTP 3xx redirects.
    """
    namespaces: Optional[Namespaces] = None
    """
    Optional namespace discovery. If omitted, Prometheus discovers targets across all namespaces.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    oauth2: Optional[Oauth2] = None
    """
    Optional OAuth 2.0 configuration.
    Cannot be set at the same time as `authorization`, or `basicAuth`.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    role: Literal["Pod", "Endpoints", "Ingress", "Service", "Node", "EndpointSlice"]
    """
    Role of the Kubernetes entities that should be discovered.
    Role `Endpointslice` requires Prometheus >= v2.21.0
    """
    selectors: Optional[List[SelectorModel]] = None
    """
    Selector to select objects.
    It requires Prometheus >= v2.17.0
    """
    tls_config: Annotated[Optional[TlsConfigModel4], Field(alias="tlsConfig")] = None
    """
    TLS configuration to connect to the Kubernetes API.
    """


class KumaSdConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["KumaSdConfig"]:
            return KumaSdConfig

        def build(self) -> "KumaSdConfig":
            return KumaSdConfig(**self._attrs)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel1], /
        ) -> "KumaSdConfig.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel1.Builder],
                AuthorizationModel1.Builder | AuthorizationModel1,
            ],
            /,
        ) -> "KumaSdConfig.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel1.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization header to use on every scrape request.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel1.builder())
                if isinstance(output, AuthorizationModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def basic_auth(
            self, value_or_callback: Optional[BasicAuth], /
        ) -> "KumaSdConfig.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "KumaSdConfig.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            BasicAuth information to use on every scrape request.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        def client_id(self, value: Optional[str], /) -> Self:
            """
            Client id is used by Kuma Control Plane to compute Monitoring Assignment for specific Prometheus backend.
            """
            return self._set("client_id", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            Whether to enable HTTP2.
            """
            return self._set("enable_http2", value)

        def fetch_timeout(self, value: Optional[str], /) -> Self:
            """
            The time after which the monitoring assignments are refreshed.
            """
            return self._set("fetch_timeout", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            Configure whether HTTP requests follow HTTP 3xx redirects.
            """
            return self._set("follow_redirects", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        @overload
        def oauth2(self, value_or_callback: Optional[Oauth2], /) -> "KumaSdConfig.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "KumaSdConfig.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            Optional OAuth 2.0 configuration.
            Cannot be set at the same time as `authorization`, or `basicAuth`.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        def refresh_interval(self, value: Optional[str], /) -> Self:
            """
            The time to wait between polling update requests.
            """
            return self._set("refresh_interval", value)

        def server(self, value: str, /) -> Self:
            """
            Address of the Kuma Control Plane's MADS xDS server.
            """
            return self._set("server", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel4], /
        ) -> "KumaSdConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel4.Builder], TlsConfigModel4.Builder | TlsConfigModel4
            ],
            /,
        ) -> "KumaSdConfig.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel4.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration to use on every scrape request
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel4.builder())
                if isinstance(output, TlsConfigModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["KumaSdConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = KumaSdConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for KumaSdConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["KumaSdConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KumaSdConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authorization: Optional[AuthorizationModel1] = None
    """
    Authorization header to use on every scrape request.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    BasicAuth information to use on every scrape request.
    """
    client_id: Annotated[Optional[str], Field(alias="clientID")] = None
    """
    Client id is used by Kuma Control Plane to compute Monitoring Assignment for specific Prometheus backend.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHTTP2")] = None
    """
    Whether to enable HTTP2.
    """
    fetch_timeout: Annotated[
        Optional[str],
        Field(
            alias="fetchTimeout",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    The time after which the monitoring assignments are refreshed.
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    Configure whether HTTP requests follow HTTP 3xx redirects.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    oauth2: Optional[Oauth2] = None
    """
    Optional OAuth 2.0 configuration.
    Cannot be set at the same time as `authorization`, or `basicAuth`.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    refresh_interval: Annotated[
        Optional[str],
        Field(
            alias="refreshInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    The time to wait between polling update requests.
    """
    server: Annotated[str, Field(min_length=1)]
    """
    Address of the Kuma Control Plane's MADS xDS server.
    """
    tls_config: Annotated[Optional[TlsConfigModel4], Field(alias="tlsConfig")] = None
    """
    TLS configuration to use on every scrape request
    """


class LightSailSdConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LightSailSdConfig"]:
            return LightSailSdConfig

        def build(self) -> "LightSailSdConfig":
            return LightSailSdConfig(**self._attrs)

        @overload
        def access_key(
            self, value_or_callback: Optional[AccessKey], /
        ) -> "LightSailSdConfig.Builder": ...

        @overload
        def access_key(
            self,
            value_or_callback: Callable[[AccessKey.Builder], AccessKey.Builder | AccessKey],
            /,
        ) -> "LightSailSdConfig.Builder": ...

        @overload
        def access_key(self, value_or_callback: Never = ...) -> "AccessKey.BuilderContext": ...

        def access_key(self, value_or_callback=None, /):
            """
            AccessKey is the AWS API key.
            """
            if self._in_context and value_or_callback is None:
                context = AccessKey.BuilderContext()
                context._parent_builder = self
                context._field_name = "access_key"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AccessKey.builder())
                if isinstance(output, AccessKey.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("access_key", value)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel1], /
        ) -> "LightSailSdConfig.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel1.Builder],
                AuthorizationModel1.Builder | AuthorizationModel1,
            ],
            /,
        ) -> "LightSailSdConfig.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel1.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Optional `authorization` HTTP header configuration.
            Cannot be set at the same time as `basicAuth`, or `oauth2`.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel1.builder())
                if isinstance(output, AuthorizationModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def basic_auth(
            self, value_or_callback: Optional[BasicAuth], /
        ) -> "LightSailSdConfig.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "LightSailSdConfig.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            Optional HTTP basic authentication information.
            Cannot be set at the same time as `authorization`, or `oauth2`.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            Configure whether to enable HTTP2.
            """
            return self._set("enable_http2", value)

        def endpoint(self, value: Optional[str], /) -> Self:
            """
            Custom endpoint to be used.
            """
            return self._set("endpoint", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            Configure whether the HTTP requests should follow HTTP 3xx redirects.
            """
            return self._set("follow_redirects", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        @overload
        def oauth2(self, value_or_callback: Optional[Oauth2], /) -> "LightSailSdConfig.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "LightSailSdConfig.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            Optional OAuth2.0 configuration.
            Cannot be set at the same time as `basicAuth`, or `authorization`.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        def port(self, value: Optional[int], /) -> Self:
            """
            Port to scrape the metrics from.
            If using the public IP address, this must instead be specified in the relabeling rule.
            """
            return self._set("port", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        def refresh_interval(self, value: Optional[str], /) -> Self:
            """
            Refresh interval to re-read the list of instances.
            """
            return self._set("refresh_interval", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The AWS region.
            """
            return self._set("region", value)

        def role_arn(self, value: Optional[str], /) -> Self:
            """
            AWS Role ARN, an alternative to using AWS API keys.
            """
            return self._set("role_arn", value)

        @overload
        def secret_key(
            self, value_or_callback: Optional[SecretKey], /
        ) -> "LightSailSdConfig.Builder": ...

        @overload
        def secret_key(
            self,
            value_or_callback: Callable[[SecretKey.Builder], SecretKey.Builder | SecretKey],
            /,
        ) -> "LightSailSdConfig.Builder": ...

        @overload
        def secret_key(self, value_or_callback: Never = ...) -> "SecretKey.BuilderContext": ...

        def secret_key(self, value_or_callback=None, /):
            """
            SecretKey is the AWS API secret.
            """
            if self._in_context and value_or_callback is None:
                context = SecretKey.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_key"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretKey.builder())
                if isinstance(output, SecretKey.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_key", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel4], /
        ) -> "LightSailSdConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel4.Builder], TlsConfigModel4.Builder | TlsConfigModel4
            ],
            /,
        ) -> "LightSailSdConfig.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel4.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration to connect to the Puppet DB.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel4.builder())
                if isinstance(output, TlsConfigModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["LightSailSdConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LightSailSdConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LightSailSdConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LightSailSdConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LightSailSdConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_key: Annotated[Optional[AccessKey], Field(alias="accessKey")] = None
    """
    AccessKey is the AWS API key.
    """
    authorization: Optional[AuthorizationModel1] = None
    """
    Optional `authorization` HTTP header configuration.
    Cannot be set at the same time as `basicAuth`, or `oauth2`.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    Optional HTTP basic authentication information.
    Cannot be set at the same time as `authorization`, or `oauth2`.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHTTP2")] = None
    """
    Configure whether to enable HTTP2.
    """
    endpoint: Annotated[Optional[str], Field(min_length=1)] = None
    """
    Custom endpoint to be used.
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    Configure whether the HTTP requests should follow HTTP 3xx redirects.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    oauth2: Optional[Oauth2] = None
    """
    Optional OAuth2.0 configuration.
    Cannot be set at the same time as `basicAuth`, or `authorization`.
    """
    port: Annotated[Optional[int], Field(ge=0, le=65535)] = None
    """
    Port to scrape the metrics from.
    If using the public IP address, this must instead be specified in the relabeling rule.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    refresh_interval: Annotated[
        Optional[str],
        Field(
            alias="refreshInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Refresh interval to re-read the list of instances.
    """
    region: Annotated[Optional[str], Field(min_length=1)] = None
    """
    The AWS region.
    """
    role_arn: Annotated[Optional[str], Field(alias="roleARN")] = None
    """
    AWS Role ARN, an alternative to using AWS API keys.
    """
    secret_key: Annotated[Optional[SecretKey], Field(alias="secretKey")] = None
    """
    SecretKey is the AWS API secret.
    """
    tls_config: Annotated[Optional[TlsConfigModel4], Field(alias="tlsConfig")] = None
    """
    TLS configuration to connect to the Puppet DB.
    """


class LinodeSdConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LinodeSdConfig"]:
            return LinodeSdConfig

        def build(self) -> "LinodeSdConfig":
            return LinodeSdConfig(**self._attrs)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel1], /
        ) -> "LinodeSdConfig.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel1.Builder],
                AuthorizationModel1.Builder | AuthorizationModel1,
            ],
            /,
        ) -> "LinodeSdConfig.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel1.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization header configuration.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel1.builder())
                if isinstance(output, AuthorizationModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            Whether to enable HTTP2.
            """
            return self._set("enable_http2", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            Configure whether HTTP requests follow HTTP 3xx redirects.
            """
            return self._set("follow_redirects", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        @overload
        def oauth2(self, value_or_callback: Optional[Oauth2], /) -> "LinodeSdConfig.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "LinodeSdConfig.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            Optional OAuth 2.0 configuration.
            Cannot be used at the same time as `authorization`.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        def port(self, value: Optional[int], /) -> Self:
            """
            Default port to scrape metrics from.
            """
            return self._set("port", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        def refresh_interval(self, value: Optional[str], /) -> Self:
            """
            Time after which the linode instances are refreshed.
            """
            return self._set("refresh_interval", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            Optional region to filter on.
            """
            return self._set("region", value)

        def tag_separator(self, value: Optional[str], /) -> Self:
            """
            The string by which Linode Instance tags are joined into the tag label.
            """
            return self._set("tag_separator", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel4], /
        ) -> "LinodeSdConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel4.Builder], TlsConfigModel4.Builder | TlsConfigModel4
            ],
            /,
        ) -> "LinodeSdConfig.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel4.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration applying to the target HTTP endpoint.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel4.builder())
                if isinstance(output, TlsConfigModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["LinodeSdConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LinodeSdConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LinodeSdConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LinodeSdConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LinodeSdConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authorization: Optional[AuthorizationModel1] = None
    """
    Authorization header configuration.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHTTP2")] = None
    """
    Whether to enable HTTP2.
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    Configure whether HTTP requests follow HTTP 3xx redirects.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    oauth2: Optional[Oauth2] = None
    """
    Optional OAuth 2.0 configuration.
    Cannot be used at the same time as `authorization`.
    """
    port: Annotated[Optional[int], Field(ge=0, le=65535)] = None
    """
    Default port to scrape metrics from.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    refresh_interval: Annotated[
        Optional[str],
        Field(
            alias="refreshInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Time after which the linode instances are refreshed.
    """
    region: Annotated[Optional[str], Field(min_length=1)] = None
    """
    Optional region to filter on.
    """
    tag_separator: Annotated[Optional[str], Field(alias="tagSeparator", min_length=1)] = None
    """
    The string by which Linode Instance tags are joined into the tag label.
    """
    tls_config: Annotated[Optional[TlsConfigModel4], Field(alias="tlsConfig")] = None
    """
    TLS configuration applying to the target HTTP endpoint.
    """


class NativeHistogramMinBucketFactor(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            If the growth factor of one bucket to the next is smaller than this,
            buckets will be merged to increase the factor sufficiently.
            It requires Prometheus >= v2.50.0.
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            If the growth factor of one bucket to the next is smaller than this,
            buckets will be merged to increase the factor sufficiently.
            It requires Prometheus >= v2.50.0.
            """
            self._value = value
            return self

        def build(self) -> "NativeHistogramMinBucketFactor":
            value = cast(int, self._value)
            return NativeHistogramMinBucketFactor(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    If the growth factor of one bucket to the next is smaller than this,
    buckets will be merged to increase the factor sufficiently.
    It requires Prometheus >= v2.50.0.
    """

    class BuilderContext(BuilderContextBase["NativeHistogramMinBucketFactor.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NativeHistogramMinBucketFactor.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NativeHistogramMinBucketFactor."""
        return cls.BuilderContext()


class NativeHistogramMinBucketFactorModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            If the growth factor of one bucket to the next is smaller than this,
            buckets will be merged to increase the factor sufficiently.
            It requires Prometheus >= v2.50.0.
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            If the growth factor of one bucket to the next is smaller than this,
            buckets will be merged to increase the factor sufficiently.
            It requires Prometheus >= v2.50.0.
            """
            self._value = value
            return self

        def build(self) -> "NativeHistogramMinBucketFactorModel":
            value = cast(str, self._value)
            return NativeHistogramMinBucketFactorModel(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    If the growth factor of one bucket to the next is smaller than this,
    buckets will be merged to increase the factor sufficiently.
    It requires Prometheus >= v2.50.0.
    """

    class BuilderContext(BuilderContextBase["NativeHistogramMinBucketFactorModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NativeHistogramMinBucketFactorModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NativeHistogramMinBucketFactorModel."""
        return cls.BuilderContext()


class NomadSdConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NomadSdConfig"]:
            return NomadSdConfig

        def build(self) -> "NomadSdConfig":
            return NomadSdConfig(**self._attrs)

        def allow_stale(self, value: Optional[bool], /) -> Self:
            """
            The information to access the Nomad API. It is to be defined
            as the Nomad documentation requires.
            """
            return self._set("allow_stale", value)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel1], /
        ) -> "NomadSdConfig.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel1.Builder],
                AuthorizationModel1.Builder | AuthorizationModel1,
            ],
            /,
        ) -> "NomadSdConfig.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel1.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization header to use on every scrape request.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel1.builder())
                if isinstance(output, AuthorizationModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def basic_auth(
            self, value_or_callback: Optional[BasicAuth], /
        ) -> "NomadSdConfig.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "NomadSdConfig.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            BasicAuth information to use on every scrape request.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            Whether to enable HTTP2.
            """
            return self._set("enable_http2", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            Configure whether HTTP requests follow HTTP 3xx redirects.
            """
            return self._set("follow_redirects", value)

        def namespace(self, value: Optional[str], /) -> Self:
            return self._set("namespace", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        @overload
        def oauth2(self, value_or_callback: Optional[Oauth2], /) -> "NomadSdConfig.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "NomadSdConfig.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            Optional OAuth 2.0 configuration.
            Cannot be set at the same time as `authorization` or `basic_auth`.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        def refresh_interval(self, value: Optional[str], /) -> Self:
            """
            Duration is a valid time duration that can be parsed by Prometheus model.ParseDuration() function.
            Supported units: y, w, d, h, m, s, ms
            Examples: `30s`, `1m`, `1h20m15s`, `15d`
            """
            return self._set("refresh_interval", value)

        def region(self, value: Optional[str], /) -> Self:
            return self._set("region", value)

        def server(self, value: str, /) -> Self:
            return self._set("server", value)

        def tag_separator(self, value: Optional[str], /) -> Self:
            return self._set("tag_separator", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel4], /
        ) -> "NomadSdConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel4.Builder], TlsConfigModel4.Builder | TlsConfigModel4
            ],
            /,
        ) -> "NomadSdConfig.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel4.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration applying to the target HTTP endpoint.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel4.builder())
                if isinstance(output, TlsConfigModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["NomadSdConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NomadSdConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NomadSdConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NomadSdConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NomadSdConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    allow_stale: Annotated[Optional[bool], Field(alias="allowStale")] = None
    """
    The information to access the Nomad API. It is to be defined
    as the Nomad documentation requires.
    """
    authorization: Optional[AuthorizationModel1] = None
    """
    Authorization header to use on every scrape request.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    BasicAuth information to use on every scrape request.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHTTP2")] = None
    """
    Whether to enable HTTP2.
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    Configure whether HTTP requests follow HTTP 3xx redirects.
    """
    namespace: Optional[str] = None
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    oauth2: Optional[Oauth2] = None
    """
    Optional OAuth 2.0 configuration.
    Cannot be set at the same time as `authorization` or `basic_auth`.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    refresh_interval: Annotated[
        Optional[str],
        Field(
            alias="refreshInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Duration is a valid time duration that can be parsed by Prometheus model.ParseDuration() function.
    Supported units: y, w, d, h, m, s, ms
    Examples: `30s`, `1m`, `1h20m15s`, `15d`
    """
    region: Optional[str] = None
    server: Annotated[str, Field(min_length=1)]
    tag_separator: Annotated[Optional[str], Field(alias="tagSeparator")] = None
    tls_config: Annotated[Optional[TlsConfigModel4], Field(alias="tlsConfig")] = None
    """
    TLS configuration applying to the target HTTP endpoint.
    """


class ApplicationCredentialSecret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ApplicationCredentialSecret"]:
            return ApplicationCredentialSecret

        def build(self) -> "ApplicationCredentialSecret":
            return ApplicationCredentialSecret(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ApplicationCredentialSecret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ApplicationCredentialSecret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ApplicationCredentialSecret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ApplicationCredentialSecret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ApplicationCredentialSecret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class OpenstackSdConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["OpenstackSdConfig"]:
            return OpenstackSdConfig

        def build(self) -> "OpenstackSdConfig":
            return OpenstackSdConfig(**self._attrs)

        def all_tenants(self, value: Optional[bool], /) -> Self:
            """
            Whether the service discovery should list all instances for all projects.
            It is only relevant for the 'instance' role and usually requires admin permissions.
            """
            return self._set("all_tenants", value)

        def application_credential_id(self, value: Optional[str], /) -> Self:
            """
            ApplicationCredentialID
            """
            return self._set("application_credential_id", value)

        def application_credential_name(self, value: Optional[str], /) -> Self:
            """
            The ApplicationCredentialID or ApplicationCredentialName fields are
            required if using an application credential to authenticate. Some providers
            allow you to create an application credential to authenticate rather than a
            password.
            """
            return self._set("application_credential_name", value)

        @overload
        def application_credential_secret(
            self, value_or_callback: Optional[ApplicationCredentialSecret], /
        ) -> "OpenstackSdConfig.Builder": ...

        @overload
        def application_credential_secret(
            self,
            value_or_callback: Callable[
                [ApplicationCredentialSecret.Builder],
                ApplicationCredentialSecret.Builder | ApplicationCredentialSecret,
            ],
            /,
        ) -> "OpenstackSdConfig.Builder": ...

        @overload
        def application_credential_secret(
            self, value_or_callback: Never = ...
        ) -> "ApplicationCredentialSecret.BuilderContext": ...

        def application_credential_secret(self, value_or_callback=None, /):
            """
            The applicationCredentialSecret field is required if using an application
            credential to authenticate.
            """
            if self._in_context and value_or_callback is None:
                context = ApplicationCredentialSecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "application_credential_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ApplicationCredentialSecret.builder())
                if isinstance(output, ApplicationCredentialSecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("application_credential_secret", value)

        def availability(
            self,
            value: Optional[Literal["Public", "public", "Admin", "admin", "Internal", "internal"]],
            /,
        ) -> Self:
            """
            Availability of the endpoint to connect to.
            """
            return self._set("availability", value)

        def domain_id(self, value: Optional[str], /) -> Self:
            """
            DomainID
            """
            return self._set("domain_id", value)

        def domain_name(self, value: Optional[str], /) -> Self:
            """
            At most one of domainId and domainName must be provided if using username
            with Identity V3. Otherwise, either are optional.
            """
            return self._set("domain_name", value)

        def identity_endpoint(self, value: Optional[str], /) -> Self:
            """
            IdentityEndpoint specifies the HTTP endpoint that is required to work with
            the Identity API of the appropriate version.
            """
            return self._set("identity_endpoint", value)

        @overload
        def password(
            self, value_or_callback: Optional[Password], /
        ) -> "OpenstackSdConfig.Builder": ...

        @overload
        def password(
            self,
            value_or_callback: Callable[[Password.Builder], Password.Builder | Password],
            /,
        ) -> "OpenstackSdConfig.Builder": ...

        @overload
        def password(self, value_or_callback: Never = ...) -> "Password.BuilderContext": ...

        def password(self, value_or_callback=None, /):
            """
            Password for the Identity V2 and V3 APIs. Consult with your provider's
            control panel to discover your account's preferred method of authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Password.BuilderContext()
                context._parent_builder = self
                context._field_name = "password"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Password.builder())
                if isinstance(output, Password.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("password", value)

        def port(self, value: Optional[int], /) -> Self:
            """
            The port to scrape metrics from. If using the public IP address, this must
            instead be specified in the relabeling rule.
            """
            return self._set("port", value)

        def project_id(self, value: Optional[str], /) -> Self:
            """
            ProjectID
            """
            return self._set("project_id", value)

        def project_name(self, value: Optional[str], /) -> Self:
            """
            The ProjectId and ProjectName fields are optional for the Identity V2 API.
            Some providers allow you to specify a ProjectName instead of the ProjectId.
            Some require both. Your provider's authentication policies will determine
            how these fields influence authentication.
            """
            return self._set("project_name", value)

        def refresh_interval(self, value: Optional[str], /) -> Self:
            """
            Refresh interval to re-read the instance list.
            """
            return self._set("refresh_interval", value)

        def region(self, value: str, /) -> Self:
            """
            The OpenStack Region.
            """
            return self._set("region", value)

        def role(
            self, value: Literal["Instance", "instance", "Hypervisor", "hypervisor"], /
        ) -> Self:
            """
            The OpenStack role of entities that should be discovered.
            """
            return self._set("role", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel4], /
        ) -> "OpenstackSdConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel4.Builder], TlsConfigModel4.Builder | TlsConfigModel4
            ],
            /,
        ) -> "OpenstackSdConfig.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel4.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration applying to the target HTTP endpoint.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel4.builder())
                if isinstance(output, TlsConfigModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

        def userid(self, value: Optional[str], /) -> Self:
            """
            UserID
            """
            return self._set("userid", value)

        def username(self, value: Optional[str], /) -> Self:
            """
            Username is required if using Identity V2 API. Consult with your provider's
            control panel to discover your account's username.
            In Identity V3, either userid or a combination of username
            and domainId or domainName are needed
            """
            return self._set("username", value)

    class BuilderContext(BuilderContextBase["OpenstackSdConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = OpenstackSdConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for OpenstackSdConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["OpenstackSdConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use OpenstackSdConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all_tenants: Annotated[Optional[bool], Field(alias="allTenants")] = None
    """
    Whether the service discovery should list all instances for all projects.
    It is only relevant for the 'instance' role and usually requires admin permissions.
    """
    application_credential_id: Annotated[Optional[str], Field(alias="applicationCredentialId")] = (
        None
    )
    """
    ApplicationCredentialID
    """
    application_credential_name: Annotated[
        Optional[str], Field(alias="applicationCredentialName", min_length=1)
    ] = None
    """
    The ApplicationCredentialID or ApplicationCredentialName fields are
    required if using an application credential to authenticate. Some providers
    allow you to create an application credential to authenticate rather than a
    password.
    """
    application_credential_secret: Annotated[
        Optional[ApplicationCredentialSecret],
        Field(alias="applicationCredentialSecret"),
    ] = None
    """
    The applicationCredentialSecret field is required if using an application
    credential to authenticate.
    """
    availability: Optional[
        Literal["Public", "public", "Admin", "admin", "Internal", "internal"]
    ] = None
    """
    Availability of the endpoint to connect to.
    """
    domain_id: Annotated[Optional[str], Field(alias="domainID", min_length=1)] = None
    """
    DomainID
    """
    domain_name: Annotated[Optional[str], Field(alias="domainName", min_length=1)] = None
    """
    At most one of domainId and domainName must be provided if using username
    with Identity V3. Otherwise, either are optional.
    """
    identity_endpoint: Annotated[
        Optional[str], Field(alias="identityEndpoint", pattern="^http(s)?:\\/\\/.+$")
    ] = None
    """
    IdentityEndpoint specifies the HTTP endpoint that is required to work with
    the Identity API of the appropriate version.
    """
    password: Optional[Password] = None
    """
    Password for the Identity V2 and V3 APIs. Consult with your provider's
    control panel to discover your account's preferred method of authentication.
    """
    port: Annotated[Optional[int], Field(ge=0, le=65535)] = None
    """
    The port to scrape metrics from. If using the public IP address, this must
    instead be specified in the relabeling rule.
    """
    project_id: Annotated[Optional[str], Field(alias="projectID", min_length=1)] = None
    """
    ProjectID
    """
    project_name: Annotated[Optional[str], Field(alias="projectName", min_length=1)] = None
    """
    The ProjectId and ProjectName fields are optional for the Identity V2 API.
    Some providers allow you to specify a ProjectName instead of the ProjectId.
    Some require both. Your provider's authentication policies will determine
    how these fields influence authentication.
    """
    refresh_interval: Annotated[
        Optional[str],
        Field(
            alias="refreshInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Refresh interval to re-read the instance list.
    """
    region: Annotated[str, Field(min_length=1)]
    """
    The OpenStack Region.
    """
    role: Literal["Instance", "instance", "Hypervisor", "hypervisor"]
    """
    The OpenStack role of entities that should be discovered.
    """
    tls_config: Annotated[Optional[TlsConfigModel4], Field(alias="tlsConfig")] = None
    """
    TLS configuration applying to the target HTTP endpoint.
    """
    userid: Annotated[Optional[str], Field(min_length=1)] = None
    """
    UserID
    """
    username: Annotated[Optional[str], Field(min_length=1)] = None
    """
    Username is required if using Identity V2 API. Consult with your provider's
    control panel to discover your account's username.
    In Identity V3, either userid or a combination of username
    and domainId or domainName are needed
    """


class ApplicationSecret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ApplicationSecret"]:
            return ApplicationSecret

        def build(self) -> "ApplicationSecret":
            return ApplicationSecret(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ApplicationSecret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ApplicationSecret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ApplicationSecret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ApplicationSecret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ApplicationSecret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class ConsumerKey(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConsumerKey"]:
            return ConsumerKey

        def build(self) -> "ConsumerKey":
            return ConsumerKey(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConsumerKey.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConsumerKey.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConsumerKey."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConsumerKey", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConsumerKey.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class Service(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Service"]:
            return Service

        def build(self) -> "Service":
            return Service(**self._attrs)

    class BuilderContext(BuilderContextBase["Service.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Service.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Service."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Service", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Service.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    pass


class OvhcloudSdConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["OvhcloudSdConfig"]:
            return OvhcloudSdConfig

        def build(self) -> "OvhcloudSdConfig":
            return OvhcloudSdConfig(**self._attrs)

        def application_key(self, value: str, /) -> Self:
            """
            Access key to use. https://api.ovh.com.
            """
            return self._set("application_key", value)

        @overload
        def application_secret(
            self, value_or_callback: ApplicationSecret, /
        ) -> "OvhcloudSdConfig.Builder": ...

        @overload
        def application_secret(
            self,
            value_or_callback: Callable[
                [ApplicationSecret.Builder],
                ApplicationSecret.Builder | ApplicationSecret,
            ],
            /,
        ) -> "OvhcloudSdConfig.Builder": ...

        @overload
        def application_secret(
            self, value_or_callback: Never = ...
        ) -> "ApplicationSecret.BuilderContext": ...

        def application_secret(self, value_or_callback=None, /):
            """
            SecretKeySelector selects a key of a Secret.
            """
            if self._in_context and value_or_callback is None:
                context = ApplicationSecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "application_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ApplicationSecret.builder())
                if isinstance(output, ApplicationSecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("application_secret", value)

        @overload
        def consumer_key(self, value_or_callback: ConsumerKey, /) -> "OvhcloudSdConfig.Builder": ...

        @overload
        def consumer_key(
            self,
            value_or_callback: Callable[[ConsumerKey.Builder], ConsumerKey.Builder | ConsumerKey],
            /,
        ) -> "OvhcloudSdConfig.Builder": ...

        @overload
        def consumer_key(self, value_or_callback: Never = ...) -> "ConsumerKey.BuilderContext": ...

        def consumer_key(self, value_or_callback=None, /):
            """
            SecretKeySelector selects a key of a Secret.
            """
            if self._in_context and value_or_callback is None:
                context = ConsumerKey.BuilderContext()
                context._parent_builder = self
                context._field_name = "consumer_key"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConsumerKey.builder())
                if isinstance(output, ConsumerKey.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("consumer_key", value)

        def endpoint(self, value: Optional[str], /) -> Self:
            """
            Custom endpoint to be used.
            """
            return self._set("endpoint", value)

        def refresh_interval(self, value: Optional[str], /) -> Self:
            """
            Refresh interval to re-read the resources list.
            """
            return self._set("refresh_interval", value)

        @overload
        def service(self, value_or_callback: Service, /) -> "OvhcloudSdConfig.Builder": ...

        @overload
        def service(
            self,
            value_or_callback: Callable[[Service.Builder], Service.Builder | Service],
            /,
        ) -> "OvhcloudSdConfig.Builder": ...

        @overload
        def service(self, value_or_callback: Never = ...) -> "Service.BuilderContext": ...

        def service(self, value_or_callback=None, /):
            """
            Service of the targets to retrieve. Must be `VPS` or `DedicatedServer`.
            """
            if self._in_context and value_or_callback is None:
                context = Service.BuilderContext()
                context._parent_builder = self
                context._field_name = "service"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Service.builder())
                if isinstance(output, Service.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service", value)

    class BuilderContext(BuilderContextBase["OvhcloudSdConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = OvhcloudSdConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for OvhcloudSdConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["OvhcloudSdConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use OvhcloudSdConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    application_key: Annotated[str, Field(alias="applicationKey", min_length=1)]
    """
    Access key to use. https://api.ovh.com.
    """
    application_secret: Annotated[ApplicationSecret, Field(alias="applicationSecret")]
    """
    SecretKeySelector selects a key of a Secret.
    """
    consumer_key: Annotated[ConsumerKey, Field(alias="consumerKey")]
    """
    SecretKeySelector selects a key of a Secret.
    """
    endpoint: Annotated[Optional[str], Field(min_length=1)] = None
    """
    Custom endpoint to be used.
    """
    refresh_interval: Annotated[
        Optional[str],
        Field(
            alias="refreshInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Refresh interval to re-read the resources list.
    """
    service: Service
    """
    Service of the targets to retrieve. Must be `VPS` or `DedicatedServer`.
    """


class PuppetDbsdConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PuppetDbsdConfig"]:
            return PuppetDbsdConfig

        def build(self) -> "PuppetDbsdConfig":
            return PuppetDbsdConfig(**self._attrs)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel1], /
        ) -> "PuppetDbsdConfig.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel1.Builder],
                AuthorizationModel1.Builder | AuthorizationModel1,
            ],
            /,
        ) -> "PuppetDbsdConfig.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel1.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Optional `authorization` HTTP header configuration.
            Cannot be set at the same time as `basicAuth`, or `oauth2`.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel1.builder())
                if isinstance(output, AuthorizationModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def basic_auth(
            self, value_or_callback: Optional[BasicAuth], /
        ) -> "PuppetDbsdConfig.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "PuppetDbsdConfig.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            Optional HTTP basic authentication information.
            Cannot be set at the same time as `authorization`, or `oauth2`.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            Configure whether to enable HTTP2.
            """
            return self._set("enable_http2", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            Configure whether the HTTP requests should follow HTTP 3xx redirects.
            """
            return self._set("follow_redirects", value)

        def include_parameters(self, value: Optional[bool], /) -> Self:
            """
            Whether to include the parameters as meta labels.
            Note: Enabling this exposes parameters in the Prometheus UI and API. Make sure
            that you don't have secrets exposed as parameters if you enable this.
            """
            return self._set("include_parameters", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        @overload
        def oauth2(self, value_or_callback: Optional[Oauth2], /) -> "PuppetDbsdConfig.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "PuppetDbsdConfig.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            Optional OAuth2.0 configuration.
            Cannot be set at the same time as `basicAuth`, or `authorization`.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        def port(self, value: Optional[int], /) -> Self:
            """
            Port to scrape the metrics from.
            """
            return self._set("port", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        def query(self, value: str, /) -> Self:
            """
            Puppet Query Language (PQL) query. Only resources are supported.
            https://puppet.com/docs/puppetdb/latest/api/query/v4/pql.html
            """
            return self._set("query", value)

        def refresh_interval(self, value: Optional[str], /) -> Self:
            """
            Refresh interval to re-read the list of resources.
            """
            return self._set("refresh_interval", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel4], /
        ) -> "PuppetDbsdConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel4.Builder], TlsConfigModel4.Builder | TlsConfigModel4
            ],
            /,
        ) -> "PuppetDbsdConfig.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel4.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration to connect to the Puppet DB.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel4.builder())
                if isinstance(output, TlsConfigModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

        def url(self, value: str, /) -> Self:
            """
            The URL of the PuppetDB root query endpoint.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["PuppetDbsdConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PuppetDbsdConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PuppetDbsdConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PuppetDbsdConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PuppetDbsdConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authorization: Optional[AuthorizationModel1] = None
    """
    Optional `authorization` HTTP header configuration.
    Cannot be set at the same time as `basicAuth`, or `oauth2`.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    Optional HTTP basic authentication information.
    Cannot be set at the same time as `authorization`, or `oauth2`.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHTTP2")] = None
    """
    Configure whether to enable HTTP2.
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    Configure whether the HTTP requests should follow HTTP 3xx redirects.
    """
    include_parameters: Annotated[Optional[bool], Field(alias="includeParameters")] = None
    """
    Whether to include the parameters as meta labels.
    Note: Enabling this exposes parameters in the Prometheus UI and API. Make sure
    that you don't have secrets exposed as parameters if you enable this.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    oauth2: Optional[Oauth2] = None
    """
    Optional OAuth2.0 configuration.
    Cannot be set at the same time as `basicAuth`, or `authorization`.
    """
    port: Annotated[Optional[int], Field(ge=0, le=65535)] = None
    """
    Port to scrape the metrics from.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    query: Annotated[str, Field(min_length=1)]
    """
    Puppet Query Language (PQL) query. Only resources are supported.
    https://puppet.com/docs/puppetdb/latest/api/query/v4/pql.html
    """
    refresh_interval: Annotated[
        Optional[str],
        Field(
            alias="refreshInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Refresh interval to re-read the list of resources.
    """
    tls_config: Annotated[Optional[TlsConfigModel4], Field(alias="tlsConfig")] = None
    """
    TLS configuration to connect to the Puppet DB.
    """
    url: Annotated[str, Field(min_length=1, pattern="^http(s)?://.+$")]
    """
    The URL of the PuppetDB root query endpoint.
    """


class TagsFilter(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "TagsFilter":
            value = cast(str, self._value)
            return TagsFilter(value)

    root: Annotated[str, Field(min_length=1)]

    class BuilderContext(BuilderContextBase["TagsFilter.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TagsFilter.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TagsFilter."""
        return cls.BuilderContext()


class ScalewaySdConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ScalewaySdConfig"]:
            return ScalewaySdConfig

        def build(self) -> "ScalewaySdConfig":
            return ScalewaySdConfig(**self._attrs)

        def access_key(self, value: str, /) -> Self:
            """
            Access key to use. https://console.scaleway.com/project/credentials
            """
            return self._set("access_key", value)

        def api_url(self, value: Optional[str], /) -> Self:
            """
            API URL to use when doing the server listing requests.
            """
            return self._set("api_url", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            Whether to enable HTTP2.
            """
            return self._set("enable_http2", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            Configure whether HTTP requests follow HTTP 3xx redirects.
            """
            return self._set("follow_redirects", value)

        def name_filter(self, value: Optional[str], /) -> Self:
            """
            NameFilter specify a name filter (works as a LIKE) to apply on the server listing request.
            """
            return self._set("name_filter", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        def port(self, value: Optional[int], /) -> Self:
            """
            The port to scrape metrics from.
            """
            return self._set("port", value)

        def project_id(self, value: str, /) -> Self:
            """
            Project ID of the targets.
            """
            return self._set("project_id", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        def refresh_interval(self, value: Optional[str], /) -> Self:
            """
            Refresh interval to re-read the list of instances.
            """
            return self._set("refresh_interval", value)

        def role(self, value: Literal["Instance", "Baremetal"], /) -> Self:
            """
            Service of the targets to retrieve. Must be `Instance` or `Baremetal`.
            """
            return self._set("role", value)

        @overload
        def secret_key(self, value_or_callback: SecretKey, /) -> "ScalewaySdConfig.Builder": ...

        @overload
        def secret_key(
            self,
            value_or_callback: Callable[[SecretKey.Builder], SecretKey.Builder | SecretKey],
            /,
        ) -> "ScalewaySdConfig.Builder": ...

        @overload
        def secret_key(self, value_or_callback: Never = ...) -> "SecretKey.BuilderContext": ...

        def secret_key(self, value_or_callback=None, /):
            """
            Secret key to use when listing targets.
            """
            if self._in_context and value_or_callback is None:
                context = SecretKey.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_key"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretKey.builder())
                if isinstance(output, SecretKey.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_key", value)

        @overload
        def tags_filter(
            self, value_or_callback: List[TagsFilter], /
        ) -> "ScalewaySdConfig.Builder": ...

        @overload
        def tags_filter(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[TagsFilter, TagsFilter.Builder]],
                GenericListBuilder[TagsFilter, TagsFilter.Builder] | List[TagsFilter],
            ],
            /,
        ) -> "ScalewaySdConfig.Builder": ...

        @overload
        def tags_filter(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[TagsFilter.Builder]: ...

        def tags_filter(self, value_or_callback=None, /):
            """
            TagsFilter specify a tag filter (a server needs to have all defined tags to be listed) to apply on the server listing request.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[TagsFilter.Builder]()
                context._parent_builder = self
                context._field_name = "tags_filter"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TagsFilter.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("tags_filter", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel4], /
        ) -> "ScalewaySdConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel4.Builder], TlsConfigModel4.Builder | TlsConfigModel4
            ],
            /,
        ) -> "ScalewaySdConfig.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel4.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration to use on every scrape request
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel4.builder())
                if isinstance(output, TlsConfigModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

        def zone(self, value: Optional[str], /) -> Self:
            """
            Zone is the availability zone of your targets (e.g. fr-par-1).
            """
            return self._set("zone", value)

    class BuilderContext(BuilderContextBase["ScalewaySdConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ScalewaySdConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ScalewaySdConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ScalewaySdConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ScalewaySdConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_key: Annotated[str, Field(alias="accessKey", min_length=1)]
    """
    Access key to use. https://console.scaleway.com/project/credentials
    """
    api_url: Annotated[Optional[str], Field(alias="apiURL", pattern="^http(s)?://.+$")] = None
    """
    API URL to use when doing the server listing requests.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHTTP2")] = None
    """
    Whether to enable HTTP2.
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    Configure whether HTTP requests follow HTTP 3xx redirects.
    """
    name_filter: Annotated[Optional[str], Field(alias="nameFilter", min_length=1)] = None
    """
    NameFilter specify a name filter (works as a LIKE) to apply on the server listing request.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    port: Annotated[Optional[int], Field(ge=0, le=65535)] = None
    """
    The port to scrape metrics from.
    """
    project_id: Annotated[str, Field(alias="projectID", min_length=1)]
    """
    Project ID of the targets.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    refresh_interval: Annotated[
        Optional[str],
        Field(
            alias="refreshInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Refresh interval to re-read the list of instances.
    """
    role: Literal["Instance", "Baremetal"]
    """
    Service of the targets to retrieve. Must be `Instance` or `Baremetal`.
    """
    secret_key: Annotated[SecretKey, Field(alias="secretKey")]
    """
    Secret key to use when listing targets.
    """
    tags_filter: Annotated[Optional[List[TagsFilter]], Field(alias="tagsFilter", min_length=1)] = (
        None
    )
    """
    TagsFilter specify a tag filter (a server needs to have all defined tags to be listed) to apply on the server listing request.
    """
    tls_config: Annotated[Optional[TlsConfigModel4], Field(alias="tlsConfig")] = None
    """
    TLS configuration to use on every scrape request
    """
    zone: Annotated[Optional[str], Field(min_length=1)] = None
    """
    Zone is the availability zone of your targets (e.g. fr-par-1).
    """


class StaticConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StaticConfig"]:
            return StaticConfig

        def build(self) -> "StaticConfig":
            return StaticConfig(**self._attrs)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Labels assigned to all metrics scraped from the targets.
            """
            return self._set("labels", value)

        def targets(self, value: List[str], /) -> Self:
            """
            List of targets for this static configuration.
            """
            return self._set("targets", value)

    class BuilderContext(BuilderContextBase["StaticConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StaticConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StaticConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StaticConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StaticConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    labels: Optional[Dict[str, str]] = None
    """
    Labels assigned to all metrics scraped from the targets.
    """
    targets: Annotated[List[str], Field(min_length=1)]
    """
    List of targets for this static configuration.
    """


class ScrapeConfigSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ScrapeConfigSpec"]:
            return ScrapeConfigSpec

        def build(self) -> "ScrapeConfigSpec":
            return ScrapeConfigSpec(**self._attrs)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel1], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel1.Builder],
                AuthorizationModel1.Builder | AuthorizationModel1,
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel1.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization header to use on every scrape request.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel1.builder())
                if isinstance(output, AuthorizationModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def azure_sd_configs(
            self, value_or_callback: List[AzureSdConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def azure_sd_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AzureSdConfig, AzureSdConfig.Builder]],
                GenericListBuilder[AzureSdConfig, AzureSdConfig.Builder] | List[AzureSdConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def azure_sd_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[AzureSdConfig.Builder]: ...

        def azure_sd_configs(self, value_or_callback=None, /):
            """
            AzureSDConfigs defines a list of Azure service discovery configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AzureSdConfig.Builder]()
                context._parent_builder = self
                context._field_name = "azure_sd_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AzureSdConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("azure_sd_configs", value)

        @overload
        def basic_auth(
            self, value_or_callback: Optional[BasicAuth], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            BasicAuth information to use on every scrape request.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        @overload
        def consul_sd_configs(
            self, value_or_callback: List[ConsulSdConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def consul_sd_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ConsulSdConfig, ConsulSdConfig.Builder]],
                GenericListBuilder[ConsulSdConfig, ConsulSdConfig.Builder] | List[ConsulSdConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def consul_sd_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ConsulSdConfig.Builder]: ...

        def consul_sd_configs(self, value_or_callback=None, /):
            """
            ConsulSDConfigs defines a list of Consul service discovery configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ConsulSdConfig.Builder]()
                context._parent_builder = self
                context._field_name = "consul_sd_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConsulSdConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("consul_sd_configs", value)

        @overload
        def digital_ocean_sd_configs(
            self, value_or_callback: List[DigitalOceanSdConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def digital_ocean_sd_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[DigitalOceanSdConfig, DigitalOceanSdConfig.Builder]],
                GenericListBuilder[DigitalOceanSdConfig, DigitalOceanSdConfig.Builder]
                | List[DigitalOceanSdConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def digital_ocean_sd_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[DigitalOceanSdConfig.Builder]: ...

        def digital_ocean_sd_configs(self, value_or_callback=None, /):
            """
            DigitalOceanSDConfigs defines a list of DigitalOcean service discovery configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[DigitalOceanSdConfig.Builder]()
                context._parent_builder = self
                context._field_name = "digital_ocean_sd_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DigitalOceanSdConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("digital_ocean_sd_configs", value)

        @overload
        def dns_sd_configs(
            self, value_or_callback: List[DnsSdConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def dns_sd_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[DnsSdConfig, DnsSdConfig.Builder]],
                GenericListBuilder[DnsSdConfig, DnsSdConfig.Builder] | List[DnsSdConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def dns_sd_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[DnsSdConfig.Builder]: ...

        def dns_sd_configs(self, value_or_callback=None, /):
            """
            DNSSDConfigs defines a list of DNS service discovery configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[DnsSdConfig.Builder]()
                context._parent_builder = self
                context._field_name = "dns_sd_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DnsSdConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("dns_sd_configs", value)

        @overload
        def docker_sd_configs(
            self, value_or_callback: List[DockerSdConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def docker_sd_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[DockerSdConfig, DockerSdConfig.Builder]],
                GenericListBuilder[DockerSdConfig, DockerSdConfig.Builder] | List[DockerSdConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def docker_sd_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[DockerSdConfig.Builder]: ...

        def docker_sd_configs(self, value_or_callback=None, /):
            """
            DockerSDConfigs defines a list of Docker service discovery configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[DockerSdConfig.Builder]()
                context._parent_builder = self
                context._field_name = "docker_sd_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DockerSdConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("docker_sd_configs", value)

        @overload
        def docker_swarm_sd_configs(
            self, value_or_callback: List[DockerSwarmSdConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def docker_swarm_sd_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[DockerSwarmSdConfig, DockerSwarmSdConfig.Builder]],
                GenericListBuilder[DockerSwarmSdConfig, DockerSwarmSdConfig.Builder]
                | List[DockerSwarmSdConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def docker_swarm_sd_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[DockerSwarmSdConfig.Builder]: ...

        def docker_swarm_sd_configs(self, value_or_callback=None, /):
            """
            DockerswarmSDConfigs defines a list of Dockerswarm service discovery configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[DockerSwarmSdConfig.Builder]()
                context._parent_builder = self
                context._field_name = "docker_swarm_sd_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DockerSwarmSdConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("docker_swarm_sd_configs", value)

        @overload
        def ec2_sd_configs(
            self, value_or_callback: List[Ec2SdConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def ec2_sd_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Ec2SdConfig, Ec2SdConfig.Builder]],
                GenericListBuilder[Ec2SdConfig, Ec2SdConfig.Builder] | List[Ec2SdConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def ec2_sd_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Ec2SdConfig.Builder]: ...

        def ec2_sd_configs(self, value_or_callback=None, /):
            """
            EC2SDConfigs defines a list of EC2 service discovery configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Ec2SdConfig.Builder]()
                context._parent_builder = self
                context._field_name = "ec2_sd_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ec2SdConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("ec2_sd_configs", value)

        def enable_compression(self, value: Optional[bool], /) -> Self:
            """
            When false, Prometheus will request uncompressed response from the scraped target.

            It requires Prometheus >= v2.49.0.

            If unset, Prometheus uses true by default.
            """
            return self._set("enable_compression", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            Whether to enable HTTP2.
            """
            return self._set("enable_http2", value)

        @overload
        def eureka_sd_configs(
            self, value_or_callback: List[EurekaSdConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def eureka_sd_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[EurekaSdConfig, EurekaSdConfig.Builder]],
                GenericListBuilder[EurekaSdConfig, EurekaSdConfig.Builder] | List[EurekaSdConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def eureka_sd_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[EurekaSdConfig.Builder]: ...

        def eureka_sd_configs(self, value_or_callback=None, /):
            """
            EurekaSDConfigs defines a list of Eureka service discovery configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[EurekaSdConfig.Builder]()
                context._parent_builder = self
                context._field_name = "eureka_sd_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(EurekaSdConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("eureka_sd_configs", value)

        def fallback_scrape_protocol(
            self,
            value: Optional[
                Literal[
                    "PrometheusProto",
                    "OpenMetricsText0.0.1",
                    "OpenMetricsText1.0.0",
                    "PrometheusText0.0.4",
                    "PrometheusText1.0.0",
                ]
            ],
            /,
        ) -> Self:
            """
            The protocol to use if a scrape returns blank, unparseable, or otherwise invalid Content-Type.

            It requires Prometheus >= v3.0.0.
            """
            return self._set("fallback_scrape_protocol", value)

        @overload
        def file_sd_configs(
            self, value_or_callback: List[FileSdConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def file_sd_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[FileSdConfig, FileSdConfig.Builder]],
                GenericListBuilder[FileSdConfig, FileSdConfig.Builder] | List[FileSdConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def file_sd_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[FileSdConfig.Builder]: ...

        def file_sd_configs(self, value_or_callback=None, /):
            """
            FileSDConfigs defines a list of file service discovery configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[FileSdConfig.Builder]()
                context._parent_builder = self
                context._field_name = "file_sd_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FileSdConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("file_sd_configs", value)

        @overload
        def gce_sd_configs(
            self, value_or_callback: List[GceSdConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def gce_sd_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[GceSdConfig, GceSdConfig.Builder]],
                GenericListBuilder[GceSdConfig, GceSdConfig.Builder] | List[GceSdConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def gce_sd_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[GceSdConfig.Builder]: ...

        def gce_sd_configs(self, value_or_callback=None, /):
            """
            GCESDConfigs defines a list of GCE service discovery configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[GceSdConfig.Builder]()
                context._parent_builder = self
                context._field_name = "gce_sd_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GceSdConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("gce_sd_configs", value)

        @overload
        def hetzner_sd_configs(
            self, value_or_callback: List[HetznerSdConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def hetzner_sd_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[HetznerSdConfig, HetznerSdConfig.Builder]],
                GenericListBuilder[HetznerSdConfig, HetznerSdConfig.Builder]
                | List[HetznerSdConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def hetzner_sd_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[HetznerSdConfig.Builder]: ...

        def hetzner_sd_configs(self, value_or_callback=None, /):
            """
            HetznerSDConfigs defines a list of Hetzner service discovery configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[HetznerSdConfig.Builder]()
                context._parent_builder = self
                context._field_name = "hetzner_sd_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HetznerSdConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("hetzner_sd_configs", value)

        def honor_labels(self, value: Optional[bool], /) -> Self:
            """
            HonorLabels chooses the metric's labels on collisions with target labels.
            """
            return self._set("honor_labels", value)

        def honor_timestamps(self, value: Optional[bool], /) -> Self:
            """
            HonorTimestamps controls whether Prometheus respects the timestamps present in scraped data.
            """
            return self._set("honor_timestamps", value)

        @overload
        def http_sd_configs(
            self, value_or_callback: List[HttpSdConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def http_sd_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[HttpSdConfig, HttpSdConfig.Builder]],
                GenericListBuilder[HttpSdConfig, HttpSdConfig.Builder] | List[HttpSdConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def http_sd_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[HttpSdConfig.Builder]: ...

        def http_sd_configs(self, value_or_callback=None, /):
            """
            HTTPSDConfigs defines a list of HTTP service discovery configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[HttpSdConfig.Builder]()
                context._parent_builder = self
                context._field_name = "http_sd_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpSdConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_sd_configs", value)

        @overload
        def ionos_sd_configs(
            self, value_or_callback: List[IonosSdConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def ionos_sd_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[IonosSdConfig, IonosSdConfig.Builder]],
                GenericListBuilder[IonosSdConfig, IonosSdConfig.Builder] | List[IonosSdConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def ionos_sd_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[IonosSdConfig.Builder]: ...

        def ionos_sd_configs(self, value_or_callback=None, /):
            """
            IonosSDConfigs defines a list of IONOS service discovery configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[IonosSdConfig.Builder]()
                context._parent_builder = self
                context._field_name = "ionos_sd_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IonosSdConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("ionos_sd_configs", value)

        def job_name(self, value: Optional[str], /) -> Self:
            """
            The value of the `job` label assigned to the scraped metrics by default.

            The `job_name` field in the rendered scrape configuration is always controlled by the
            operator to prevent duplicate job names, which Prometheus does not allow. Instead the
            `job` label is set by means of relabeling configs.
            """
            return self._set("job_name", value)

        def keep_dropped_targets(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on the number of targets dropped by relabeling
            that will be kept in memory. 0 means no limit.

            It requires Prometheus >= v2.47.0.
            """
            return self._set("keep_dropped_targets", value)

        @overload
        def kubernetes_sd_configs(
            self, value_or_callback: List[KubernetesSdConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def kubernetes_sd_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[KubernetesSdConfig, KubernetesSdConfig.Builder]],
                GenericListBuilder[KubernetesSdConfig, KubernetesSdConfig.Builder]
                | List[KubernetesSdConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def kubernetes_sd_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[KubernetesSdConfig.Builder]: ...

        def kubernetes_sd_configs(self, value_or_callback=None, /):
            """
            KubernetesSDConfigs defines a list of Kubernetes service discovery configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[KubernetesSdConfig.Builder]()
                context._parent_builder = self
                context._field_name = "kubernetes_sd_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KubernetesSdConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("kubernetes_sd_configs", value)

        @overload
        def kuma_sd_configs(
            self, value_or_callback: List[KumaSdConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def kuma_sd_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[KumaSdConfig, KumaSdConfig.Builder]],
                GenericListBuilder[KumaSdConfig, KumaSdConfig.Builder] | List[KumaSdConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def kuma_sd_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[KumaSdConfig.Builder]: ...

        def kuma_sd_configs(self, value_or_callback=None, /):
            """
            KumaSDConfigs defines a list of Kuma service discovery configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[KumaSdConfig.Builder]()
                context._parent_builder = self
                context._field_name = "kuma_sd_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KumaSdConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("kuma_sd_configs", value)

        def label_limit(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on number of labels that will be accepted for a sample.
            Only valid in Prometheus versions 2.27.0 and newer.
            """
            return self._set("label_limit", value)

        def label_name_length_limit(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on length of labels name that will be accepted for a sample.
            Only valid in Prometheus versions 2.27.0 and newer.
            """
            return self._set("label_name_length_limit", value)

        def label_value_length_limit(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on length of labels value that will be accepted for a sample.
            Only valid in Prometheus versions 2.27.0 and newer.
            """
            return self._set("label_value_length_limit", value)

        @overload
        def light_sail_sd_configs(
            self, value_or_callback: List[LightSailSdConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def light_sail_sd_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[LightSailSdConfig, LightSailSdConfig.Builder]],
                GenericListBuilder[LightSailSdConfig, LightSailSdConfig.Builder]
                | List[LightSailSdConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def light_sail_sd_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[LightSailSdConfig.Builder]: ...

        def light_sail_sd_configs(self, value_or_callback=None, /):
            """
            LightsailSDConfigs defines a list of Lightsail service discovery configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[LightSailSdConfig.Builder]()
                context._parent_builder = self
                context._field_name = "light_sail_sd_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LightSailSdConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("light_sail_sd_configs", value)

        @overload
        def linode_sd_configs(
            self, value_or_callback: List[LinodeSdConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def linode_sd_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[LinodeSdConfig, LinodeSdConfig.Builder]],
                GenericListBuilder[LinodeSdConfig, LinodeSdConfig.Builder] | List[LinodeSdConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def linode_sd_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[LinodeSdConfig.Builder]: ...

        def linode_sd_configs(self, value_or_callback=None, /):
            """
            LinodeSDConfigs defines a list of Linode service discovery configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[LinodeSdConfig.Builder]()
                context._parent_builder = self
                context._field_name = "linode_sd_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LinodeSdConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("linode_sd_configs", value)

        @overload
        def metric_relabelings(
            self, value_or_callback: List[MetricRelabeling], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def metric_relabelings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MetricRelabeling, MetricRelabeling.Builder]],
                GenericListBuilder[MetricRelabeling, MetricRelabeling.Builder]
                | List[MetricRelabeling],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def metric_relabelings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MetricRelabeling.Builder]: ...

        def metric_relabelings(self, value_or_callback=None, /):
            """
            MetricRelabelConfigs to apply to samples before ingestion.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MetricRelabeling.Builder]()
                context._parent_builder = self
                context._field_name = "metric_relabelings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MetricRelabeling.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("metric_relabelings", value)

        def metrics_path(self, value: Optional[str], /) -> Self:
            """
            MetricsPath HTTP path to scrape for metrics. If empty, Prometheus uses the default value (e.g. /metrics).
            """
            return self._set("metrics_path", value)

        def native_histogram_bucket_limit(self, value: Optional[int], /) -> Self:
            """
            If there are more than this many buckets in a native histogram,
            buckets will be merged to stay within the limit.
            It requires Prometheus >= v2.45.0.
            """
            return self._set("native_histogram_bucket_limit", value)

        def native_histogram_min_bucket_factor(
            self,
            value: Optional[
                Union[NativeHistogramMinBucketFactor, NativeHistogramMinBucketFactorModel]
            ],
            /,
        ) -> Self:
            """
            If the growth factor of one bucket to the next is smaller than this,
            buckets will be merged to increase the factor sufficiently.
            It requires Prometheus >= v2.50.0.
            """
            return self._set("native_histogram_min_bucket_factor", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        @overload
        def nomad_sd_configs(
            self, value_or_callback: List[NomadSdConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def nomad_sd_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[NomadSdConfig, NomadSdConfig.Builder]],
                GenericListBuilder[NomadSdConfig, NomadSdConfig.Builder] | List[NomadSdConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def nomad_sd_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[NomadSdConfig.Builder]: ...

        def nomad_sd_configs(self, value_or_callback=None, /):
            """
            NomadSDConfigs defines a list of Nomad service discovery configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[NomadSdConfig.Builder]()
                context._parent_builder = self
                context._field_name = "nomad_sd_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NomadSdConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("nomad_sd_configs", value)

        @overload
        def oauth2(self, value_or_callback: Optional[Oauth2], /) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            OAuth2 configuration to use on every scrape request.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        @overload
        def openstack_sd_configs(
            self, value_or_callback: List[OpenstackSdConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def openstack_sd_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[OpenstackSdConfig, OpenstackSdConfig.Builder]],
                GenericListBuilder[OpenstackSdConfig, OpenstackSdConfig.Builder]
                | List[OpenstackSdConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def openstack_sd_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[OpenstackSdConfig.Builder]: ...

        def openstack_sd_configs(self, value_or_callback=None, /):
            """
            OpenStackSDConfigs defines a list of OpenStack service discovery configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[OpenstackSdConfig.Builder]()
                context._parent_builder = self
                context._field_name = "openstack_sd_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OpenstackSdConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("openstack_sd_configs", value)

        @overload
        def ovhcloud_sd_configs(
            self, value_or_callback: List[OvhcloudSdConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def ovhcloud_sd_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[OvhcloudSdConfig, OvhcloudSdConfig.Builder]],
                GenericListBuilder[OvhcloudSdConfig, OvhcloudSdConfig.Builder]
                | List[OvhcloudSdConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def ovhcloud_sd_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[OvhcloudSdConfig.Builder]: ...

        def ovhcloud_sd_configs(self, value_or_callback=None, /):
            """
            OVHCloudSDConfigs defines a list of OVHcloud service discovery configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[OvhcloudSdConfig.Builder]()
                context._parent_builder = self
                context._field_name = "ovhcloud_sd_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OvhcloudSdConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("ovhcloud_sd_configs", value)

        def params(self, value: Optional[Dict[str, List[str]]], /) -> Self:
            """
            Optional HTTP URL parameters
            """
            return self._set("params", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        @overload
        def puppet_dbsd_configs(
            self, value_or_callback: List[PuppetDbsdConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def puppet_dbsd_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PuppetDbsdConfig, PuppetDbsdConfig.Builder]],
                GenericListBuilder[PuppetDbsdConfig, PuppetDbsdConfig.Builder]
                | List[PuppetDbsdConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def puppet_dbsd_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PuppetDbsdConfig.Builder]: ...

        def puppet_dbsd_configs(self, value_or_callback=None, /):
            """
            PuppetDBSDConfigs defines a list of PuppetDB service discovery configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PuppetDbsdConfig.Builder]()
                context._parent_builder = self
                context._field_name = "puppet_dbsd_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PuppetDbsdConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("puppet_dbsd_configs", value)

        @overload
        def relabelings(
            self, value_or_callback: List[Relabeling], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def relabelings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Relabeling, Relabeling.Builder]],
                GenericListBuilder[Relabeling, Relabeling.Builder] | List[Relabeling],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def relabelings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Relabeling.Builder]: ...

        def relabelings(self, value_or_callback=None, /):
            """
            RelabelConfigs defines how to rewrite the target's labels before scraping.
            Prometheus Operator automatically adds relabelings for a few standard Kubernetes fields.
            The original scrape job's name is available via the `__tmp_prometheus_job_name` label.
            More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Relabeling.Builder]()
                context._parent_builder = self
                context._field_name = "relabelings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Relabeling.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("relabelings", value)

        def sample_limit(self, value: Optional[int], /) -> Self:
            """
            SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
            """
            return self._set("sample_limit", value)

        @overload
        def scaleway_sd_configs(
            self, value_or_callback: List[ScalewaySdConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def scaleway_sd_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ScalewaySdConfig, ScalewaySdConfig.Builder]],
                GenericListBuilder[ScalewaySdConfig, ScalewaySdConfig.Builder]
                | List[ScalewaySdConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def scaleway_sd_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ScalewaySdConfig.Builder]: ...

        def scaleway_sd_configs(self, value_or_callback=None, /):
            """
            ScalewaySDConfigs defines a list of Scaleway instances and baremetal service discovery configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ScalewaySdConfig.Builder]()
                context._parent_builder = self
                context._field_name = "scaleway_sd_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ScalewaySdConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("scaleway_sd_configs", value)

        def scheme(self, value: Optional[Literal["HTTP", "HTTPS"]], /) -> Self:
            """
            Configures the protocol scheme used for requests.
            If empty, Prometheus uses HTTP by default.
            """
            return self._set("scheme", value)

        def scrape_class(self, value: Optional[str], /) -> Self:
            """
            The scrape class to apply.
            """
            return self._set("scrape_class", value)

        def scrape_classic_histograms(self, value: Optional[bool], /) -> Self:
            """
            Whether to scrape a classic histogram that is also exposed as a native histogram.
            It requires Prometheus >= v2.45.0.
            """
            return self._set("scrape_classic_histograms", value)

        def scrape_interval(self, value: Optional[str], /) -> Self:
            """
            ScrapeInterval is the interval between consecutive scrapes.
            """
            return self._set("scrape_interval", value)

        def scrape_protocols(
            self,
            value: Optional[
                List[
                    Literal[
                        "PrometheusProto",
                        "OpenMetricsText0.0.1",
                        "OpenMetricsText1.0.0",
                        "PrometheusText0.0.4",
                        "PrometheusText1.0.0",
                    ]
                ]
            ],
            /,
        ) -> Self:
            """
            The protocols to negotiate during a scrape. It tells clients the
            protocols supported by Prometheus in order of preference (from most to least preferred).

            If unset, Prometheus uses its default value.

            It requires Prometheus >= v2.49.0.
            """
            return self._set("scrape_protocols", value)

        def scrape_timeout(self, value: Optional[str], /) -> Self:
            """
            ScrapeTimeout is the number of seconds to wait until a scrape request times out.
            The value cannot be greater than the scrape interval otherwise the operator will reject the resource.
            """
            return self._set("scrape_timeout", value)

        @overload
        def static_configs(
            self, value_or_callback: List[StaticConfig], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def static_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[StaticConfig, StaticConfig.Builder]],
                GenericListBuilder[StaticConfig, StaticConfig.Builder] | List[StaticConfig],
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def static_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[StaticConfig.Builder]: ...

        def static_configs(self, value_or_callback=None, /):
            """
            StaticConfigs defines a list of static targets with a common label set.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[StaticConfig.Builder]()
                context._parent_builder = self
                context._field_name = "static_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(StaticConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("static_configs", value)

        def target_limit(self, value: Optional[int], /) -> Self:
            """
            TargetLimit defines a limit on the number of scraped targets that will be accepted.
            """
            return self._set("target_limit", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel4], /
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel4.Builder], TlsConfigModel4.Builder | TlsConfigModel4
            ],
            /,
        ) -> "ScrapeConfigSpec.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel4.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration to use on every scrape request
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel4.builder())
                if isinstance(output, TlsConfigModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

        def track_timestamps_staleness(self, value: Optional[bool], /) -> Self:
            """
            TrackTimestampsStaleness whether Prometheus tracks staleness of
            the metrics that have an explicit timestamp present in scraped data.
            Has no effect if `honorTimestamps` is false.
            It requires Prometheus >= v2.48.0.
            """
            return self._set("track_timestamps_staleness", value)

    class BuilderContext(BuilderContextBase["ScrapeConfigSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ScrapeConfigSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ScrapeConfigSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ScrapeConfigSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ScrapeConfigSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authorization: Optional[AuthorizationModel1] = None
    """
    Authorization header to use on every scrape request.
    """
    azure_sd_configs: Annotated[Optional[List[AzureSdConfig]], Field(alias="azureSDConfigs")] = None
    """
    AzureSDConfigs defines a list of Azure service discovery configurations.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    BasicAuth information to use on every scrape request.
    """
    consul_sd_configs: Annotated[Optional[List[ConsulSdConfig]], Field(alias="consulSDConfigs")] = (
        None
    )
    """
    ConsulSDConfigs defines a list of Consul service discovery configurations.
    """
    digital_ocean_sd_configs: Annotated[
        Optional[List[DigitalOceanSdConfig]], Field(alias="digitalOceanSDConfigs")
    ] = None
    """
    DigitalOceanSDConfigs defines a list of DigitalOcean service discovery configurations.
    """
    dns_sd_configs: Annotated[Optional[List[DnsSdConfig]], Field(alias="dnsSDConfigs")] = None
    """
    DNSSDConfigs defines a list of DNS service discovery configurations.
    """
    docker_sd_configs: Annotated[Optional[List[DockerSdConfig]], Field(alias="dockerSDConfigs")] = (
        None
    )
    """
    DockerSDConfigs defines a list of Docker service discovery configurations.
    """
    docker_swarm_sd_configs: Annotated[
        Optional[List[DockerSwarmSdConfig]], Field(alias="dockerSwarmSDConfigs")
    ] = None
    """
    DockerswarmSDConfigs defines a list of Dockerswarm service discovery configurations.
    """
    ec2_sd_configs: Annotated[Optional[List[Ec2SdConfig]], Field(alias="ec2SDConfigs")] = None
    """
    EC2SDConfigs defines a list of EC2 service discovery configurations.
    """
    enable_compression: Annotated[Optional[bool], Field(alias="enableCompression")] = None
    """
    When false, Prometheus will request uncompressed response from the scraped target.

    It requires Prometheus >= v2.49.0.

    If unset, Prometheus uses true by default.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHTTP2")] = None
    """
    Whether to enable HTTP2.
    """
    eureka_sd_configs: Annotated[Optional[List[EurekaSdConfig]], Field(alias="eurekaSDConfigs")] = (
        None
    )
    """
    EurekaSDConfigs defines a list of Eureka service discovery configurations.
    """
    fallback_scrape_protocol: Annotated[
        Optional[
            Literal[
                "PrometheusProto",
                "OpenMetricsText0.0.1",
                "OpenMetricsText1.0.0",
                "PrometheusText0.0.4",
                "PrometheusText1.0.0",
            ]
        ],
        Field(alias="fallbackScrapeProtocol"),
    ] = None
    """
    The protocol to use if a scrape returns blank, unparseable, or otherwise invalid Content-Type.

    It requires Prometheus >= v3.0.0.
    """
    file_sd_configs: Annotated[Optional[List[FileSdConfig]], Field(alias="fileSDConfigs")] = None
    """
    FileSDConfigs defines a list of file service discovery configurations.
    """
    gce_sd_configs: Annotated[Optional[List[GceSdConfig]], Field(alias="gceSDConfigs")] = None
    """
    GCESDConfigs defines a list of GCE service discovery configurations.
    """
    hetzner_sd_configs: Annotated[
        Optional[List[HetznerSdConfig]], Field(alias="hetznerSDConfigs")
    ] = None
    """
    HetznerSDConfigs defines a list of Hetzner service discovery configurations.
    """
    honor_labels: Annotated[Optional[bool], Field(alias="honorLabels")] = None
    """
    HonorLabels chooses the metric's labels on collisions with target labels.
    """
    honor_timestamps: Annotated[Optional[bool], Field(alias="honorTimestamps")] = None
    """
    HonorTimestamps controls whether Prometheus respects the timestamps present in scraped data.
    """
    http_sd_configs: Annotated[Optional[List[HttpSdConfig]], Field(alias="httpSDConfigs")] = None
    """
    HTTPSDConfigs defines a list of HTTP service discovery configurations.
    """
    ionos_sd_configs: Annotated[Optional[List[IonosSdConfig]], Field(alias="ionosSDConfigs")] = None
    """
    IonosSDConfigs defines a list of IONOS service discovery configurations.
    """
    job_name: Annotated[Optional[str], Field(alias="jobName", min_length=1)] = None
    """
    The value of the `job` label assigned to the scraped metrics by default.

    The `job_name` field in the rendered scrape configuration is always controlled by the
    operator to prevent duplicate job names, which Prometheus does not allow. Instead the
    `job` label is set by means of relabeling configs.
    """
    keep_dropped_targets: Annotated[Optional[int], Field(alias="keepDroppedTargets")] = None
    """
    Per-scrape limit on the number of targets dropped by relabeling
    that will be kept in memory. 0 means no limit.

    It requires Prometheus >= v2.47.0.
    """
    kubernetes_sd_configs: Annotated[
        Optional[List[KubernetesSdConfig]], Field(alias="kubernetesSDConfigs")
    ] = None
    """
    KubernetesSDConfigs defines a list of Kubernetes service discovery configurations.
    """
    kuma_sd_configs: Annotated[Optional[List[KumaSdConfig]], Field(alias="kumaSDConfigs")] = None
    """
    KumaSDConfigs defines a list of Kuma service discovery configurations.
    """
    label_limit: Annotated[Optional[int], Field(alias="labelLimit")] = None
    """
    Per-scrape limit on number of labels that will be accepted for a sample.
    Only valid in Prometheus versions 2.27.0 and newer.
    """
    label_name_length_limit: Annotated[Optional[int], Field(alias="labelNameLengthLimit")] = None
    """
    Per-scrape limit on length of labels name that will be accepted for a sample.
    Only valid in Prometheus versions 2.27.0 and newer.
    """
    label_value_length_limit: Annotated[Optional[int], Field(alias="labelValueLengthLimit")] = None
    """
    Per-scrape limit on length of labels value that will be accepted for a sample.
    Only valid in Prometheus versions 2.27.0 and newer.
    """
    light_sail_sd_configs: Annotated[
        Optional[List[LightSailSdConfig]], Field(alias="lightSailSDConfigs")
    ] = None
    """
    LightsailSDConfigs defines a list of Lightsail service discovery configurations.
    """
    linode_sd_configs: Annotated[Optional[List[LinodeSdConfig]], Field(alias="linodeSDConfigs")] = (
        None
    )
    """
    LinodeSDConfigs defines a list of Linode service discovery configurations.
    """
    metric_relabelings: Annotated[
        Optional[List[MetricRelabeling]], Field(alias="metricRelabelings", min_length=1)
    ] = None
    """
    MetricRelabelConfigs to apply to samples before ingestion.
    """
    metrics_path: Annotated[Optional[str], Field(alias="metricsPath", min_length=1)] = None
    """
    MetricsPath HTTP path to scrape for metrics. If empty, Prometheus uses the default value (e.g. /metrics).
    """
    native_histogram_bucket_limit: Annotated[
        Optional[int], Field(alias="nativeHistogramBucketLimit")
    ] = None
    """
    If there are more than this many buckets in a native histogram,
    buckets will be merged to stay within the limit.
    It requires Prometheus >= v2.45.0.
    """
    native_histogram_min_bucket_factor: Annotated[
        Optional[Union[NativeHistogramMinBucketFactor, NativeHistogramMinBucketFactorModel]],
        Field(alias="nativeHistogramMinBucketFactor"),
    ] = None
    """
    If the growth factor of one bucket to the next is smaller than this,
    buckets will be merged to increase the factor sufficiently.
    It requires Prometheus >= v2.50.0.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    nomad_sd_configs: Annotated[Optional[List[NomadSdConfig]], Field(alias="nomadSDConfigs")] = None
    """
    NomadSDConfigs defines a list of Nomad service discovery configurations.
    """
    oauth2: Optional[Oauth2] = None
    """
    OAuth2 configuration to use on every scrape request.
    """
    openstack_sd_configs: Annotated[
        Optional[List[OpenstackSdConfig]], Field(alias="openstackSDConfigs")
    ] = None
    """
    OpenStackSDConfigs defines a list of OpenStack service discovery configurations.
    """
    ovhcloud_sd_configs: Annotated[
        Optional[List[OvhcloudSdConfig]], Field(alias="ovhcloudSDConfigs")
    ] = None
    """
    OVHCloudSDConfigs defines a list of OVHcloud service discovery configurations.
    """
    params: Optional[Dict[str, List[str]]] = None
    """
    Optional HTTP URL parameters
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    puppet_dbsd_configs: Annotated[
        Optional[List[PuppetDbsdConfig]], Field(alias="puppetDBSDConfigs")
    ] = None
    """
    PuppetDBSDConfigs defines a list of PuppetDB service discovery configurations.
    """
    relabelings: Annotated[Optional[List[Relabeling]], Field(min_length=1)] = None
    """
    RelabelConfigs defines how to rewrite the target's labels before scraping.
    Prometheus Operator automatically adds relabelings for a few standard Kubernetes fields.
    The original scrape job's name is available via the `__tmp_prometheus_job_name` label.
    More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
    """
    sample_limit: Annotated[Optional[int], Field(alias="sampleLimit")] = None
    """
    SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
    """
    scaleway_sd_configs: Annotated[
        Optional[List[ScalewaySdConfig]], Field(alias="scalewaySDConfigs")
    ] = None
    """
    ScalewaySDConfigs defines a list of Scaleway instances and baremetal service discovery configurations.
    """
    scheme: Optional[Literal["HTTP", "HTTPS"]] = None
    """
    Configures the protocol scheme used for requests.
    If empty, Prometheus uses HTTP by default.
    """
    scrape_class: Annotated[Optional[str], Field(alias="scrapeClass", min_length=1)] = None
    """
    The scrape class to apply.
    """
    scrape_classic_histograms: Annotated[Optional[bool], Field(alias="scrapeClassicHistograms")] = (
        None
    )
    """
    Whether to scrape a classic histogram that is also exposed as a native histogram.
    It requires Prometheus >= v2.45.0.
    """
    scrape_interval: Annotated[
        Optional[str],
        Field(
            alias="scrapeInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    ScrapeInterval is the interval between consecutive scrapes.
    """
    scrape_protocols: Annotated[
        Optional[
            List[
                Literal[
                    "PrometheusProto",
                    "OpenMetricsText0.0.1",
                    "OpenMetricsText1.0.0",
                    "PrometheusText0.0.4",
                    "PrometheusText1.0.0",
                ]
            ]
        ],
        Field(alias="scrapeProtocols", min_length=1),
    ] = None
    """
    The protocols to negotiate during a scrape. It tells clients the
    protocols supported by Prometheus in order of preference (from most to least preferred).

    If unset, Prometheus uses its default value.

    It requires Prometheus >= v2.49.0.
    """
    scrape_timeout: Annotated[
        Optional[str],
        Field(
            alias="scrapeTimeout",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    ScrapeTimeout is the number of seconds to wait until a scrape request times out.
    The value cannot be greater than the scrape interval otherwise the operator will reject the resource.
    """
    static_configs: Annotated[Optional[List[StaticConfig]], Field(alias="staticConfigs")] = None
    """
    StaticConfigs defines a list of static targets with a common label set.
    """
    target_limit: Annotated[Optional[int], Field(alias="targetLimit")] = None
    """
    TargetLimit defines a limit on the number of scraped targets that will be accepted.
    """
    tls_config: Annotated[Optional[TlsConfigModel4], Field(alias="tlsConfig")] = None
    """
    TLS configuration to use on every scrape request
    """
    track_timestamps_staleness: Annotated[
        Optional[bool], Field(alias="trackTimestampsStaleness")
    ] = None
    """
    TrackTimestampsStaleness whether Prometheus tracks staleness of
    the metrics that have an explicit timestamp present in scraped data.
    Has no effect if `honorTimestamps` is false.
    It requires Prometheus >= v2.48.0.
    """


class AlertmanagerConfig(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AlertmanagerConfig"]:
            return AlertmanagerConfig

        def build(self) -> "AlertmanagerConfig":
            return AlertmanagerConfig(**self._attrs)

        def api_version(
            self, value: Optional[Literal["monitoring.coreos.com/v1alpha1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["AlertmanagerConfig"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "AlertmanagerConfig.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "AlertmanagerConfig.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: AlertmanagerConfigSpec, /
        ) -> "AlertmanagerConfig.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [AlertmanagerConfigSpec.Builder],
                AlertmanagerConfigSpec.Builder | AlertmanagerConfigSpec,
            ],
            /,
        ) -> "AlertmanagerConfig.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "AlertmanagerConfigSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AlertmanagerConfigSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AlertmanagerConfigSpec.builder())
                if isinstance(output, AlertmanagerConfigSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["AlertmanagerConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AlertmanagerConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AlertmanagerConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AlertmanagerConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AlertmanagerConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["monitoring.coreos.com/v1alpha1"]], Field(alias="apiVersion")
    ] = "monitoring.coreos.com/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["AlertmanagerConfig"]] = "AlertmanagerConfig"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: AlertmanagerConfigSpec


class PrometheusAgent(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PrometheusAgent"]:
            return PrometheusAgent

        def build(self) -> "PrometheusAgent":
            return PrometheusAgent(**self._attrs)

        def api_version(
            self, value: Optional[Literal["monitoring.coreos.com/v1alpha1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["PrometheusAgent"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "PrometheusAgent.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "PrometheusAgent.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: PrometheusAgentSpec, /) -> "PrometheusAgent.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [PrometheusAgentSpec.Builder],
                PrometheusAgentSpec.Builder | PrometheusAgentSpec,
            ],
            /,
        ) -> "PrometheusAgent.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "PrometheusAgentSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PrometheusAgentSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PrometheusAgentSpec.builder())
                if isinstance(output, PrometheusAgentSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[PrometheusAgentStatus], /
        ) -> "PrometheusAgent.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [PrometheusAgentStatus.Builder],
                PrometheusAgentStatus.Builder | PrometheusAgentStatus,
            ],
            /,
        ) -> "PrometheusAgent.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "PrometheusAgentStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PrometheusAgentStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PrometheusAgentStatus.builder())
                if isinstance(output, PrometheusAgentStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["PrometheusAgent.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PrometheusAgent.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PrometheusAgent."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PrometheusAgent", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PrometheusAgent.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["monitoring.coreos.com/v1alpha1"]], Field(alias="apiVersion")
    ] = "monitoring.coreos.com/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["PrometheusAgent"]] = "PrometheusAgent"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: PrometheusAgentSpec
    status: Optional[PrometheusAgentStatus] = None


class ScrapeConfig(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ScrapeConfig"]:
            return ScrapeConfig

        def build(self) -> "ScrapeConfig":
            return ScrapeConfig(**self._attrs)

        def api_version(
            self, value: Optional[Literal["monitoring.coreos.com/v1alpha1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ScrapeConfig"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ScrapeConfig.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ScrapeConfig.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: ScrapeConfigSpec, /) -> "ScrapeConfig.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ScrapeConfigSpec.Builder], ScrapeConfigSpec.Builder | ScrapeConfigSpec
            ],
            /,
        ) -> "ScrapeConfig.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ScrapeConfigSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ScrapeConfigSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ScrapeConfigSpec.builder())
                if isinstance(output, ScrapeConfigSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["ScrapeConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ScrapeConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ScrapeConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ScrapeConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ScrapeConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["monitoring.coreos.com/v1alpha1"]], Field(alias="apiVersion")
    ] = "monitoring.coreos.com/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ScrapeConfig"]] = "ScrapeConfig"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: ScrapeConfigSpec
