# Generated by cloudcoil-model-codegen v0.5.6
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    Union,
    cast,
    overload,
)

from pydantic import Field, RootModel

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseBuilder,
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class MatchExpression(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchExpression"]:
            return MatchExpression

        def build(self) -> "MatchExpression":
            return MatchExpression(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The label key that the selector applies to.
            """
            return self._set("key", value)

        def operator(self, value: str, /) -> Self:
            """
            Represents a key's relationship to a set of values.
            Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
            """
            return self._set("operator", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            An array of string values. If the operator is In or NotIn,
            the values array must be non-empty. If the operator is Exists or DoesNotExist,
            the values array must be empty. If the operator is Gt or Lt, the values
            array must have a single element, which will be interpreted as an integer.
            This array is replaced during a strategic merge patch.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["MatchExpression.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchExpression.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchExpression."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchExpression", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchExpression.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The label key that the selector applies to.
    """
    operator: str
    """
    Represents a key's relationship to a set of values.
    Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    """
    values: Optional[List[str]] = None
    """
    An array of string values. If the operator is In or NotIn,
    the values array must be non-empty. If the operator is Exists or DoesNotExist,
    the values array must be empty. If the operator is Gt or Lt, the values
    array must have a single element, which will be interpreted as an integer.
    This array is replaced during a strategic merge patch.
    """


class MatchField(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchField"]:
            return MatchField

        def build(self) -> "MatchField":
            return MatchField(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The label key that the selector applies to.
            """
            return self._set("key", value)

        def operator(self, value: str, /) -> Self:
            """
            Represents a key's relationship to a set of values.
            Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
            """
            return self._set("operator", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            An array of string values. If the operator is In or NotIn,
            the values array must be non-empty. If the operator is Exists or DoesNotExist,
            the values array must be empty. If the operator is Gt or Lt, the values
            array must have a single element, which will be interpreted as an integer.
            This array is replaced during a strategic merge patch.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["MatchField.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchField.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchField."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchField", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchField.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The label key that the selector applies to.
    """
    operator: str
    """
    Represents a key's relationship to a set of values.
    Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    """
    values: Optional[List[str]] = None
    """
    An array of string values. If the operator is In or NotIn,
    the values array must be non-empty. If the operator is Exists or DoesNotExist,
    the values array must be empty. If the operator is Gt or Lt, the values
    array must have a single element, which will be interpreted as an integer.
    This array is replaced during a strategic merge patch.
    """


class Preference(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Preference"]:
            return Preference

        def build(self) -> "Preference":
            return Preference(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpression], /
        ) -> "Preference.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpression, MatchExpression.Builder]],
                GenericListBuilder[MatchExpression, MatchExpression.Builder]
                | List[MatchExpression],
            ],
            /,
        ) -> "Preference.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpression.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            A list of node selector requirements by node's labels.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpression.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpression.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        @overload
        def match_fields(self, value_or_callback: List[MatchField], /) -> "Preference.Builder": ...

        @overload
        def match_fields(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchField, MatchField.Builder]],
                GenericListBuilder[MatchField, MatchField.Builder] | List[MatchField],
            ],
            /,
        ) -> "Preference.Builder": ...

        @overload
        def match_fields(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchField.Builder]: ...

        def match_fields(self, value_or_callback=None, /):
            """
            A list of node selector requirements by node's fields.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchField.Builder]()
                context._parent_builder = self
                context._field_name = "match_fields"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchField.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_fields", value)

    class BuilderContext(BuilderContextBase["Preference.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Preference.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Preference."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Preference", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Preference.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpression]], Field(alias="matchExpressions")
    ] = None
    """
    A list of node selector requirements by node's labels.
    """
    match_fields: Annotated[Optional[List[MatchField]], Field(alias="matchFields")] = None
    """
    A list of node selector requirements by node's fields.
    """


class PreferredDuringSchedulingIgnoredDuringExecution(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PreferredDuringSchedulingIgnoredDuringExecution"]:
            return PreferredDuringSchedulingIgnoredDuringExecution

        def build(self) -> "PreferredDuringSchedulingIgnoredDuringExecution":
            return PreferredDuringSchedulingIgnoredDuringExecution(**self._attrs)

        @overload
        def preference(
            self, value_or_callback: Preference, /
        ) -> "PreferredDuringSchedulingIgnoredDuringExecution.Builder": ...

        @overload
        def preference(
            self,
            value_or_callback: Callable[[Preference.Builder], Preference.Builder | Preference],
            /,
        ) -> "PreferredDuringSchedulingIgnoredDuringExecution.Builder": ...

        @overload
        def preference(self, value_or_callback: Never = ...) -> "Preference.BuilderContext": ...

        def preference(self, value_or_callback=None, /):
            """
            A node selector term, associated with the corresponding weight.
            """
            if self._in_context and value_or_callback is None:
                context = Preference.BuilderContext()
                context._parent_builder = self
                context._field_name = "preference"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Preference.builder())
                if isinstance(output, Preference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("preference", value)

        def weight(self, value: int, /) -> Self:
            """
            Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
            """
            return self._set("weight", value)

    class BuilderContext(
        BuilderContextBase["PreferredDuringSchedulingIgnoredDuringExecution.Builder"]
    ):
        def model_post_init(self, __context) -> None:
            self._builder = PreferredDuringSchedulingIgnoredDuringExecution.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PreferredDuringSchedulingIgnoredDuringExecution."""
        return cls.BuilderContext()

    class ListBuilder(
        GenericListBuilder["PreferredDuringSchedulingIgnoredDuringExecution", Builder]
    ):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PreferredDuringSchedulingIgnoredDuringExecution.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    preference: Preference
    """
    A node selector term, associated with the corresponding weight.
    """
    weight: int
    """
    Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
    """


class NodeSelectorTerm(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NodeSelectorTerm"]:
            return NodeSelectorTerm

        def build(self) -> "NodeSelectorTerm":
            return NodeSelectorTerm(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpression], /
        ) -> "NodeSelectorTerm.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpression, MatchExpression.Builder]],
                GenericListBuilder[MatchExpression, MatchExpression.Builder]
                | List[MatchExpression],
            ],
            /,
        ) -> "NodeSelectorTerm.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpression.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            A list of node selector requirements by node's labels.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpression.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpression.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        @overload
        def match_fields(
            self, value_or_callback: List[MatchField], /
        ) -> "NodeSelectorTerm.Builder": ...

        @overload
        def match_fields(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchField, MatchField.Builder]],
                GenericListBuilder[MatchField, MatchField.Builder] | List[MatchField],
            ],
            /,
        ) -> "NodeSelectorTerm.Builder": ...

        @overload
        def match_fields(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchField.Builder]: ...

        def match_fields(self, value_or_callback=None, /):
            """
            A list of node selector requirements by node's fields.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchField.Builder]()
                context._parent_builder = self
                context._field_name = "match_fields"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchField.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_fields", value)

    class BuilderContext(BuilderContextBase["NodeSelectorTerm.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NodeSelectorTerm.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NodeSelectorTerm."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NodeSelectorTerm", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NodeSelectorTerm.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpression]], Field(alias="matchExpressions")
    ] = None
    """
    A list of node selector requirements by node's labels.
    """
    match_fields: Annotated[Optional[List[MatchField]], Field(alias="matchFields")] = None
    """
    A list of node selector requirements by node's fields.
    """


class RequiredDuringSchedulingIgnoredDuringExecution(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RequiredDuringSchedulingIgnoredDuringExecution"]:
            return RequiredDuringSchedulingIgnoredDuringExecution

        def build(self) -> "RequiredDuringSchedulingIgnoredDuringExecution":
            return RequiredDuringSchedulingIgnoredDuringExecution(**self._attrs)

        @overload
        def node_selector_terms(
            self, value_or_callback: List[NodeSelectorTerm], /
        ) -> "RequiredDuringSchedulingIgnoredDuringExecution.Builder": ...

        @overload
        def node_selector_terms(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[NodeSelectorTerm, NodeSelectorTerm.Builder]],
                GenericListBuilder[NodeSelectorTerm, NodeSelectorTerm.Builder]
                | List[NodeSelectorTerm],
            ],
            /,
        ) -> "RequiredDuringSchedulingIgnoredDuringExecution.Builder": ...

        @overload
        def node_selector_terms(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[NodeSelectorTerm.Builder]: ...

        def node_selector_terms(self, value_or_callback=None, /):
            """
            Required. A list of node selector terms. The terms are ORed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[NodeSelectorTerm.Builder]()
                context._parent_builder = self
                context._field_name = "node_selector_terms"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NodeSelectorTerm.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("node_selector_terms", value)

    class BuilderContext(
        BuilderContextBase["RequiredDuringSchedulingIgnoredDuringExecution.Builder"]
    ):
        def model_post_init(self, __context) -> None:
            self._builder = RequiredDuringSchedulingIgnoredDuringExecution.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequiredDuringSchedulingIgnoredDuringExecution."""
        return cls.BuilderContext()

    class ListBuilder(
        GenericListBuilder["RequiredDuringSchedulingIgnoredDuringExecution", Builder]
    ):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RequiredDuringSchedulingIgnoredDuringExecution.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    node_selector_terms: Annotated[List[NodeSelectorTerm], Field(alias="nodeSelectorTerms")]
    """
    Required. A list of node selector terms. The terms are ORed.
    """


class NodeAffinity(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NodeAffinity"]:
            return NodeAffinity

        def build(self) -> "NodeAffinity":
            return NodeAffinity(**self._attrs)

        @overload
        def preferred_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: List[PreferredDuringSchedulingIgnoredDuringExecution],
            /,
        ) -> "NodeAffinity.Builder": ...

        @overload
        def preferred_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        PreferredDuringSchedulingIgnoredDuringExecution,
                        PreferredDuringSchedulingIgnoredDuringExecution.Builder,
                    ]
                ],
                GenericListBuilder[
                    PreferredDuringSchedulingIgnoredDuringExecution,
                    PreferredDuringSchedulingIgnoredDuringExecution.Builder,
                ]
                | List[PreferredDuringSchedulingIgnoredDuringExecution],
            ],
            /,
        ) -> "NodeAffinity.Builder": ...

        @overload
        def preferred_during_scheduling_ignored_during_execution(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PreferredDuringSchedulingIgnoredDuringExecution.Builder]: ...

        def preferred_during_scheduling_ignored_during_execution(self, value_or_callback=None, /):
            """
            The scheduler will prefer to schedule pods to nodes that satisfy
            the affinity expressions specified by this field, but it may choose
            a node that violates one or more of the expressions. The node that is
            most preferred is the one with the greatest sum of weights, i.e.
            for each node that meets all of the scheduling requirements (resource
            request, requiredDuringScheduling affinity expressions, etc.),
            compute a sum by iterating through the elements of this field and adding
            "weight" to the sum if the node matches the corresponding matchExpressions; the
            node(s) with the highest sum are the most preferred.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[
                    PreferredDuringSchedulingIgnoredDuringExecution.Builder
                ]()
                context._parent_builder = self
                context._field_name = "preferred_during_scheduling_ignored_during_execution"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(
                    PreferredDuringSchedulingIgnoredDuringExecution.list_builder()
                )
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("preferred_during_scheduling_ignored_during_execution", value)

        @overload
        def required_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: Optional[RequiredDuringSchedulingIgnoredDuringExecution],
            /,
        ) -> "NodeAffinity.Builder": ...

        @overload
        def required_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: Callable[
                [RequiredDuringSchedulingIgnoredDuringExecution.Builder],
                RequiredDuringSchedulingIgnoredDuringExecution.Builder
                | RequiredDuringSchedulingIgnoredDuringExecution,
            ],
            /,
        ) -> "NodeAffinity.Builder": ...

        @overload
        def required_during_scheduling_ignored_during_execution(
            self, value_or_callback: Never = ...
        ) -> "RequiredDuringSchedulingIgnoredDuringExecution.BuilderContext": ...

        def required_during_scheduling_ignored_during_execution(self, value_or_callback=None, /):
            """
            If the affinity requirements specified by this field are not met at
            scheduling time, the pod will not be scheduled onto the node.
            If the affinity requirements specified by this field cease to be met
            at some point during pod execution (e.g. due to an update), the system
            may or may not try to eventually evict the pod from its node.
            """
            if self._in_context and value_or_callback is None:
                context = RequiredDuringSchedulingIgnoredDuringExecution.BuilderContext()
                context._parent_builder = self
                context._field_name = "required_during_scheduling_ignored_during_execution"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RequiredDuringSchedulingIgnoredDuringExecution.builder())
                if isinstance(output, RequiredDuringSchedulingIgnoredDuringExecution.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("required_during_scheduling_ignored_during_execution", value)

    class BuilderContext(BuilderContextBase["NodeAffinity.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NodeAffinity.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NodeAffinity."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NodeAffinity", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NodeAffinity.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    preferred_during_scheduling_ignored_during_execution: Annotated[
        Optional[List[PreferredDuringSchedulingIgnoredDuringExecution]],
        Field(alias="preferredDuringSchedulingIgnoredDuringExecution"),
    ] = None
    """
    The scheduler will prefer to schedule pods to nodes that satisfy
    the affinity expressions specified by this field, but it may choose
    a node that violates one or more of the expressions. The node that is
    most preferred is the one with the greatest sum of weights, i.e.
    for each node that meets all of the scheduling requirements (resource
    request, requiredDuringScheduling affinity expressions, etc.),
    compute a sum by iterating through the elements of this field and adding
    "weight" to the sum if the node matches the corresponding matchExpressions; the
    node(s) with the highest sum are the most preferred.
    """
    required_during_scheduling_ignored_during_execution: Annotated[
        Optional[RequiredDuringSchedulingIgnoredDuringExecution],
        Field(alias="requiredDuringSchedulingIgnoredDuringExecution"),
    ] = None
    """
    If the affinity requirements specified by this field are not met at
    scheduling time, the pod will not be scheduled onto the node.
    If the affinity requirements specified by this field cease to be met
    at some point during pod execution (e.g. due to an update), the system
    may or may not try to eventually evict the pod from its node.
    """


class MatchExpressionModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchExpressionModel"]:
            return MatchExpressionModel

        def build(self) -> "MatchExpressionModel":
            return MatchExpressionModel(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key is the label key that the selector applies to.
            """
            return self._set("key", value)

        def operator(self, value: str, /) -> Self:
            """
            operator represents a key's relationship to a set of values.
            Valid operators are In, NotIn, Exists and DoesNotExist.
            """
            return self._set("operator", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            values is an array of string values. If the operator is In or NotIn,
            the values array must be non-empty. If the operator is Exists or DoesNotExist,
            the values array must be empty. This array is replaced during a strategic
            merge patch.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["MatchExpressionModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchExpressionModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchExpressionModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchExpressionModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchExpressionModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key is the label key that the selector applies to.
    """
    operator: str
    """
    operator represents a key's relationship to a set of values.
    Valid operators are In, NotIn, Exists and DoesNotExist.
    """
    values: Optional[List[str]] = None
    """
    values is an array of string values. If the operator is In or NotIn,
    the values array must be non-empty. If the operator is Exists or DoesNotExist,
    the values array must be empty. This array is replaced during a strategic
    merge patch.
    """


class LabelSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LabelSelector"]:
            return LabelSelector

        def build(self) -> "LabelSelector":
            return LabelSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel], /
        ) -> "LabelSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]],
                GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]
                | List[MatchExpressionModel],
            ],
            /,
        ) -> "LabelSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["LabelSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LabelSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LabelSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LabelSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LabelSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class NamespaceSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NamespaceSelector"]:
            return NamespaceSelector

        def build(self) -> "NamespaceSelector":
            return NamespaceSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel], /
        ) -> "NamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]],
                GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]
                | List[MatchExpressionModel],
            ],
            /,
        ) -> "NamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["NamespaceSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NamespaceSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NamespaceSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NamespaceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamespaceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class PodAffinityTerm(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodAffinityTerm"]:
            return PodAffinityTerm

        def build(self) -> "PodAffinityTerm":
            return PodAffinityTerm(**self._attrs)

        @overload
        def label_selector(
            self, value_or_callback: Optional[LabelSelector], /
        ) -> "PodAffinityTerm.Builder": ...

        @overload
        def label_selector(
            self,
            value_or_callback: Callable[
                [LabelSelector.Builder], LabelSelector.Builder | LabelSelector
            ],
            /,
        ) -> "PodAffinityTerm.Builder": ...

        @overload
        def label_selector(
            self, value_or_callback: Never = ...
        ) -> "LabelSelector.BuilderContext": ...

        def label_selector(self, value_or_callback=None, /):
            """
            A label query over a set of resources, in this case pods.
            If it's null, this PodAffinityTerm matches with no Pods.
            """
            if self._in_context and value_or_callback is None:
                context = LabelSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "label_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LabelSelector.builder())
                if isinstance(output, LabelSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("label_selector", value)

        def match_label_keys(self, value: Optional[List[str]], /) -> Self:
            """
            MatchLabelKeys is a set of pod label keys to select which pods will
            be taken into consideration. The keys are used to lookup values from the
            incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
            to select the group of existing pods which pods will be taken into consideration
            for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
            pod labels will be ignored. The default value is empty.
            The same key is forbidden to exist in both matchLabelKeys and labelSelector.
            Also, matchLabelKeys cannot be set when labelSelector isn't set.
            This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
            """
            return self._set("match_label_keys", value)

        def mismatch_label_keys(self, value: Optional[List[str]], /) -> Self:
            """
            MismatchLabelKeys is a set of pod label keys to select which pods will
            be taken into consideration. The keys are used to lookup values from the
            incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
            to select the group of existing pods which pods will be taken into consideration
            for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
            pod labels will be ignored. The default value is empty.
            The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
            Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
            This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
            """
            return self._set("mismatch_label_keys", value)

        @overload
        def namespace_selector(
            self, value_or_callback: Optional[NamespaceSelector], /
        ) -> "PodAffinityTerm.Builder": ...

        @overload
        def namespace_selector(
            self,
            value_or_callback: Callable[
                [NamespaceSelector.Builder],
                NamespaceSelector.Builder | NamespaceSelector,
            ],
            /,
        ) -> "PodAffinityTerm.Builder": ...

        @overload
        def namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "NamespaceSelector.BuilderContext": ...

        def namespace_selector(self, value_or_callback=None, /):
            """
            A label query over the set of namespaces that the term applies to.
            The term is applied to the union of the namespaces selected by this field
            and the ones listed in the namespaces field.
            null selector and null or empty namespaces list means "this pod's namespace".
            An empty selector ({}) matches all namespaces.
            """
            if self._in_context and value_or_callback is None:
                context = NamespaceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamespaceSelector.builder())
                if isinstance(output, NamespaceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("namespace_selector", value)

        def namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            namespaces specifies a static list of namespace names that the term applies to.
            The term is applied to the union of the namespaces listed in this field
            and the ones selected by namespaceSelector.
            null or empty namespaces list and null namespaceSelector means "this pod's namespace".
            """
            return self._set("namespaces", value)

        def topology_key(self, value: str, /) -> Self:
            """
            This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
            the labelSelector in the specified namespaces, where co-located is defined as running on a node
            whose value of the label with key topologyKey matches that of any node on which any of the
            selected pods is running.
            Empty topologyKey is not allowed.
            """
            return self._set("topology_key", value)

    class BuilderContext(BuilderContextBase["PodAffinityTerm.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodAffinityTerm.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodAffinityTerm."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodAffinityTerm", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodAffinityTerm.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    label_selector: Annotated[Optional[LabelSelector], Field(alias="labelSelector")] = None
    """
    A label query over a set of resources, in this case pods.
    If it's null, this PodAffinityTerm matches with no Pods.
    """
    match_label_keys: Annotated[Optional[List[str]], Field(alias="matchLabelKeys")] = None
    """
    MatchLabelKeys is a set of pod label keys to select which pods will
    be taken into consideration. The keys are used to lookup values from the
    incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
    to select the group of existing pods which pods will be taken into consideration
    for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    pod labels will be ignored. The default value is empty.
    The same key is forbidden to exist in both matchLabelKeys and labelSelector.
    Also, matchLabelKeys cannot be set when labelSelector isn't set.
    This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
    """
    mismatch_label_keys: Annotated[Optional[List[str]], Field(alias="mismatchLabelKeys")] = None
    """
    MismatchLabelKeys is a set of pod label keys to select which pods will
    be taken into consideration. The keys are used to lookup values from the
    incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
    to select the group of existing pods which pods will be taken into consideration
    for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    pod labels will be ignored. The default value is empty.
    The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
    Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
    This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
    """
    namespace_selector: Annotated[Optional[NamespaceSelector], Field(alias="namespaceSelector")] = (
        None
    )
    """
    A label query over the set of namespaces that the term applies to.
    The term is applied to the union of the namespaces selected by this field
    and the ones listed in the namespaces field.
    null selector and null or empty namespaces list means "this pod's namespace".
    An empty selector ({}) matches all namespaces.
    """
    namespaces: Optional[List[str]] = None
    """
    namespaces specifies a static list of namespace names that the term applies to.
    The term is applied to the union of the namespaces listed in this field
    and the ones selected by namespaceSelector.
    null or empty namespaces list and null namespaceSelector means "this pod's namespace".
    """
    topology_key: Annotated[str, Field(alias="topologyKey")]
    """
    This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
    the labelSelector in the specified namespaces, where co-located is defined as running on a node
    whose value of the label with key topologyKey matches that of any node on which any of the
    selected pods is running.
    Empty topologyKey is not allowed.
    """


class PreferredDuringSchedulingIgnoredDuringExecutionModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PreferredDuringSchedulingIgnoredDuringExecutionModel"]:
            return PreferredDuringSchedulingIgnoredDuringExecutionModel

        def build(self) -> "PreferredDuringSchedulingIgnoredDuringExecutionModel":
            return PreferredDuringSchedulingIgnoredDuringExecutionModel(**self._attrs)

        @overload
        def pod_affinity_term(
            self, value_or_callback: PodAffinityTerm, /
        ) -> "PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder": ...

        @overload
        def pod_affinity_term(
            self,
            value_or_callback: Callable[
                [PodAffinityTerm.Builder], PodAffinityTerm.Builder | PodAffinityTerm
            ],
            /,
        ) -> "PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder": ...

        @overload
        def pod_affinity_term(
            self, value_or_callback: Never = ...
        ) -> "PodAffinityTerm.BuilderContext": ...

        def pod_affinity_term(self, value_or_callback=None, /):
            """
            Required. A pod affinity term, associated with the corresponding weight.
            """
            if self._in_context and value_or_callback is None:
                context = PodAffinityTerm.BuilderContext()
                context._parent_builder = self
                context._field_name = "pod_affinity_term"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodAffinityTerm.builder())
                if isinstance(output, PodAffinityTerm.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("pod_affinity_term", value)

        def weight(self, value: int, /) -> Self:
            """
            weight associated with matching the corresponding podAffinityTerm,
            in the range 1-100.
            """
            return self._set("weight", value)

    class BuilderContext(
        BuilderContextBase["PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder"]
    ):
        def model_post_init(self, __context) -> None:
            self._builder = PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PreferredDuringSchedulingIgnoredDuringExecutionModel."""
        return cls.BuilderContext()

    class ListBuilder(
        GenericListBuilder["PreferredDuringSchedulingIgnoredDuringExecutionModel", Builder]
    ):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PreferredDuringSchedulingIgnoredDuringExecutionModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    pod_affinity_term: Annotated[PodAffinityTerm, Field(alias="podAffinityTerm")]
    """
    Required. A pod affinity term, associated with the corresponding weight.
    """
    weight: int
    """
    weight associated with matching the corresponding podAffinityTerm,
    in the range 1-100.
    """


class RequiredDuringSchedulingIgnoredDuringExecutionModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RequiredDuringSchedulingIgnoredDuringExecutionModel"]:
            return RequiredDuringSchedulingIgnoredDuringExecutionModel

        def build(self) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel":
            return RequiredDuringSchedulingIgnoredDuringExecutionModel(**self._attrs)

        @overload
        def label_selector(
            self, value_or_callback: Optional[LabelSelector], /
        ) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder": ...

        @overload
        def label_selector(
            self,
            value_or_callback: Callable[
                [LabelSelector.Builder], LabelSelector.Builder | LabelSelector
            ],
            /,
        ) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder": ...

        @overload
        def label_selector(
            self, value_or_callback: Never = ...
        ) -> "LabelSelector.BuilderContext": ...

        def label_selector(self, value_or_callback=None, /):
            """
            A label query over a set of resources, in this case pods.
            If it's null, this PodAffinityTerm matches with no Pods.
            """
            if self._in_context and value_or_callback is None:
                context = LabelSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "label_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LabelSelector.builder())
                if isinstance(output, LabelSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("label_selector", value)

        def match_label_keys(self, value: Optional[List[str]], /) -> Self:
            """
            MatchLabelKeys is a set of pod label keys to select which pods will
            be taken into consideration. The keys are used to lookup values from the
            incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
            to select the group of existing pods which pods will be taken into consideration
            for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
            pod labels will be ignored. The default value is empty.
            The same key is forbidden to exist in both matchLabelKeys and labelSelector.
            Also, matchLabelKeys cannot be set when labelSelector isn't set.
            This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
            """
            return self._set("match_label_keys", value)

        def mismatch_label_keys(self, value: Optional[List[str]], /) -> Self:
            """
            MismatchLabelKeys is a set of pod label keys to select which pods will
            be taken into consideration. The keys are used to lookup values from the
            incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
            to select the group of existing pods which pods will be taken into consideration
            for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
            pod labels will be ignored. The default value is empty.
            The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
            Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
            This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
            """
            return self._set("mismatch_label_keys", value)

        @overload
        def namespace_selector(
            self, value_or_callback: Optional[NamespaceSelector], /
        ) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder": ...

        @overload
        def namespace_selector(
            self,
            value_or_callback: Callable[
                [NamespaceSelector.Builder],
                NamespaceSelector.Builder | NamespaceSelector,
            ],
            /,
        ) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder": ...

        @overload
        def namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "NamespaceSelector.BuilderContext": ...

        def namespace_selector(self, value_or_callback=None, /):
            """
            A label query over the set of namespaces that the term applies to.
            The term is applied to the union of the namespaces selected by this field
            and the ones listed in the namespaces field.
            null selector and null or empty namespaces list means "this pod's namespace".
            An empty selector ({}) matches all namespaces.
            """
            if self._in_context and value_or_callback is None:
                context = NamespaceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamespaceSelector.builder())
                if isinstance(output, NamespaceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("namespace_selector", value)

        def namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            namespaces specifies a static list of namespace names that the term applies to.
            The term is applied to the union of the namespaces listed in this field
            and the ones selected by namespaceSelector.
            null or empty namespaces list and null namespaceSelector means "this pod's namespace".
            """
            return self._set("namespaces", value)

        def topology_key(self, value: str, /) -> Self:
            """
            This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
            the labelSelector in the specified namespaces, where co-located is defined as running on a node
            whose value of the label with key topologyKey matches that of any node on which any of the
            selected pods is running.
            Empty topologyKey is not allowed.
            """
            return self._set("topology_key", value)

    class BuilderContext(
        BuilderContextBase["RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder"]
    ):
        def model_post_init(self, __context) -> None:
            self._builder = RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequiredDuringSchedulingIgnoredDuringExecutionModel."""
        return cls.BuilderContext()

    class ListBuilder(
        GenericListBuilder["RequiredDuringSchedulingIgnoredDuringExecutionModel", Builder]
    ):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RequiredDuringSchedulingIgnoredDuringExecutionModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    label_selector: Annotated[Optional[LabelSelector], Field(alias="labelSelector")] = None
    """
    A label query over a set of resources, in this case pods.
    If it's null, this PodAffinityTerm matches with no Pods.
    """
    match_label_keys: Annotated[Optional[List[str]], Field(alias="matchLabelKeys")] = None
    """
    MatchLabelKeys is a set of pod label keys to select which pods will
    be taken into consideration. The keys are used to lookup values from the
    incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
    to select the group of existing pods which pods will be taken into consideration
    for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    pod labels will be ignored. The default value is empty.
    The same key is forbidden to exist in both matchLabelKeys and labelSelector.
    Also, matchLabelKeys cannot be set when labelSelector isn't set.
    This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
    """
    mismatch_label_keys: Annotated[Optional[List[str]], Field(alias="mismatchLabelKeys")] = None
    """
    MismatchLabelKeys is a set of pod label keys to select which pods will
    be taken into consideration. The keys are used to lookup values from the
    incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
    to select the group of existing pods which pods will be taken into consideration
    for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    pod labels will be ignored. The default value is empty.
    The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
    Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
    This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
    """
    namespace_selector: Annotated[Optional[NamespaceSelector], Field(alias="namespaceSelector")] = (
        None
    )
    """
    A label query over the set of namespaces that the term applies to.
    The term is applied to the union of the namespaces selected by this field
    and the ones listed in the namespaces field.
    null selector and null or empty namespaces list means "this pod's namespace".
    An empty selector ({}) matches all namespaces.
    """
    namespaces: Optional[List[str]] = None
    """
    namespaces specifies a static list of namespace names that the term applies to.
    The term is applied to the union of the namespaces listed in this field
    and the ones selected by namespaceSelector.
    null or empty namespaces list and null namespaceSelector means "this pod's namespace".
    """
    topology_key: Annotated[str, Field(alias="topologyKey")]
    """
    This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
    the labelSelector in the specified namespaces, where co-located is defined as running on a node
    whose value of the label with key topologyKey matches that of any node on which any of the
    selected pods is running.
    Empty topologyKey is not allowed.
    """


class PodAffinity(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodAffinity"]:
            return PodAffinity

        def build(self) -> "PodAffinity":
            return PodAffinity(**self._attrs)

        @overload
        def preferred_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: List[PreferredDuringSchedulingIgnoredDuringExecutionModel],
            /,
        ) -> "PodAffinity.Builder": ...

        @overload
        def preferred_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        PreferredDuringSchedulingIgnoredDuringExecutionModel,
                        PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder,
                    ]
                ],
                GenericListBuilder[
                    PreferredDuringSchedulingIgnoredDuringExecutionModel,
                    PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder,
                ]
                | List[PreferredDuringSchedulingIgnoredDuringExecutionModel],
            ],
            /,
        ) -> "PodAffinity.Builder": ...

        @overload
        def preferred_during_scheduling_ignored_during_execution(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder]: ...

        def preferred_during_scheduling_ignored_during_execution(self, value_or_callback=None, /):
            """
            The scheduler will prefer to schedule pods to nodes that satisfy
            the affinity expressions specified by this field, but it may choose
            a node that violates one or more of the expressions. The node that is
            most preferred is the one with the greatest sum of weights, i.e.
            for each node that meets all of the scheduling requirements (resource
            request, requiredDuringScheduling affinity expressions, etc.),
            compute a sum by iterating through the elements of this field and adding
            "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
            node(s) with the highest sum are the most preferred.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[
                    PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder
                ]()
                context._parent_builder = self
                context._field_name = "preferred_during_scheduling_ignored_during_execution"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(
                    PreferredDuringSchedulingIgnoredDuringExecutionModel.list_builder()
                )
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("preferred_during_scheduling_ignored_during_execution", value)

        @overload
        def required_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: List[RequiredDuringSchedulingIgnoredDuringExecutionModel],
            /,
        ) -> "PodAffinity.Builder": ...

        @overload
        def required_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        RequiredDuringSchedulingIgnoredDuringExecutionModel,
                        RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder,
                    ]
                ],
                GenericListBuilder[
                    RequiredDuringSchedulingIgnoredDuringExecutionModel,
                    RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder,
                ]
                | List[RequiredDuringSchedulingIgnoredDuringExecutionModel],
            ],
            /,
        ) -> "PodAffinity.Builder": ...

        @overload
        def required_during_scheduling_ignored_during_execution(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder]: ...

        def required_during_scheduling_ignored_during_execution(self, value_or_callback=None, /):
            """
            If the affinity requirements specified by this field are not met at
            scheduling time, the pod will not be scheduled onto the node.
            If the affinity requirements specified by this field cease to be met
            at some point during pod execution (e.g. due to a pod label update), the
            system may or may not try to eventually evict the pod from its node.
            When there are multiple elements, the lists of nodes corresponding to each
            podAffinityTerm are intersected, i.e. all terms must be satisfied.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[
                    RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder
                ]()
                context._parent_builder = self
                context._field_name = "required_during_scheduling_ignored_during_execution"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(
                    RequiredDuringSchedulingIgnoredDuringExecutionModel.list_builder()
                )
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("required_during_scheduling_ignored_during_execution", value)

    class BuilderContext(BuilderContextBase["PodAffinity.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodAffinity.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodAffinity."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodAffinity", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodAffinity.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    preferred_during_scheduling_ignored_during_execution: Annotated[
        Optional[List[PreferredDuringSchedulingIgnoredDuringExecutionModel]],
        Field(alias="preferredDuringSchedulingIgnoredDuringExecution"),
    ] = None
    """
    The scheduler will prefer to schedule pods to nodes that satisfy
    the affinity expressions specified by this field, but it may choose
    a node that violates one or more of the expressions. The node that is
    most preferred is the one with the greatest sum of weights, i.e.
    for each node that meets all of the scheduling requirements (resource
    request, requiredDuringScheduling affinity expressions, etc.),
    compute a sum by iterating through the elements of this field and adding
    "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
    node(s) with the highest sum are the most preferred.
    """
    required_during_scheduling_ignored_during_execution: Annotated[
        Optional[List[RequiredDuringSchedulingIgnoredDuringExecutionModel]],
        Field(alias="requiredDuringSchedulingIgnoredDuringExecution"),
    ] = None
    """
    If the affinity requirements specified by this field are not met at
    scheduling time, the pod will not be scheduled onto the node.
    If the affinity requirements specified by this field cease to be met
    at some point during pod execution (e.g. due to a pod label update), the
    system may or may not try to eventually evict the pod from its node.
    When there are multiple elements, the lists of nodes corresponding to each
    podAffinityTerm are intersected, i.e. all terms must be satisfied.
    """


class PodAntiAffinity(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodAntiAffinity"]:
            return PodAntiAffinity

        def build(self) -> "PodAntiAffinity":
            return PodAntiAffinity(**self._attrs)

        @overload
        def preferred_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: List[PreferredDuringSchedulingIgnoredDuringExecutionModel],
            /,
        ) -> "PodAntiAffinity.Builder": ...

        @overload
        def preferred_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        PreferredDuringSchedulingIgnoredDuringExecutionModel,
                        PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder,
                    ]
                ],
                GenericListBuilder[
                    PreferredDuringSchedulingIgnoredDuringExecutionModel,
                    PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder,
                ]
                | List[PreferredDuringSchedulingIgnoredDuringExecutionModel],
            ],
            /,
        ) -> "PodAntiAffinity.Builder": ...

        @overload
        def preferred_during_scheduling_ignored_during_execution(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder]: ...

        def preferred_during_scheduling_ignored_during_execution(self, value_or_callback=None, /):
            """
            The scheduler will prefer to schedule pods to nodes that satisfy
            the anti-affinity expressions specified by this field, but it may choose
            a node that violates one or more of the expressions. The node that is
            most preferred is the one with the greatest sum of weights, i.e.
            for each node that meets all of the scheduling requirements (resource
            request, requiredDuringScheduling anti-affinity expressions, etc.),
            compute a sum by iterating through the elements of this field and adding
            "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
            node(s) with the highest sum are the most preferred.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[
                    PreferredDuringSchedulingIgnoredDuringExecutionModel.Builder
                ]()
                context._parent_builder = self
                context._field_name = "preferred_during_scheduling_ignored_during_execution"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(
                    PreferredDuringSchedulingIgnoredDuringExecutionModel.list_builder()
                )
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("preferred_during_scheduling_ignored_during_execution", value)

        @overload
        def required_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: List[RequiredDuringSchedulingIgnoredDuringExecutionModel],
            /,
        ) -> "PodAntiAffinity.Builder": ...

        @overload
        def required_during_scheduling_ignored_during_execution(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        RequiredDuringSchedulingIgnoredDuringExecutionModel,
                        RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder,
                    ]
                ],
                GenericListBuilder[
                    RequiredDuringSchedulingIgnoredDuringExecutionModel,
                    RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder,
                ]
                | List[RequiredDuringSchedulingIgnoredDuringExecutionModel],
            ],
            /,
        ) -> "PodAntiAffinity.Builder": ...

        @overload
        def required_during_scheduling_ignored_during_execution(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder]: ...

        def required_during_scheduling_ignored_during_execution(self, value_or_callback=None, /):
            """
            If the anti-affinity requirements specified by this field are not met at
            scheduling time, the pod will not be scheduled onto the node.
            If the anti-affinity requirements specified by this field cease to be met
            at some point during pod execution (e.g. due to a pod label update), the
            system may or may not try to eventually evict the pod from its node.
            When there are multiple elements, the lists of nodes corresponding to each
            podAffinityTerm are intersected, i.e. all terms must be satisfied.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[
                    RequiredDuringSchedulingIgnoredDuringExecutionModel.Builder
                ]()
                context._parent_builder = self
                context._field_name = "required_during_scheduling_ignored_during_execution"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(
                    RequiredDuringSchedulingIgnoredDuringExecutionModel.list_builder()
                )
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("required_during_scheduling_ignored_during_execution", value)

    class BuilderContext(BuilderContextBase["PodAntiAffinity.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodAntiAffinity.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodAntiAffinity."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodAntiAffinity", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodAntiAffinity.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    preferred_during_scheduling_ignored_during_execution: Annotated[
        Optional[List[PreferredDuringSchedulingIgnoredDuringExecutionModel]],
        Field(alias="preferredDuringSchedulingIgnoredDuringExecution"),
    ] = None
    """
    The scheduler will prefer to schedule pods to nodes that satisfy
    the anti-affinity expressions specified by this field, but it may choose
    a node that violates one or more of the expressions. The node that is
    most preferred is the one with the greatest sum of weights, i.e.
    for each node that meets all of the scheduling requirements (resource
    request, requiredDuringScheduling anti-affinity expressions, etc.),
    compute a sum by iterating through the elements of this field and adding
    "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
    node(s) with the highest sum are the most preferred.
    """
    required_during_scheduling_ignored_during_execution: Annotated[
        Optional[List[RequiredDuringSchedulingIgnoredDuringExecutionModel]],
        Field(alias="requiredDuringSchedulingIgnoredDuringExecution"),
    ] = None
    """
    If the anti-affinity requirements specified by this field are not met at
    scheduling time, the pod will not be scheduled onto the node.
    If the anti-affinity requirements specified by this field cease to be met
    at some point during pod execution (e.g. due to a pod label update), the
    system may or may not try to eventually evict the pod from its node.
    When there are multiple elements, the lists of nodes corresponding to each
    podAffinityTerm are intersected, i.e. all terms must be satisfied.
    """


class Affinity(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Affinity"]:
            return Affinity

        def build(self) -> "Affinity":
            return Affinity(**self._attrs)

        @overload
        def node_affinity(
            self, value_or_callback: Optional[NodeAffinity], /
        ) -> "Affinity.Builder": ...

        @overload
        def node_affinity(
            self,
            value_or_callback: Callable[
                [NodeAffinity.Builder], NodeAffinity.Builder | NodeAffinity
            ],
            /,
        ) -> "Affinity.Builder": ...

        @overload
        def node_affinity(
            self, value_or_callback: Never = ...
        ) -> "NodeAffinity.BuilderContext": ...

        def node_affinity(self, value_or_callback=None, /):
            """
            Describes node affinity scheduling rules for the pod.
            """
            if self._in_context and value_or_callback is None:
                context = NodeAffinity.BuilderContext()
                context._parent_builder = self
                context._field_name = "node_affinity"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NodeAffinity.builder())
                if isinstance(output, NodeAffinity.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("node_affinity", value)

        @overload
        def pod_affinity(
            self, value_or_callback: Optional[PodAffinity], /
        ) -> "Affinity.Builder": ...

        @overload
        def pod_affinity(
            self,
            value_or_callback: Callable[[PodAffinity.Builder], PodAffinity.Builder | PodAffinity],
            /,
        ) -> "Affinity.Builder": ...

        @overload
        def pod_affinity(self, value_or_callback: Never = ...) -> "PodAffinity.BuilderContext": ...

        def pod_affinity(self, value_or_callback=None, /):
            """
            Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
            """
            if self._in_context and value_or_callback is None:
                context = PodAffinity.BuilderContext()
                context._parent_builder = self
                context._field_name = "pod_affinity"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodAffinity.builder())
                if isinstance(output, PodAffinity.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("pod_affinity", value)

        @overload
        def pod_anti_affinity(
            self, value_or_callback: Optional[PodAntiAffinity], /
        ) -> "Affinity.Builder": ...

        @overload
        def pod_anti_affinity(
            self,
            value_or_callback: Callable[
                [PodAntiAffinity.Builder], PodAntiAffinity.Builder | PodAntiAffinity
            ],
            /,
        ) -> "Affinity.Builder": ...

        @overload
        def pod_anti_affinity(
            self, value_or_callback: Never = ...
        ) -> "PodAntiAffinity.BuilderContext": ...

        def pod_anti_affinity(self, value_or_callback=None, /):
            """
            Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
            """
            if self._in_context and value_or_callback is None:
                context = PodAntiAffinity.BuilderContext()
                context._parent_builder = self
                context._field_name = "pod_anti_affinity"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodAntiAffinity.builder())
                if isinstance(output, PodAntiAffinity.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("pod_anti_affinity", value)

    class BuilderContext(BuilderContextBase["Affinity.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Affinity.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Affinity."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Affinity", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Affinity.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    node_affinity: Annotated[Optional[NodeAffinity], Field(alias="nodeAffinity")] = None
    """
    Describes node affinity scheduling rules for the pod.
    """
    pod_affinity: Annotated[Optional[PodAffinity], Field(alias="podAffinity")] = None
    """
    Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
    """
    pod_anti_affinity: Annotated[Optional[PodAntiAffinity], Field(alias="podAntiAffinity")] = None
    """
    Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
    """


class AlertmanagerConfigMatcherStrategy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AlertmanagerConfigMatcherStrategy"]:
            return AlertmanagerConfigMatcherStrategy

        def build(self) -> "AlertmanagerConfigMatcherStrategy":
            return AlertmanagerConfigMatcherStrategy(**self._attrs)

        def type(self, value: Optional[Literal["OnNamespace", "None"]], /) -> Self:
            """
            AlertmanagerConfigMatcherStrategyType defines the strategy used by
            AlertmanagerConfig objects to match alerts in the routes and inhibition
            rules.

            The default value is `OnNamespace`.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["AlertmanagerConfigMatcherStrategy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AlertmanagerConfigMatcherStrategy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AlertmanagerConfigMatcherStrategy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AlertmanagerConfigMatcherStrategy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AlertmanagerConfigMatcherStrategy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    type: Optional[Literal["OnNamespace", "None"]] = "OnNamespace"
    """
    AlertmanagerConfigMatcherStrategyType defines the strategy used by
    AlertmanagerConfig objects to match alerts in the routes and inhibition
    rules.

    The default value is `OnNamespace`.
    """


class AlertmanagerConfigNamespaceSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AlertmanagerConfigNamespaceSelector"]:
            return AlertmanagerConfigNamespaceSelector

        def build(self) -> "AlertmanagerConfigNamespaceSelector":
            return AlertmanagerConfigNamespaceSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel], /
        ) -> "AlertmanagerConfigNamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]],
                GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]
                | List[MatchExpressionModel],
            ],
            /,
        ) -> "AlertmanagerConfigNamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["AlertmanagerConfigNamespaceSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AlertmanagerConfigNamespaceSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AlertmanagerConfigNamespaceSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AlertmanagerConfigNamespaceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AlertmanagerConfigNamespaceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class AlertmanagerConfigSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AlertmanagerConfigSelector"]:
            return AlertmanagerConfigSelector

        def build(self) -> "AlertmanagerConfigSelector":
            return AlertmanagerConfigSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel], /
        ) -> "AlertmanagerConfigSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]],
                GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]
                | List[MatchExpressionModel],
            ],
            /,
        ) -> "AlertmanagerConfigSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["AlertmanagerConfigSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AlertmanagerConfigSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AlertmanagerConfigSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AlertmanagerConfigSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AlertmanagerConfigSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class Credentials(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Credentials"]:
            return Credentials

        def build(self) -> "Credentials":
            return Credentials(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["Credentials.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Credentials.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Credentials."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Credentials", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Credentials.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class Authorization(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Authorization"]:
            return Authorization

        def build(self) -> "Authorization":
            return Authorization(**self._attrs)

        @overload
        def credentials(
            self, value_or_callback: Optional[Credentials], /
        ) -> "Authorization.Builder": ...

        @overload
        def credentials(
            self,
            value_or_callback: Callable[[Credentials.Builder], Credentials.Builder | Credentials],
            /,
        ) -> "Authorization.Builder": ...

        @overload
        def credentials(self, value_or_callback: Never = ...) -> "Credentials.BuilderContext": ...

        def credentials(self, value_or_callback=None, /):
            """
            Selects a key of a Secret in the namespace that contains the credentials for authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Credentials.BuilderContext()
                context._parent_builder = self
                context._field_name = "credentials"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Credentials.builder())
                if isinstance(output, Credentials.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("credentials", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Defines the authentication type. The value is case-insensitive.

            "Basic" is not a supported value.

            Default: "Bearer"
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Authorization.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Authorization.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Authorization."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Authorization", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Authorization.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    credentials: Optional[Credentials] = None
    """
    Selects a key of a Secret in the namespace that contains the credentials for authentication.
    """
    type: Optional[str] = None
    """
    Defines the authentication type. The value is case-insensitive.

    "Basic" is not a supported value.

    Default: "Bearer"
    """


class Password(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Password"]:
            return Password

        def build(self) -> "Password":
            return Password(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["Password.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Password.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Password."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Password", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Password.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class Username(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Username"]:
            return Username

        def build(self) -> "Username":
            return Username(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["Username.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Username.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Username."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Username", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Username.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class BasicAuth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BasicAuth"]:
            return BasicAuth

        def build(self) -> "BasicAuth":
            return BasicAuth(**self._attrs)

        @overload
        def password(self, value_or_callback: Optional[Password], /) -> "BasicAuth.Builder": ...

        @overload
        def password(
            self,
            value_or_callback: Callable[[Password.Builder], Password.Builder | Password],
            /,
        ) -> "BasicAuth.Builder": ...

        @overload
        def password(self, value_or_callback: Never = ...) -> "Password.BuilderContext": ...

        def password(self, value_or_callback=None, /):
            """
            `password` specifies a key of a Secret containing the password for
            authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Password.BuilderContext()
                context._parent_builder = self
                context._field_name = "password"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Password.builder())
                if isinstance(output, Password.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("password", value)

        @overload
        def username(self, value_or_callback: Optional[Username], /) -> "BasicAuth.Builder": ...

        @overload
        def username(
            self,
            value_or_callback: Callable[[Username.Builder], Username.Builder | Username],
            /,
        ) -> "BasicAuth.Builder": ...

        @overload
        def username(self, value_or_callback: Never = ...) -> "Username.BuilderContext": ...

        def username(self, value_or_callback=None, /):
            """
            `username` specifies a key of a Secret containing the username for
            authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Username.BuilderContext()
                context._parent_builder = self
                context._field_name = "username"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Username.builder())
                if isinstance(output, Username.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("username", value)

    class BuilderContext(BuilderContextBase["BasicAuth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BasicAuth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BasicAuth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BasicAuth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BasicAuth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    password: Optional[Password] = None
    """
    `password` specifies a key of a Secret containing the password for
    authentication.
    """
    username: Optional[Username] = None
    """
    `username` specifies a key of a Secret containing the username for
    authentication.
    """


class BearerTokenSecret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BearerTokenSecret"]:
            return BearerTokenSecret

        def build(self) -> "BearerTokenSecret":
            return BearerTokenSecret(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["BearerTokenSecret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BearerTokenSecret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BearerTokenSecret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BearerTokenSecret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BearerTokenSecret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class ConfigMap(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMap"]:
            return ConfigMap

        def build(self) -> "ConfigMap":
            return ConfigMap(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key to select.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the ConfigMap or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMap.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMap.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMap."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMap", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMap.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key to select.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the ConfigMap or its key must be defined
    """


class Secret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Secret"]:
            return Secret

        def build(self) -> "Secret":
            return Secret(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["Secret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Secret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Secret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Secret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Secret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class ClientId(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClientId"]:
            return ClientId

        def build(self) -> "ClientId":
            return ClientId(**self._attrs)

        @overload
        def config_map(self, value_or_callback: Optional[ConfigMap], /) -> "ClientId.Builder": ...

        @overload
        def config_map(
            self,
            value_or_callback: Callable[[ConfigMap.Builder], ConfigMap.Builder | ConfigMap],
            /,
        ) -> "ClientId.Builder": ...

        @overload
        def config_map(self, value_or_callback: Never = ...) -> "ConfigMap.BuilderContext": ...

        def config_map(self, value_or_callback=None, /):
            """
            ConfigMap containing data to use for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMap.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMap.builder())
                if isinstance(output, ConfigMap.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map", value)

        @overload
        def secret(self, value_or_callback: Optional[Secret], /) -> "ClientId.Builder": ...

        @overload
        def secret(
            self,
            value_or_callback: Callable[[Secret.Builder], Secret.Builder | Secret],
            /,
        ) -> "ClientId.Builder": ...

        @overload
        def secret(self, value_or_callback: Never = ...) -> "Secret.BuilderContext": ...

        def secret(self, value_or_callback=None, /):
            """
            Secret containing data to use for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = Secret.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Secret.builder())
                if isinstance(output, Secret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret", value)

    class BuilderContext(BuilderContextBase["ClientId.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClientId.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClientId."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClientId", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClientId.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_map: Annotated[Optional[ConfigMap], Field(alias="configMap")] = None
    """
    ConfigMap containing data to use for the targets.
    """
    secret: Optional[Secret] = None
    """
    Secret containing data to use for the targets.
    """


class ClientSecret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClientSecret"]:
            return ClientSecret

        def build(self) -> "ClientSecret":
            return ClientSecret(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ClientSecret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClientSecret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClientSecret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClientSecret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClientSecret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class ProxyConnectHeader(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProxyConnectHeader"]:
            return ProxyConnectHeader

        def build(self) -> "ProxyConnectHeader":
            return ProxyConnectHeader(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ProxyConnectHeader.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProxyConnectHeader.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProxyConnectHeader."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProxyConnectHeader", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProxyConnectHeader.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class Ca(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ca"]:
            return Ca

        def build(self) -> "Ca":
            return Ca(**self._attrs)

        @overload
        def config_map(self, value_or_callback: Optional[ConfigMap], /) -> "Ca.Builder": ...

        @overload
        def config_map(
            self,
            value_or_callback: Callable[[ConfigMap.Builder], ConfigMap.Builder | ConfigMap],
            /,
        ) -> "Ca.Builder": ...

        @overload
        def config_map(self, value_or_callback: Never = ...) -> "ConfigMap.BuilderContext": ...

        def config_map(self, value_or_callback=None, /):
            """
            ConfigMap containing data to use for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMap.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMap.builder())
                if isinstance(output, ConfigMap.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map", value)

        @overload
        def secret(self, value_or_callback: Optional[Secret], /) -> "Ca.Builder": ...

        @overload
        def secret(
            self,
            value_or_callback: Callable[[Secret.Builder], Secret.Builder | Secret],
            /,
        ) -> "Ca.Builder": ...

        @overload
        def secret(self, value_or_callback: Never = ...) -> "Secret.BuilderContext": ...

        def secret(self, value_or_callback=None, /):
            """
            Secret containing data to use for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = Secret.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Secret.builder())
                if isinstance(output, Secret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret", value)

    class BuilderContext(BuilderContextBase["Ca.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ca.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ca."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ca", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ca.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_map: Annotated[Optional[ConfigMap], Field(alias="configMap")] = None
    """
    ConfigMap containing data to use for the targets.
    """
    secret: Optional[Secret] = None
    """
    Secret containing data to use for the targets.
    """


class Cert(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Cert"]:
            return Cert

        def build(self) -> "Cert":
            return Cert(**self._attrs)

        @overload
        def config_map(self, value_or_callback: Optional[ConfigMap], /) -> "Cert.Builder": ...

        @overload
        def config_map(
            self,
            value_or_callback: Callable[[ConfigMap.Builder], ConfigMap.Builder | ConfigMap],
            /,
        ) -> "Cert.Builder": ...

        @overload
        def config_map(self, value_or_callback: Never = ...) -> "ConfigMap.BuilderContext": ...

        def config_map(self, value_or_callback=None, /):
            """
            ConfigMap containing data to use for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMap.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMap.builder())
                if isinstance(output, ConfigMap.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map", value)

        @overload
        def secret(self, value_or_callback: Optional[Secret], /) -> "Cert.Builder": ...

        @overload
        def secret(
            self,
            value_or_callback: Callable[[Secret.Builder], Secret.Builder | Secret],
            /,
        ) -> "Cert.Builder": ...

        @overload
        def secret(self, value_or_callback: Never = ...) -> "Secret.BuilderContext": ...

        def secret(self, value_or_callback=None, /):
            """
            Secret containing data to use for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = Secret.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Secret.builder())
                if isinstance(output, Secret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret", value)

    class BuilderContext(BuilderContextBase["Cert.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Cert.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Cert."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Cert", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Cert.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_map: Annotated[Optional[ConfigMap], Field(alias="configMap")] = None
    """
    ConfigMap containing data to use for the targets.
    """
    secret: Optional[Secret] = None
    """
    Secret containing data to use for the targets.
    """


class KeySecret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["KeySecret"]:
            return KeySecret

        def build(self) -> "KeySecret":
            return KeySecret(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["KeySecret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = KeySecret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for KeySecret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["KeySecret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KeySecret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class TlsConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsConfig"]:
            return TlsConfig

        def build(self) -> "TlsConfig":
            return TlsConfig(**self._attrs)

        @overload
        def ca(self, value_or_callback: Optional[Ca], /) -> "TlsConfig.Builder": ...

        @overload
        def ca(
            self, value_or_callback: Callable[[Ca.Builder], Ca.Builder | Ca], /
        ) -> "TlsConfig.Builder": ...

        @overload
        def ca(self, value_or_callback: Never = ...) -> "Ca.BuilderContext": ...

        def ca(self, value_or_callback=None, /):
            """
            Certificate authority used when verifying server certificates.
            """
            if self._in_context and value_or_callback is None:
                context = Ca.BuilderContext()
                context._parent_builder = self
                context._field_name = "ca"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ca.builder())
                if isinstance(output, Ca.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ca", value)

        @overload
        def cert(self, value_or_callback: Optional[Cert], /) -> "TlsConfig.Builder": ...

        @overload
        def cert(
            self, value_or_callback: Callable[[Cert.Builder], Cert.Builder | Cert], /
        ) -> "TlsConfig.Builder": ...

        @overload
        def cert(self, value_or_callback: Never = ...) -> "Cert.BuilderContext": ...

        def cert(self, value_or_callback=None, /):
            """
            Client certificate to present when doing client-authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Cert.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cert.builder())
                if isinstance(output, Cert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert", value)

        def insecure_skip_verify(self, value: Optional[bool], /) -> Self:
            """
            Disable target certificate validation.
            """
            return self._set("insecure_skip_verify", value)

        @overload
        def key_secret(self, value_or_callback: Optional[KeySecret], /) -> "TlsConfig.Builder": ...

        @overload
        def key_secret(
            self,
            value_or_callback: Callable[[KeySecret.Builder], KeySecret.Builder | KeySecret],
            /,
        ) -> "TlsConfig.Builder": ...

        @overload
        def key_secret(self, value_or_callback: Never = ...) -> "KeySecret.BuilderContext": ...

        def key_secret(self, value_or_callback=None, /):
            """
            Secret containing the client key file for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = KeySecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "key_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KeySecret.builder())
                if isinstance(output, KeySecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("key_secret", value)

        def max_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Maximum acceptable TLS version.

            It requires Prometheus >= v2.41.0.
            """
            return self._set("max_version", value)

        def min_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Minimum acceptable TLS version.

            It requires Prometheus >= v2.35.0.
            """
            return self._set("min_version", value)

        def server_name(self, value: Optional[str], /) -> Self:
            """
            Used to verify the hostname for the targets.
            """
            return self._set("server_name", value)

    class BuilderContext(BuilderContextBase["TlsConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca: Optional[Ca] = None
    """
    Certificate authority used when verifying server certificates.
    """
    cert: Optional[Cert] = None
    """
    Client certificate to present when doing client-authentication.
    """
    insecure_skip_verify: Annotated[Optional[bool], Field(alias="insecureSkipVerify")] = None
    """
    Disable target certificate validation.
    """
    key_secret: Annotated[Optional[KeySecret], Field(alias="keySecret")] = None
    """
    Secret containing the client key file for the targets.
    """
    max_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="maxVersion")
    ] = None
    """
    Maximum acceptable TLS version.

    It requires Prometheus >= v2.41.0.
    """
    min_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="minVersion")
    ] = None
    """
    Minimum acceptable TLS version.

    It requires Prometheus >= v2.35.0.
    """
    server_name: Annotated[Optional[str], Field(alias="serverName")] = None
    """
    Used to verify the hostname for the targets.
    """


class Oauth2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Oauth2"]:
            return Oauth2

        def build(self) -> "Oauth2":
            return Oauth2(**self._attrs)

        @overload
        def client_id(self, value_or_callback: ClientId, /) -> "Oauth2.Builder": ...

        @overload
        def client_id(
            self,
            value_or_callback: Callable[[ClientId.Builder], ClientId.Builder | ClientId],
            /,
        ) -> "Oauth2.Builder": ...

        @overload
        def client_id(self, value_or_callback: Never = ...) -> "ClientId.BuilderContext": ...

        def client_id(self, value_or_callback=None, /):
            """
            `clientId` specifies a key of a Secret or ConfigMap containing the
            OAuth2 client's ID.
            """
            if self._in_context and value_or_callback is None:
                context = ClientId.BuilderContext()
                context._parent_builder = self
                context._field_name = "client_id"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClientId.builder())
                if isinstance(output, ClientId.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("client_id", value)

        @overload
        def client_secret(self, value_or_callback: ClientSecret, /) -> "Oauth2.Builder": ...

        @overload
        def client_secret(
            self,
            value_or_callback: Callable[
                [ClientSecret.Builder], ClientSecret.Builder | ClientSecret
            ],
            /,
        ) -> "Oauth2.Builder": ...

        @overload
        def client_secret(
            self, value_or_callback: Never = ...
        ) -> "ClientSecret.BuilderContext": ...

        def client_secret(self, value_or_callback=None, /):
            """
            `clientSecret` specifies a key of a Secret containing the OAuth2
            client's secret.
            """
            if self._in_context and value_or_callback is None:
                context = ClientSecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "client_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClientSecret.builder())
                if isinstance(output, ClientSecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("client_secret", value)

        def endpoint_params(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            `endpointParams` configures the HTTP parameters to append to the token
            URL.
            """
            return self._set("endpoint_params", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        def scopes(self, value: Optional[List[str]], /) -> Self:
            """
            `scopes` defines the OAuth2 scopes used for the token request.
            """
            return self._set("scopes", value)

        @overload
        def tls_config(self, value_or_callback: Optional[TlsConfig], /) -> "Oauth2.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[[TlsConfig.Builder], TlsConfig.Builder | TlsConfig],
            /,
        ) -> "Oauth2.Builder": ...

        @overload
        def tls_config(self, value_or_callback: Never = ...) -> "TlsConfig.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration to use when connecting to the OAuth2 server.
            It requires Prometheus >= v2.43.0.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfig.builder())
                if isinstance(output, TlsConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

        def token_url(self, value: str, /) -> Self:
            """
            `tokenURL` configures the URL to fetch the token from.
            """
            return self._set("token_url", value)

    class BuilderContext(BuilderContextBase["Oauth2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Oauth2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Oauth2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Oauth2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Oauth2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    client_id: Annotated[ClientId, Field(alias="clientId")]
    """
    `clientId` specifies a key of a Secret or ConfigMap containing the
    OAuth2 client's ID.
    """
    client_secret: Annotated[ClientSecret, Field(alias="clientSecret")]
    """
    `clientSecret` specifies a key of a Secret containing the OAuth2
    client's secret.
    """
    endpoint_params: Annotated[Optional[Dict[str, str]], Field(alias="endpointParams")] = None
    """
    `endpointParams` configures the HTTP parameters to append to the token
    URL.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    scopes: Optional[List[str]] = None
    """
    `scopes` defines the OAuth2 scopes used for the token request.
    """
    tls_config: Annotated[Optional[TlsConfig], Field(alias="tlsConfig")] = None
    """
    TLS configuration to use when connecting to the OAuth2 server.
    It requires Prometheus >= v2.43.0.
    """
    token_url: Annotated[str, Field(alias="tokenUrl", min_length=1)]
    """
    `tokenURL` configures the URL to fetch the token from.
    """


class HttpConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HttpConfig"]:
            return HttpConfig

        def build(self) -> "HttpConfig":
            return HttpConfig(**self._attrs)

        @overload
        def authorization(
            self, value_or_callback: Optional[Authorization], /
        ) -> "HttpConfig.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [Authorization.Builder], Authorization.Builder | Authorization
            ],
            /,
        ) -> "HttpConfig.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "Authorization.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization header configuration for the client.
            This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
            """
            if self._in_context and value_or_callback is None:
                context = Authorization.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Authorization.builder())
                if isinstance(output, Authorization.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def basic_auth(self, value_or_callback: Optional[BasicAuth], /) -> "HttpConfig.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "HttpConfig.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            BasicAuth for the client.
            This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        @overload
        def bearer_token_secret(
            self, value_or_callback: Optional[BearerTokenSecret], /
        ) -> "HttpConfig.Builder": ...

        @overload
        def bearer_token_secret(
            self,
            value_or_callback: Callable[
                [BearerTokenSecret.Builder],
                BearerTokenSecret.Builder | BearerTokenSecret,
            ],
            /,
        ) -> "HttpConfig.Builder": ...

        @overload
        def bearer_token_secret(
            self, value_or_callback: Never = ...
        ) -> "BearerTokenSecret.BuilderContext": ...

        def bearer_token_secret(self, value_or_callback=None, /):
            """
            The secret's key that contains the bearer token to be used by the client
            for authentication.
            The secret needs to be in the same namespace as the Alertmanager
            object and accessible by the Prometheus Operator.
            """
            if self._in_context and value_or_callback is None:
                context = BearerTokenSecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "bearer_token_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BearerTokenSecret.builder())
                if isinstance(output, BearerTokenSecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("bearer_token_secret", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
            """
            return self._set("follow_redirects", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        @overload
        def oauth2(self, value_or_callback: Optional[Oauth2], /) -> "HttpConfig.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "HttpConfig.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            OAuth2 client credentials used to fetch a token for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        @overload
        def tls_config(self, value_or_callback: Optional[TlsConfig], /) -> "HttpConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[[TlsConfig.Builder], TlsConfig.Builder | TlsConfig],
            /,
        ) -> "HttpConfig.Builder": ...

        @overload
        def tls_config(self, value_or_callback: Never = ...) -> "TlsConfig.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration for the client.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfig.builder())
                if isinstance(output, TlsConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["HttpConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HttpConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HttpConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HttpConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HttpConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authorization: Optional[Authorization] = None
    """
    Authorization header configuration for the client.
    This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    BasicAuth for the client.
    This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
    """
    bearer_token_secret: Annotated[
        Optional[BearerTokenSecret], Field(alias="bearerTokenSecret")
    ] = None
    """
    The secret's key that contains the bearer token to be used by the client
    for authentication.
    The secret needs to be in the same namespace as the Alertmanager
    object and accessible by the Prometheus Operator.
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    oauth2: Optional[Oauth2] = None
    """
    OAuth2 client credentials used to fetch a token for the targets.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    tls_config: Annotated[Optional[TlsConfig], Field(alias="tlsConfig")] = None
    """
    TLS configuration for the client.
    """


class OpsGenieApiKey(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["OpsGenieApiKey"]:
            return OpsGenieApiKey

        def build(self) -> "OpsGenieApiKey":
            return OpsGenieApiKey(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["OpsGenieApiKey.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = OpsGenieApiKey.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for OpsGenieApiKey."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["OpsGenieApiKey", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use OpsGenieApiKey.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class OpsGenieApiUrl(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["OpsGenieApiUrl"]:
            return OpsGenieApiUrl

        def build(self) -> "OpsGenieApiUrl":
            return OpsGenieApiUrl(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["OpsGenieApiUrl.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = OpsGenieApiUrl.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for OpsGenieApiUrl."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["OpsGenieApiUrl", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use OpsGenieApiUrl.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class SlackApiUrl(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SlackApiUrl"]:
            return SlackApiUrl

        def build(self) -> "SlackApiUrl":
            return SlackApiUrl(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["SlackApiUrl.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SlackApiUrl.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SlackApiUrl."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SlackApiUrl", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SlackApiUrl.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class AuthPassword(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AuthPassword"]:
            return AuthPassword

        def build(self) -> "AuthPassword":
            return AuthPassword(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["AuthPassword.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AuthPassword.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AuthPassword."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AuthPassword", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AuthPassword.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class AuthSecret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AuthSecret"]:
            return AuthSecret

        def build(self) -> "AuthSecret":
            return AuthSecret(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["AuthSecret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AuthSecret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AuthSecret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AuthSecret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AuthSecret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class SmartHost(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SmartHost"]:
            return SmartHost

        def build(self) -> "SmartHost":
            return SmartHost(**self._attrs)

        def host(self, value: str, /) -> Self:
            """
            Defines the host's address, it can be a DNS name or a literal IP address.
            """
            return self._set("host", value)

        def port(self, value: str, /) -> Self:
            """
            Defines the host's port, it can be a literal port number or a port name.
            """
            return self._set("port", value)

    class BuilderContext(BuilderContextBase["SmartHost.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SmartHost.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SmartHost."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SmartHost", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SmartHost.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    host: Annotated[str, Field(min_length=1)]
    """
    Defines the host's address, it can be a DNS name or a literal IP address.
    """
    port: Annotated[str, Field(min_length=1)]
    """
    Defines the host's port, it can be a literal port number or a port name.
    """


class Smtp(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Smtp"]:
            return Smtp

        def build(self) -> "Smtp":
            return Smtp(**self._attrs)

        def auth_identity(self, value: Optional[str], /) -> Self:
            """
            SMTP Auth using PLAIN
            """
            return self._set("auth_identity", value)

        @overload
        def auth_password(self, value_or_callback: Optional[AuthPassword], /) -> "Smtp.Builder": ...

        @overload
        def auth_password(
            self,
            value_or_callback: Callable[
                [AuthPassword.Builder], AuthPassword.Builder | AuthPassword
            ],
            /,
        ) -> "Smtp.Builder": ...

        @overload
        def auth_password(
            self, value_or_callback: Never = ...
        ) -> "AuthPassword.BuilderContext": ...

        def auth_password(self, value_or_callback=None, /):
            """
            SMTP Auth using LOGIN and PLAIN.
            """
            if self._in_context and value_or_callback is None:
                context = AuthPassword.BuilderContext()
                context._parent_builder = self
                context._field_name = "auth_password"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthPassword.builder())
                if isinstance(output, AuthPassword.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("auth_password", value)

        @overload
        def auth_secret(self, value_or_callback: Optional[AuthSecret], /) -> "Smtp.Builder": ...

        @overload
        def auth_secret(
            self,
            value_or_callback: Callable[[AuthSecret.Builder], AuthSecret.Builder | AuthSecret],
            /,
        ) -> "Smtp.Builder": ...

        @overload
        def auth_secret(self, value_or_callback: Never = ...) -> "AuthSecret.BuilderContext": ...

        def auth_secret(self, value_or_callback=None, /):
            """
            SMTP Auth using CRAM-MD5.
            """
            if self._in_context and value_or_callback is None:
                context = AuthSecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "auth_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthSecret.builder())
                if isinstance(output, AuthSecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("auth_secret", value)

        def auth_username(self, value: Optional[str], /) -> Self:
            """
            SMTP Auth using CRAM-MD5, LOGIN and PLAIN. If empty, Alertmanager doesn't authenticate to the SMTP server.
            """
            return self._set("auth_username", value)

        def from_(self, value: Optional[str], /) -> Self:
            """
            The default SMTP From header field.
            """
            return self._set("from_", value)

        def hello(self, value: Optional[str], /) -> Self:
            """
            The default hostname to identify to the SMTP server.
            """
            return self._set("hello", value)

        def require_tls(self, value: Optional[bool], /) -> Self:
            """
            The default SMTP TLS requirement.
            Note that Go does not support unencrypted connections to remote SMTP endpoints.
            """
            return self._set("require_tls", value)

        @overload
        def smart_host(self, value_or_callback: Optional[SmartHost], /) -> "Smtp.Builder": ...

        @overload
        def smart_host(
            self,
            value_or_callback: Callable[[SmartHost.Builder], SmartHost.Builder | SmartHost],
            /,
        ) -> "Smtp.Builder": ...

        @overload
        def smart_host(self, value_or_callback: Never = ...) -> "SmartHost.BuilderContext": ...

        def smart_host(self, value_or_callback=None, /):
            """
            The default SMTP smarthost used for sending emails.
            """
            if self._in_context and value_or_callback is None:
                context = SmartHost.BuilderContext()
                context._parent_builder = self
                context._field_name = "smart_host"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SmartHost.builder())
                if isinstance(output, SmartHost.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("smart_host", value)

    class BuilderContext(BuilderContextBase["Smtp.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Smtp.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Smtp."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Smtp", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Smtp.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    auth_identity: Annotated[Optional[str], Field(alias="authIdentity")] = None
    """
    SMTP Auth using PLAIN
    """
    auth_password: Annotated[Optional[AuthPassword], Field(alias="authPassword")] = None
    """
    SMTP Auth using LOGIN and PLAIN.
    """
    auth_secret: Annotated[Optional[AuthSecret], Field(alias="authSecret")] = None
    """
    SMTP Auth using CRAM-MD5.
    """
    auth_username: Annotated[Optional[str], Field(alias="authUsername")] = None
    """
    SMTP Auth using CRAM-MD5, LOGIN and PLAIN. If empty, Alertmanager doesn't authenticate to the SMTP server.
    """
    from_: Annotated[Optional[str], Field(alias="from")] = None
    """
    The default SMTP From header field.
    """
    hello: Optional[str] = None
    """
    The default hostname to identify to the SMTP server.
    """
    require_tls: Annotated[Optional[bool], Field(alias="requireTLS")] = None
    """
    The default SMTP TLS requirement.
    Note that Go does not support unencrypted connections to remote SMTP endpoints.
    """
    smart_host: Annotated[Optional[SmartHost], Field(alias="smartHost")] = None
    """
    The default SMTP smarthost used for sending emails.
    """


class Global(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Global"]:
            return Global

        def build(self) -> "Global":
            return Global(**self._attrs)

        @overload
        def http_config(self, value_or_callback: Optional[HttpConfig], /) -> "Global.Builder": ...

        @overload
        def http_config(
            self,
            value_or_callback: Callable[[HttpConfig.Builder], HttpConfig.Builder | HttpConfig],
            /,
        ) -> "Global.Builder": ...

        @overload
        def http_config(self, value_or_callback: Never = ...) -> "HttpConfig.BuilderContext": ...

        def http_config(self, value_or_callback=None, /):
            """
            HTTP client configuration.
            """
            if self._in_context and value_or_callback is None:
                context = HttpConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpConfig.builder())
                if isinstance(output, HttpConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_config", value)

        @overload
        def ops_genie_api_key(
            self, value_or_callback: Optional[OpsGenieApiKey], /
        ) -> "Global.Builder": ...

        @overload
        def ops_genie_api_key(
            self,
            value_or_callback: Callable[
                [OpsGenieApiKey.Builder], OpsGenieApiKey.Builder | OpsGenieApiKey
            ],
            /,
        ) -> "Global.Builder": ...

        @overload
        def ops_genie_api_key(
            self, value_or_callback: Never = ...
        ) -> "OpsGenieApiKey.BuilderContext": ...

        def ops_genie_api_key(self, value_or_callback=None, /):
            """
            The default OpsGenie API Key.
            """
            if self._in_context and value_or_callback is None:
                context = OpsGenieApiKey.BuilderContext()
                context._parent_builder = self
                context._field_name = "ops_genie_api_key"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OpsGenieApiKey.builder())
                if isinstance(output, OpsGenieApiKey.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ops_genie_api_key", value)

        @overload
        def ops_genie_api_url(
            self, value_or_callback: Optional[OpsGenieApiUrl], /
        ) -> "Global.Builder": ...

        @overload
        def ops_genie_api_url(
            self,
            value_or_callback: Callable[
                [OpsGenieApiUrl.Builder], OpsGenieApiUrl.Builder | OpsGenieApiUrl
            ],
            /,
        ) -> "Global.Builder": ...

        @overload
        def ops_genie_api_url(
            self, value_or_callback: Never = ...
        ) -> "OpsGenieApiUrl.BuilderContext": ...

        def ops_genie_api_url(self, value_or_callback=None, /):
            """
            The default OpsGenie API URL.
            """
            if self._in_context and value_or_callback is None:
                context = OpsGenieApiUrl.BuilderContext()
                context._parent_builder = self
                context._field_name = "ops_genie_api_url"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OpsGenieApiUrl.builder())
                if isinstance(output, OpsGenieApiUrl.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ops_genie_api_url", value)

        def pagerduty_url(self, value: Optional[str], /) -> Self:
            """
            The default Pagerduty URL.
            """
            return self._set("pagerduty_url", value)

        def resolve_timeout(self, value: Optional[str], /) -> Self:
            """
            ResolveTimeout is the default value used by alertmanager if the alert does
            not include EndsAt, after this time passes it can declare the alert as resolved if it has not been updated.
            This has no impact on alerts from Prometheus, as they always include EndsAt.
            """
            return self._set("resolve_timeout", value)

        @overload
        def slack_api_url(
            self, value_or_callback: Optional[SlackApiUrl], /
        ) -> "Global.Builder": ...

        @overload
        def slack_api_url(
            self,
            value_or_callback: Callable[[SlackApiUrl.Builder], SlackApiUrl.Builder | SlackApiUrl],
            /,
        ) -> "Global.Builder": ...

        @overload
        def slack_api_url(self, value_or_callback: Never = ...) -> "SlackApiUrl.BuilderContext": ...

        def slack_api_url(self, value_or_callback=None, /):
            """
            The default Slack API URL.
            """
            if self._in_context and value_or_callback is None:
                context = SlackApiUrl.BuilderContext()
                context._parent_builder = self
                context._field_name = "slack_api_url"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SlackApiUrl.builder())
                if isinstance(output, SlackApiUrl.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("slack_api_url", value)

        @overload
        def smtp(self, value_or_callback: Optional[Smtp], /) -> "Global.Builder": ...

        @overload
        def smtp(
            self, value_or_callback: Callable[[Smtp.Builder], Smtp.Builder | Smtp], /
        ) -> "Global.Builder": ...

        @overload
        def smtp(self, value_or_callback: Never = ...) -> "Smtp.BuilderContext": ...

        def smtp(self, value_or_callback=None, /):
            """
            Configures global SMTP parameters.
            """
            if self._in_context and value_or_callback is None:
                context = Smtp.BuilderContext()
                context._parent_builder = self
                context._field_name = "smtp"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Smtp.builder())
                if isinstance(output, Smtp.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("smtp", value)

    class BuilderContext(BuilderContextBase["Global.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Global.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Global."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Global", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Global.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    http_config: Annotated[Optional[HttpConfig], Field(alias="httpConfig")] = None
    """
    HTTP client configuration.
    """
    ops_genie_api_key: Annotated[Optional[OpsGenieApiKey], Field(alias="opsGenieApiKey")] = None
    """
    The default OpsGenie API Key.
    """
    ops_genie_api_url: Annotated[Optional[OpsGenieApiUrl], Field(alias="opsGenieApiUrl")] = None
    """
    The default OpsGenie API URL.
    """
    pagerduty_url: Annotated[Optional[str], Field(alias="pagerdutyUrl")] = None
    """
    The default Pagerduty URL.
    """
    resolve_timeout: Annotated[
        Optional[str],
        Field(
            alias="resolveTimeout",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    ResolveTimeout is the default value used by alertmanager if the alert does
    not include EndsAt, after this time passes it can declare the alert as resolved if it has not been updated.
    This has no impact on alerts from Prometheus, as they always include EndsAt.
    """
    slack_api_url: Annotated[Optional[SlackApiUrl], Field(alias="slackApiUrl")] = None
    """
    The default Slack API URL.
    """
    smtp: Optional[Smtp] = None
    """
    Configures global SMTP parameters.
    """


class Template(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Template"]:
            return Template

        def build(self) -> "Template":
            return Template(**self._attrs)

        @overload
        def config_map(self, value_or_callback: Optional[ConfigMap], /) -> "Template.Builder": ...

        @overload
        def config_map(
            self,
            value_or_callback: Callable[[ConfigMap.Builder], ConfigMap.Builder | ConfigMap],
            /,
        ) -> "Template.Builder": ...

        @overload
        def config_map(self, value_or_callback: Never = ...) -> "ConfigMap.BuilderContext": ...

        def config_map(self, value_or_callback=None, /):
            """
            ConfigMap containing data to use for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMap.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMap.builder())
                if isinstance(output, ConfigMap.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map", value)

        @overload
        def secret(self, value_or_callback: Optional[Secret], /) -> "Template.Builder": ...

        @overload
        def secret(
            self,
            value_or_callback: Callable[[Secret.Builder], Secret.Builder | Secret],
            /,
        ) -> "Template.Builder": ...

        @overload
        def secret(self, value_or_callback: Never = ...) -> "Secret.BuilderContext": ...

        def secret(self, value_or_callback=None, /):
            """
            Secret containing data to use for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = Secret.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Secret.builder())
                if isinstance(output, Secret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret", value)

    class BuilderContext(BuilderContextBase["Template.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Template.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Template."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Template", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Template.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_map: Annotated[Optional[ConfigMap], Field(alias="configMap")] = None
    """
    ConfigMap containing data to use for the targets.
    """
    secret: Optional[Secret] = None
    """
    Secret containing data to use for the targets.
    """


class AlertmanagerConfiguration(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AlertmanagerConfiguration"]:
            return AlertmanagerConfiguration

        def build(self) -> "AlertmanagerConfiguration":
            return AlertmanagerConfiguration(**self._attrs)

        @overload
        def global_(
            self, value_or_callback: Optional[Global], /
        ) -> "AlertmanagerConfiguration.Builder": ...

        @overload
        def global_(
            self,
            value_or_callback: Callable[[Global.Builder], Global.Builder | Global],
            /,
        ) -> "AlertmanagerConfiguration.Builder": ...

        @overload
        def global_(self, value_or_callback: Never = ...) -> "Global.BuilderContext": ...

        def global_(self, value_or_callback=None, /):
            """
            Defines the global parameters of the Alertmanager configuration.
            """
            if self._in_context and value_or_callback is None:
                context = Global.BuilderContext()
                context._parent_builder = self
                context._field_name = "global_"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Global.builder())
                if isinstance(output, Global.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("global_", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the AlertmanagerConfig resource which is used to generate the Alertmanager configuration.
            It must be defined in the same namespace as the Alertmanager object.
            The operator will not enforce a `namespace` label for routes and inhibition rules.
            """
            return self._set("name", value)

        @overload
        def templates(
            self, value_or_callback: List[Template], /
        ) -> "AlertmanagerConfiguration.Builder": ...

        @overload
        def templates(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Template, Template.Builder]],
                GenericListBuilder[Template, Template.Builder] | List[Template],
            ],
            /,
        ) -> "AlertmanagerConfiguration.Builder": ...

        @overload
        def templates(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Template.Builder]: ...

        def templates(self, value_or_callback=None, /):
            """
            Custom notification templates.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Template.Builder]()
                context._parent_builder = self
                context._field_name = "templates"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Template.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("templates", value)

    class BuilderContext(BuilderContextBase["AlertmanagerConfiguration.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AlertmanagerConfiguration.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AlertmanagerConfiguration."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AlertmanagerConfiguration", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AlertmanagerConfiguration.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    global_: Annotated[Optional[Global], Field(alias="global")] = None
    """
    Defines the global parameters of the Alertmanager configuration.
    """
    name: Annotated[Optional[str], Field(min_length=1)] = None
    """
    The name of the AlertmanagerConfig resource which is used to generate the Alertmanager configuration.
    It must be defined in the same namespace as the Alertmanager object.
    The operator will not enforce a `namespace` label for routes and inhibition rules.
    """
    templates: Optional[List[Template]] = None
    """
    Custom notification templates.
    """


class ConfigMapKeyRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapKeyRef"]:
            return ConfigMapKeyRef

        def build(self) -> "ConfigMapKeyRef":
            return ConfigMapKeyRef(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key to select.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the ConfigMap or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapKeyRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapKeyRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapKeyRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapKeyRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapKeyRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key to select.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the ConfigMap or its key must be defined
    """


class FieldRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FieldRef"]:
            return FieldRef

        def build(self) -> "FieldRef":
            return FieldRef(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            Version of the schema the FieldPath is written in terms of, defaults to "v1".
            """
            return self._set("api_version", value)

        def field_path(self, value: str, /) -> Self:
            """
            Path of the field to select in the specified API version.
            """
            return self._set("field_path", value)

    class BuilderContext(BuilderContextBase["FieldRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FieldRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FieldRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FieldRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FieldRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    Version of the schema the FieldPath is written in terms of, defaults to "v1".
    """
    field_path: Annotated[str, Field(alias="fieldPath")]
    """
    Path of the field to select in the specified API version.
    """


class Divisor(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "Divisor":
            value = cast(int, self._value)
            return Divisor(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["Divisor.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Divisor.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Divisor."""
        return cls.BuilderContext()


class DivisorModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel":
            value = cast(str, self._value)
            return DivisorModel(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel."""
        return cls.BuilderContext()


class ResourceFieldRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceFieldRef"]:
            return ResourceFieldRef

        def build(self) -> "ResourceFieldRef":
            return ResourceFieldRef(**self._attrs)

        def container_name(self, value: Optional[str], /) -> Self:
            """
            Container name: required for volumes, optional for env vars
            """
            return self._set("container_name", value)

        def divisor(self, value: Optional[Union[Divisor, DivisorModel]], /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            return self._set("divisor", value)

        def resource(self, value: str, /) -> Self:
            """
            Required: resource to select
            """
            return self._set("resource", value)

    class BuilderContext(BuilderContextBase["ResourceFieldRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceFieldRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceFieldRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceFieldRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceFieldRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    container_name: Annotated[Optional[str], Field(alias="containerName")] = None
    """
    Container name: required for volumes, optional for env vars
    """
    divisor: Optional[Union[Divisor, DivisorModel]] = None
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """
    resource: str
    """
    Required: resource to select
    """


class SecretKeyRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretKeyRef"]:
            return SecretKeyRef

        def build(self) -> "SecretKeyRef":
            return SecretKeyRef(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["SecretKeyRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretKeyRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretKeyRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretKeyRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretKeyRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class ValueFrom(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ValueFrom"]:
            return ValueFrom

        def build(self) -> "ValueFrom":
            return ValueFrom(**self._attrs)

        @overload
        def config_map_key_ref(
            self, value_or_callback: Optional[ConfigMapKeyRef], /
        ) -> "ValueFrom.Builder": ...

        @overload
        def config_map_key_ref(
            self,
            value_or_callback: Callable[
                [ConfigMapKeyRef.Builder], ConfigMapKeyRef.Builder | ConfigMapKeyRef
            ],
            /,
        ) -> "ValueFrom.Builder": ...

        @overload
        def config_map_key_ref(
            self, value_or_callback: Never = ...
        ) -> "ConfigMapKeyRef.BuilderContext": ...

        def config_map_key_ref(self, value_or_callback=None, /):
            """
            Selects a key of a ConfigMap.
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMapKeyRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map_key_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMapKeyRef.builder())
                if isinstance(output, ConfigMapKeyRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map_key_ref", value)

        @overload
        def field_ref(self, value_or_callback: Optional[FieldRef], /) -> "ValueFrom.Builder": ...

        @overload
        def field_ref(
            self,
            value_or_callback: Callable[[FieldRef.Builder], FieldRef.Builder | FieldRef],
            /,
        ) -> "ValueFrom.Builder": ...

        @overload
        def field_ref(self, value_or_callback: Never = ...) -> "FieldRef.BuilderContext": ...

        def field_ref(self, value_or_callback=None, /):
            """
            Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
            spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
            """
            if self._in_context and value_or_callback is None:
                context = FieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FieldRef.builder())
                if isinstance(output, FieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("field_ref", value)

        @overload
        def resource_field_ref(
            self, value_or_callback: Optional[ResourceFieldRef], /
        ) -> "ValueFrom.Builder": ...

        @overload
        def resource_field_ref(
            self,
            value_or_callback: Callable[
                [ResourceFieldRef.Builder], ResourceFieldRef.Builder | ResourceFieldRef
            ],
            /,
        ) -> "ValueFrom.Builder": ...

        @overload
        def resource_field_ref(
            self, value_or_callback: Never = ...
        ) -> "ResourceFieldRef.BuilderContext": ...

        def resource_field_ref(self, value_or_callback=None, /):
            """
            Selects a resource of the container: only resources limits and requests
            (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceFieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource_field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceFieldRef.builder())
                if isinstance(output, ResourceFieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_field_ref", value)

        @overload
        def secret_key_ref(
            self, value_or_callback: Optional[SecretKeyRef], /
        ) -> "ValueFrom.Builder": ...

        @overload
        def secret_key_ref(
            self,
            value_or_callback: Callable[
                [SecretKeyRef.Builder], SecretKeyRef.Builder | SecretKeyRef
            ],
            /,
        ) -> "ValueFrom.Builder": ...

        @overload
        def secret_key_ref(
            self, value_or_callback: Never = ...
        ) -> "SecretKeyRef.BuilderContext": ...

        def secret_key_ref(self, value_or_callback=None, /):
            """
            Selects a key of a secret in the pod's namespace
            """
            if self._in_context and value_or_callback is None:
                context = SecretKeyRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_key_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretKeyRef.builder())
                if isinstance(output, SecretKeyRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_key_ref", value)

    class BuilderContext(BuilderContextBase["ValueFrom.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ValueFrom.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ValueFrom."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ValueFrom", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ValueFrom.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_map_key_ref: Annotated[Optional[ConfigMapKeyRef], Field(alias="configMapKeyRef")] = None
    """
    Selects a key of a ConfigMap.
    """
    field_ref: Annotated[Optional[FieldRef], Field(alias="fieldRef")] = None
    """
    Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    """
    resource_field_ref: Annotated[Optional[ResourceFieldRef], Field(alias="resourceFieldRef")] = (
        None
    )
    """
    Selects a resource of the container: only resources limits and requests
    (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    """
    secret_key_ref: Annotated[Optional[SecretKeyRef], Field(alias="secretKeyRef")] = None
    """
    Selects a key of a secret in the pod's namespace
    """


class Env(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Env"]:
            return Env

        def build(self) -> "Env":
            return Env(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the environment variable. Must be a C_IDENTIFIER.
            """
            return self._set("name", value)

        def value(self, value: Optional[str], /) -> Self:
            """
            Variable references $(VAR_NAME) are expanded
            using the previously defined environment variables in the container and
            any service environment variables. If a variable cannot be resolved,
            the reference in the input string will be unchanged. Double $$ are reduced
            to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
            "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
            Escaped references will never be expanded, regardless of whether the variable
            exists or not.
            Defaults to "".
            """
            return self._set("value", value)

        @overload
        def value_from(self, value_or_callback: Optional[ValueFrom], /) -> "Env.Builder": ...

        @overload
        def value_from(
            self,
            value_or_callback: Callable[[ValueFrom.Builder], ValueFrom.Builder | ValueFrom],
            /,
        ) -> "Env.Builder": ...

        @overload
        def value_from(self, value_or_callback: Never = ...) -> "ValueFrom.BuilderContext": ...

        def value_from(self, value_or_callback=None, /):
            """
            Source for the environment variable's value. Cannot be used if value is not empty.
            """
            if self._in_context and value_or_callback is None:
                context = ValueFrom.BuilderContext()
                context._parent_builder = self
                context._field_name = "value_from"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ValueFrom.builder())
                if isinstance(output, ValueFrom.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("value_from", value)

    class BuilderContext(BuilderContextBase["Env.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Env.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Env."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Env", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Env.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the environment variable. Must be a C_IDENTIFIER.
    """
    value: Optional[str] = None
    """
    Variable references $(VAR_NAME) are expanded
    using the previously defined environment variables in the container and
    any service environment variables. If a variable cannot be resolved,
    the reference in the input string will be unchanged. Double $$ are reduced
    to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    Escaped references will never be expanded, regardless of whether the variable
    exists or not.
    Defaults to "".
    """
    value_from: Annotated[Optional[ValueFrom], Field(alias="valueFrom")] = None
    """
    Source for the environment variable's value. Cannot be used if value is not empty.
    """


class ConfigMapRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapRef"]:
            return ConfigMapRef

        def build(self) -> "ConfigMapRef":
            return ConfigMapRef(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the ConfigMap must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the ConfigMap must be defined
    """


class SecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretRef"]:
            return SecretRef

        def build(self) -> "SecretRef":
            return SecretRef(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["SecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret must be defined
    """


class EnvFrom(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["EnvFrom"]:
            return EnvFrom

        def build(self) -> "EnvFrom":
            return EnvFrom(**self._attrs)

        @overload
        def config_map_ref(
            self, value_or_callback: Optional[ConfigMapRef], /
        ) -> "EnvFrom.Builder": ...

        @overload
        def config_map_ref(
            self,
            value_or_callback: Callable[
                [ConfigMapRef.Builder], ConfigMapRef.Builder | ConfigMapRef
            ],
            /,
        ) -> "EnvFrom.Builder": ...

        @overload
        def config_map_ref(
            self, value_or_callback: Never = ...
        ) -> "ConfigMapRef.BuilderContext": ...

        def config_map_ref(self, value_or_callback=None, /):
            """
            The ConfigMap to select from
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMapRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMapRef.builder())
                if isinstance(output, ConfigMapRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map_ref", value)

        def prefix(self, value: Optional[str], /) -> Self:
            """
            An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
            """
            return self._set("prefix", value)

        @overload
        def secret_ref(self, value_or_callback: Optional[SecretRef], /) -> "EnvFrom.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "EnvFrom.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            The Secret to select from
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

    class BuilderContext(BuilderContextBase["EnvFrom.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = EnvFrom.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for EnvFrom."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["EnvFrom", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use EnvFrom.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_map_ref: Annotated[Optional[ConfigMapRef], Field(alias="configMapRef")] = None
    """
    The ConfigMap to select from
    """
    prefix: Optional[str] = None
    """
    An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
    """
    secret_ref: Annotated[Optional[SecretRef], Field(alias="secretRef")] = None
    """
    The Secret to select from
    """


class Exec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Exec"]:
            return Exec

        def build(self) -> "Exec":
            return Exec(**self._attrs)

        def command(self, value: Optional[List[str]], /) -> Self:
            """
            Command is the command line to execute inside the container, the working directory for the
            command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
            not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
            a shell, you need to explicitly call out to that shell.
            Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
            """
            return self._set("command", value)

    class BuilderContext(BuilderContextBase["Exec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Exec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Exec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Exec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Exec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    command: Optional[List[str]] = None
    """
    Command is the command line to execute inside the container, the working directory for the
    command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    a shell, you need to explicitly call out to that shell.
    Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    """


class HttpHeader(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HttpHeader"]:
            return HttpHeader

        def build(self) -> "HttpHeader":
            return HttpHeader(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            The header field name.
            This will be canonicalized upon output, so case-variant names will be understood as the same header.
            """
            return self._set("name", value)

        def value(self, value: str, /) -> Self:
            """
            The header field value
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["HttpHeader.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HttpHeader.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HttpHeader."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HttpHeader", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HttpHeader.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    The header field name.
    This will be canonicalized upon output, so case-variant names will be understood as the same header.
    """
    value: str
    """
    The header field value
    """


class HttpGet(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HttpGet"]:
            return HttpGet

        def build(self) -> "HttpGet":
            return HttpGet(**self._attrs)

        def host(self, value: Optional[str], /) -> Self:
            """
            Host name to connect to, defaults to the pod IP. You probably want to set
            "Host" in httpHeaders instead.
            """
            return self._set("host", value)

        @overload
        def http_headers(self, value_or_callback: List[HttpHeader], /) -> "HttpGet.Builder": ...

        @overload
        def http_headers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[HttpHeader, HttpHeader.Builder]],
                GenericListBuilder[HttpHeader, HttpHeader.Builder] | List[HttpHeader],
            ],
            /,
        ) -> "HttpGet.Builder": ...

        @overload
        def http_headers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[HttpHeader.Builder]: ...

        def http_headers(self, value_or_callback=None, /):
            """
            Custom headers to set in the request. HTTP allows repeated headers.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[HttpHeader.Builder]()
                context._parent_builder = self
                context._field_name = "http_headers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpHeader.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_headers", value)

        def path(self, value: Optional[str], /) -> Self:
            """
            Path to access on the HTTP server.
            """
            return self._set("path", value)

        def port(self, value: Union[int, str], /) -> Self:
            """
            Name or number of the port to access on the container.
            Number must be in the range 1 to 65535.
            Name must be an IANA_SVC_NAME.
            """
            return self._set("port", value)

        def scheme(self, value: Optional[str], /) -> Self:
            """
            Scheme to use for connecting to the host.
            Defaults to HTTP.
            """
            return self._set("scheme", value)

    class BuilderContext(BuilderContextBase["HttpGet.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HttpGet.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HttpGet."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HttpGet", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HttpGet.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    host: Optional[str] = None
    """
    Host name to connect to, defaults to the pod IP. You probably want to set
    "Host" in httpHeaders instead.
    """
    http_headers: Annotated[Optional[List[HttpHeader]], Field(alias="httpHeaders")] = None
    """
    Custom headers to set in the request. HTTP allows repeated headers.
    """
    path: Optional[str] = None
    """
    Path to access on the HTTP server.
    """
    port: Union[int, str]
    """
    Name or number of the port to access on the container.
    Number must be in the range 1 to 65535.
    Name must be an IANA_SVC_NAME.
    """
    scheme: Optional[str] = None
    """
    Scheme to use for connecting to the host.
    Defaults to HTTP.
    """


class Sleep(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Sleep"]:
            return Sleep

        def build(self) -> "Sleep":
            return Sleep(**self._attrs)

        def seconds(self, value: int, /) -> Self:
            """
            Seconds is the number of seconds to sleep.
            """
            return self._set("seconds", value)

    class BuilderContext(BuilderContextBase["Sleep.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Sleep.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Sleep."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Sleep", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Sleep.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    seconds: int
    """
    Seconds is the number of seconds to sleep.
    """


class TcpSocket(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TcpSocket"]:
            return TcpSocket

        def build(self) -> "TcpSocket":
            return TcpSocket(**self._attrs)

        def host(self, value: Optional[str], /) -> Self:
            """
            Optional: Host name to connect to, defaults to the pod IP.
            """
            return self._set("host", value)

        def port(self, value: Union[int, str], /) -> Self:
            """
            Number or name of the port to access on the container.
            Number must be in the range 1 to 65535.
            Name must be an IANA_SVC_NAME.
            """
            return self._set("port", value)

    class BuilderContext(BuilderContextBase["TcpSocket.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TcpSocket.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TcpSocket."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TcpSocket", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TcpSocket.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    host: Optional[str] = None
    """
    Optional: Host name to connect to, defaults to the pod IP.
    """
    port: Union[int, str]
    """
    Number or name of the port to access on the container.
    Number must be in the range 1 to 65535.
    Name must be an IANA_SVC_NAME.
    """


class PostStart(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PostStart"]:
            return PostStart

        def build(self) -> "PostStart":
            return PostStart(**self._attrs)

        @overload
        def exec(self, value_or_callback: Optional[Exec], /) -> "PostStart.Builder": ...

        @overload
        def exec(
            self, value_or_callback: Callable[[Exec.Builder], Exec.Builder | Exec], /
        ) -> "PostStart.Builder": ...

        @overload
        def exec(self, value_or_callback: Never = ...) -> "Exec.BuilderContext": ...

        def exec(self, value_or_callback=None, /):
            """
            Exec specifies a command to execute in the container.
            """
            if self._in_context and value_or_callback is None:
                context = Exec.BuilderContext()
                context._parent_builder = self
                context._field_name = "exec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exec.builder())
                if isinstance(output, Exec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exec", value)

        @overload
        def http_get(self, value_or_callback: Optional[HttpGet], /) -> "PostStart.Builder": ...

        @overload
        def http_get(
            self,
            value_or_callback: Callable[[HttpGet.Builder], HttpGet.Builder | HttpGet],
            /,
        ) -> "PostStart.Builder": ...

        @overload
        def http_get(self, value_or_callback: Never = ...) -> "HttpGet.BuilderContext": ...

        def http_get(self, value_or_callback=None, /):
            """
            HTTPGet specifies an HTTP GET request to perform.
            """
            if self._in_context and value_or_callback is None:
                context = HttpGet.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_get"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpGet.builder())
                if isinstance(output, HttpGet.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_get", value)

        @overload
        def sleep(self, value_or_callback: Optional[Sleep], /) -> "PostStart.Builder": ...

        @overload
        def sleep(
            self, value_or_callback: Callable[[Sleep.Builder], Sleep.Builder | Sleep], /
        ) -> "PostStart.Builder": ...

        @overload
        def sleep(self, value_or_callback: Never = ...) -> "Sleep.BuilderContext": ...

        def sleep(self, value_or_callback=None, /):
            """
            Sleep represents a duration that the container should sleep.
            """
            if self._in_context and value_or_callback is None:
                context = Sleep.BuilderContext()
                context._parent_builder = self
                context._field_name = "sleep"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sleep.builder())
                if isinstance(output, Sleep.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sleep", value)

        @overload
        def tcp_socket(self, value_or_callback: Optional[TcpSocket], /) -> "PostStart.Builder": ...

        @overload
        def tcp_socket(
            self,
            value_or_callback: Callable[[TcpSocket.Builder], TcpSocket.Builder | TcpSocket],
            /,
        ) -> "PostStart.Builder": ...

        @overload
        def tcp_socket(self, value_or_callback: Never = ...) -> "TcpSocket.BuilderContext": ...

        def tcp_socket(self, value_or_callback=None, /):
            """
            Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
            for backward compatibility. There is no validation of this field and
            lifecycle hooks will fail at runtime when it is specified.
            """
            if self._in_context and value_or_callback is None:
                context = TcpSocket.BuilderContext()
                context._parent_builder = self
                context._field_name = "tcp_socket"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TcpSocket.builder())
                if isinstance(output, TcpSocket.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tcp_socket", value)

    class BuilderContext(BuilderContextBase["PostStart.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PostStart.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PostStart."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PostStart", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PostStart.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exec: Optional[Exec] = None
    """
    Exec specifies a command to execute in the container.
    """
    http_get: Annotated[Optional[HttpGet], Field(alias="httpGet")] = None
    """
    HTTPGet specifies an HTTP GET request to perform.
    """
    sleep: Optional[Sleep] = None
    """
    Sleep represents a duration that the container should sleep.
    """
    tcp_socket: Annotated[Optional[TcpSocket], Field(alias="tcpSocket")] = None
    """
    Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    for backward compatibility. There is no validation of this field and
    lifecycle hooks will fail at runtime when it is specified.
    """


class PreStop(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PreStop"]:
            return PreStop

        def build(self) -> "PreStop":
            return PreStop(**self._attrs)

        @overload
        def exec(self, value_or_callback: Optional[Exec], /) -> "PreStop.Builder": ...

        @overload
        def exec(
            self, value_or_callback: Callable[[Exec.Builder], Exec.Builder | Exec], /
        ) -> "PreStop.Builder": ...

        @overload
        def exec(self, value_or_callback: Never = ...) -> "Exec.BuilderContext": ...

        def exec(self, value_or_callback=None, /):
            """
            Exec specifies a command to execute in the container.
            """
            if self._in_context and value_or_callback is None:
                context = Exec.BuilderContext()
                context._parent_builder = self
                context._field_name = "exec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exec.builder())
                if isinstance(output, Exec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exec", value)

        @overload
        def http_get(self, value_or_callback: Optional[HttpGet], /) -> "PreStop.Builder": ...

        @overload
        def http_get(
            self,
            value_or_callback: Callable[[HttpGet.Builder], HttpGet.Builder | HttpGet],
            /,
        ) -> "PreStop.Builder": ...

        @overload
        def http_get(self, value_or_callback: Never = ...) -> "HttpGet.BuilderContext": ...

        def http_get(self, value_or_callback=None, /):
            """
            HTTPGet specifies an HTTP GET request to perform.
            """
            if self._in_context and value_or_callback is None:
                context = HttpGet.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_get"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpGet.builder())
                if isinstance(output, HttpGet.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_get", value)

        @overload
        def sleep(self, value_or_callback: Optional[Sleep], /) -> "PreStop.Builder": ...

        @overload
        def sleep(
            self, value_or_callback: Callable[[Sleep.Builder], Sleep.Builder | Sleep], /
        ) -> "PreStop.Builder": ...

        @overload
        def sleep(self, value_or_callback: Never = ...) -> "Sleep.BuilderContext": ...

        def sleep(self, value_or_callback=None, /):
            """
            Sleep represents a duration that the container should sleep.
            """
            if self._in_context and value_or_callback is None:
                context = Sleep.BuilderContext()
                context._parent_builder = self
                context._field_name = "sleep"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sleep.builder())
                if isinstance(output, Sleep.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sleep", value)

        @overload
        def tcp_socket(self, value_or_callback: Optional[TcpSocket], /) -> "PreStop.Builder": ...

        @overload
        def tcp_socket(
            self,
            value_or_callback: Callable[[TcpSocket.Builder], TcpSocket.Builder | TcpSocket],
            /,
        ) -> "PreStop.Builder": ...

        @overload
        def tcp_socket(self, value_or_callback: Never = ...) -> "TcpSocket.BuilderContext": ...

        def tcp_socket(self, value_or_callback=None, /):
            """
            Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
            for backward compatibility. There is no validation of this field and
            lifecycle hooks will fail at runtime when it is specified.
            """
            if self._in_context and value_or_callback is None:
                context = TcpSocket.BuilderContext()
                context._parent_builder = self
                context._field_name = "tcp_socket"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TcpSocket.builder())
                if isinstance(output, TcpSocket.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tcp_socket", value)

    class BuilderContext(BuilderContextBase["PreStop.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PreStop.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PreStop."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PreStop", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PreStop.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exec: Optional[Exec] = None
    """
    Exec specifies a command to execute in the container.
    """
    http_get: Annotated[Optional[HttpGet], Field(alias="httpGet")] = None
    """
    HTTPGet specifies an HTTP GET request to perform.
    """
    sleep: Optional[Sleep] = None
    """
    Sleep represents a duration that the container should sleep.
    """
    tcp_socket: Annotated[Optional[TcpSocket], Field(alias="tcpSocket")] = None
    """
    Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
    for backward compatibility. There is no validation of this field and
    lifecycle hooks will fail at runtime when it is specified.
    """


class Lifecycle(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Lifecycle"]:
            return Lifecycle

        def build(self) -> "Lifecycle":
            return Lifecycle(**self._attrs)

        @overload
        def post_start(self, value_or_callback: Optional[PostStart], /) -> "Lifecycle.Builder": ...

        @overload
        def post_start(
            self,
            value_or_callback: Callable[[PostStart.Builder], PostStart.Builder | PostStart],
            /,
        ) -> "Lifecycle.Builder": ...

        @overload
        def post_start(self, value_or_callback: Never = ...) -> "PostStart.BuilderContext": ...

        def post_start(self, value_or_callback=None, /):
            """
            PostStart is called immediately after a container is created. If the handler fails,
            the container is terminated and restarted according to its restart policy.
            Other management of the container blocks until the hook completes.
            More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
            """
            if self._in_context and value_or_callback is None:
                context = PostStart.BuilderContext()
                context._parent_builder = self
                context._field_name = "post_start"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PostStart.builder())
                if isinstance(output, PostStart.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("post_start", value)

        @overload
        def pre_stop(self, value_or_callback: Optional[PreStop], /) -> "Lifecycle.Builder": ...

        @overload
        def pre_stop(
            self,
            value_or_callback: Callable[[PreStop.Builder], PreStop.Builder | PreStop],
            /,
        ) -> "Lifecycle.Builder": ...

        @overload
        def pre_stop(self, value_or_callback: Never = ...) -> "PreStop.BuilderContext": ...

        def pre_stop(self, value_or_callback=None, /):
            """
            PreStop is called immediately before a container is terminated due to an
            API request or management event such as liveness/startup probe failure,
            preemption, resource contention, etc. The handler is not called if the
            container crashes or exits. The Pod's termination grace period countdown begins before the
            PreStop hook is executed. Regardless of the outcome of the handler, the
            container will eventually terminate within the Pod's termination grace
            period (unless delayed by finalizers). Other management of the container blocks until the hook completes
            or until the termination grace period is reached.
            More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
            """
            if self._in_context and value_or_callback is None:
                context = PreStop.BuilderContext()
                context._parent_builder = self
                context._field_name = "pre_stop"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PreStop.builder())
                if isinstance(output, PreStop.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("pre_stop", value)

    class BuilderContext(BuilderContextBase["Lifecycle.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Lifecycle.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Lifecycle."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Lifecycle", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Lifecycle.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    post_start: Annotated[Optional[PostStart], Field(alias="postStart")] = None
    """
    PostStart is called immediately after a container is created. If the handler fails,
    the container is terminated and restarted according to its restart policy.
    Other management of the container blocks until the hook completes.
    More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
    """
    pre_stop: Annotated[Optional[PreStop], Field(alias="preStop")] = None
    """
    PreStop is called immediately before a container is terminated due to an
    API request or management event such as liveness/startup probe failure,
    preemption, resource contention, etc. The handler is not called if the
    container crashes or exits. The Pod's termination grace period countdown begins before the
    PreStop hook is executed. Regardless of the outcome of the handler, the
    container will eventually terminate within the Pod's termination grace
    period (unless delayed by finalizers). Other management of the container blocks until the hook completes
    or until the termination grace period is reached.
    More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
    """


class Grpc(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Grpc"]:
            return Grpc

        def build(self) -> "Grpc":
            return Grpc(**self._attrs)

        def port(self, value: int, /) -> Self:
            """
            Port number of the gRPC service. Number must be in the range 1 to 65535.
            """
            return self._set("port", value)

        def service(self, value: Optional[str], /) -> Self:
            """
            Service is the name of the service to place in the gRPC HealthCheckRequest
            (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).

            If this is not specified, the default behavior is defined by gRPC.
            """
            return self._set("service", value)

    class BuilderContext(BuilderContextBase["Grpc.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Grpc.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Grpc."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Grpc", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Grpc.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    port: int
    """
    Port number of the gRPC service. Number must be in the range 1 to 65535.
    """
    service: Optional[str] = ""
    """
    Service is the name of the service to place in the gRPC HealthCheckRequest
    (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).

    If this is not specified, the default behavior is defined by gRPC.
    """


class LivenessProbe(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LivenessProbe"]:
            return LivenessProbe

        def build(self) -> "LivenessProbe":
            return LivenessProbe(**self._attrs)

        @overload
        def exec(self, value_or_callback: Optional[Exec], /) -> "LivenessProbe.Builder": ...

        @overload
        def exec(
            self, value_or_callback: Callable[[Exec.Builder], Exec.Builder | Exec], /
        ) -> "LivenessProbe.Builder": ...

        @overload
        def exec(self, value_or_callback: Never = ...) -> "Exec.BuilderContext": ...

        def exec(self, value_or_callback=None, /):
            """
            Exec specifies a command to execute in the container.
            """
            if self._in_context and value_or_callback is None:
                context = Exec.BuilderContext()
                context._parent_builder = self
                context._field_name = "exec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exec.builder())
                if isinstance(output, Exec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exec", value)

        def failure_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive failures for the probe to be considered failed after having succeeded.
            Defaults to 3. Minimum value is 1.
            """
            return self._set("failure_threshold", value)

        @overload
        def grpc(self, value_or_callback: Optional[Grpc], /) -> "LivenessProbe.Builder": ...

        @overload
        def grpc(
            self, value_or_callback: Callable[[Grpc.Builder], Grpc.Builder | Grpc], /
        ) -> "LivenessProbe.Builder": ...

        @overload
        def grpc(self, value_or_callback: Never = ...) -> "Grpc.BuilderContext": ...

        def grpc(self, value_or_callback=None, /):
            """
            GRPC specifies a GRPC HealthCheckRequest.
            """
            if self._in_context and value_or_callback is None:
                context = Grpc.BuilderContext()
                context._parent_builder = self
                context._field_name = "grpc"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Grpc.builder())
                if isinstance(output, Grpc.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("grpc", value)

        @overload
        def http_get(self, value_or_callback: Optional[HttpGet], /) -> "LivenessProbe.Builder": ...

        @overload
        def http_get(
            self,
            value_or_callback: Callable[[HttpGet.Builder], HttpGet.Builder | HttpGet],
            /,
        ) -> "LivenessProbe.Builder": ...

        @overload
        def http_get(self, value_or_callback: Never = ...) -> "HttpGet.BuilderContext": ...

        def http_get(self, value_or_callback=None, /):
            """
            HTTPGet specifies an HTTP GET request to perform.
            """
            if self._in_context and value_or_callback is None:
                context = HttpGet.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_get"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpGet.builder())
                if isinstance(output, HttpGet.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_get", value)

        def initial_delay_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after the container has started before liveness probes are initiated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            return self._set("initial_delay_seconds", value)

        def period_seconds(self, value: Optional[int], /) -> Self:
            """
            How often (in seconds) to perform the probe.
            Default to 10 seconds. Minimum value is 1.
            """
            return self._set("period_seconds", value)

        def success_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive successes for the probe to be considered successful after having failed.
            Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
            """
            return self._set("success_threshold", value)

        @overload
        def tcp_socket(
            self, value_or_callback: Optional[TcpSocket], /
        ) -> "LivenessProbe.Builder": ...

        @overload
        def tcp_socket(
            self,
            value_or_callback: Callable[[TcpSocket.Builder], TcpSocket.Builder | TcpSocket],
            /,
        ) -> "LivenessProbe.Builder": ...

        @overload
        def tcp_socket(self, value_or_callback: Never = ...) -> "TcpSocket.BuilderContext": ...

        def tcp_socket(self, value_or_callback=None, /):
            """
            TCPSocket specifies a connection to a TCP port.
            """
            if self._in_context and value_or_callback is None:
                context = TcpSocket.BuilderContext()
                context._parent_builder = self
                context._field_name = "tcp_socket"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TcpSocket.builder())
                if isinstance(output, TcpSocket.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tcp_socket", value)

        def termination_grace_period_seconds(self, value: Optional[int], /) -> Self:
            """
            Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
            The grace period is the duration in seconds after the processes running in the pod are sent
            a termination signal and the time when the processes are forcibly halted with a kill signal.
            Set this value longer than the expected cleanup time for your process.
            If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
            value overrides the value provided by the pod spec.
            Value must be non-negative integer. The value zero indicates stop immediately via
            the kill signal (no opportunity to shut down).
            This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
            Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
            """
            return self._set("termination_grace_period_seconds", value)

        def timeout_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after which the probe times out.
            Defaults to 1 second. Minimum value is 1.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            return self._set("timeout_seconds", value)

    class BuilderContext(BuilderContextBase["LivenessProbe.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LivenessProbe.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LivenessProbe."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LivenessProbe", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LivenessProbe.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exec: Optional[Exec] = None
    """
    Exec specifies a command to execute in the container.
    """
    failure_threshold: Annotated[Optional[int], Field(alias="failureThreshold")] = None
    """
    Minimum consecutive failures for the probe to be considered failed after having succeeded.
    Defaults to 3. Minimum value is 1.
    """
    grpc: Optional[Grpc] = None
    """
    GRPC specifies a GRPC HealthCheckRequest.
    """
    http_get: Annotated[Optional[HttpGet], Field(alias="httpGet")] = None
    """
    HTTPGet specifies an HTTP GET request to perform.
    """
    initial_delay_seconds: Annotated[Optional[int], Field(alias="initialDelaySeconds")] = None
    """
    Number of seconds after the container has started before liveness probes are initiated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    period_seconds: Annotated[Optional[int], Field(alias="periodSeconds")] = None
    """
    How often (in seconds) to perform the probe.
    Default to 10 seconds. Minimum value is 1.
    """
    success_threshold: Annotated[Optional[int], Field(alias="successThreshold")] = None
    """
    Minimum consecutive successes for the probe to be considered successful after having failed.
    Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    """
    tcp_socket: Annotated[Optional[TcpSocket], Field(alias="tcpSocket")] = None
    """
    TCPSocket specifies a connection to a TCP port.
    """
    termination_grace_period_seconds: Annotated[
        Optional[int], Field(alias="terminationGracePeriodSeconds")
    ] = None
    """
    Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    The grace period is the duration in seconds after the processes running in the pod are sent
    a termination signal and the time when the processes are forcibly halted with a kill signal.
    Set this value longer than the expected cleanup time for your process.
    If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    value overrides the value provided by the pod spec.
    Value must be non-negative integer. The value zero indicates stop immediately via
    the kill signal (no opportunity to shut down).
    This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    """
    timeout_seconds: Annotated[Optional[int], Field(alias="timeoutSeconds")] = None
    """
    Number of seconds after which the probe times out.
    Defaults to 1 second. Minimum value is 1.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """


class Port(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Port"]:
            return Port

        def build(self) -> "Port":
            return Port(**self._attrs)

        def container_port(self, value: int, /) -> Self:
            """
            Number of port to expose on the pod's IP address.
            This must be a valid port number, 0 < x < 65536.
            """
            return self._set("container_port", value)

        def host_ip(self, value: Optional[str], /) -> Self:
            """
            What host IP to bind the external port to.
            """
            return self._set("host_ip", value)

        def host_port(self, value: Optional[int], /) -> Self:
            """
            Number of port to expose on the host.
            If specified, this must be a valid port number, 0 < x < 65536.
            If HostNetwork is specified, this must match ContainerPort.
            Most containers do not need this.
            """
            return self._set("host_port", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
            named port in a pod must have a unique name. Name for the port that can be
            referred to by services.
            """
            return self._set("name", value)

        def protocol(self, value: Optional[str], /) -> Self:
            """
            Protocol for port. Must be UDP, TCP, or SCTP.
            Defaults to "TCP".
            """
            return self._set("protocol", value)

    class BuilderContext(BuilderContextBase["Port.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Port.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Port."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Port", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Port.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    container_port: Annotated[int, Field(alias="containerPort")]
    """
    Number of port to expose on the pod's IP address.
    This must be a valid port number, 0 < x < 65536.
    """
    host_ip: Annotated[Optional[str], Field(alias="hostIP")] = None
    """
    What host IP to bind the external port to.
    """
    host_port: Annotated[Optional[int], Field(alias="hostPort")] = None
    """
    Number of port to expose on the host.
    If specified, this must be a valid port number, 0 < x < 65536.
    If HostNetwork is specified, this must match ContainerPort.
    Most containers do not need this.
    """
    name: Optional[str] = None
    """
    If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
    named port in a pod must have a unique name. Name for the port that can be
    referred to by services.
    """
    protocol: Optional[str] = "TCP"
    """
    Protocol for port. Must be UDP, TCP, or SCTP.
    Defaults to "TCP".
    """


class ReadinessProbe(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ReadinessProbe"]:
            return ReadinessProbe

        def build(self) -> "ReadinessProbe":
            return ReadinessProbe(**self._attrs)

        @overload
        def exec(self, value_or_callback: Optional[Exec], /) -> "ReadinessProbe.Builder": ...

        @overload
        def exec(
            self, value_or_callback: Callable[[Exec.Builder], Exec.Builder | Exec], /
        ) -> "ReadinessProbe.Builder": ...

        @overload
        def exec(self, value_or_callback: Never = ...) -> "Exec.BuilderContext": ...

        def exec(self, value_or_callback=None, /):
            """
            Exec specifies a command to execute in the container.
            """
            if self._in_context and value_or_callback is None:
                context = Exec.BuilderContext()
                context._parent_builder = self
                context._field_name = "exec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exec.builder())
                if isinstance(output, Exec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exec", value)

        def failure_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive failures for the probe to be considered failed after having succeeded.
            Defaults to 3. Minimum value is 1.
            """
            return self._set("failure_threshold", value)

        @overload
        def grpc(self, value_or_callback: Optional[Grpc], /) -> "ReadinessProbe.Builder": ...

        @overload
        def grpc(
            self, value_or_callback: Callable[[Grpc.Builder], Grpc.Builder | Grpc], /
        ) -> "ReadinessProbe.Builder": ...

        @overload
        def grpc(self, value_or_callback: Never = ...) -> "Grpc.BuilderContext": ...

        def grpc(self, value_or_callback=None, /):
            """
            GRPC specifies a GRPC HealthCheckRequest.
            """
            if self._in_context and value_or_callback is None:
                context = Grpc.BuilderContext()
                context._parent_builder = self
                context._field_name = "grpc"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Grpc.builder())
                if isinstance(output, Grpc.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("grpc", value)

        @overload
        def http_get(self, value_or_callback: Optional[HttpGet], /) -> "ReadinessProbe.Builder": ...

        @overload
        def http_get(
            self,
            value_or_callback: Callable[[HttpGet.Builder], HttpGet.Builder | HttpGet],
            /,
        ) -> "ReadinessProbe.Builder": ...

        @overload
        def http_get(self, value_or_callback: Never = ...) -> "HttpGet.BuilderContext": ...

        def http_get(self, value_or_callback=None, /):
            """
            HTTPGet specifies an HTTP GET request to perform.
            """
            if self._in_context and value_or_callback is None:
                context = HttpGet.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_get"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpGet.builder())
                if isinstance(output, HttpGet.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_get", value)

        def initial_delay_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after the container has started before liveness probes are initiated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            return self._set("initial_delay_seconds", value)

        def period_seconds(self, value: Optional[int], /) -> Self:
            """
            How often (in seconds) to perform the probe.
            Default to 10 seconds. Minimum value is 1.
            """
            return self._set("period_seconds", value)

        def success_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive successes for the probe to be considered successful after having failed.
            Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
            """
            return self._set("success_threshold", value)

        @overload
        def tcp_socket(
            self, value_or_callback: Optional[TcpSocket], /
        ) -> "ReadinessProbe.Builder": ...

        @overload
        def tcp_socket(
            self,
            value_or_callback: Callable[[TcpSocket.Builder], TcpSocket.Builder | TcpSocket],
            /,
        ) -> "ReadinessProbe.Builder": ...

        @overload
        def tcp_socket(self, value_or_callback: Never = ...) -> "TcpSocket.BuilderContext": ...

        def tcp_socket(self, value_or_callback=None, /):
            """
            TCPSocket specifies a connection to a TCP port.
            """
            if self._in_context and value_or_callback is None:
                context = TcpSocket.BuilderContext()
                context._parent_builder = self
                context._field_name = "tcp_socket"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TcpSocket.builder())
                if isinstance(output, TcpSocket.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tcp_socket", value)

        def termination_grace_period_seconds(self, value: Optional[int], /) -> Self:
            """
            Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
            The grace period is the duration in seconds after the processes running in the pod are sent
            a termination signal and the time when the processes are forcibly halted with a kill signal.
            Set this value longer than the expected cleanup time for your process.
            If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
            value overrides the value provided by the pod spec.
            Value must be non-negative integer. The value zero indicates stop immediately via
            the kill signal (no opportunity to shut down).
            This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
            Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
            """
            return self._set("termination_grace_period_seconds", value)

        def timeout_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after which the probe times out.
            Defaults to 1 second. Minimum value is 1.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            return self._set("timeout_seconds", value)

    class BuilderContext(BuilderContextBase["ReadinessProbe.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ReadinessProbe.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ReadinessProbe."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ReadinessProbe", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ReadinessProbe.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exec: Optional[Exec] = None
    """
    Exec specifies a command to execute in the container.
    """
    failure_threshold: Annotated[Optional[int], Field(alias="failureThreshold")] = None
    """
    Minimum consecutive failures for the probe to be considered failed after having succeeded.
    Defaults to 3. Minimum value is 1.
    """
    grpc: Optional[Grpc] = None
    """
    GRPC specifies a GRPC HealthCheckRequest.
    """
    http_get: Annotated[Optional[HttpGet], Field(alias="httpGet")] = None
    """
    HTTPGet specifies an HTTP GET request to perform.
    """
    initial_delay_seconds: Annotated[Optional[int], Field(alias="initialDelaySeconds")] = None
    """
    Number of seconds after the container has started before liveness probes are initiated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    period_seconds: Annotated[Optional[int], Field(alias="periodSeconds")] = None
    """
    How often (in seconds) to perform the probe.
    Default to 10 seconds. Minimum value is 1.
    """
    success_threshold: Annotated[Optional[int], Field(alias="successThreshold")] = None
    """
    Minimum consecutive successes for the probe to be considered successful after having failed.
    Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    """
    tcp_socket: Annotated[Optional[TcpSocket], Field(alias="tcpSocket")] = None
    """
    TCPSocket specifies a connection to a TCP port.
    """
    termination_grace_period_seconds: Annotated[
        Optional[int], Field(alias="terminationGracePeriodSeconds")
    ] = None
    """
    Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    The grace period is the duration in seconds after the processes running in the pod are sent
    a termination signal and the time when the processes are forcibly halted with a kill signal.
    Set this value longer than the expected cleanup time for your process.
    If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    value overrides the value provided by the pod spec.
    Value must be non-negative integer. The value zero indicates stop immediately via
    the kill signal (no opportunity to shut down).
    This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    """
    timeout_seconds: Annotated[Optional[int], Field(alias="timeoutSeconds")] = None
    """
    Number of seconds after which the probe times out.
    Defaults to 1 second. Minimum value is 1.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """


class ResizePolicy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResizePolicy"]:
            return ResizePolicy

        def build(self) -> "ResizePolicy":
            return ResizePolicy(**self._attrs)

        def resource_name(self, value: str, /) -> Self:
            """
            Name of the resource to which this resource resize policy applies.
            Supported values: cpu, memory.
            """
            return self._set("resource_name", value)

        def restart_policy(self, value: str, /) -> Self:
            """
            Restart policy to apply when specified resource is resized.
            If not specified, it defaults to NotRequired.
            """
            return self._set("restart_policy", value)

    class BuilderContext(BuilderContextBase["ResizePolicy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResizePolicy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResizePolicy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResizePolicy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResizePolicy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    resource_name: Annotated[str, Field(alias="resourceName")]
    """
    Name of the resource to which this resource resize policy applies.
    Supported values: cpu, memory.
    """
    restart_policy: Annotated[str, Field(alias="restartPolicy")]
    """
    Restart policy to apply when specified resource is resized.
    If not specified, it defaults to NotRequired.
    """


class Claim(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Claim"]:
            return Claim

        def build(self) -> "Claim":
            return Claim(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name must match the name of one entry in pod.spec.resourceClaims of
            the Pod where this field is used. It makes that resource available
            inside a container.
            """
            return self._set("name", value)

        def request(self, value: Optional[str], /) -> Self:
            """
            Request is the name chosen for a request in the referenced claim.
            If empty, everything from the claim is made available, otherwise
            only the result of this request.
            """
            return self._set("request", value)

    class BuilderContext(BuilderContextBase["Claim.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Claim.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Claim."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Claim", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Claim.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name must match the name of one entry in pod.spec.resourceClaims of
    the Pod where this field is used. It makes that resource available
    inside a container.
    """
    request: Optional[str] = None
    """
    Request is the name chosen for a request in the referenced claim.
    If empty, everything from the claim is made available, otherwise
    only the result of this request.
    """


class Limits(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "Limits":
            value = cast(int, self._value)
            return Limits(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["Limits.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Limits.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Limits."""
        return cls.BuilderContext()


class LimitsModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel":
            value = cast(str, self._value)
            return LimitsModel(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel."""
        return cls.BuilderContext()


class Requests(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "Requests":
            value = cast(int, self._value)
            return Requests(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["Requests.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Requests.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Requests."""
        return cls.BuilderContext()


class RequestsModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel":
            value = cast(str, self._value)
            return RequestsModel(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel."""
        return cls.BuilderContext()


class Resources(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Resources"]:
            return Resources

        def build(self) -> "Resources":
            return Resources(**self._attrs)

        @overload
        def claims(self, value_or_callback: List[Claim], /) -> "Resources.Builder": ...

        @overload
        def claims(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Claim, Claim.Builder]],
                GenericListBuilder[Claim, Claim.Builder] | List[Claim],
            ],
            /,
        ) -> "Resources.Builder": ...

        @overload
        def claims(self, value_or_callback: Never = ...) -> ListBuilderContext[Claim.Builder]: ...

        def claims(self, value_or_callback=None, /):
            """
            Claims lists the names of resources, defined in spec.resourceClaims,
            that are used by this container.

            This is an alpha field and requires enabling the
            DynamicResourceAllocation feature gate.

            This field is immutable. It can only be set for containers.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Claim.Builder]()
                context._parent_builder = self
                context._field_name = "claims"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Claim.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("claims", value)

        def limits(self, value: Optional[Dict[str, Union[Limits, LimitsModel]]], /) -> Self:
            """
            Limits describes the maximum amount of compute resources allowed.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            return self._set("limits", value)

        def requests(self, value: Optional[Dict[str, Union[Requests, RequestsModel]]], /) -> Self:
            """
            Requests describes the minimum amount of compute resources required.
            If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
            otherwise to an implementation-defined value. Requests cannot exceed Limits.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            return self._set("requests", value)

    class BuilderContext(BuilderContextBase["Resources.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Resources.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Resources."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Resources", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Resources.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    claims: Optional[List[Claim]] = None
    """
    Claims lists the names of resources, defined in spec.resourceClaims,
    that are used by this container.

    This is an alpha field and requires enabling the
    DynamicResourceAllocation feature gate.

    This field is immutable. It can only be set for containers.
    """
    limits: Optional[Dict[str, Union[Limits, LimitsModel]]] = None
    """
    Limits describes the maximum amount of compute resources allowed.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """
    requests: Optional[Dict[str, Union[Requests, RequestsModel]]] = None
    """
    Requests describes the minimum amount of compute resources required.
    If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    otherwise to an implementation-defined value. Requests cannot exceed Limits.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """


class AppArmorProfile(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AppArmorProfile"]:
            return AppArmorProfile

        def build(self) -> "AppArmorProfile":
            return AppArmorProfile(**self._attrs)

        def localhost_profile(self, value: Optional[str], /) -> Self:
            """
            localhostProfile indicates a profile loaded on the node that should be used.
            The profile must be preconfigured on the node to work.
            Must match the loaded name of the profile.
            Must be set if and only if type is "Localhost".
            """
            return self._set("localhost_profile", value)

        def type(self, value: str, /) -> Self:
            """
            type indicates which kind of AppArmor profile will be applied.
            Valid options are:
              Localhost - a profile pre-loaded on the node.
              RuntimeDefault - the container runtime's default profile.
              Unconfined - no AppArmor enforcement.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["AppArmorProfile.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AppArmorProfile.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AppArmorProfile."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AppArmorProfile", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AppArmorProfile.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    localhost_profile: Annotated[Optional[str], Field(alias="localhostProfile")] = None
    """
    localhostProfile indicates a profile loaded on the node that should be used.
    The profile must be preconfigured on the node to work.
    Must match the loaded name of the profile.
    Must be set if and only if type is "Localhost".
    """
    type: str
    """
    type indicates which kind of AppArmor profile will be applied.
    Valid options are:
      Localhost - a profile pre-loaded on the node.
      RuntimeDefault - the container runtime's default profile.
      Unconfined - no AppArmor enforcement.
    """


class Capabilities(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Capabilities"]:
            return Capabilities

        def build(self) -> "Capabilities":
            return Capabilities(**self._attrs)

        def add(self, value: Optional[List[str]], /) -> Self:
            """
            Added capabilities
            """
            return self._set("add", value)

        def drop(self, value: Optional[List[str]], /) -> Self:
            """
            Removed capabilities
            """
            return self._set("drop", value)

    class BuilderContext(BuilderContextBase["Capabilities.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Capabilities.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Capabilities."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Capabilities", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Capabilities.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    add: Optional[List[str]] = None
    """
    Added capabilities
    """
    drop: Optional[List[str]] = None
    """
    Removed capabilities
    """


class SeLinuxOptions(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SeLinuxOptions"]:
            return SeLinuxOptions

        def build(self) -> "SeLinuxOptions":
            return SeLinuxOptions(**self._attrs)

        def level(self, value: Optional[str], /) -> Self:
            """
            Level is SELinux level label that applies to the container.
            """
            return self._set("level", value)

        def role(self, value: Optional[str], /) -> Self:
            """
            Role is a SELinux role label that applies to the container.
            """
            return self._set("role", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Type is a SELinux type label that applies to the container.
            """
            return self._set("type", value)

        def user(self, value: Optional[str], /) -> Self:
            """
            User is a SELinux user label that applies to the container.
            """
            return self._set("user", value)

    class BuilderContext(BuilderContextBase["SeLinuxOptions.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SeLinuxOptions.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SeLinuxOptions."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SeLinuxOptions", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SeLinuxOptions.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    level: Optional[str] = None
    """
    Level is SELinux level label that applies to the container.
    """
    role: Optional[str] = None
    """
    Role is a SELinux role label that applies to the container.
    """
    type: Optional[str] = None
    """
    Type is a SELinux type label that applies to the container.
    """
    user: Optional[str] = None
    """
    User is a SELinux user label that applies to the container.
    """


class SeccompProfile(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SeccompProfile"]:
            return SeccompProfile

        def build(self) -> "SeccompProfile":
            return SeccompProfile(**self._attrs)

        def localhost_profile(self, value: Optional[str], /) -> Self:
            """
            localhostProfile indicates a profile defined in a file on the node should be used.
            The profile must be preconfigured on the node to work.
            Must be a descending path, relative to the kubelet's configured seccomp profile location.
            Must be set if type is "Localhost". Must NOT be set for any other type.
            """
            return self._set("localhost_profile", value)

        def type(self, value: str, /) -> Self:
            """
            type indicates which kind of seccomp profile will be applied.
            Valid options are:

            Localhost - a profile defined in a file on the node should be used.
            RuntimeDefault - the container runtime default profile should be used.
            Unconfined - no profile should be applied.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["SeccompProfile.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SeccompProfile.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SeccompProfile."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SeccompProfile", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SeccompProfile.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    localhost_profile: Annotated[Optional[str], Field(alias="localhostProfile")] = None
    """
    localhostProfile indicates a profile defined in a file on the node should be used.
    The profile must be preconfigured on the node to work.
    Must be a descending path, relative to the kubelet's configured seccomp profile location.
    Must be set if type is "Localhost". Must NOT be set for any other type.
    """
    type: str
    """
    type indicates which kind of seccomp profile will be applied.
    Valid options are:

    Localhost - a profile defined in a file on the node should be used.
    RuntimeDefault - the container runtime default profile should be used.
    Unconfined - no profile should be applied.
    """


class WindowsOptions(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WindowsOptions"]:
            return WindowsOptions

        def build(self) -> "WindowsOptions":
            return WindowsOptions(**self._attrs)

        def gmsa_credential_spec(self, value: Optional[str], /) -> Self:
            """
            GMSACredentialSpec is where the GMSA admission webhook
            (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
            GMSA credential spec named by the GMSACredentialSpecName field.
            """
            return self._set("gmsa_credential_spec", value)

        def gmsa_credential_spec_name(self, value: Optional[str], /) -> Self:
            """
            GMSACredentialSpecName is the name of the GMSA credential spec to use.
            """
            return self._set("gmsa_credential_spec_name", value)

        def host_process(self, value: Optional[bool], /) -> Self:
            """
            HostProcess determines if a container should be run as a 'Host Process' container.
            All of a Pod's containers must have the same effective HostProcess value
            (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
            In addition, if HostProcess is true then HostNetwork must also be set to true.
            """
            return self._set("host_process", value)

        def run_as_user_name(self, value: Optional[str], /) -> Self:
            """
            The UserName in Windows to run the entrypoint of the container process.
            Defaults to the user specified in image metadata if unspecified.
            May also be set in PodSecurityContext. If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            """
            return self._set("run_as_user_name", value)

    class BuilderContext(BuilderContextBase["WindowsOptions.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WindowsOptions.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WindowsOptions."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WindowsOptions", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WindowsOptions.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    gmsa_credential_spec: Annotated[Optional[str], Field(alias="gmsaCredentialSpec")] = None
    """
    GMSACredentialSpec is where the GMSA admission webhook
    (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
    GMSA credential spec named by the GMSACredentialSpecName field.
    """
    gmsa_credential_spec_name: Annotated[Optional[str], Field(alias="gmsaCredentialSpecName")] = (
        None
    )
    """
    GMSACredentialSpecName is the name of the GMSA credential spec to use.
    """
    host_process: Annotated[Optional[bool], Field(alias="hostProcess")] = None
    """
    HostProcess determines if a container should be run as a 'Host Process' container.
    All of a Pod's containers must have the same effective HostProcess value
    (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
    In addition, if HostProcess is true then HostNetwork must also be set to true.
    """
    run_as_user_name: Annotated[Optional[str], Field(alias="runAsUserName")] = None
    """
    The UserName in Windows to run the entrypoint of the container process.
    Defaults to the user specified in image metadata if unspecified.
    May also be set in PodSecurityContext. If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    """


class SecurityContext(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecurityContext"]:
            return SecurityContext

        def build(self) -> "SecurityContext":
            return SecurityContext(**self._attrs)

        def allow_privilege_escalation(self, value: Optional[bool], /) -> Self:
            """
            AllowPrivilegeEscalation controls whether a process can gain more
            privileges than its parent process. This bool directly controls if
            the no_new_privs flag will be set on the container process.
            AllowPrivilegeEscalation is true always when the container is:
            1) run as Privileged
            2) has CAP_SYS_ADMIN
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("allow_privilege_escalation", value)

        @overload
        def app_armor_profile(
            self, value_or_callback: Optional[AppArmorProfile], /
        ) -> "SecurityContext.Builder": ...

        @overload
        def app_armor_profile(
            self,
            value_or_callback: Callable[
                [AppArmorProfile.Builder], AppArmorProfile.Builder | AppArmorProfile
            ],
            /,
        ) -> "SecurityContext.Builder": ...

        @overload
        def app_armor_profile(
            self, value_or_callback: Never = ...
        ) -> "AppArmorProfile.BuilderContext": ...

        def app_armor_profile(self, value_or_callback=None, /):
            """
            appArmorProfile is the AppArmor options to use by this container. If set, this profile
            overrides the pod's appArmorProfile.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = AppArmorProfile.BuilderContext()
                context._parent_builder = self
                context._field_name = "app_armor_profile"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AppArmorProfile.builder())
                if isinstance(output, AppArmorProfile.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("app_armor_profile", value)

        @overload
        def capabilities(
            self, value_or_callback: Optional[Capabilities], /
        ) -> "SecurityContext.Builder": ...

        @overload
        def capabilities(
            self,
            value_or_callback: Callable[
                [Capabilities.Builder], Capabilities.Builder | Capabilities
            ],
            /,
        ) -> "SecurityContext.Builder": ...

        @overload
        def capabilities(self, value_or_callback: Never = ...) -> "Capabilities.BuilderContext": ...

        def capabilities(self, value_or_callback=None, /):
            """
            The capabilities to add/drop when running containers.
            Defaults to the default set of capabilities granted by the container runtime.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = Capabilities.BuilderContext()
                context._parent_builder = self
                context._field_name = "capabilities"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Capabilities.builder())
                if isinstance(output, Capabilities.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("capabilities", value)

        def privileged(self, value: Optional[bool], /) -> Self:
            """
            Run container in privileged mode.
            Processes in privileged containers are essentially equivalent to root on the host.
            Defaults to false.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("privileged", value)

        def proc_mount(self, value: Optional[str], /) -> Self:
            """
            procMount denotes the type of proc mount to use for the containers.
            The default value is Default which uses the container runtime defaults for
            readonly paths and masked paths.
            This requires the ProcMountType feature flag to be enabled.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("proc_mount", value)

        def read_only_root_filesystem(self, value: Optional[bool], /) -> Self:
            """
            Whether this container has a read-only root filesystem.
            Default is false.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("read_only_root_filesystem", value)

        def run_as_group(self, value: Optional[int], /) -> Self:
            """
            The GID to run the entrypoint of the container process.
            Uses runtime default if unset.
            May also be set in PodSecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("run_as_group", value)

        def run_as_non_root(self, value: Optional[bool], /) -> Self:
            """
            Indicates that the container must run as a non-root user.
            If true, the Kubelet will validate the image at runtime to ensure that it
            does not run as UID 0 (root) and fail to start the container if it does.
            If unset or false, no such validation will be performed.
            May also be set in PodSecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            """
            return self._set("run_as_non_root", value)

        def run_as_user(self, value: Optional[int], /) -> Self:
            """
            The UID to run the entrypoint of the container process.
            Defaults to user specified in image metadata if unspecified.
            May also be set in PodSecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("run_as_user", value)

        @overload
        def se_linux_options(
            self, value_or_callback: Optional[SeLinuxOptions], /
        ) -> "SecurityContext.Builder": ...

        @overload
        def se_linux_options(
            self,
            value_or_callback: Callable[
                [SeLinuxOptions.Builder], SeLinuxOptions.Builder | SeLinuxOptions
            ],
            /,
        ) -> "SecurityContext.Builder": ...

        @overload
        def se_linux_options(
            self, value_or_callback: Never = ...
        ) -> "SeLinuxOptions.BuilderContext": ...

        def se_linux_options(self, value_or_callback=None, /):
            """
            The SELinux context to be applied to the container.
            If unspecified, the container runtime will allocate a random SELinux context for each
            container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = SeLinuxOptions.BuilderContext()
                context._parent_builder = self
                context._field_name = "se_linux_options"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SeLinuxOptions.builder())
                if isinstance(output, SeLinuxOptions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("se_linux_options", value)

        @overload
        def seccomp_profile(
            self, value_or_callback: Optional[SeccompProfile], /
        ) -> "SecurityContext.Builder": ...

        @overload
        def seccomp_profile(
            self,
            value_or_callback: Callable[
                [SeccompProfile.Builder], SeccompProfile.Builder | SeccompProfile
            ],
            /,
        ) -> "SecurityContext.Builder": ...

        @overload
        def seccomp_profile(
            self, value_or_callback: Never = ...
        ) -> "SeccompProfile.BuilderContext": ...

        def seccomp_profile(self, value_or_callback=None, /):
            """
            The seccomp options to use by this container. If seccomp options are
            provided at both the pod & container level, the container options
            override the pod options.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = SeccompProfile.BuilderContext()
                context._parent_builder = self
                context._field_name = "seccomp_profile"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SeccompProfile.builder())
                if isinstance(output, SeccompProfile.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("seccomp_profile", value)

        @overload
        def windows_options(
            self, value_or_callback: Optional[WindowsOptions], /
        ) -> "SecurityContext.Builder": ...

        @overload
        def windows_options(
            self,
            value_or_callback: Callable[
                [WindowsOptions.Builder], WindowsOptions.Builder | WindowsOptions
            ],
            /,
        ) -> "SecurityContext.Builder": ...

        @overload
        def windows_options(
            self, value_or_callback: Never = ...
        ) -> "WindowsOptions.BuilderContext": ...

        def windows_options(self, value_or_callback=None, /):
            """
            The Windows specific settings applied to all containers.
            If unspecified, the options from the PodSecurityContext will be used.
            If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
            Note that this field cannot be set when spec.os.name is linux.
            """
            if self._in_context and value_or_callback is None:
                context = WindowsOptions.BuilderContext()
                context._parent_builder = self
                context._field_name = "windows_options"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WindowsOptions.builder())
                if isinstance(output, WindowsOptions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("windows_options", value)

    class BuilderContext(BuilderContextBase["SecurityContext.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecurityContext.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecurityContext."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecurityContext", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecurityContext.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    allow_privilege_escalation: Annotated[
        Optional[bool], Field(alias="allowPrivilegeEscalation")
    ] = None
    """
    AllowPrivilegeEscalation controls whether a process can gain more
    privileges than its parent process. This bool directly controls if
    the no_new_privs flag will be set on the container process.
    AllowPrivilegeEscalation is true always when the container is:
    1) run as Privileged
    2) has CAP_SYS_ADMIN
    Note that this field cannot be set when spec.os.name is windows.
    """
    app_armor_profile: Annotated[Optional[AppArmorProfile], Field(alias="appArmorProfile")] = None
    """
    appArmorProfile is the AppArmor options to use by this container. If set, this profile
    overrides the pod's appArmorProfile.
    Note that this field cannot be set when spec.os.name is windows.
    """
    capabilities: Optional[Capabilities] = None
    """
    The capabilities to add/drop when running containers.
    Defaults to the default set of capabilities granted by the container runtime.
    Note that this field cannot be set when spec.os.name is windows.
    """
    privileged: Optional[bool] = None
    """
    Run container in privileged mode.
    Processes in privileged containers are essentially equivalent to root on the host.
    Defaults to false.
    Note that this field cannot be set when spec.os.name is windows.
    """
    proc_mount: Annotated[Optional[str], Field(alias="procMount")] = None
    """
    procMount denotes the type of proc mount to use for the containers.
    The default value is Default which uses the container runtime defaults for
    readonly paths and masked paths.
    This requires the ProcMountType feature flag to be enabled.
    Note that this field cannot be set when spec.os.name is windows.
    """
    read_only_root_filesystem: Annotated[Optional[bool], Field(alias="readOnlyRootFilesystem")] = (
        None
    )
    """
    Whether this container has a read-only root filesystem.
    Default is false.
    Note that this field cannot be set when spec.os.name is windows.
    """
    run_as_group: Annotated[Optional[int], Field(alias="runAsGroup")] = None
    """
    The GID to run the entrypoint of the container process.
    Uses runtime default if unset.
    May also be set in PodSecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    Note that this field cannot be set when spec.os.name is windows.
    """
    run_as_non_root: Annotated[Optional[bool], Field(alias="runAsNonRoot")] = None
    """
    Indicates that the container must run as a non-root user.
    If true, the Kubelet will validate the image at runtime to ensure that it
    does not run as UID 0 (root) and fail to start the container if it does.
    If unset or false, no such validation will be performed.
    May also be set in PodSecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    """
    run_as_user: Annotated[Optional[int], Field(alias="runAsUser")] = None
    """
    The UID to run the entrypoint of the container process.
    Defaults to user specified in image metadata if unspecified.
    May also be set in PodSecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    Note that this field cannot be set when spec.os.name is windows.
    """
    se_linux_options: Annotated[Optional[SeLinuxOptions], Field(alias="seLinuxOptions")] = None
    """
    The SELinux context to be applied to the container.
    If unspecified, the container runtime will allocate a random SELinux context for each
    container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    Note that this field cannot be set when spec.os.name is windows.
    """
    seccomp_profile: Annotated[Optional[SeccompProfile], Field(alias="seccompProfile")] = None
    """
    The seccomp options to use by this container. If seccomp options are
    provided at both the pod & container level, the container options
    override the pod options.
    Note that this field cannot be set when spec.os.name is windows.
    """
    windows_options: Annotated[Optional[WindowsOptions], Field(alias="windowsOptions")] = None
    """
    The Windows specific settings applied to all containers.
    If unspecified, the options from the PodSecurityContext will be used.
    If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
    Note that this field cannot be set when spec.os.name is linux.
    """


class StartupProbe(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StartupProbe"]:
            return StartupProbe

        def build(self) -> "StartupProbe":
            return StartupProbe(**self._attrs)

        @overload
        def exec(self, value_or_callback: Optional[Exec], /) -> "StartupProbe.Builder": ...

        @overload
        def exec(
            self, value_or_callback: Callable[[Exec.Builder], Exec.Builder | Exec], /
        ) -> "StartupProbe.Builder": ...

        @overload
        def exec(self, value_or_callback: Never = ...) -> "Exec.BuilderContext": ...

        def exec(self, value_or_callback=None, /):
            """
            Exec specifies a command to execute in the container.
            """
            if self._in_context and value_or_callback is None:
                context = Exec.BuilderContext()
                context._parent_builder = self
                context._field_name = "exec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exec.builder())
                if isinstance(output, Exec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exec", value)

        def failure_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive failures for the probe to be considered failed after having succeeded.
            Defaults to 3. Minimum value is 1.
            """
            return self._set("failure_threshold", value)

        @overload
        def grpc(self, value_or_callback: Optional[Grpc], /) -> "StartupProbe.Builder": ...

        @overload
        def grpc(
            self, value_or_callback: Callable[[Grpc.Builder], Grpc.Builder | Grpc], /
        ) -> "StartupProbe.Builder": ...

        @overload
        def grpc(self, value_or_callback: Never = ...) -> "Grpc.BuilderContext": ...

        def grpc(self, value_or_callback=None, /):
            """
            GRPC specifies a GRPC HealthCheckRequest.
            """
            if self._in_context and value_or_callback is None:
                context = Grpc.BuilderContext()
                context._parent_builder = self
                context._field_name = "grpc"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Grpc.builder())
                if isinstance(output, Grpc.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("grpc", value)

        @overload
        def http_get(self, value_or_callback: Optional[HttpGet], /) -> "StartupProbe.Builder": ...

        @overload
        def http_get(
            self,
            value_or_callback: Callable[[HttpGet.Builder], HttpGet.Builder | HttpGet],
            /,
        ) -> "StartupProbe.Builder": ...

        @overload
        def http_get(self, value_or_callback: Never = ...) -> "HttpGet.BuilderContext": ...

        def http_get(self, value_or_callback=None, /):
            """
            HTTPGet specifies an HTTP GET request to perform.
            """
            if self._in_context and value_or_callback is None:
                context = HttpGet.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_get"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpGet.builder())
                if isinstance(output, HttpGet.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_get", value)

        def initial_delay_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after the container has started before liveness probes are initiated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            return self._set("initial_delay_seconds", value)

        def period_seconds(self, value: Optional[int], /) -> Self:
            """
            How often (in seconds) to perform the probe.
            Default to 10 seconds. Minimum value is 1.
            """
            return self._set("period_seconds", value)

        def success_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive successes for the probe to be considered successful after having failed.
            Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
            """
            return self._set("success_threshold", value)

        @overload
        def tcp_socket(
            self, value_or_callback: Optional[TcpSocket], /
        ) -> "StartupProbe.Builder": ...

        @overload
        def tcp_socket(
            self,
            value_or_callback: Callable[[TcpSocket.Builder], TcpSocket.Builder | TcpSocket],
            /,
        ) -> "StartupProbe.Builder": ...

        @overload
        def tcp_socket(self, value_or_callback: Never = ...) -> "TcpSocket.BuilderContext": ...

        def tcp_socket(self, value_or_callback=None, /):
            """
            TCPSocket specifies a connection to a TCP port.
            """
            if self._in_context and value_or_callback is None:
                context = TcpSocket.BuilderContext()
                context._parent_builder = self
                context._field_name = "tcp_socket"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TcpSocket.builder())
                if isinstance(output, TcpSocket.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tcp_socket", value)

        def termination_grace_period_seconds(self, value: Optional[int], /) -> Self:
            """
            Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
            The grace period is the duration in seconds after the processes running in the pod are sent
            a termination signal and the time when the processes are forcibly halted with a kill signal.
            Set this value longer than the expected cleanup time for your process.
            If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
            value overrides the value provided by the pod spec.
            Value must be non-negative integer. The value zero indicates stop immediately via
            the kill signal (no opportunity to shut down).
            This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
            Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
            """
            return self._set("termination_grace_period_seconds", value)

        def timeout_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after which the probe times out.
            Defaults to 1 second. Minimum value is 1.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            return self._set("timeout_seconds", value)

    class BuilderContext(BuilderContextBase["StartupProbe.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StartupProbe.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StartupProbe."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StartupProbe", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StartupProbe.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exec: Optional[Exec] = None
    """
    Exec specifies a command to execute in the container.
    """
    failure_threshold: Annotated[Optional[int], Field(alias="failureThreshold")] = None
    """
    Minimum consecutive failures for the probe to be considered failed after having succeeded.
    Defaults to 3. Minimum value is 1.
    """
    grpc: Optional[Grpc] = None
    """
    GRPC specifies a GRPC HealthCheckRequest.
    """
    http_get: Annotated[Optional[HttpGet], Field(alias="httpGet")] = None
    """
    HTTPGet specifies an HTTP GET request to perform.
    """
    initial_delay_seconds: Annotated[Optional[int], Field(alias="initialDelaySeconds")] = None
    """
    Number of seconds after the container has started before liveness probes are initiated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    period_seconds: Annotated[Optional[int], Field(alias="periodSeconds")] = None
    """
    How often (in seconds) to perform the probe.
    Default to 10 seconds. Minimum value is 1.
    """
    success_threshold: Annotated[Optional[int], Field(alias="successThreshold")] = None
    """
    Minimum consecutive successes for the probe to be considered successful after having failed.
    Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    """
    tcp_socket: Annotated[Optional[TcpSocket], Field(alias="tcpSocket")] = None
    """
    TCPSocket specifies a connection to a TCP port.
    """
    termination_grace_period_seconds: Annotated[
        Optional[int], Field(alias="terminationGracePeriodSeconds")
    ] = None
    """
    Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    The grace period is the duration in seconds after the processes running in the pod are sent
    a termination signal and the time when the processes are forcibly halted with a kill signal.
    Set this value longer than the expected cleanup time for your process.
    If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    value overrides the value provided by the pod spec.
    Value must be non-negative integer. The value zero indicates stop immediately via
    the kill signal (no opportunity to shut down).
    This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    """
    timeout_seconds: Annotated[Optional[int], Field(alias="timeoutSeconds")] = None
    """
    Number of seconds after which the probe times out.
    Defaults to 1 second. Minimum value is 1.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """


class VolumeDevice(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VolumeDevice"]:
            return VolumeDevice

        def build(self) -> "VolumeDevice":
            return VolumeDevice(**self._attrs)

        def device_path(self, value: str, /) -> Self:
            """
            devicePath is the path inside of the container that the device will be mapped to.
            """
            return self._set("device_path", value)

        def name(self, value: str, /) -> Self:
            """
            name must match the name of a persistentVolumeClaim in the pod
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["VolumeDevice.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VolumeDevice.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VolumeDevice."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VolumeDevice", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VolumeDevice.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    device_path: Annotated[str, Field(alias="devicePath")]
    """
    devicePath is the path inside of the container that the device will be mapped to.
    """
    name: str
    """
    name must match the name of a persistentVolumeClaim in the pod
    """


class VolumeMount(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VolumeMount"]:
            return VolumeMount

        def build(self) -> "VolumeMount":
            return VolumeMount(**self._attrs)

        def mount_path(self, value: str, /) -> Self:
            """
            Path within the container at which the volume should be mounted.  Must
            not contain ':'.
            """
            return self._set("mount_path", value)

        def mount_propagation(self, value: Optional[str], /) -> Self:
            """
            mountPropagation determines how mounts are propagated from the host
            to container and the other way around.
            When not set, MountPropagationNone is used.
            This field is beta in 1.10.
            When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
            (which defaults to None).
            """
            return self._set("mount_propagation", value)

        def name(self, value: str, /) -> Self:
            """
            This must match the Name of a Volume.
            """
            return self._set("name", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            Mounted read-only if true, read-write otherwise (false or unspecified).
            Defaults to false.
            """
            return self._set("read_only", value)

        def recursive_read_only(self, value: Optional[str], /) -> Self:
            """
            RecursiveReadOnly specifies whether read-only mounts should be handled
            recursively.

            If ReadOnly is false, this field has no meaning and must be unspecified.

            If ReadOnly is true, and this field is set to Disabled, the mount is not made
            recursively read-only.  If this field is set to IfPossible, the mount is made
            recursively read-only, if it is supported by the container runtime.  If this
            field is set to Enabled, the mount is made recursively read-only if it is
            supported by the container runtime, otherwise the pod will not be started and
            an error will be generated to indicate the reason.

            If this field is set to IfPossible or Enabled, MountPropagation must be set to
            None (or be unspecified, which defaults to None).

            If this field is not specified, it is treated as an equivalent of Disabled.
            """
            return self._set("recursive_read_only", value)

        def sub_path(self, value: Optional[str], /) -> Self:
            """
            Path within the volume from which the container's volume should be mounted.
            Defaults to "" (volume's root).
            """
            return self._set("sub_path", value)

        def sub_path_expr(self, value: Optional[str], /) -> Self:
            """
            Expanded path within the volume from which the container's volume should be mounted.
            Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
            Defaults to "" (volume's root).
            SubPathExpr and SubPath are mutually exclusive.
            """
            return self._set("sub_path_expr", value)

    class BuilderContext(BuilderContextBase["VolumeMount.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VolumeMount.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VolumeMount."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VolumeMount", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VolumeMount.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    mount_path: Annotated[str, Field(alias="mountPath")]
    """
    Path within the container at which the volume should be mounted.  Must
    not contain ':'.
    """
    mount_propagation: Annotated[Optional[str], Field(alias="mountPropagation")] = None
    """
    mountPropagation determines how mounts are propagated from the host
    to container and the other way around.
    When not set, MountPropagationNone is used.
    This field is beta in 1.10.
    When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
    (which defaults to None).
    """
    name: str
    """
    This must match the Name of a Volume.
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    Mounted read-only if true, read-write otherwise (false or unspecified).
    Defaults to false.
    """
    recursive_read_only: Annotated[Optional[str], Field(alias="recursiveReadOnly")] = None
    """
    RecursiveReadOnly specifies whether read-only mounts should be handled
    recursively.

    If ReadOnly is false, this field has no meaning and must be unspecified.

    If ReadOnly is true, and this field is set to Disabled, the mount is not made
    recursively read-only.  If this field is set to IfPossible, the mount is made
    recursively read-only, if it is supported by the container runtime.  If this
    field is set to Enabled, the mount is made recursively read-only if it is
    supported by the container runtime, otherwise the pod will not be started and
    an error will be generated to indicate the reason.

    If this field is set to IfPossible or Enabled, MountPropagation must be set to
    None (or be unspecified, which defaults to None).

    If this field is not specified, it is treated as an equivalent of Disabled.
    """
    sub_path: Annotated[Optional[str], Field(alias="subPath")] = None
    """
    Path within the volume from which the container's volume should be mounted.
    Defaults to "" (volume's root).
    """
    sub_path_expr: Annotated[Optional[str], Field(alias="subPathExpr")] = None
    """
    Expanded path within the volume from which the container's volume should be mounted.
    Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    Defaults to "" (volume's root).
    SubPathExpr and SubPath are mutually exclusive.
    """


class Container(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Container"]:
            return Container

        def build(self) -> "Container":
            return Container(**self._attrs)

        def args(self, value: Optional[List[str]], /) -> Self:
            """
            Arguments to the entrypoint.
            The container image's CMD is used if this is not provided.
            Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
            cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
            to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
            produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
            of whether the variable exists or not. Cannot be updated.
            More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
            """
            return self._set("args", value)

        def command(self, value: Optional[List[str]], /) -> Self:
            """
            Entrypoint array. Not executed within a shell.
            The container image's ENTRYPOINT is used if this is not provided.
            Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
            cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
            to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
            produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
            of whether the variable exists or not. Cannot be updated.
            More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
            """
            return self._set("command", value)

        @overload
        def env(self, value_or_callback: List[Env], /) -> "Container.Builder": ...

        @overload
        def env(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Env, Env.Builder]],
                GenericListBuilder[Env, Env.Builder] | List[Env],
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def env(self, value_or_callback: Never = ...) -> ListBuilderContext[Env.Builder]: ...

        def env(self, value_or_callback=None, /):
            """
            List of environment variables to set in the container.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Env.Builder]()
                context._parent_builder = self
                context._field_name = "env"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Env.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("env", value)

        @overload
        def env_from(self, value_or_callback: List[EnvFrom], /) -> "Container.Builder": ...

        @overload
        def env_from(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[EnvFrom, EnvFrom.Builder]],
                GenericListBuilder[EnvFrom, EnvFrom.Builder] | List[EnvFrom],
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def env_from(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[EnvFrom.Builder]: ...

        def env_from(self, value_or_callback=None, /):
            """
            List of sources to populate environment variables in the container.
            The keys defined within a source must be a C_IDENTIFIER. All invalid keys
            will be reported as an event when the container is starting. When a key exists in multiple
            sources, the value associated with the last source will take precedence.
            Values defined by an Env with a duplicate key will take precedence.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[EnvFrom.Builder]()
                context._parent_builder = self
                context._field_name = "env_from"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(EnvFrom.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("env_from", value)

        def image(self, value: Optional[str], /) -> Self:
            """
            Container image name.
            More info: https://kubernetes.io/docs/concepts/containers/images
            This field is optional to allow higher level config management to default or override
            container images in workload controllers like Deployments and StatefulSets.
            """
            return self._set("image", value)

        def image_pull_policy(self, value: Optional[str], /) -> Self:
            """
            Image pull policy.
            One of Always, Never, IfNotPresent.
            Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
            Cannot be updated.
            More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
            """
            return self._set("image_pull_policy", value)

        @overload
        def lifecycle(self, value_or_callback: Optional[Lifecycle], /) -> "Container.Builder": ...

        @overload
        def lifecycle(
            self,
            value_or_callback: Callable[[Lifecycle.Builder], Lifecycle.Builder | Lifecycle],
            /,
        ) -> "Container.Builder": ...

        @overload
        def lifecycle(self, value_or_callback: Never = ...) -> "Lifecycle.BuilderContext": ...

        def lifecycle(self, value_or_callback=None, /):
            """
            Actions that the management system should take in response to container lifecycle events.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = Lifecycle.BuilderContext()
                context._parent_builder = self
                context._field_name = "lifecycle"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Lifecycle.builder())
                if isinstance(output, Lifecycle.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("lifecycle", value)

        @overload
        def liveness_probe(
            self, value_or_callback: Optional[LivenessProbe], /
        ) -> "Container.Builder": ...

        @overload
        def liveness_probe(
            self,
            value_or_callback: Callable[
                [LivenessProbe.Builder], LivenessProbe.Builder | LivenessProbe
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def liveness_probe(
            self, value_or_callback: Never = ...
        ) -> "LivenessProbe.BuilderContext": ...

        def liveness_probe(self, value_or_callback=None, /):
            """
            Periodic probe of container liveness.
            Container will be restarted if the probe fails.
            Cannot be updated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            if self._in_context and value_or_callback is None:
                context = LivenessProbe.BuilderContext()
                context._parent_builder = self
                context._field_name = "liveness_probe"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LivenessProbe.builder())
                if isinstance(output, LivenessProbe.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("liveness_probe", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the container specified as a DNS_LABEL.
            Each container in a pod must have a unique name (DNS_LABEL).
            Cannot be updated.
            """
            return self._set("name", value)

        @overload
        def ports(self, value_or_callback: List[Port], /) -> "Container.Builder": ...

        @overload
        def ports(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Port, Port.Builder]],
                GenericListBuilder[Port, Port.Builder] | List[Port],
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def ports(self, value_or_callback: Never = ...) -> ListBuilderContext[Port.Builder]: ...

        def ports(self, value_or_callback=None, /):
            """
            List of ports to expose from the container. Not specifying a port here
            DOES NOT prevent that port from being exposed. Any port which is
            listening on the default "0.0.0.0" address inside a container will be
            accessible from the network.
            Modifying this array with strategic merge patch may corrupt the data.
            For more information See https://github.com/kubernetes/kubernetes/issues/108255.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Port.Builder]()
                context._parent_builder = self
                context._field_name = "ports"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Port.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("ports", value)

        @overload
        def readiness_probe(
            self, value_or_callback: Optional[ReadinessProbe], /
        ) -> "Container.Builder": ...

        @overload
        def readiness_probe(
            self,
            value_or_callback: Callable[
                [ReadinessProbe.Builder], ReadinessProbe.Builder | ReadinessProbe
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def readiness_probe(
            self, value_or_callback: Never = ...
        ) -> "ReadinessProbe.BuilderContext": ...

        def readiness_probe(self, value_or_callback=None, /):
            """
            Periodic probe of container service readiness.
            Container will be removed from service endpoints if the probe fails.
            Cannot be updated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            if self._in_context and value_or_callback is None:
                context = ReadinessProbe.BuilderContext()
                context._parent_builder = self
                context._field_name = "readiness_probe"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ReadinessProbe.builder())
                if isinstance(output, ReadinessProbe.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("readiness_probe", value)

        @overload
        def resize_policy(
            self, value_or_callback: List[ResizePolicy], /
        ) -> "Container.Builder": ...

        @overload
        def resize_policy(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ResizePolicy, ResizePolicy.Builder]],
                GenericListBuilder[ResizePolicy, ResizePolicy.Builder] | List[ResizePolicy],
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def resize_policy(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ResizePolicy.Builder]: ...

        def resize_policy(self, value_or_callback=None, /):
            """
            Resources resize policy for the container.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ResizePolicy.Builder]()
                context._parent_builder = self
                context._field_name = "resize_policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResizePolicy.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("resize_policy", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "Container.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "Container.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            Compute Resources required by this container.
            Cannot be updated.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def restart_policy(self, value: Optional[str], /) -> Self:
            """
            RestartPolicy defines the restart behavior of individual containers in a pod.
            This field may only be set for init containers, and the only allowed value is "Always".
            For non-init containers or when this field is not specified,
            the restart behavior is defined by the Pod's restart policy and the container type.
            Setting the RestartPolicy as "Always" for the init container will have the following effect:
            this init container will be continually restarted on
            exit until all regular containers have terminated. Once all regular
            containers have completed, all init containers with restartPolicy "Always"
            will be shut down. This lifecycle differs from normal init containers and
            is often referred to as a "sidecar" container. Although this init
            container still starts in the init container sequence, it does not wait
            for the container to complete before proceeding to the next init
            container. Instead, the next init container starts immediately after this
            init container is started, or after any startupProbe has successfully
            completed.
            """
            return self._set("restart_policy", value)

        @overload
        def security_context(
            self, value_or_callback: Optional[SecurityContext], /
        ) -> "Container.Builder": ...

        @overload
        def security_context(
            self,
            value_or_callback: Callable[
                [SecurityContext.Builder], SecurityContext.Builder | SecurityContext
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def security_context(
            self, value_or_callback: Never = ...
        ) -> "SecurityContext.BuilderContext": ...

        def security_context(self, value_or_callback=None, /):
            """
            SecurityContext defines the security options the container should be run with.
            If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
            More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
            """
            if self._in_context and value_or_callback is None:
                context = SecurityContext.BuilderContext()
                context._parent_builder = self
                context._field_name = "security_context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecurityContext.builder())
                if isinstance(output, SecurityContext.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("security_context", value)

        @overload
        def startup_probe(
            self, value_or_callback: Optional[StartupProbe], /
        ) -> "Container.Builder": ...

        @overload
        def startup_probe(
            self,
            value_or_callback: Callable[
                [StartupProbe.Builder], StartupProbe.Builder | StartupProbe
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def startup_probe(
            self, value_or_callback: Never = ...
        ) -> "StartupProbe.BuilderContext": ...

        def startup_probe(self, value_or_callback=None, /):
            """
            StartupProbe indicates that the Pod has successfully initialized.
            If specified, no other probes are executed until this completes successfully.
            If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
            This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
            when it might take a long time to load data or warm a cache, than during steady-state operation.
            This cannot be updated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            if self._in_context and value_or_callback is None:
                context = StartupProbe.BuilderContext()
                context._parent_builder = self
                context._field_name = "startup_probe"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(StartupProbe.builder())
                if isinstance(output, StartupProbe.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("startup_probe", value)

        def stdin(self, value: Optional[bool], /) -> Self:
            """
            Whether this container should allocate a buffer for stdin in the container runtime. If this
            is not set, reads from stdin in the container will always result in EOF.
            Default is false.
            """
            return self._set("stdin", value)

        def stdin_once(self, value: Optional[bool], /) -> Self:
            """
            Whether the container runtime should close the stdin channel after it has been opened by
            a single attach. When stdin is true the stdin stream will remain open across multiple attach
            sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
            first client attaches to stdin, and then remains open and accepts data until the client disconnects,
            at which time stdin is closed and remains closed until the container is restarted. If this
            flag is false, a container processes that reads from stdin will never receive an EOF.
            Default is false
            """
            return self._set("stdin_once", value)

        def termination_message_path(self, value: Optional[str], /) -> Self:
            """
            Optional: Path at which the file to which the container's termination message
            will be written is mounted into the container's filesystem.
            Message written is intended to be brief final status, such as an assertion failure message.
            Will be truncated by the node if greater than 4096 bytes. The total message length across
            all containers will be limited to 12kb.
            Defaults to /dev/termination-log.
            Cannot be updated.
            """
            return self._set("termination_message_path", value)

        def termination_message_policy(self, value: Optional[str], /) -> Self:
            """
            Indicate how the termination message should be populated. File will use the contents of
            terminationMessagePath to populate the container status message on both success and failure.
            FallbackToLogsOnError will use the last chunk of container log output if the termination
            message file is empty and the container exited with an error.
            The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
            Defaults to File.
            Cannot be updated.
            """
            return self._set("termination_message_policy", value)

        def tty(self, value: Optional[bool], /) -> Self:
            """
            Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
            Default is false.
            """
            return self._set("tty", value)

        @overload
        def volume_devices(
            self, value_or_callback: List[VolumeDevice], /
        ) -> "Container.Builder": ...

        @overload
        def volume_devices(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[VolumeDevice, VolumeDevice.Builder]],
                GenericListBuilder[VolumeDevice, VolumeDevice.Builder] | List[VolumeDevice],
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def volume_devices(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[VolumeDevice.Builder]: ...

        def volume_devices(self, value_or_callback=None, /):
            """
            volumeDevices is the list of block devices to be used by the container.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[VolumeDevice.Builder]()
                context._parent_builder = self
                context._field_name = "volume_devices"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VolumeDevice.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("volume_devices", value)

        @overload
        def volume_mounts(self, value_or_callback: List[VolumeMount], /) -> "Container.Builder": ...

        @overload
        def volume_mounts(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[VolumeMount, VolumeMount.Builder]],
                GenericListBuilder[VolumeMount, VolumeMount.Builder] | List[VolumeMount],
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def volume_mounts(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[VolumeMount.Builder]: ...

        def volume_mounts(self, value_or_callback=None, /):
            """
            Pod volumes to mount into the container's filesystem.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[VolumeMount.Builder]()
                context._parent_builder = self
                context._field_name = "volume_mounts"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VolumeMount.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("volume_mounts", value)

        def working_dir(self, value: Optional[str], /) -> Self:
            """
            Container's working directory.
            If not specified, the container runtime's default will be used, which
            might be configured in the container image.
            Cannot be updated.
            """
            return self._set("working_dir", value)

    class BuilderContext(BuilderContextBase["Container.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Container.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Container."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Container", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Container.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    args: Optional[List[str]] = None
    """
    Arguments to the entrypoint.
    The container image's CMD is used if this is not provided.
    Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    of whether the variable exists or not. Cannot be updated.
    More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
    """
    command: Optional[List[str]] = None
    """
    Entrypoint array. Not executed within a shell.
    The container image's ENTRYPOINT is used if this is not provided.
    Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    of whether the variable exists or not. Cannot be updated.
    More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
    """
    env: Optional[List[Env]] = None
    """
    List of environment variables to set in the container.
    Cannot be updated.
    """
    env_from: Annotated[Optional[List[EnvFrom]], Field(alias="envFrom")] = None
    """
    List of sources to populate environment variables in the container.
    The keys defined within a source must be a C_IDENTIFIER. All invalid keys
    will be reported as an event when the container is starting. When a key exists in multiple
    sources, the value associated with the last source will take precedence.
    Values defined by an Env with a duplicate key will take precedence.
    Cannot be updated.
    """
    image: Optional[str] = None
    """
    Container image name.
    More info: https://kubernetes.io/docs/concepts/containers/images
    This field is optional to allow higher level config management to default or override
    container images in workload controllers like Deployments and StatefulSets.
    """
    image_pull_policy: Annotated[Optional[str], Field(alias="imagePullPolicy")] = None
    """
    Image pull policy.
    One of Always, Never, IfNotPresent.
    Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    Cannot be updated.
    More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
    """
    lifecycle: Optional[Lifecycle] = None
    """
    Actions that the management system should take in response to container lifecycle events.
    Cannot be updated.
    """
    liveness_probe: Annotated[Optional[LivenessProbe], Field(alias="livenessProbe")] = None
    """
    Periodic probe of container liveness.
    Container will be restarted if the probe fails.
    Cannot be updated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    name: str
    """
    Name of the container specified as a DNS_LABEL.
    Each container in a pod must have a unique name (DNS_LABEL).
    Cannot be updated.
    """
    ports: Optional[List[Port]] = None
    """
    List of ports to expose from the container. Not specifying a port here
    DOES NOT prevent that port from being exposed. Any port which is
    listening on the default "0.0.0.0" address inside a container will be
    accessible from the network.
    Modifying this array with strategic merge patch may corrupt the data.
    For more information See https://github.com/kubernetes/kubernetes/issues/108255.
    Cannot be updated.
    """
    readiness_probe: Annotated[Optional[ReadinessProbe], Field(alias="readinessProbe")] = None
    """
    Periodic probe of container service readiness.
    Container will be removed from service endpoints if the probe fails.
    Cannot be updated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    resize_policy: Annotated[Optional[List[ResizePolicy]], Field(alias="resizePolicy")] = None
    """
    Resources resize policy for the container.
    """
    resources: Optional[Resources] = None
    """
    Compute Resources required by this container.
    Cannot be updated.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """
    restart_policy: Annotated[Optional[str], Field(alias="restartPolicy")] = None
    """
    RestartPolicy defines the restart behavior of individual containers in a pod.
    This field may only be set for init containers, and the only allowed value is "Always".
    For non-init containers or when this field is not specified,
    the restart behavior is defined by the Pod's restart policy and the container type.
    Setting the RestartPolicy as "Always" for the init container will have the following effect:
    this init container will be continually restarted on
    exit until all regular containers have terminated. Once all regular
    containers have completed, all init containers with restartPolicy "Always"
    will be shut down. This lifecycle differs from normal init containers and
    is often referred to as a "sidecar" container. Although this init
    container still starts in the init container sequence, it does not wait
    for the container to complete before proceeding to the next init
    container. Instead, the next init container starts immediately after this
    init container is started, or after any startupProbe has successfully
    completed.
    """
    security_context: Annotated[Optional[SecurityContext], Field(alias="securityContext")] = None
    """
    SecurityContext defines the security options the container should be run with.
    If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
    More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
    """
    startup_probe: Annotated[Optional[StartupProbe], Field(alias="startupProbe")] = None
    """
    StartupProbe indicates that the Pod has successfully initialized.
    If specified, no other probes are executed until this completes successfully.
    If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
    This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
    when it might take a long time to load data or warm a cache, than during steady-state operation.
    This cannot be updated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    stdin: Optional[bool] = None
    """
    Whether this container should allocate a buffer for stdin in the container runtime. If this
    is not set, reads from stdin in the container will always result in EOF.
    Default is false.
    """
    stdin_once: Annotated[Optional[bool], Field(alias="stdinOnce")] = None
    """
    Whether the container runtime should close the stdin channel after it has been opened by
    a single attach. When stdin is true the stdin stream will remain open across multiple attach
    sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
    first client attaches to stdin, and then remains open and accepts data until the client disconnects,
    at which time stdin is closed and remains closed until the container is restarted. If this
    flag is false, a container processes that reads from stdin will never receive an EOF.
    Default is false
    """
    termination_message_path: Annotated[Optional[str], Field(alias="terminationMessagePath")] = None
    """
    Optional: Path at which the file to which the container's termination message
    will be written is mounted into the container's filesystem.
    Message written is intended to be brief final status, such as an assertion failure message.
    Will be truncated by the node if greater than 4096 bytes. The total message length across
    all containers will be limited to 12kb.
    Defaults to /dev/termination-log.
    Cannot be updated.
    """
    termination_message_policy: Annotated[
        Optional[str], Field(alias="terminationMessagePolicy")
    ] = None
    """
    Indicate how the termination message should be populated. File will use the contents of
    terminationMessagePath to populate the container status message on both success and failure.
    FallbackToLogsOnError will use the last chunk of container log output if the termination
    message file is empty and the container exited with an error.
    The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
    Defaults to File.
    Cannot be updated.
    """
    tty: Optional[bool] = None
    """
    Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
    Default is false.
    """
    volume_devices: Annotated[Optional[List[VolumeDevice]], Field(alias="volumeDevices")] = None
    """
    volumeDevices is the list of block devices to be used by the container.
    """
    volume_mounts: Annotated[Optional[List[VolumeMount]], Field(alias="volumeMounts")] = None
    """
    Pod volumes to mount into the container's filesystem.
    Cannot be updated.
    """
    working_dir: Annotated[Optional[str], Field(alias="workingDir")] = None
    """
    Container's working directory.
    If not specified, the container runtime's default will be used, which
    might be configured in the container image.
    Cannot be updated.
    """


class Nameserver(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "Nameserver":
            value = cast(str, self._value)
            return Nameserver(value)

    root: Annotated[str, Field(min_length=1)]

    class BuilderContext(BuilderContextBase["Nameserver.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Nameserver.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Nameserver."""
        return cls.BuilderContext()


class Option(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Option"]:
            return Option

        def build(self) -> "Option":
            return Option(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name is required and must be unique.
            """
            return self._set("name", value)

        def value(self, value: Optional[str], /) -> Self:
            """
            Value is optional.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["Option.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Option.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Option."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Option", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Option.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Annotated[str, Field(min_length=1)]
    """
    Name is required and must be unique.
    """
    value: Optional[str] = None
    """
    Value is optional.
    """


class Search(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "Search":
            value = cast(str, self._value)
            return Search(value)

    root: Annotated[str, Field(min_length=1)]

    class BuilderContext(BuilderContextBase["Search.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Search.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Search."""
        return cls.BuilderContext()


class DnsConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DnsConfig"]:
            return DnsConfig

        def build(self) -> "DnsConfig":
            return DnsConfig(**self._attrs)

        @overload
        def nameservers(self, value_or_callback: List[Nameserver], /) -> "DnsConfig.Builder": ...

        @overload
        def nameservers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Nameserver, Nameserver.Builder]],
                GenericListBuilder[Nameserver, Nameserver.Builder] | List[Nameserver],
            ],
            /,
        ) -> "DnsConfig.Builder": ...

        @overload
        def nameservers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Nameserver.Builder]: ...

        def nameservers(self, value_or_callback=None, /):
            """
            A list of DNS name server IP addresses.
            This will be appended to the base nameservers generated from DNSPolicy.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Nameserver.Builder]()
                context._parent_builder = self
                context._field_name = "nameservers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Nameserver.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("nameservers", value)

        @overload
        def options(self, value_or_callback: List[Option], /) -> "DnsConfig.Builder": ...

        @overload
        def options(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Option, Option.Builder]],
                GenericListBuilder[Option, Option.Builder] | List[Option],
            ],
            /,
        ) -> "DnsConfig.Builder": ...

        @overload
        def options(self, value_or_callback: Never = ...) -> ListBuilderContext[Option.Builder]: ...

        def options(self, value_or_callback=None, /):
            """
            A list of DNS resolver options.
            This will be merged with the base options generated from DNSPolicy.
            Resolution options given in Options
            will override those that appear in the base DNSPolicy.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Option.Builder]()
                context._parent_builder = self
                context._field_name = "options"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Option.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("options", value)

        @overload
        def searches(self, value_or_callback: List[Search], /) -> "DnsConfig.Builder": ...

        @overload
        def searches(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Search, Search.Builder]],
                GenericListBuilder[Search, Search.Builder] | List[Search],
            ],
            /,
        ) -> "DnsConfig.Builder": ...

        @overload
        def searches(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Search.Builder]: ...

        def searches(self, value_or_callback=None, /):
            """
            A list of DNS search domains for host-name lookup.
            This will be appended to the base search paths generated from DNSPolicy.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Search.Builder]()
                context._parent_builder = self
                context._field_name = "searches"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Search.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("searches", value)

    class BuilderContext(BuilderContextBase["DnsConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DnsConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DnsConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DnsConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DnsConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    nameservers: Optional[List[Nameserver]] = None
    """
    A list of DNS name server IP addresses.
    This will be appended to the base nameservers generated from DNSPolicy.
    """
    options: Optional[List[Option]] = None
    """
    A list of DNS resolver options.
    This will be merged with the base options generated from DNSPolicy.
    Resolution options given in Options
    will override those that appear in the base DNSPolicy.
    """
    searches: Optional[List[Search]] = None
    """
    A list of DNS search domains for host-name lookup.
    This will be appended to the base search paths generated from DNSPolicy.
    """


class HostAliase(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HostAliase"]:
            return HostAliase

        def build(self) -> "HostAliase":
            return HostAliase(**self._attrs)

        def hostnames(self, value: List[str], /) -> Self:
            """
            Hostnames for the above IP address.
            """
            return self._set("hostnames", value)

        def ip(self, value: str, /) -> Self:
            """
            IP address of the host file entry.
            """
            return self._set("ip", value)

    class BuilderContext(BuilderContextBase["HostAliase.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HostAliase.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HostAliase."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HostAliase", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HostAliase.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    hostnames: List[str]
    """
    Hostnames for the above IP address.
    """
    ip: str
    """
    IP address of the host file entry.
    """


class ImagePullSecret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImagePullSecret"]:
            return ImagePullSecret

        def build(self) -> "ImagePullSecret":
            return ImagePullSecret(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["ImagePullSecret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImagePullSecret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImagePullSecret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImagePullSecret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImagePullSecret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """


class DivisorModel1(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel1":
            value = cast(int, self._value)
            return DivisorModel1(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel1.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel1."""
        return cls.BuilderContext()


class DivisorModel2(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel2":
            value = cast(str, self._value)
            return DivisorModel2(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel2.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel2."""
        return cls.BuilderContext()


class LimitsModel1(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel1":
            value = cast(int, self._value)
            return LimitsModel1(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel1.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel1."""
        return cls.BuilderContext()


class LimitsModel2(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel2":
            value = cast(str, self._value)
            return LimitsModel2(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel2.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel2."""
        return cls.BuilderContext()


class RequestsModel1(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel1":
            value = cast(int, self._value)
            return RequestsModel1(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel1.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel1."""
        return cls.BuilderContext()


class RequestsModel2(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel2":
            value = cast(str, self._value)
            return RequestsModel2(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel2.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel2."""
        return cls.BuilderContext()


class InitContainer(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitContainer"]:
            return InitContainer

        def build(self) -> "InitContainer":
            return InitContainer(**self._attrs)

        def args(self, value: Optional[List[str]], /) -> Self:
            """
            Arguments to the entrypoint.
            The container image's CMD is used if this is not provided.
            Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
            cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
            to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
            produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
            of whether the variable exists or not. Cannot be updated.
            More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
            """
            return self._set("args", value)

        def command(self, value: Optional[List[str]], /) -> Self:
            """
            Entrypoint array. Not executed within a shell.
            The container image's ENTRYPOINT is used if this is not provided.
            Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
            cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
            to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
            produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
            of whether the variable exists or not. Cannot be updated.
            More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
            """
            return self._set("command", value)

        @overload
        def env(self, value_or_callback: List[Env], /) -> "InitContainer.Builder": ...

        @overload
        def env(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Env, Env.Builder]],
                GenericListBuilder[Env, Env.Builder] | List[Env],
            ],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def env(self, value_or_callback: Never = ...) -> ListBuilderContext[Env.Builder]: ...

        def env(self, value_or_callback=None, /):
            """
            List of environment variables to set in the container.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Env.Builder]()
                context._parent_builder = self
                context._field_name = "env"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Env.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("env", value)

        @overload
        def env_from(self, value_or_callback: List[EnvFrom], /) -> "InitContainer.Builder": ...

        @overload
        def env_from(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[EnvFrom, EnvFrom.Builder]],
                GenericListBuilder[EnvFrom, EnvFrom.Builder] | List[EnvFrom],
            ],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def env_from(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[EnvFrom.Builder]: ...

        def env_from(self, value_or_callback=None, /):
            """
            List of sources to populate environment variables in the container.
            The keys defined within a source must be a C_IDENTIFIER. All invalid keys
            will be reported as an event when the container is starting. When a key exists in multiple
            sources, the value associated with the last source will take precedence.
            Values defined by an Env with a duplicate key will take precedence.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[EnvFrom.Builder]()
                context._parent_builder = self
                context._field_name = "env_from"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(EnvFrom.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("env_from", value)

        def image(self, value: Optional[str], /) -> Self:
            """
            Container image name.
            More info: https://kubernetes.io/docs/concepts/containers/images
            This field is optional to allow higher level config management to default or override
            container images in workload controllers like Deployments and StatefulSets.
            """
            return self._set("image", value)

        def image_pull_policy(self, value: Optional[str], /) -> Self:
            """
            Image pull policy.
            One of Always, Never, IfNotPresent.
            Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
            Cannot be updated.
            More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
            """
            return self._set("image_pull_policy", value)

        @overload
        def lifecycle(
            self, value_or_callback: Optional[Lifecycle], /
        ) -> "InitContainer.Builder": ...

        @overload
        def lifecycle(
            self,
            value_or_callback: Callable[[Lifecycle.Builder], Lifecycle.Builder | Lifecycle],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def lifecycle(self, value_or_callback: Never = ...) -> "Lifecycle.BuilderContext": ...

        def lifecycle(self, value_or_callback=None, /):
            """
            Actions that the management system should take in response to container lifecycle events.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = Lifecycle.BuilderContext()
                context._parent_builder = self
                context._field_name = "lifecycle"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Lifecycle.builder())
                if isinstance(output, Lifecycle.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("lifecycle", value)

        @overload
        def liveness_probe(
            self, value_or_callback: Optional[LivenessProbe], /
        ) -> "InitContainer.Builder": ...

        @overload
        def liveness_probe(
            self,
            value_or_callback: Callable[
                [LivenessProbe.Builder], LivenessProbe.Builder | LivenessProbe
            ],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def liveness_probe(
            self, value_or_callback: Never = ...
        ) -> "LivenessProbe.BuilderContext": ...

        def liveness_probe(self, value_or_callback=None, /):
            """
            Periodic probe of container liveness.
            Container will be restarted if the probe fails.
            Cannot be updated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            if self._in_context and value_or_callback is None:
                context = LivenessProbe.BuilderContext()
                context._parent_builder = self
                context._field_name = "liveness_probe"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LivenessProbe.builder())
                if isinstance(output, LivenessProbe.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("liveness_probe", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the container specified as a DNS_LABEL.
            Each container in a pod must have a unique name (DNS_LABEL).
            Cannot be updated.
            """
            return self._set("name", value)

        @overload
        def ports(self, value_or_callback: List[Port], /) -> "InitContainer.Builder": ...

        @overload
        def ports(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Port, Port.Builder]],
                GenericListBuilder[Port, Port.Builder] | List[Port],
            ],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def ports(self, value_or_callback: Never = ...) -> ListBuilderContext[Port.Builder]: ...

        def ports(self, value_or_callback=None, /):
            """
            List of ports to expose from the container. Not specifying a port here
            DOES NOT prevent that port from being exposed. Any port which is
            listening on the default "0.0.0.0" address inside a container will be
            accessible from the network.
            Modifying this array with strategic merge patch may corrupt the data.
            For more information See https://github.com/kubernetes/kubernetes/issues/108255.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Port.Builder]()
                context._parent_builder = self
                context._field_name = "ports"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Port.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("ports", value)

        @overload
        def readiness_probe(
            self, value_or_callback: Optional[ReadinessProbe], /
        ) -> "InitContainer.Builder": ...

        @overload
        def readiness_probe(
            self,
            value_or_callback: Callable[
                [ReadinessProbe.Builder], ReadinessProbe.Builder | ReadinessProbe
            ],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def readiness_probe(
            self, value_or_callback: Never = ...
        ) -> "ReadinessProbe.BuilderContext": ...

        def readiness_probe(self, value_or_callback=None, /):
            """
            Periodic probe of container service readiness.
            Container will be removed from service endpoints if the probe fails.
            Cannot be updated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            if self._in_context and value_or_callback is None:
                context = ReadinessProbe.BuilderContext()
                context._parent_builder = self
                context._field_name = "readiness_probe"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ReadinessProbe.builder())
                if isinstance(output, ReadinessProbe.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("readiness_probe", value)

        @overload
        def resize_policy(
            self, value_or_callback: List[ResizePolicy], /
        ) -> "InitContainer.Builder": ...

        @overload
        def resize_policy(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ResizePolicy, ResizePolicy.Builder]],
                GenericListBuilder[ResizePolicy, ResizePolicy.Builder] | List[ResizePolicy],
            ],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def resize_policy(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ResizePolicy.Builder]: ...

        def resize_policy(self, value_or_callback=None, /):
            """
            Resources resize policy for the container.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ResizePolicy.Builder]()
                context._parent_builder = self
                context._field_name = "resize_policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResizePolicy.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("resize_policy", value)

        @overload
        def resources(
            self, value_or_callback: Optional[Resources], /
        ) -> "InitContainer.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            Compute Resources required by this container.
            Cannot be updated.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def restart_policy(self, value: Optional[str], /) -> Self:
            """
            RestartPolicy defines the restart behavior of individual containers in a pod.
            This field may only be set for init containers, and the only allowed value is "Always".
            For non-init containers or when this field is not specified,
            the restart behavior is defined by the Pod's restart policy and the container type.
            Setting the RestartPolicy as "Always" for the init container will have the following effect:
            this init container will be continually restarted on
            exit until all regular containers have terminated. Once all regular
            containers have completed, all init containers with restartPolicy "Always"
            will be shut down. This lifecycle differs from normal init containers and
            is often referred to as a "sidecar" container. Although this init
            container still starts in the init container sequence, it does not wait
            for the container to complete before proceeding to the next init
            container. Instead, the next init container starts immediately after this
            init container is started, or after any startupProbe has successfully
            completed.
            """
            return self._set("restart_policy", value)

        @overload
        def security_context(
            self, value_or_callback: Optional[SecurityContext], /
        ) -> "InitContainer.Builder": ...

        @overload
        def security_context(
            self,
            value_or_callback: Callable[
                [SecurityContext.Builder], SecurityContext.Builder | SecurityContext
            ],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def security_context(
            self, value_or_callback: Never = ...
        ) -> "SecurityContext.BuilderContext": ...

        def security_context(self, value_or_callback=None, /):
            """
            SecurityContext defines the security options the container should be run with.
            If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
            More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
            """
            if self._in_context and value_or_callback is None:
                context = SecurityContext.BuilderContext()
                context._parent_builder = self
                context._field_name = "security_context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecurityContext.builder())
                if isinstance(output, SecurityContext.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("security_context", value)

        @overload
        def startup_probe(
            self, value_or_callback: Optional[StartupProbe], /
        ) -> "InitContainer.Builder": ...

        @overload
        def startup_probe(
            self,
            value_or_callback: Callable[
                [StartupProbe.Builder], StartupProbe.Builder | StartupProbe
            ],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def startup_probe(
            self, value_or_callback: Never = ...
        ) -> "StartupProbe.BuilderContext": ...

        def startup_probe(self, value_or_callback=None, /):
            """
            StartupProbe indicates that the Pod has successfully initialized.
            If specified, no other probes are executed until this completes successfully.
            If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
            This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
            when it might take a long time to load data or warm a cache, than during steady-state operation.
            This cannot be updated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            if self._in_context and value_or_callback is None:
                context = StartupProbe.BuilderContext()
                context._parent_builder = self
                context._field_name = "startup_probe"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(StartupProbe.builder())
                if isinstance(output, StartupProbe.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("startup_probe", value)

        def stdin(self, value: Optional[bool], /) -> Self:
            """
            Whether this container should allocate a buffer for stdin in the container runtime. If this
            is not set, reads from stdin in the container will always result in EOF.
            Default is false.
            """
            return self._set("stdin", value)

        def stdin_once(self, value: Optional[bool], /) -> Self:
            """
            Whether the container runtime should close the stdin channel after it has been opened by
            a single attach. When stdin is true the stdin stream will remain open across multiple attach
            sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
            first client attaches to stdin, and then remains open and accepts data until the client disconnects,
            at which time stdin is closed and remains closed until the container is restarted. If this
            flag is false, a container processes that reads from stdin will never receive an EOF.
            Default is false
            """
            return self._set("stdin_once", value)

        def termination_message_path(self, value: Optional[str], /) -> Self:
            """
            Optional: Path at which the file to which the container's termination message
            will be written is mounted into the container's filesystem.
            Message written is intended to be brief final status, such as an assertion failure message.
            Will be truncated by the node if greater than 4096 bytes. The total message length across
            all containers will be limited to 12kb.
            Defaults to /dev/termination-log.
            Cannot be updated.
            """
            return self._set("termination_message_path", value)

        def termination_message_policy(self, value: Optional[str], /) -> Self:
            """
            Indicate how the termination message should be populated. File will use the contents of
            terminationMessagePath to populate the container status message on both success and failure.
            FallbackToLogsOnError will use the last chunk of container log output if the termination
            message file is empty and the container exited with an error.
            The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
            Defaults to File.
            Cannot be updated.
            """
            return self._set("termination_message_policy", value)

        def tty(self, value: Optional[bool], /) -> Self:
            """
            Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
            Default is false.
            """
            return self._set("tty", value)

        @overload
        def volume_devices(
            self, value_or_callback: List[VolumeDevice], /
        ) -> "InitContainer.Builder": ...

        @overload
        def volume_devices(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[VolumeDevice, VolumeDevice.Builder]],
                GenericListBuilder[VolumeDevice, VolumeDevice.Builder] | List[VolumeDevice],
            ],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def volume_devices(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[VolumeDevice.Builder]: ...

        def volume_devices(self, value_or_callback=None, /):
            """
            volumeDevices is the list of block devices to be used by the container.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[VolumeDevice.Builder]()
                context._parent_builder = self
                context._field_name = "volume_devices"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VolumeDevice.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("volume_devices", value)

        @overload
        def volume_mounts(
            self, value_or_callback: List[VolumeMount], /
        ) -> "InitContainer.Builder": ...

        @overload
        def volume_mounts(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[VolumeMount, VolumeMount.Builder]],
                GenericListBuilder[VolumeMount, VolumeMount.Builder] | List[VolumeMount],
            ],
            /,
        ) -> "InitContainer.Builder": ...

        @overload
        def volume_mounts(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[VolumeMount.Builder]: ...

        def volume_mounts(self, value_or_callback=None, /):
            """
            Pod volumes to mount into the container's filesystem.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[VolumeMount.Builder]()
                context._parent_builder = self
                context._field_name = "volume_mounts"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VolumeMount.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("volume_mounts", value)

        def working_dir(self, value: Optional[str], /) -> Self:
            """
            Container's working directory.
            If not specified, the container runtime's default will be used, which
            might be configured in the container image.
            Cannot be updated.
            """
            return self._set("working_dir", value)

    class BuilderContext(BuilderContextBase["InitContainer.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitContainer.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitContainer."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitContainer", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitContainer.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    args: Optional[List[str]] = None
    """
    Arguments to the entrypoint.
    The container image's CMD is used if this is not provided.
    Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    of whether the variable exists or not. Cannot be updated.
    More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
    """
    command: Optional[List[str]] = None
    """
    Entrypoint array. Not executed within a shell.
    The container image's ENTRYPOINT is used if this is not provided.
    Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    of whether the variable exists or not. Cannot be updated.
    More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
    """
    env: Optional[List[Env]] = None
    """
    List of environment variables to set in the container.
    Cannot be updated.
    """
    env_from: Annotated[Optional[List[EnvFrom]], Field(alias="envFrom")] = None
    """
    List of sources to populate environment variables in the container.
    The keys defined within a source must be a C_IDENTIFIER. All invalid keys
    will be reported as an event when the container is starting. When a key exists in multiple
    sources, the value associated with the last source will take precedence.
    Values defined by an Env with a duplicate key will take precedence.
    Cannot be updated.
    """
    image: Optional[str] = None
    """
    Container image name.
    More info: https://kubernetes.io/docs/concepts/containers/images
    This field is optional to allow higher level config management to default or override
    container images in workload controllers like Deployments and StatefulSets.
    """
    image_pull_policy: Annotated[Optional[str], Field(alias="imagePullPolicy")] = None
    """
    Image pull policy.
    One of Always, Never, IfNotPresent.
    Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    Cannot be updated.
    More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
    """
    lifecycle: Optional[Lifecycle] = None
    """
    Actions that the management system should take in response to container lifecycle events.
    Cannot be updated.
    """
    liveness_probe: Annotated[Optional[LivenessProbe], Field(alias="livenessProbe")] = None
    """
    Periodic probe of container liveness.
    Container will be restarted if the probe fails.
    Cannot be updated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    name: str
    """
    Name of the container specified as a DNS_LABEL.
    Each container in a pod must have a unique name (DNS_LABEL).
    Cannot be updated.
    """
    ports: Optional[List[Port]] = None
    """
    List of ports to expose from the container. Not specifying a port here
    DOES NOT prevent that port from being exposed. Any port which is
    listening on the default "0.0.0.0" address inside a container will be
    accessible from the network.
    Modifying this array with strategic merge patch may corrupt the data.
    For more information See https://github.com/kubernetes/kubernetes/issues/108255.
    Cannot be updated.
    """
    readiness_probe: Annotated[Optional[ReadinessProbe], Field(alias="readinessProbe")] = None
    """
    Periodic probe of container service readiness.
    Container will be removed from service endpoints if the probe fails.
    Cannot be updated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    resize_policy: Annotated[Optional[List[ResizePolicy]], Field(alias="resizePolicy")] = None
    """
    Resources resize policy for the container.
    """
    resources: Optional[Resources] = None
    """
    Compute Resources required by this container.
    Cannot be updated.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """
    restart_policy: Annotated[Optional[str], Field(alias="restartPolicy")] = None
    """
    RestartPolicy defines the restart behavior of individual containers in a pod.
    This field may only be set for init containers, and the only allowed value is "Always".
    For non-init containers or when this field is not specified,
    the restart behavior is defined by the Pod's restart policy and the container type.
    Setting the RestartPolicy as "Always" for the init container will have the following effect:
    this init container will be continually restarted on
    exit until all regular containers have terminated. Once all regular
    containers have completed, all init containers with restartPolicy "Always"
    will be shut down. This lifecycle differs from normal init containers and
    is often referred to as a "sidecar" container. Although this init
    container still starts in the init container sequence, it does not wait
    for the container to complete before proceeding to the next init
    container. Instead, the next init container starts immediately after this
    init container is started, or after any startupProbe has successfully
    completed.
    """
    security_context: Annotated[Optional[SecurityContext], Field(alias="securityContext")] = None
    """
    SecurityContext defines the security options the container should be run with.
    If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
    More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
    """
    startup_probe: Annotated[Optional[StartupProbe], Field(alias="startupProbe")] = None
    """
    StartupProbe indicates that the Pod has successfully initialized.
    If specified, no other probes are executed until this completes successfully.
    If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
    This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
    when it might take a long time to load data or warm a cache, than during steady-state operation.
    This cannot be updated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    stdin: Optional[bool] = None
    """
    Whether this container should allocate a buffer for stdin in the container runtime. If this
    is not set, reads from stdin in the container will always result in EOF.
    Default is false.
    """
    stdin_once: Annotated[Optional[bool], Field(alias="stdinOnce")] = None
    """
    Whether the container runtime should close the stdin channel after it has been opened by
    a single attach. When stdin is true the stdin stream will remain open across multiple attach
    sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
    first client attaches to stdin, and then remains open and accepts data until the client disconnects,
    at which time stdin is closed and remains closed until the container is restarted. If this
    flag is false, a container processes that reads from stdin will never receive an EOF.
    Default is false
    """
    termination_message_path: Annotated[Optional[str], Field(alias="terminationMessagePath")] = None
    """
    Optional: Path at which the file to which the container's termination message
    will be written is mounted into the container's filesystem.
    Message written is intended to be brief final status, such as an assertion failure message.
    Will be truncated by the node if greater than 4096 bytes. The total message length across
    all containers will be limited to 12kb.
    Defaults to /dev/termination-log.
    Cannot be updated.
    """
    termination_message_policy: Annotated[
        Optional[str], Field(alias="terminationMessagePolicy")
    ] = None
    """
    Indicate how the termination message should be populated. File will use the contents of
    terminationMessagePath to populate the container status message on both success and failure.
    FallbackToLogsOnError will use the last chunk of container log output if the termination
    message file is empty and the container exited with an error.
    The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
    Defaults to File.
    Cannot be updated.
    """
    tty: Optional[bool] = None
    """
    Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
    Default is false.
    """
    volume_devices: Annotated[Optional[List[VolumeDevice]], Field(alias="volumeDevices")] = None
    """
    volumeDevices is the list of block devices to be used by the container.
    """
    volume_mounts: Annotated[Optional[List[VolumeMount]], Field(alias="volumeMounts")] = None
    """
    Pod volumes to mount into the container's filesystem.
    Cannot be updated.
    """
    working_dir: Annotated[Optional[str], Field(alias="workingDir")] = None
    """
    Container's working directory.
    If not specified, the container runtime's default will be used, which
    might be configured in the container image.
    Cannot be updated.
    """


class PersistentVolumeClaimRetentionPolicy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PersistentVolumeClaimRetentionPolicy"]:
            return PersistentVolumeClaimRetentionPolicy

        def build(self) -> "PersistentVolumeClaimRetentionPolicy":
            return PersistentVolumeClaimRetentionPolicy(**self._attrs)

        def when_deleted(self, value: Optional[str], /) -> Self:
            """
            WhenDeleted specifies what happens to PVCs created from StatefulSet
            VolumeClaimTemplates when the StatefulSet is deleted. The default policy
            of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
            `Delete` policy causes those PVCs to be deleted.
            """
            return self._set("when_deleted", value)

        def when_scaled(self, value: Optional[str], /) -> Self:
            """
            WhenScaled specifies what happens to PVCs created from StatefulSet
            VolumeClaimTemplates when the StatefulSet is scaled down. The default
            policy of `Retain` causes PVCs to not be affected by a scaledown. The
            `Delete` policy causes the associated PVCs for any excess pods above
            the replica count to be deleted.
            """
            return self._set("when_scaled", value)

    class BuilderContext(BuilderContextBase["PersistentVolumeClaimRetentionPolicy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PersistentVolumeClaimRetentionPolicy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PersistentVolumeClaimRetentionPolicy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PersistentVolumeClaimRetentionPolicy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PersistentVolumeClaimRetentionPolicy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    when_deleted: Annotated[Optional[str], Field(alias="whenDeleted")] = None
    """
    WhenDeleted specifies what happens to PVCs created from StatefulSet
    VolumeClaimTemplates when the StatefulSet is deleted. The default policy
    of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
    `Delete` policy causes those PVCs to be deleted.
    """
    when_scaled: Annotated[Optional[str], Field(alias="whenScaled")] = None
    """
    WhenScaled specifies what happens to PVCs created from StatefulSet
    VolumeClaimTemplates when the StatefulSet is scaled down. The default
    policy of `Retain` causes PVCs to not be affected by a scaledown. The
    `Delete` policy causes the associated PVCs for any excess pods above
    the replica count to be deleted.
    """


class PodMetadata(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodMetadata"]:
            return PodMetadata

        def build(self) -> "PodMetadata":
            return PodMetadata(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations is an unstructured key value map stored with a resource that may be
            set by external tools to store and retrieve arbitrary metadata. They are not
            queryable and should be preserved when modifying objects.
            More info: http://kubernetes.io/docs/user-guide/annotations
            """
            return self._set("annotations", value)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Map of string keys and values that can be used to organize and categorize
            (scope and select) objects. May match selectors of replication controllers
            and services.
            More info: http://kubernetes.io/docs/user-guide/labels
            """
            return self._set("labels", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name must be unique within a namespace. Is required when creating resources, although
            some resources may allow a client to request the generation of an appropriate name
            automatically. Name is primarily intended for creation idempotence and configuration
            definition.
            Cannot be updated.
            More info: http://kubernetes.io/docs/user-guide/identifiers#names
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["PodMetadata.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodMetadata.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodMetadata."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodMetadata", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodMetadata.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, str]] = None
    """
    Annotations is an unstructured key value map stored with a resource that may be
    set by external tools to store and retrieve arbitrary metadata. They are not
    queryable and should be preserved when modifying objects.
    More info: http://kubernetes.io/docs/user-guide/annotations
    """
    labels: Optional[Dict[str, str]] = None
    """
    Map of string keys and values that can be used to organize and categorize
    (scope and select) objects. May match selectors of replication controllers
    and services.
    More info: http://kubernetes.io/docs/user-guide/labels
    """
    name: Optional[str] = None
    """
    Name must be unique within a namespace. Is required when creating resources, although
    some resources may allow a client to request the generation of an appropriate name
    automatically. Name is primarily intended for creation idempotence and configuration
    definition.
    Cannot be updated.
    More info: http://kubernetes.io/docs/user-guide/identifiers#names
    """


class LimitsModel3(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel3":
            value = cast(int, self._value)
            return LimitsModel3(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel3.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel3."""
        return cls.BuilderContext()


class LimitsModel4(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel4":
            value = cast(str, self._value)
            return LimitsModel4(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel4.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel4."""
        return cls.BuilderContext()


class RequestsModel3(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel3":
            value = cast(int, self._value)
            return RequestsModel3(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel3.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel3."""
        return cls.BuilderContext()


class RequestsModel4(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel4":
            value = cast(str, self._value)
            return RequestsModel4(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel4.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel4."""
        return cls.BuilderContext()


class Sysctl(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Sysctl"]:
            return Sysctl

        def build(self) -> "Sysctl":
            return Sysctl(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of a property to set
            """
            return self._set("name", value)

        def value(self, value: str, /) -> Self:
            """
            Value of a property to set
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["Sysctl.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Sysctl.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Sysctl."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Sysctl", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Sysctl.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of a property to set
    """
    value: str
    """
    Value of a property to set
    """


class SecurityContextModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecurityContextModel"]:
            return SecurityContextModel

        def build(self) -> "SecurityContextModel":
            return SecurityContextModel(**self._attrs)

        @overload
        def app_armor_profile(
            self, value_or_callback: Optional[AppArmorProfile], /
        ) -> "SecurityContextModel.Builder": ...

        @overload
        def app_armor_profile(
            self,
            value_or_callback: Callable[
                [AppArmorProfile.Builder], AppArmorProfile.Builder | AppArmorProfile
            ],
            /,
        ) -> "SecurityContextModel.Builder": ...

        @overload
        def app_armor_profile(
            self, value_or_callback: Never = ...
        ) -> "AppArmorProfile.BuilderContext": ...

        def app_armor_profile(self, value_or_callback=None, /):
            """
            appArmorProfile is the AppArmor options to use by the containers in this pod.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = AppArmorProfile.BuilderContext()
                context._parent_builder = self
                context._field_name = "app_armor_profile"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AppArmorProfile.builder())
                if isinstance(output, AppArmorProfile.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("app_armor_profile", value)

        def fs_group(self, value: Optional[int], /) -> Self:
            """
            A special supplemental group that applies to all containers in a pod.
            Some volume types allow the Kubelet to change the ownership of that volume
            to be owned by the pod:

            1. The owning GID will be the FSGroup
            2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
            3. The permission bits are OR'd with rw-rw----

            If unset, the Kubelet will not modify the ownership and permissions of any volume.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("fs_group", value)

        def fs_group_change_policy(self, value: Optional[str], /) -> Self:
            """
            fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
            before being exposed inside Pod. This field will only apply to
            volume types which support fsGroup based ownership(and permissions).
            It will have no effect on ephemeral volume types such as: secret, configmaps
            and emptydir.
            Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("fs_group_change_policy", value)

        def run_as_group(self, value: Optional[int], /) -> Self:
            """
            The GID to run the entrypoint of the container process.
            Uses runtime default if unset.
            May also be set in SecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence
            for that container.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("run_as_group", value)

        def run_as_non_root(self, value: Optional[bool], /) -> Self:
            """
            Indicates that the container must run as a non-root user.
            If true, the Kubelet will validate the image at runtime to ensure that it
            does not run as UID 0 (root) and fail to start the container if it does.
            If unset or false, no such validation will be performed.
            May also be set in SecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            """
            return self._set("run_as_non_root", value)

        def run_as_user(self, value: Optional[int], /) -> Self:
            """
            The UID to run the entrypoint of the container process.
            Defaults to user specified in image metadata if unspecified.
            May also be set in SecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence
            for that container.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("run_as_user", value)

        def se_linux_change_policy(self, value: Optional[str], /) -> Self:
            """
            seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
            It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
            Valid values are "MountOption" and "Recursive".

            "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
            This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.

            "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
            This requires all Pods that share the same volume to use the same SELinux label.
            It is not possible to share the same volume among privileged and unprivileged Pods.
            Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
            whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
            CSIDriver instance. Other volumes are always re-labelled recursively.
            "MountOption" value is allowed only when SELinuxMount feature gate is enabled.

            If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
            If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
            and "Recursive" for all other volumes.

            This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.

            All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("se_linux_change_policy", value)

        @overload
        def se_linux_options(
            self, value_or_callback: Optional[SeLinuxOptions], /
        ) -> "SecurityContextModel.Builder": ...

        @overload
        def se_linux_options(
            self,
            value_or_callback: Callable[
                [SeLinuxOptions.Builder], SeLinuxOptions.Builder | SeLinuxOptions
            ],
            /,
        ) -> "SecurityContextModel.Builder": ...

        @overload
        def se_linux_options(
            self, value_or_callback: Never = ...
        ) -> "SeLinuxOptions.BuilderContext": ...

        def se_linux_options(self, value_or_callback=None, /):
            """
            The SELinux context to be applied to all containers.
            If unspecified, the container runtime will allocate a random SELinux context for each
            container.  May also be set in SecurityContext.  If set in
            both SecurityContext and PodSecurityContext, the value specified in SecurityContext
            takes precedence for that container.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = SeLinuxOptions.BuilderContext()
                context._parent_builder = self
                context._field_name = "se_linux_options"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SeLinuxOptions.builder())
                if isinstance(output, SeLinuxOptions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("se_linux_options", value)

        @overload
        def seccomp_profile(
            self, value_or_callback: Optional[SeccompProfile], /
        ) -> "SecurityContextModel.Builder": ...

        @overload
        def seccomp_profile(
            self,
            value_or_callback: Callable[
                [SeccompProfile.Builder], SeccompProfile.Builder | SeccompProfile
            ],
            /,
        ) -> "SecurityContextModel.Builder": ...

        @overload
        def seccomp_profile(
            self, value_or_callback: Never = ...
        ) -> "SeccompProfile.BuilderContext": ...

        def seccomp_profile(self, value_or_callback=None, /):
            """
            The seccomp options to use by the containers in this pod.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = SeccompProfile.BuilderContext()
                context._parent_builder = self
                context._field_name = "seccomp_profile"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SeccompProfile.builder())
                if isinstance(output, SeccompProfile.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("seccomp_profile", value)

        def supplemental_groups(self, value: Optional[List[int]], /) -> Self:
            """
            A list of groups applied to the first process run in each container, in
            addition to the container's primary GID and fsGroup (if specified).  If
            the SupplementalGroupsPolicy feature is enabled, the
            supplementalGroupsPolicy field determines whether these are in addition
            to or instead of any group memberships defined in the container image.
            If unspecified, no additional groups are added, though group memberships
            defined in the container image may still be used, depending on the
            supplementalGroupsPolicy field.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("supplemental_groups", value)

        def supplemental_groups_policy(self, value: Optional[str], /) -> Self:
            """
            Defines how supplemental groups of the first container processes are calculated.
            Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
            (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
            and the container runtime must implement support for this feature.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("supplemental_groups_policy", value)

        @overload
        def sysctls(self, value_or_callback: List[Sysctl], /) -> "SecurityContextModel.Builder": ...

        @overload
        def sysctls(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Sysctl, Sysctl.Builder]],
                GenericListBuilder[Sysctl, Sysctl.Builder] | List[Sysctl],
            ],
            /,
        ) -> "SecurityContextModel.Builder": ...

        @overload
        def sysctls(self, value_or_callback: Never = ...) -> ListBuilderContext[Sysctl.Builder]: ...

        def sysctls(self, value_or_callback=None, /):
            """
            Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
            sysctls (by the container runtime) might fail to launch.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Sysctl.Builder]()
                context._parent_builder = self
                context._field_name = "sysctls"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sysctl.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("sysctls", value)

        @overload
        def windows_options(
            self, value_or_callback: Optional[WindowsOptions], /
        ) -> "SecurityContextModel.Builder": ...

        @overload
        def windows_options(
            self,
            value_or_callback: Callable[
                [WindowsOptions.Builder], WindowsOptions.Builder | WindowsOptions
            ],
            /,
        ) -> "SecurityContextModel.Builder": ...

        @overload
        def windows_options(
            self, value_or_callback: Never = ...
        ) -> "WindowsOptions.BuilderContext": ...

        def windows_options(self, value_or_callback=None, /):
            """
            The Windows specific settings applied to all containers.
            If unspecified, the options within a container's SecurityContext will be used.
            If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
            Note that this field cannot be set when spec.os.name is linux.
            """
            if self._in_context and value_or_callback is None:
                context = WindowsOptions.BuilderContext()
                context._parent_builder = self
                context._field_name = "windows_options"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WindowsOptions.builder())
                if isinstance(output, WindowsOptions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("windows_options", value)

    class BuilderContext(BuilderContextBase["SecurityContextModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecurityContextModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecurityContextModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecurityContextModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecurityContextModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    app_armor_profile: Annotated[Optional[AppArmorProfile], Field(alias="appArmorProfile")] = None
    """
    appArmorProfile is the AppArmor options to use by the containers in this pod.
    Note that this field cannot be set when spec.os.name is windows.
    """
    fs_group: Annotated[Optional[int], Field(alias="fsGroup")] = None
    """
    A special supplemental group that applies to all containers in a pod.
    Some volume types allow the Kubelet to change the ownership of that volume
    to be owned by the pod:

    1. The owning GID will be the FSGroup
    2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
    3. The permission bits are OR'd with rw-rw----

    If unset, the Kubelet will not modify the ownership and permissions of any volume.
    Note that this field cannot be set when spec.os.name is windows.
    """
    fs_group_change_policy: Annotated[Optional[str], Field(alias="fsGroupChangePolicy")] = None
    """
    fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
    before being exposed inside Pod. This field will only apply to
    volume types which support fsGroup based ownership(and permissions).
    It will have no effect on ephemeral volume types such as: secret, configmaps
    and emptydir.
    Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
    Note that this field cannot be set when spec.os.name is windows.
    """
    run_as_group: Annotated[Optional[int], Field(alias="runAsGroup")] = None
    """
    The GID to run the entrypoint of the container process.
    Uses runtime default if unset.
    May also be set in SecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence
    for that container.
    Note that this field cannot be set when spec.os.name is windows.
    """
    run_as_non_root: Annotated[Optional[bool], Field(alias="runAsNonRoot")] = None
    """
    Indicates that the container must run as a non-root user.
    If true, the Kubelet will validate the image at runtime to ensure that it
    does not run as UID 0 (root) and fail to start the container if it does.
    If unset or false, no such validation will be performed.
    May also be set in SecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    """
    run_as_user: Annotated[Optional[int], Field(alias="runAsUser")] = None
    """
    The UID to run the entrypoint of the container process.
    Defaults to user specified in image metadata if unspecified.
    May also be set in SecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence
    for that container.
    Note that this field cannot be set when spec.os.name is windows.
    """
    se_linux_change_policy: Annotated[Optional[str], Field(alias="seLinuxChangePolicy")] = None
    """
    seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
    It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
    Valid values are "MountOption" and "Recursive".

    "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
    This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.

    "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
    This requires all Pods that share the same volume to use the same SELinux label.
    It is not possible to share the same volume among privileged and unprivileged Pods.
    Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
    whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
    CSIDriver instance. Other volumes are always re-labelled recursively.
    "MountOption" value is allowed only when SELinuxMount feature gate is enabled.

    If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
    If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
    and "Recursive" for all other volumes.

    This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.

    All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
    Note that this field cannot be set when spec.os.name is windows.
    """
    se_linux_options: Annotated[Optional[SeLinuxOptions], Field(alias="seLinuxOptions")] = None
    """
    The SELinux context to be applied to all containers.
    If unspecified, the container runtime will allocate a random SELinux context for each
    container.  May also be set in SecurityContext.  If set in
    both SecurityContext and PodSecurityContext, the value specified in SecurityContext
    takes precedence for that container.
    Note that this field cannot be set when spec.os.name is windows.
    """
    seccomp_profile: Annotated[Optional[SeccompProfile], Field(alias="seccompProfile")] = None
    """
    The seccomp options to use by the containers in this pod.
    Note that this field cannot be set when spec.os.name is windows.
    """
    supplemental_groups: Annotated[Optional[List[int]], Field(alias="supplementalGroups")] = None
    """
    A list of groups applied to the first process run in each container, in
    addition to the container's primary GID and fsGroup (if specified).  If
    the SupplementalGroupsPolicy feature is enabled, the
    supplementalGroupsPolicy field determines whether these are in addition
    to or instead of any group memberships defined in the container image.
    If unspecified, no additional groups are added, though group memberships
    defined in the container image may still be used, depending on the
    supplementalGroupsPolicy field.
    Note that this field cannot be set when spec.os.name is windows.
    """
    supplemental_groups_policy: Annotated[
        Optional[str], Field(alias="supplementalGroupsPolicy")
    ] = None
    """
    Defines how supplemental groups of the first container processes are calculated.
    Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
    (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
    and the container runtime must implement support for this feature.
    Note that this field cannot be set when spec.os.name is windows.
    """
    sysctls: Optional[List[Sysctl]] = None
    """
    Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
    sysctls (by the container runtime) might fail to launch.
    Note that this field cannot be set when spec.os.name is windows.
    """
    windows_options: Annotated[Optional[WindowsOptions], Field(alias="windowsOptions")] = None
    """
    The Windows specific settings applied to all containers.
    If unspecified, the options within a container's SecurityContext will be used.
    If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
    Note that this field cannot be set when spec.os.name is linux.
    """


class SizeLimit(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def build(self) -> "SizeLimit":
            value = cast(int, self._value)
            return SizeLimit(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    sizeLimit is the total amount of local storage required for this EmptyDir volume.
    The size limit is also applicable for memory medium.
    The maximum usage on memory medium EmptyDir would be the minimum value between
    the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    The default is nil which means that the limit is undefined.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    """

    class BuilderContext(BuilderContextBase["SizeLimit.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SizeLimit.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SizeLimit."""
        return cls.BuilderContext()


class SizeLimitModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def build(self) -> "SizeLimitModel":
            value = cast(str, self._value)
            return SizeLimitModel(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    sizeLimit is the total amount of local storage required for this EmptyDir volume.
    The size limit is also applicable for memory medium.
    The maximum usage on memory medium EmptyDir would be the minimum value between
    the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    The default is nil which means that the limit is undefined.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    """

    class BuilderContext(BuilderContextBase["SizeLimitModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SizeLimitModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SizeLimitModel."""
        return cls.BuilderContext()


class EmptyDir(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["EmptyDir"]:
            return EmptyDir

        def build(self) -> "EmptyDir":
            return EmptyDir(**self._attrs)

        def medium(self, value: Optional[str], /) -> Self:
            """
            medium represents what type of storage medium should back this directory.
            The default is "" which means to use the node's default medium.
            Must be an empty string (default) or Memory.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            return self._set("medium", value)

        def size_limit(self, value: Optional[Union[SizeLimit, SizeLimitModel]], /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            return self._set("size_limit", value)

    class BuilderContext(BuilderContextBase["EmptyDir.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = EmptyDir.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for EmptyDir."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["EmptyDir", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use EmptyDir.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    medium: Optional[str] = None
    """
    medium represents what type of storage medium should back this directory.
    The default is "" which means to use the node's default medium.
    Must be an empty string (default) or Memory.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    """
    size_limit: Annotated[Optional[Union[SizeLimit, SizeLimitModel]], Field(alias="sizeLimit")] = (
        None
    )
    """
    sizeLimit is the total amount of local storage required for this EmptyDir volume.
    The size limit is also applicable for memory medium.
    The maximum usage on memory medium EmptyDir would be the minimum value between
    the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    The default is nil which means that the limit is undefined.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    """


class DataSource(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DataSource"]:
            return DataSource

        def build(self) -> "DataSource":
            return DataSource(**self._attrs)

        def api_group(self, value: Optional[str], /) -> Self:
            """
            APIGroup is the group for the resource being referenced.
            If APIGroup is not specified, the specified Kind must be in the core API group.
            For any other third-party types, APIGroup is required.
            """
            return self._set("api_group", value)

        def kind(self, value: str, /) -> Self:
            """
            Kind is the type of resource being referenced
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of resource being referenced
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["DataSource.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DataSource.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DataSource."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DataSource", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DataSource.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_group: Annotated[Optional[str], Field(alias="apiGroup")] = None
    """
    APIGroup is the group for the resource being referenced.
    If APIGroup is not specified, the specified Kind must be in the core API group.
    For any other third-party types, APIGroup is required.
    """
    kind: str
    """
    Kind is the type of resource being referenced
    """
    name: str
    """
    Name is the name of resource being referenced
    """


class DataSourceRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DataSourceRef"]:
            return DataSourceRef

        def build(self) -> "DataSourceRef":
            return DataSourceRef(**self._attrs)

        def api_group(self, value: Optional[str], /) -> Self:
            """
            APIGroup is the group for the resource being referenced.
            If APIGroup is not specified, the specified Kind must be in the core API group.
            For any other third-party types, APIGroup is required.
            """
            return self._set("api_group", value)

        def kind(self, value: str, /) -> Self:
            """
            Kind is the type of resource being referenced
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of resource being referenced
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace is the namespace of resource being referenced
            Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
            (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["DataSourceRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DataSourceRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DataSourceRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DataSourceRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DataSourceRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_group: Annotated[Optional[str], Field(alias="apiGroup")] = None
    """
    APIGroup is the group for the resource being referenced.
    If APIGroup is not specified, the specified Kind must be in the core API group.
    For any other third-party types, APIGroup is required.
    """
    kind: str
    """
    Kind is the type of resource being referenced
    """
    name: str
    """
    Name is the name of resource being referenced
    """
    namespace: Optional[str] = None
    """
    Namespace is the namespace of resource being referenced
    Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
    (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    """


class LimitsModel5(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel5":
            value = cast(int, self._value)
            return LimitsModel5(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel5.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel5."""
        return cls.BuilderContext()


class LimitsModel6(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel6":
            value = cast(str, self._value)
            return LimitsModel6(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel6.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel6.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel6."""
        return cls.BuilderContext()


class RequestsModel5(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel5":
            value = cast(int, self._value)
            return RequestsModel5(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel5.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel5."""
        return cls.BuilderContext()


class RequestsModel6(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel6":
            value = cast(str, self._value)
            return RequestsModel6(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel6.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel6.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel6."""
        return cls.BuilderContext()


class ResourcesModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourcesModel"]:
            return ResourcesModel

        def build(self) -> "ResourcesModel":
            return ResourcesModel(**self._attrs)

        def limits(self, value: Optional[Dict[str, Union[LimitsModel5, LimitsModel6]]], /) -> Self:
            """
            Limits describes the maximum amount of compute resources allowed.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            return self._set("limits", value)

        def requests(
            self, value: Optional[Dict[str, Union[RequestsModel5, RequestsModel6]]], /
        ) -> Self:
            """
            Requests describes the minimum amount of compute resources required.
            If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
            otherwise to an implementation-defined value. Requests cannot exceed Limits.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            return self._set("requests", value)

    class BuilderContext(BuilderContextBase["ResourcesModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourcesModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourcesModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourcesModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourcesModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    limits: Optional[Dict[str, Union[LimitsModel5, LimitsModel6]]] = None
    """
    Limits describes the maximum amount of compute resources allowed.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """
    requests: Optional[Dict[str, Union[RequestsModel5, RequestsModel6]]] = None
    """
    Requests describes the minimum amount of compute resources required.
    If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    otherwise to an implementation-defined value. Requests cannot exceed Limits.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """


class Selector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Selector"]:
            return Selector

        def build(self) -> "Selector":
            return Selector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel], /
        ) -> "Selector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]],
                GenericListBuilder[MatchExpressionModel, MatchExpressionModel.Builder]
                | List[MatchExpressionModel],
            ],
            /,
        ) -> "Selector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["Selector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Selector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Selector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Selector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Selector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class Spec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Spec"]:
            return Spec

        def build(self) -> "Spec":
            return Spec(**self._attrs)

        def access_modes(self, value: Optional[List[str]], /) -> Self:
            """
            accessModes contains the desired access modes the volume should have.
            More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
            """
            return self._set("access_modes", value)

        @overload
        def data_source(self, value_or_callback: Optional[DataSource], /) -> "Spec.Builder": ...

        @overload
        def data_source(
            self,
            value_or_callback: Callable[[DataSource.Builder], DataSource.Builder | DataSource],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def data_source(self, value_or_callback: Never = ...) -> "DataSource.BuilderContext": ...

        def data_source(self, value_or_callback=None, /):
            """
            dataSource field can be used to specify either:
            * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
            * An existing PVC (PersistentVolumeClaim)
            If the provisioner or an external controller can support the specified data source,
            it will create a new volume based on the contents of the specified data source.
            When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
            and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
            If the namespace is specified, then dataSourceRef will not be copied to dataSource.
            """
            if self._in_context and value_or_callback is None:
                context = DataSource.BuilderContext()
                context._parent_builder = self
                context._field_name = "data_source"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DataSource.builder())
                if isinstance(output, DataSource.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("data_source", value)

        @overload
        def data_source_ref(
            self, value_or_callback: Optional[DataSourceRef], /
        ) -> "Spec.Builder": ...

        @overload
        def data_source_ref(
            self,
            value_or_callback: Callable[
                [DataSourceRef.Builder], DataSourceRef.Builder | DataSourceRef
            ],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def data_source_ref(
            self, value_or_callback: Never = ...
        ) -> "DataSourceRef.BuilderContext": ...

        def data_source_ref(self, value_or_callback=None, /):
            """
            dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
            volume is desired. This may be any object from a non-empty API group (non
            core object) or a PersistentVolumeClaim object.
            When this field is specified, volume binding will only succeed if the type of
            the specified object matches some installed volume populator or dynamic
            provisioner.
            This field will replace the functionality of the dataSource field and as such
            if both fields are non-empty, they must have the same value. For backwards
            compatibility, when namespace isn't specified in dataSourceRef,
            both fields (dataSource and dataSourceRef) will be set to the same
            value automatically if one of them is empty and the other is non-empty.
            When namespace is specified in dataSourceRef,
            dataSource isn't set to the same value and must be empty.
            There are three important differences between dataSource and dataSourceRef:
            * While dataSource only allows two specific types of objects, dataSourceRef
              allows any non-core object, as well as PersistentVolumeClaim objects.
            * While dataSource ignores disallowed values (dropping them), dataSourceRef
              preserves all values, and generates an error if a disallowed value is
              specified.
            * While dataSource only allows local objects, dataSourceRef allows objects
              in any namespaces.
            (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
            (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
            """
            if self._in_context and value_or_callback is None:
                context = DataSourceRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "data_source_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DataSourceRef.builder())
                if isinstance(output, DataSourceRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("data_source_ref", value)

        @overload
        def resources(self, value_or_callback: Optional[ResourcesModel], /) -> "Spec.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[
                [ResourcesModel.Builder], ResourcesModel.Builder | ResourcesModel
            ],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "ResourcesModel.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            resources represents the minimum resources the volume should have.
            If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
            that are lower than previous value but must still be higher than capacity recorded in the
            status field of the claim.
            More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
            """
            if self._in_context and value_or_callback is None:
                context = ResourcesModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourcesModel.builder())
                if isinstance(output, ResourcesModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        @overload
        def selector(self, value_or_callback: Optional[Selector], /) -> "Spec.Builder": ...

        @overload
        def selector(
            self,
            value_or_callback: Callable[[Selector.Builder], Selector.Builder | Selector],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def selector(self, value_or_callback: Never = ...) -> "Selector.BuilderContext": ...

        def selector(self, value_or_callback=None, /):
            """
            selector is a label query over volumes to consider for binding.
            """
            if self._in_context and value_or_callback is None:
                context = Selector.BuilderContext()
                context._parent_builder = self
                context._field_name = "selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Selector.builder())
                if isinstance(output, Selector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("selector", value)

        def storage_class_name(self, value: Optional[str], /) -> Self:
            """
            storageClassName is the name of the StorageClass required by the claim.
            More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
            """
            return self._set("storage_class_name", value)

        def volume_attributes_class_name(self, value: Optional[str], /) -> Self:
            """
            volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
            If specified, the CSI driver will create or update the volume with the attributes defined
            in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
            it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
            will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
            If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
            will be set by the persistentvolume controller if it exists.
            If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
            set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
            exists.
            More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
            (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
            """
            return self._set("volume_attributes_class_name", value)

        def volume_mode(self, value: Optional[str], /) -> Self:
            """
            volumeMode defines what type of volume is required by the claim.
            Value of Filesystem is implied when not included in claim spec.
            """
            return self._set("volume_mode", value)

        def volume_name(self, value: Optional[str], /) -> Self:
            """
            volumeName is the binding reference to the PersistentVolume backing this claim.
            """
            return self._set("volume_name", value)

    class BuilderContext(BuilderContextBase["Spec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Spec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Spec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Spec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Spec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_modes: Annotated[Optional[List[str]], Field(alias="accessModes")] = None
    """
    accessModes contains the desired access modes the volume should have.
    More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
    """
    data_source: Annotated[Optional[DataSource], Field(alias="dataSource")] = None
    """
    dataSource field can be used to specify either:
    * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
    * An existing PVC (PersistentVolumeClaim)
    If the provisioner or an external controller can support the specified data source,
    it will create a new volume based on the contents of the specified data source.
    When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
    and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
    If the namespace is specified, then dataSourceRef will not be copied to dataSource.
    """
    data_source_ref: Annotated[Optional[DataSourceRef], Field(alias="dataSourceRef")] = None
    """
    dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
    volume is desired. This may be any object from a non-empty API group (non
    core object) or a PersistentVolumeClaim object.
    When this field is specified, volume binding will only succeed if the type of
    the specified object matches some installed volume populator or dynamic
    provisioner.
    This field will replace the functionality of the dataSource field and as such
    if both fields are non-empty, they must have the same value. For backwards
    compatibility, when namespace isn't specified in dataSourceRef,
    both fields (dataSource and dataSourceRef) will be set to the same
    value automatically if one of them is empty and the other is non-empty.
    When namespace is specified in dataSourceRef,
    dataSource isn't set to the same value and must be empty.
    There are three important differences between dataSource and dataSourceRef:
    * While dataSource only allows two specific types of objects, dataSourceRef
      allows any non-core object, as well as PersistentVolumeClaim objects.
    * While dataSource ignores disallowed values (dropping them), dataSourceRef
      preserves all values, and generates an error if a disallowed value is
      specified.
    * While dataSource only allows local objects, dataSourceRef allows objects
      in any namespaces.
    (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    """
    resources: Optional[ResourcesModel] = None
    """
    resources represents the minimum resources the volume should have.
    If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
    that are lower than previous value but must still be higher than capacity recorded in the
    status field of the claim.
    More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
    """
    selector: Optional[Selector] = None
    """
    selector is a label query over volumes to consider for binding.
    """
    storage_class_name: Annotated[Optional[str], Field(alias="storageClassName")] = None
    """
    storageClassName is the name of the StorageClass required by the claim.
    More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
    """
    volume_attributes_class_name: Annotated[
        Optional[str], Field(alias="volumeAttributesClassName")
    ] = None
    """
    volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
    If specified, the CSI driver will create or update the volume with the attributes defined
    in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
    it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
    will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
    If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
    will be set by the persistentvolume controller if it exists.
    If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
    set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
    exists.
    More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
    (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
    """
    volume_mode: Annotated[Optional[str], Field(alias="volumeMode")] = None
    """
    volumeMode defines what type of volume is required by the claim.
    Value of Filesystem is implied when not included in claim spec.
    """
    volume_name: Annotated[Optional[str], Field(alias="volumeName")] = None
    """
    volumeName is the binding reference to the PersistentVolume backing this claim.
    """


class VolumeClaimTemplate(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VolumeClaimTemplate"]:
            return VolumeClaimTemplate

        def build(self) -> "VolumeClaimTemplate":
            return VolumeClaimTemplate(**self._attrs)

        def metadata(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            May contain labels and annotations that will be copied into the PVC
            when creating it. No other fields are allowed and will be rejected during
            validation.
            """
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Spec, /) -> "VolumeClaimTemplate.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Callable[[Spec.Builder], Spec.Builder | Spec], /
        ) -> "VolumeClaimTemplate.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "Spec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            """
            The specification for the PersistentVolumeClaim. The entire content is
            copied unchanged into the PVC that gets created from this
            template. The same fields as in a PersistentVolumeClaim
            are also valid here.
            """
            if self._in_context and value_or_callback is None:
                context = Spec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Spec.builder())
                if isinstance(output, Spec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["VolumeClaimTemplate.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VolumeClaimTemplate.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VolumeClaimTemplate."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VolumeClaimTemplate", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VolumeClaimTemplate.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    metadata: Optional[Dict[str, Any]] = None
    """
    May contain labels and annotations that will be copied into the PVC
    when creating it. No other fields are allowed and will be rejected during
    validation.
    """
    spec: Spec
    """
    The specification for the PersistentVolumeClaim. The entire content is
    copied unchanged into the PVC that gets created from this
    template. The same fields as in a PersistentVolumeClaim
    are also valid here.
    """


class Ephemeral(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ephemeral"]:
            return Ephemeral

        def build(self) -> "Ephemeral":
            return Ephemeral(**self._attrs)

        @overload
        def volume_claim_template(
            self, value_or_callback: Optional[VolumeClaimTemplate], /
        ) -> "Ephemeral.Builder": ...

        @overload
        def volume_claim_template(
            self,
            value_or_callback: Callable[
                [VolumeClaimTemplate.Builder],
                VolumeClaimTemplate.Builder | VolumeClaimTemplate,
            ],
            /,
        ) -> "Ephemeral.Builder": ...

        @overload
        def volume_claim_template(
            self, value_or_callback: Never = ...
        ) -> "VolumeClaimTemplate.BuilderContext": ...

        def volume_claim_template(self, value_or_callback=None, /):
            """
            Will be used to create a stand-alone PVC to provision the volume.
            The pod in which this EphemeralVolumeSource is embedded will be the
            owner of the PVC, i.e. the PVC will be deleted together with the
            pod.  The name of the PVC will be `<pod name>-<volume name>` where
            `<volume name>` is the name from the `PodSpec.Volumes` array
            entry. Pod validation will reject the pod if the concatenated name
            is not valid for a PVC (for example, too long).

            An existing PVC with that name that is not owned by the pod
            will *not* be used for the pod to avoid using an unrelated
            volume by mistake. Starting the pod is then blocked until
            the unrelated PVC is removed. If such a pre-created PVC is
            meant to be used by the pod, the PVC has to updated with an
            owner reference to the pod once the pod exists. Normally
            this should not be necessary, but it may be useful when
            manually reconstructing a broken cluster.

            This field is read-only and no changes will be made by Kubernetes
            to the PVC after it has been created.

            Required, must not be nil.
            """
            if self._in_context and value_or_callback is None:
                context = VolumeClaimTemplate.BuilderContext()
                context._parent_builder = self
                context._field_name = "volume_claim_template"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VolumeClaimTemplate.builder())
                if isinstance(output, VolumeClaimTemplate.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("volume_claim_template", value)

    class BuilderContext(BuilderContextBase["Ephemeral.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ephemeral.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ephemeral."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ephemeral", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ephemeral.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    volume_claim_template: Annotated[
        Optional[VolumeClaimTemplate], Field(alias="volumeClaimTemplate")
    ] = None
    """
    Will be used to create a stand-alone PVC to provision the volume.
    The pod in which this EphemeralVolumeSource is embedded will be the
    owner of the PVC, i.e. the PVC will be deleted together with the
    pod.  The name of the PVC will be `<pod name>-<volume name>` where
    `<volume name>` is the name from the `PodSpec.Volumes` array
    entry. Pod validation will reject the pod if the concatenated name
    is not valid for a PVC (for example, too long).

    An existing PVC with that name that is not owned by the pod
    will *not* be used for the pod to avoid using an unrelated
    volume by mistake. Starting the pod is then blocked until
    the unrelated PVC is removed. If such a pre-created PVC is
    meant to be used by the pod, the PVC has to updated with an
    owner reference to the pod once the pod exists. Normally
    this should not be necessary, but it may be useful when
    manually reconstructing a broken cluster.

    This field is read-only and no changes will be made by Kubernetes
    to the PVC after it has been created.

    Required, must not be nil.
    """


class Metadata(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Metadata"]:
            return Metadata

        def build(self) -> "Metadata":
            return Metadata(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations is an unstructured key value map stored with a resource that may be
            set by external tools to store and retrieve arbitrary metadata. They are not
            queryable and should be preserved when modifying objects.
            More info: http://kubernetes.io/docs/user-guide/annotations
            """
            return self._set("annotations", value)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Map of string keys and values that can be used to organize and categorize
            (scope and select) objects. May match selectors of replication controllers
            and services.
            More info: http://kubernetes.io/docs/user-guide/labels
            """
            return self._set("labels", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name must be unique within a namespace. Is required when creating resources, although
            some resources may allow a client to request the generation of an appropriate name
            automatically. Name is primarily intended for creation idempotence and configuration
            definition.
            Cannot be updated.
            More info: http://kubernetes.io/docs/user-guide/identifiers#names
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["Metadata.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Metadata.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Metadata."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Metadata", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Metadata.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, str]] = None
    """
    Annotations is an unstructured key value map stored with a resource that may be
    set by external tools to store and retrieve arbitrary metadata. They are not
    queryable and should be preserved when modifying objects.
    More info: http://kubernetes.io/docs/user-guide/annotations
    """
    labels: Optional[Dict[str, str]] = None
    """
    Map of string keys and values that can be used to organize and categorize
    (scope and select) objects. May match selectors of replication controllers
    and services.
    More info: http://kubernetes.io/docs/user-guide/labels
    """
    name: Optional[str] = None
    """
    Name must be unique within a namespace. Is required when creating resources, although
    some resources may allow a client to request the generation of an appropriate name
    automatically. Name is primarily intended for creation idempotence and configuration
    definition.
    Cannot be updated.
    More info: http://kubernetes.io/docs/user-guide/identifiers#names
    """


class LimitsModel7(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel7":
            value = cast(int, self._value)
            return LimitsModel7(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel7.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel7.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel7."""
        return cls.BuilderContext()


class LimitsModel8(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel8":
            value = cast(str, self._value)
            return LimitsModel8(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel8.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel8.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel8."""
        return cls.BuilderContext()


class RequestsModel7(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel7":
            value = cast(int, self._value)
            return RequestsModel7(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel7.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel7.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel7."""
        return cls.BuilderContext()


class RequestsModel8(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel8":
            value = cast(str, self._value)
            return RequestsModel8(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel8.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel8.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel8."""
        return cls.BuilderContext()


class AllocatedResources(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "AllocatedResources":
            value = cast(int, self._value)
            return AllocatedResources(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["AllocatedResources.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllocatedResources.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllocatedResources."""
        return cls.BuilderContext()


class AllocatedResourcesModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "AllocatedResourcesModel":
            value = cast(str, self._value)
            return AllocatedResourcesModel(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["AllocatedResourcesModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllocatedResourcesModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllocatedResourcesModel."""
        return cls.BuilderContext()


class Capacity(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "Capacity":
            value = cast(int, self._value)
            return Capacity(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["Capacity.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Capacity.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Capacity."""
        return cls.BuilderContext()


class CapacityModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "CapacityModel":
            value = cast(str, self._value)
            return CapacityModel(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["CapacityModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CapacityModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CapacityModel."""
        return cls.BuilderContext()


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_probe_time(self, value: Optional[datetime], /) -> Self:
            """
            lastProbeTime is the time we probed the condition.
            """
            return self._set("last_probe_time", value)

        def last_transition_time(self, value: Optional[datetime], /) -> Self:
            """
            lastTransitionTime is the time the condition transitioned from one status to another.
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            message is the human-readable message indicating details about last transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            reason is a unique, this should be a short, machine understandable string that gives the reason
            for condition's last transition. If it reports "Resizing" that means the underlying
            persistent volume is being resized.
            """
            return self._set("reason", value)

        def status(self, value: str, /) -> Self:
            """
            Status is the status of the condition.
            Can be True, False, Unknown.
            More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type is the type of the condition.
            More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_probe_time: Annotated[Optional[datetime], Field(alias="lastProbeTime")] = None
    """
    lastProbeTime is the time we probed the condition.
    """
    last_transition_time: Annotated[Optional[datetime], Field(alias="lastTransitionTime")] = None
    """
    lastTransitionTime is the time the condition transitioned from one status to another.
    """
    message: Optional[str] = None
    """
    message is the human-readable message indicating details about last transition.
    """
    reason: Optional[str] = None
    """
    reason is a unique, this should be a short, machine understandable string that gives the reason
    for condition's last transition. If it reports "Resizing" that means the underlying
    persistent volume is being resized.
    """
    status: str
    """
    Status is the status of the condition.
    Can be True, False, Unknown.
    More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required
    """
    type: str
    """
    Type is the type of the condition.
    More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about
    """


class ModifyVolumeStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ModifyVolumeStatus"]:
            return ModifyVolumeStatus

        def build(self) -> "ModifyVolumeStatus":
            return ModifyVolumeStatus(**self._attrs)

        def status(self, value: str, /) -> Self:
            """
            status is the status of the ControllerModifyVolume operation. It can be in any of following states:
             - Pending
               Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
               the specified VolumeAttributesClass not existing.
             - InProgress
               InProgress indicates that the volume is being modified.
             - Infeasible
              Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
                  resolve the error, a valid VolumeAttributesClass needs to be specified.
            Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
            """
            return self._set("status", value)

        def target_volume_attributes_class_name(self, value: Optional[str], /) -> Self:
            """
            targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
            """
            return self._set("target_volume_attributes_class_name", value)

    class BuilderContext(BuilderContextBase["ModifyVolumeStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ModifyVolumeStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ModifyVolumeStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ModifyVolumeStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ModifyVolumeStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    status: str
    """
    status is the status of the ControllerModifyVolume operation. It can be in any of following states:
     - Pending
       Pending indicates that the PersistentVolumeClaim cannot be modified due to unmet requirements, such as
       the specified VolumeAttributesClass not existing.
     - InProgress
       InProgress indicates that the volume is being modified.
     - Infeasible
      Infeasible indicates that the request has been rejected as invalid by the CSI driver. To
          resolve the error, a valid VolumeAttributesClass needs to be specified.
    Note: New statuses can be added in the future. Consumers should check for unknown statuses and fail appropriately.
    """
    target_volume_attributes_class_name: Annotated[
        Optional[str], Field(alias="targetVolumeAttributesClassName")
    ] = None
    """
    targetVolumeAttributesClassName is the name of the VolumeAttributesClass the PVC currently being reconciled
    """


class Status(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Status"]:
            return Status

        def build(self) -> "Status":
            return Status(**self._attrs)

        def access_modes(self, value: Optional[List[str]], /) -> Self:
            """
            accessModes contains the actual access modes the volume backing the PVC has.
            More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
            """
            return self._set("access_modes", value)

        def allocated_resource_statuses(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            allocatedResourceStatuses stores status of resource being resized for the given PVC.
            Key names follow standard Kubernetes label syntax. Valid values are either:
                * Un-prefixed keys:
                    - storage - the capacity of the volume.
                * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
            Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
            reserved and hence may not be used.

            ClaimResourceStatus can be in any of following states:
                - ControllerResizeInProgress:
                    State set when resize controller starts resizing the volume in control-plane.
                - ControllerResizeFailed:
                    State set when resize has failed in resize controller with a terminal error.
                - NodeResizePending:
                    State set when resize controller has finished resizing the volume but further resizing of
                    volume is needed on the node.
                - NodeResizeInProgress:
                    State set when kubelet starts resizing the volume.
                - NodeResizeFailed:
                    State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
                    NodeResizeFailed.
            For example: if expanding a PVC for more capacity - this field can be one of the following states:
                - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
                 - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
                 - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
                 - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
                 - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
            When this field is not set, it means that no resize operation is in progress for the given PVC.

            A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
            should ignore the update for the purpose it was designed. For example - a controller that
            only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
            resources associated with PVC.

            This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
            """
            return self._set("allocated_resource_statuses", value)

        def allocated_resources(
            self,
            value: Optional[Dict[str, Union[AllocatedResources, AllocatedResourcesModel]]],
            /,
        ) -> Self:
            """
            allocatedResources tracks the resources allocated to a PVC including its capacity.
            Key names follow standard Kubernetes label syntax. Valid values are either:
                * Un-prefixed keys:
                    - storage - the capacity of the volume.
                * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
            Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
            reserved and hence may not be used.

            Capacity reported here may be larger than the actual capacity when a volume expansion operation
            is requested.
            For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
            If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
            If a volume expansion capacity request is lowered, allocatedResources is only
            lowered if there are no expansion operations in progress and if the actual volume capacity
            is equal or lower than the requested capacity.

            A controller that receives PVC update with previously unknown resourceName
            should ignore the update for the purpose it was designed. For example - a controller that
            only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
            resources associated with PVC.

            This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
            """
            return self._set("allocated_resources", value)

        def capacity(self, value: Optional[Dict[str, Union[Capacity, CapacityModel]]], /) -> Self:
            """
            capacity represents the actual resources of the underlying volume.
            """
            return self._set("capacity", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "Status.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "Status.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
            resized then the Condition will be set to 'Resizing'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def current_volume_attributes_class_name(self, value: Optional[str], /) -> Self:
            """
            currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
            When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
            This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
            """
            return self._set("current_volume_attributes_class_name", value)

        @overload
        def modify_volume_status(
            self, value_or_callback: Optional[ModifyVolumeStatus], /
        ) -> "Status.Builder": ...

        @overload
        def modify_volume_status(
            self,
            value_or_callback: Callable[
                [ModifyVolumeStatus.Builder],
                ModifyVolumeStatus.Builder | ModifyVolumeStatus,
            ],
            /,
        ) -> "Status.Builder": ...

        @overload
        def modify_volume_status(
            self, value_or_callback: Never = ...
        ) -> "ModifyVolumeStatus.BuilderContext": ...

        def modify_volume_status(self, value_or_callback=None, /):
            """
            ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
            When this is unset, there is no ModifyVolume operation being attempted.
            This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
            """
            if self._in_context and value_or_callback is None:
                context = ModifyVolumeStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "modify_volume_status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ModifyVolumeStatus.builder())
                if isinstance(output, ModifyVolumeStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("modify_volume_status", value)

        def phase(self, value: Optional[str], /) -> Self:
            """
            phase represents the current phase of PersistentVolumeClaim.
            """
            return self._set("phase", value)

    class BuilderContext(BuilderContextBase["Status.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Status.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Status."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Status", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Status.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_modes: Annotated[Optional[List[str]], Field(alias="accessModes")] = None
    """
    accessModes contains the actual access modes the volume backing the PVC has.
    More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
    """
    allocated_resource_statuses: Annotated[
        Optional[Dict[str, str]], Field(alias="allocatedResourceStatuses")
    ] = None
    """
    allocatedResourceStatuses stores status of resource being resized for the given PVC.
    Key names follow standard Kubernetes label syntax. Valid values are either:
        * Un-prefixed keys:
            - storage - the capacity of the volume.
        * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
    Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
    reserved and hence may not be used.

    ClaimResourceStatus can be in any of following states:
        - ControllerResizeInProgress:
            State set when resize controller starts resizing the volume in control-plane.
        - ControllerResizeFailed:
            State set when resize has failed in resize controller with a terminal error.
        - NodeResizePending:
            State set when resize controller has finished resizing the volume but further resizing of
            volume is needed on the node.
        - NodeResizeInProgress:
            State set when kubelet starts resizing the volume.
        - NodeResizeFailed:
            State set when resizing has failed in kubelet with a terminal error. Transient errors don't set
            NodeResizeFailed.
    For example: if expanding a PVC for more capacity - this field can be one of the following states:
        - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeInProgress"
         - pvc.status.allocatedResourceStatus['storage'] = "ControllerResizeFailed"
         - pvc.status.allocatedResourceStatus['storage'] = "NodeResizePending"
         - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeInProgress"
         - pvc.status.allocatedResourceStatus['storage'] = "NodeResizeFailed"
    When this field is not set, it means that no resize operation is in progress for the given PVC.

    A controller that receives PVC update with previously unknown resourceName or ClaimResourceStatus
    should ignore the update for the purpose it was designed. For example - a controller that
    only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
    resources associated with PVC.

    This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
    """
    allocated_resources: Annotated[
        Optional[Dict[str, Union[AllocatedResources, AllocatedResourcesModel]]],
        Field(alias="allocatedResources"),
    ] = None
    """
    allocatedResources tracks the resources allocated to a PVC including its capacity.
    Key names follow standard Kubernetes label syntax. Valid values are either:
        * Un-prefixed keys:
            - storage - the capacity of the volume.
        * Custom resources must use implementation-defined prefixed names such as "example.com/my-custom-resource"
    Apart from above values - keys that are unprefixed or have kubernetes.io prefix are considered
    reserved and hence may not be used.

    Capacity reported here may be larger than the actual capacity when a volume expansion operation
    is requested.
    For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
    If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
    If a volume expansion capacity request is lowered, allocatedResources is only
    lowered if there are no expansion operations in progress and if the actual volume capacity
    is equal or lower than the requested capacity.

    A controller that receives PVC update with previously unknown resourceName
    should ignore the update for the purpose it was designed. For example - a controller that
    only is responsible for resizing capacity of the volume, should ignore PVC updates that change other valid
    resources associated with PVC.

    This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
    """
    capacity: Optional[Dict[str, Union[Capacity, CapacityModel]]] = None
    """
    capacity represents the actual resources of the underlying volume.
    """
    conditions: Optional[List[Condition]] = None
    """
    conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
    resized then the Condition will be set to 'Resizing'.
    """
    current_volume_attributes_class_name: Annotated[
        Optional[str], Field(alias="currentVolumeAttributesClassName")
    ] = None
    """
    currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using.
    When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim
    This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
    """
    modify_volume_status: Annotated[
        Optional[ModifyVolumeStatus], Field(alias="modifyVolumeStatus")
    ] = None
    """
    ModifyVolumeStatus represents the status object of ControllerModifyVolume operation.
    When this is unset, there is no ModifyVolume operation being attempted.
    This is a beta field and requires enabling VolumeAttributesClass feature (off by default).
    """
    phase: Optional[str] = None
    """
    phase represents the current phase of PersistentVolumeClaim.
    """


class VolumeClaimTemplateModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VolumeClaimTemplateModel"]:
            return VolumeClaimTemplateModel

        def build(self) -> "VolumeClaimTemplateModel":
            return VolumeClaimTemplateModel(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[Metadata], /
        ) -> "VolumeClaimTemplateModel.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[[Metadata.Builder], Metadata.Builder | Metadata],
            /,
        ) -> "VolumeClaimTemplateModel.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "Metadata.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            """
            EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
            """
            if self._in_context and value_or_callback is None:
                context = Metadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Metadata.builder())
                if isinstance(output, Metadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[Spec], /
        ) -> "VolumeClaimTemplateModel.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Callable[[Spec.Builder], Spec.Builder | Spec], /
        ) -> "VolumeClaimTemplateModel.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "Spec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            """
            Defines the desired characteristics of a volume requested by a pod author.
            More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
            """
            if self._in_context and value_or_callback is None:
                context = Spec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Spec.builder())
                if isinstance(output, Spec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[Status], /
        ) -> "VolumeClaimTemplateModel.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[[Status.Builder], Status.Builder | Status],
            /,
        ) -> "VolumeClaimTemplateModel.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "Status.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            """
            Deprecated: this field is never set.
            """
            if self._in_context and value_or_callback is None:
                context = Status.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Status.builder())
                if isinstance(output, Status.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["VolumeClaimTemplateModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VolumeClaimTemplateModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VolumeClaimTemplateModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VolumeClaimTemplateModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VolumeClaimTemplateModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[str] = None
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[Metadata] = None
    """
    EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
    """
    spec: Optional[Spec] = None
    """
    Defines the desired characteristics of a volume requested by a pod author.
    More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
    """
    status: Optional[Status] = None
    """
    Deprecated: this field is never set.
    """


class Storage(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Storage"]:
            return Storage

        def build(self) -> "Storage":
            return Storage(**self._attrs)

        def disable_mount_sub_path(self, value: Optional[bool], /) -> Self:
            """
            Deprecated: subPath usage will be removed in a future release.
            """
            return self._set("disable_mount_sub_path", value)

        @overload
        def empty_dir(self, value_or_callback: Optional[EmptyDir], /) -> "Storage.Builder": ...

        @overload
        def empty_dir(
            self,
            value_or_callback: Callable[[EmptyDir.Builder], EmptyDir.Builder | EmptyDir],
            /,
        ) -> "Storage.Builder": ...

        @overload
        def empty_dir(self, value_or_callback: Never = ...) -> "EmptyDir.BuilderContext": ...

        def empty_dir(self, value_or_callback=None, /):
            """
            EmptyDirVolumeSource to be used by the StatefulSet.
            If specified, it takes precedence over `ephemeral` and `volumeClaimTemplate`.
            More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
            """
            if self._in_context and value_or_callback is None:
                context = EmptyDir.BuilderContext()
                context._parent_builder = self
                context._field_name = "empty_dir"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(EmptyDir.builder())
                if isinstance(output, EmptyDir.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("empty_dir", value)

        @overload
        def ephemeral(self, value_or_callback: Optional[Ephemeral], /) -> "Storage.Builder": ...

        @overload
        def ephemeral(
            self,
            value_or_callback: Callable[[Ephemeral.Builder], Ephemeral.Builder | Ephemeral],
            /,
        ) -> "Storage.Builder": ...

        @overload
        def ephemeral(self, value_or_callback: Never = ...) -> "Ephemeral.BuilderContext": ...

        def ephemeral(self, value_or_callback=None, /):
            """
            EphemeralVolumeSource to be used by the StatefulSet.
            This is a beta field in k8s 1.21 and GA in 1.15.
            For lower versions, starting with k8s 1.19, it requires enabling the GenericEphemeralVolume feature gate.
            More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
            """
            if self._in_context and value_or_callback is None:
                context = Ephemeral.BuilderContext()
                context._parent_builder = self
                context._field_name = "ephemeral"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ephemeral.builder())
                if isinstance(output, Ephemeral.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ephemeral", value)

        @overload
        def volume_claim_template(
            self, value_or_callback: Optional[VolumeClaimTemplateModel], /
        ) -> "Storage.Builder": ...

        @overload
        def volume_claim_template(
            self,
            value_or_callback: Callable[
                [VolumeClaimTemplateModel.Builder],
                VolumeClaimTemplateModel.Builder | VolumeClaimTemplateModel,
            ],
            /,
        ) -> "Storage.Builder": ...

        @overload
        def volume_claim_template(
            self, value_or_callback: Never = ...
        ) -> "VolumeClaimTemplateModel.BuilderContext": ...

        def volume_claim_template(self, value_or_callback=None, /):
            """
            Defines the PVC spec to be used by the Prometheus StatefulSets.
            The easiest way to use a volume that cannot be automatically provisioned
            is to use a label selector alongside manually created PersistentVolumes.
            """
            if self._in_context and value_or_callback is None:
                context = VolumeClaimTemplateModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "volume_claim_template"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VolumeClaimTemplateModel.builder())
                if isinstance(output, VolumeClaimTemplateModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("volume_claim_template", value)

    class BuilderContext(BuilderContextBase["Storage.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Storage.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Storage."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Storage", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Storage.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    disable_mount_sub_path: Annotated[Optional[bool], Field(alias="disableMountSubPath")] = None
    """
    Deprecated: subPath usage will be removed in a future release.
    """
    empty_dir: Annotated[Optional[EmptyDir], Field(alias="emptyDir")] = None
    """
    EmptyDirVolumeSource to be used by the StatefulSet.
    If specified, it takes precedence over `ephemeral` and `volumeClaimTemplate`.
    More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
    """
    ephemeral: Optional[Ephemeral] = None
    """
    EphemeralVolumeSource to be used by the StatefulSet.
    This is a beta field in k8s 1.21 and GA in 1.15.
    For lower versions, starting with k8s 1.19, it requires enabling the GenericEphemeralVolume feature gate.
    More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
    """
    volume_claim_template: Annotated[
        Optional[VolumeClaimTemplateModel], Field(alias="volumeClaimTemplate")
    ] = None
    """
    Defines the PVC spec to be used by the Prometheus StatefulSets.
    The easiest way to use a volume that cannot be automatically provisioned
    is to use a label selector alongside manually created PersistentVolumes.
    """


class Toleration(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Toleration"]:
            return Toleration

        def build(self) -> "Toleration":
            return Toleration(**self._attrs)

        def effect(self, value: Optional[str], /) -> Self:
            """
            Effect indicates the taint effect to match. Empty means match all taint effects.
            When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
            """
            return self._set("effect", value)

        def key(self, value: Optional[str], /) -> Self:
            """
            Key is the taint key that the toleration applies to. Empty means match all taint keys.
            If the key is empty, operator must be Exists; this combination means to match all values and all keys.
            """
            return self._set("key", value)

        def operator(self, value: Optional[str], /) -> Self:
            """
            Operator represents a key's relationship to the value.
            Valid operators are Exists and Equal. Defaults to Equal.
            Exists is equivalent to wildcard for value, so that a pod can
            tolerate all taints of a particular category.
            """
            return self._set("operator", value)

        def toleration_seconds(self, value: Optional[int], /) -> Self:
            """
            TolerationSeconds represents the period of time the toleration (which must be
            of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
            it is not set, which means tolerate the taint forever (do not evict). Zero and
            negative values will be treated as 0 (evict immediately) by the system.
            """
            return self._set("toleration_seconds", value)

        def value(self, value: Optional[str], /) -> Self:
            """
            Value is the taint value the toleration matches to.
            If the operator is Exists, the value should be empty, otherwise just a regular string.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["Toleration.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Toleration.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Toleration."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Toleration", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Toleration.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    effect: Optional[str] = None
    """
    Effect indicates the taint effect to match. Empty means match all taint effects.
    When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    """
    key: Optional[str] = None
    """
    Key is the taint key that the toleration applies to. Empty means match all taint keys.
    If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    """
    operator: Optional[str] = None
    """
    Operator represents a key's relationship to the value.
    Valid operators are Exists and Equal. Defaults to Equal.
    Exists is equivalent to wildcard for value, so that a pod can
    tolerate all taints of a particular category.
    """
    toleration_seconds: Annotated[Optional[int], Field(alias="tolerationSeconds")] = None
    """
    TolerationSeconds represents the period of time the toleration (which must be
    of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    it is not set, which means tolerate the taint forever (do not evict). Zero and
    negative values will be treated as 0 (evict immediately) by the system.
    """
    value: Optional[str] = None
    """
    Value is the taint value the toleration matches to.
    If the operator is Exists, the value should be empty, otherwise just a regular string.
    """


class TopologySpreadConstraint(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TopologySpreadConstraint"]:
            return TopologySpreadConstraint

        def build(self) -> "TopologySpreadConstraint":
            return TopologySpreadConstraint(**self._attrs)

        @overload
        def label_selector(
            self, value_or_callback: Optional[LabelSelector], /
        ) -> "TopologySpreadConstraint.Builder": ...

        @overload
        def label_selector(
            self,
            value_or_callback: Callable[
                [LabelSelector.Builder], LabelSelector.Builder | LabelSelector
            ],
            /,
        ) -> "TopologySpreadConstraint.Builder": ...

        @overload
        def label_selector(
            self, value_or_callback: Never = ...
        ) -> "LabelSelector.BuilderContext": ...

        def label_selector(self, value_or_callback=None, /):
            """
            LabelSelector is used to find matching pods.
            Pods that match this label selector are counted to determine the number of pods
            in their corresponding topology domain.
            """
            if self._in_context and value_or_callback is None:
                context = LabelSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "label_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LabelSelector.builder())
                if isinstance(output, LabelSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("label_selector", value)

        def match_label_keys(self, value: Optional[List[str]], /) -> Self:
            """
            MatchLabelKeys is a set of pod label keys to select the pods over which
            spreading will be calculated. The keys are used to lookup values from the
            incoming pod labels, those key-value labels are ANDed with labelSelector
            to select the group of existing pods over which spreading will be calculated
            for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
            MatchLabelKeys cannot be set when LabelSelector isn't set.
            Keys that don't exist in the incoming pod labels will
            be ignored. A null or empty list means only match against labelSelector.

            This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
            """
            return self._set("match_label_keys", value)

        def max_skew(self, value: int, /) -> Self:
            """
            MaxSkew describes the degree to which pods may be unevenly distributed.
            When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
            between the number of matching pods in the target topology and the global minimum.
            The global minimum is the minimum number of matching pods in an eligible domain
            or zero if the number of eligible domains is less than MinDomains.
            For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
            labelSelector spread as 2/2/1:
            In this case, the global minimum is 1.
            | zone1 | zone2 | zone3 |
            |  P P  |  P P  |   P   |
            - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
            scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
            violate MaxSkew(1).
            - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
            When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
            to topologies that satisfy it.
            It's a required field. Default value is 1 and 0 is not allowed.
            """
            return self._set("max_skew", value)

        def min_domains(self, value: Optional[int], /) -> Self:
            """
            MinDomains indicates a minimum number of eligible domains.
            When the number of eligible domains with matching topology keys is less than minDomains,
            Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
            And when the number of eligible domains with matching topology keys equals or greater than minDomains,
            this value has no effect on scheduling.
            As a result, when the number of eligible domains is less than minDomains,
            scheduler won't schedule more than maxSkew Pods to those domains.
            If value is nil, the constraint behaves as if MinDomains is equal to 1.
            Valid values are integers greater than 0.
            When value is not nil, WhenUnsatisfiable must be DoNotSchedule.

            For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
            labelSelector spread as 2/2/2:
            | zone1 | zone2 | zone3 |
            |  P P  |  P P  |  P P  |
            The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
            In this situation, new pod with the same labelSelector cannot be scheduled,
            because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
            it will violate MaxSkew.
            """
            return self._set("min_domains", value)

        def node_affinity_policy(self, value: Optional[str], /) -> Self:
            """
            NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
            when calculating pod topology spread skew. Options are:
            - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
            - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.

            If this value is nil, the behavior is equivalent to the Honor policy.
            This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
            """
            return self._set("node_affinity_policy", value)

        def node_taints_policy(self, value: Optional[str], /) -> Self:
            """
            NodeTaintsPolicy indicates how we will treat node taints when calculating
            pod topology spread skew. Options are:
            - Honor: nodes without taints, along with tainted nodes for which the incoming pod
            has a toleration, are included.
            - Ignore: node taints are ignored. All nodes are included.

            If this value is nil, the behavior is equivalent to the Ignore policy.
            This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
            """
            return self._set("node_taints_policy", value)

        def topology_key(self, value: str, /) -> Self:
            """
            TopologyKey is the key of node labels. Nodes that have a label with this key
            and identical values are considered to be in the same topology.
            We consider each <key, value> as a "bucket", and try to put balanced number
            of pods into each bucket.
            We define a domain as a particular instance of a topology.
            Also, we define an eligible domain as a domain whose nodes meet the requirements of
            nodeAffinityPolicy and nodeTaintsPolicy.
            e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
            And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
            It's a required field.
            """
            return self._set("topology_key", value)

        def when_unsatisfiable(self, value: str, /) -> Self:
            """
            WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
            the spread constraint.
            - DoNotSchedule (default) tells the scheduler not to schedule it.
            - ScheduleAnyway tells the scheduler to schedule the pod in any location,
              but giving higher precedence to topologies that would help reduce the
              skew.
            A constraint is considered "Unsatisfiable" for an incoming pod
            if and only if every possible node assignment for that pod would violate
            "MaxSkew" on some topology.
            For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
            labelSelector spread as 3/1/1:
            | zone1 | zone2 | zone3 |
            | P P P |   P   |   P   |
            If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
            to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
            MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
            won't make it *more* imbalanced.
            It's a required field.
            """
            return self._set("when_unsatisfiable", value)

    class BuilderContext(BuilderContextBase["TopologySpreadConstraint.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TopologySpreadConstraint.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TopologySpreadConstraint."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TopologySpreadConstraint", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TopologySpreadConstraint.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    label_selector: Annotated[Optional[LabelSelector], Field(alias="labelSelector")] = None
    """
    LabelSelector is used to find matching pods.
    Pods that match this label selector are counted to determine the number of pods
    in their corresponding topology domain.
    """
    match_label_keys: Annotated[Optional[List[str]], Field(alias="matchLabelKeys")] = None
    """
    MatchLabelKeys is a set of pod label keys to select the pods over which
    spreading will be calculated. The keys are used to lookup values from the
    incoming pod labels, those key-value labels are ANDed with labelSelector
    to select the group of existing pods over which spreading will be calculated
    for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
    MatchLabelKeys cannot be set when LabelSelector isn't set.
    Keys that don't exist in the incoming pod labels will
    be ignored. A null or empty list means only match against labelSelector.

    This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
    """
    max_skew: Annotated[int, Field(alias="maxSkew")]
    """
    MaxSkew describes the degree to which pods may be unevenly distributed.
    When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
    between the number of matching pods in the target topology and the global minimum.
    The global minimum is the minimum number of matching pods in an eligible domain
    or zero if the number of eligible domains is less than MinDomains.
    For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
    labelSelector spread as 2/2/1:
    In this case, the global minimum is 1.
    | zone1 | zone2 | zone3 |
    |  P P  |  P P  |   P   |
    - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
    scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
    violate MaxSkew(1).
    - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
    When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
    to topologies that satisfy it.
    It's a required field. Default value is 1 and 0 is not allowed.
    """
    min_domains: Annotated[Optional[int], Field(alias="minDomains")] = None
    """
    MinDomains indicates a minimum number of eligible domains.
    When the number of eligible domains with matching topology keys is less than minDomains,
    Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
    And when the number of eligible domains with matching topology keys equals or greater than minDomains,
    this value has no effect on scheduling.
    As a result, when the number of eligible domains is less than minDomains,
    scheduler won't schedule more than maxSkew Pods to those domains.
    If value is nil, the constraint behaves as if MinDomains is equal to 1.
    Valid values are integers greater than 0.
    When value is not nil, WhenUnsatisfiable must be DoNotSchedule.

    For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
    labelSelector spread as 2/2/2:
    | zone1 | zone2 | zone3 |
    |  P P  |  P P  |  P P  |
    The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
    In this situation, new pod with the same labelSelector cannot be scheduled,
    because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
    it will violate MaxSkew.
    """
    node_affinity_policy: Annotated[Optional[str], Field(alias="nodeAffinityPolicy")] = None
    """
    NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
    when calculating pod topology spread skew. Options are:
    - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
    - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.

    If this value is nil, the behavior is equivalent to the Honor policy.
    This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
    """
    node_taints_policy: Annotated[Optional[str], Field(alias="nodeTaintsPolicy")] = None
    """
    NodeTaintsPolicy indicates how we will treat node taints when calculating
    pod topology spread skew. Options are:
    - Honor: nodes without taints, along with tainted nodes for which the incoming pod
    has a toleration, are included.
    - Ignore: node taints are ignored. All nodes are included.

    If this value is nil, the behavior is equivalent to the Ignore policy.
    This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
    """
    topology_key: Annotated[str, Field(alias="topologyKey")]
    """
    TopologyKey is the key of node labels. Nodes that have a label with this key
    and identical values are considered to be in the same topology.
    We consider each <key, value> as a "bucket", and try to put balanced number
    of pods into each bucket.
    We define a domain as a particular instance of a topology.
    Also, we define an eligible domain as a domain whose nodes meet the requirements of
    nodeAffinityPolicy and nodeTaintsPolicy.
    e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
    And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
    It's a required field.
    """
    when_unsatisfiable: Annotated[str, Field(alias="whenUnsatisfiable")]
    """
    WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
    the spread constraint.
    - DoNotSchedule (default) tells the scheduler not to schedule it.
    - ScheduleAnyway tells the scheduler to schedule the pod in any location,
      but giving higher precedence to topologies that would help reduce the
      skew.
    A constraint is considered "Unsatisfiable" for an incoming pod
    if and only if every possible node assignment for that pod would violate
    "MaxSkew" on some topology.
    For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
    labelSelector spread as 3/1/1:
    | zone1 | zone2 | zone3 |
    | P P P |   P   |   P   |
    If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
    to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
    MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
    won't make it *more* imbalanced.
    It's a required field.
    """


class AwsElasticBlockStore(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AwsElasticBlockStore"]:
            return AwsElasticBlockStore

        def build(self) -> "AwsElasticBlockStore":
            return AwsElasticBlockStore(**self._attrs)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is the filesystem type of the volume that you want to mount.
            Tip: Ensure that the filesystem type is supported by the host operating system.
            Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
            """
            return self._set("fs_type", value)

        def partition(self, value: Optional[int], /) -> Self:
            """
            partition is the partition in the volume that you want to mount.
            If omitted, the default is to mount by volume name.
            Examples: For volume /dev/sda1, you specify the partition as "1".
            Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
            """
            return self._set("partition", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly value true will force the readOnly setting in VolumeMounts.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
            """
            return self._set("read_only", value)

        def volume_id(self, value: str, /) -> Self:
            """
            volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
            More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
            """
            return self._set("volume_id", value)

    class BuilderContext(BuilderContextBase["AwsElasticBlockStore.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AwsElasticBlockStore.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AwsElasticBlockStore."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AwsElasticBlockStore", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AwsElasticBlockStore.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fsType is the filesystem type of the volume that you want to mount.
    Tip: Ensure that the filesystem type is supported by the host operating system.
    Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
    """
    partition: Optional[int] = None
    """
    partition is the partition in the volume that you want to mount.
    If omitted, the default is to mount by volume name.
    Examples: For volume /dev/sda1, you specify the partition as "1".
    Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly value true will force the readOnly setting in VolumeMounts.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
    """
    volume_id: Annotated[str, Field(alias="volumeID")]
    """
    volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
    More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
    """


class AzureDisk(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AzureDisk"]:
            return AzureDisk

        def build(self) -> "AzureDisk":
            return AzureDisk(**self._attrs)

        def caching_mode(self, value: Optional[str], /) -> Self:
            """
            cachingMode is the Host Caching mode: None, Read Only, Read Write.
            """
            return self._set("caching_mode", value)

        def disk_name(self, value: str, /) -> Self:
            """
            diskName is the Name of the data disk in the blob storage
            """
            return self._set("disk_name", value)

        def disk_uri(self, value: str, /) -> Self:
            """
            diskURI is the URI of data disk in the blob storage
            """
            return self._set("disk_uri", value)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is Filesystem type to mount.
            Must be a filesystem type supported by the host operating system.
            Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
            """
            return self._set("fs_type", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
            """
            return self._set("kind", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly Defaults to false (read/write). ReadOnly here will force
            the ReadOnly setting in VolumeMounts.
            """
            return self._set("read_only", value)

    class BuilderContext(BuilderContextBase["AzureDisk.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AzureDisk.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AzureDisk."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AzureDisk", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AzureDisk.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    caching_mode: Annotated[Optional[str], Field(alias="cachingMode")] = None
    """
    cachingMode is the Host Caching mode: None, Read Only, Read Write.
    """
    disk_name: Annotated[str, Field(alias="diskName")]
    """
    diskName is the Name of the data disk in the blob storage
    """
    disk_uri: Annotated[str, Field(alias="diskURI")]
    """
    diskURI is the URI of data disk in the blob storage
    """
    fs_type: Annotated[Optional[str], Field(alias="fsType")] = "ext4"
    """
    fsType is Filesystem type to mount.
    Must be a filesystem type supported by the host operating system.
    Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    """
    kind: Optional[str] = None
    """
    kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = False
    """
    readOnly Defaults to false (read/write). ReadOnly here will force
    the ReadOnly setting in VolumeMounts.
    """


class AzureFile(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AzureFile"]:
            return AzureFile

        def build(self) -> "AzureFile":
            return AzureFile(**self._attrs)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly defaults to false (read/write). ReadOnly here will force
            the ReadOnly setting in VolumeMounts.
            """
            return self._set("read_only", value)

        def secret_name(self, value: str, /) -> Self:
            """
            secretName is the  name of secret that contains Azure Storage Account Name and Key
            """
            return self._set("secret_name", value)

        def share_name(self, value: str, /) -> Self:
            """
            shareName is the azure share Name
            """
            return self._set("share_name", value)

    class BuilderContext(BuilderContextBase["AzureFile.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AzureFile.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AzureFile."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AzureFile", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AzureFile.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly defaults to false (read/write). ReadOnly here will force
    the ReadOnly setting in VolumeMounts.
    """
    secret_name: Annotated[str, Field(alias="secretName")]
    """
    secretName is the  name of secret that contains Azure Storage Account Name and Key
    """
    share_name: Annotated[str, Field(alias="shareName")]
    """
    shareName is the azure share Name
    """


class SecretRefModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretRefModel"]:
            return SecretRefModel

        def build(self) -> "SecretRefModel":
            return SecretRefModel(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["SecretRefModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretRefModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretRefModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretRefModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRefModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """


class Cephfs(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Cephfs"]:
            return Cephfs

        def build(self) -> "Cephfs":
            return Cephfs(**self._attrs)

        def monitors(self, value: List[str], /) -> Self:
            """
            monitors is Required: Monitors is a collection of Ceph monitors
            More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
            """
            return self._set("monitors", value)

        def path(self, value: Optional[str], /) -> Self:
            """
            path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
            """
            return self._set("path", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
            the ReadOnly setting in VolumeMounts.
            More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
            """
            return self._set("read_only", value)

        def secret_file(self, value: Optional[str], /) -> Self:
            """
            secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
            More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
            """
            return self._set("secret_file", value)

        @overload
        def secret_ref(
            self, value_or_callback: Optional[SecretRefModel], /
        ) -> "Cephfs.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[
                [SecretRefModel.Builder], SecretRefModel.Builder | SecretRefModel
            ],
            /,
        ) -> "Cephfs.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRefModel.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
            More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
            """
            if self._in_context and value_or_callback is None:
                context = SecretRefModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRefModel.builder())
                if isinstance(output, SecretRefModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def user(self, value: Optional[str], /) -> Self:
            """
            user is optional: User is the rados user name, default is admin
            More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
            """
            return self._set("user", value)

    class BuilderContext(BuilderContextBase["Cephfs.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Cephfs.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Cephfs."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Cephfs", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Cephfs.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    monitors: List[str]
    """
    monitors is Required: Monitors is a collection of Ceph monitors
    More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    """
    path: Optional[str] = None
    """
    path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
    the ReadOnly setting in VolumeMounts.
    More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    """
    secret_file: Annotated[Optional[str], Field(alias="secretFile")] = None
    """
    secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
    More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    """
    secret_ref: Annotated[Optional[SecretRefModel], Field(alias="secretRef")] = None
    """
    secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
    More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    """
    user: Optional[str] = None
    """
    user is optional: User is the rados user name, default is admin
    More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    """


class Cinder(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Cinder"]:
            return Cinder

        def build(self) -> "Cinder":
            return Cinder(**self._attrs)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is the filesystem type to mount.
            Must be a filesystem type supported by the host operating system.
            Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
            More info: https://examples.k8s.io/mysql-cinder-pd/README.md
            """
            return self._set("fs_type", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly defaults to false (read/write). ReadOnly here will force
            the ReadOnly setting in VolumeMounts.
            More info: https://examples.k8s.io/mysql-cinder-pd/README.md
            """
            return self._set("read_only", value)

        @overload
        def secret_ref(
            self, value_or_callback: Optional[SecretRefModel], /
        ) -> "Cinder.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[
                [SecretRefModel.Builder], SecretRefModel.Builder | SecretRefModel
            ],
            /,
        ) -> "Cinder.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRefModel.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            secretRef is optional: points to a secret object containing parameters used to connect
            to OpenStack.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRefModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRefModel.builder())
                if isinstance(output, SecretRefModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def volume_id(self, value: str, /) -> Self:
            """
            volumeID used to identify the volume in cinder.
            More info: https://examples.k8s.io/mysql-cinder-pd/README.md
            """
            return self._set("volume_id", value)

    class BuilderContext(BuilderContextBase["Cinder.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Cinder.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Cinder."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Cinder", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Cinder.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fsType is the filesystem type to mount.
    Must be a filesystem type supported by the host operating system.
    Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    More info: https://examples.k8s.io/mysql-cinder-pd/README.md
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly defaults to false (read/write). ReadOnly here will force
    the ReadOnly setting in VolumeMounts.
    More info: https://examples.k8s.io/mysql-cinder-pd/README.md
    """
    secret_ref: Annotated[Optional[SecretRefModel], Field(alias="secretRef")] = None
    """
    secretRef is optional: points to a secret object containing parameters used to connect
    to OpenStack.
    """
    volume_id: Annotated[str, Field(alias="volumeID")]
    """
    volumeID used to identify the volume in cinder.
    More info: https://examples.k8s.io/mysql-cinder-pd/README.md
    """


class Item(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Item"]:
            return Item

        def build(self) -> "Item":
            return Item(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key is the key to project.
            """
            return self._set("key", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            mode is Optional: mode bits used to set permissions on this file.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            path is the relative path of the file to map the key to.
            May not be an absolute path.
            May not contain the path element '..'.
            May not start with the string '..'.
            """
            return self._set("path", value)

    class BuilderContext(BuilderContextBase["Item.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Item.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Item."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Item", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Item.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key is the key to project.
    """
    mode: Optional[int] = None
    """
    mode is Optional: mode bits used to set permissions on this file.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    path is the relative path of the file to map the key to.
    May not be an absolute path.
    May not contain the path element '..'.
    May not start with the string '..'.
    """


class ConfigMapModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapModel"]:
            return ConfigMapModel

        def build(self) -> "ConfigMapModel":
            return ConfigMapModel(**self._attrs)

        def default_mode(self, value: Optional[int], /) -> Self:
            """
            defaultMode is optional: mode bits used to set permissions on created files by default.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            Defaults to 0644.
            Directories within the path are not affected by this setting.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("default_mode", value)

        @overload
        def items(self, value_or_callback: List[Item], /) -> "ConfigMapModel.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Item, Item.Builder]],
                GenericListBuilder[Item, Item.Builder] | List[Item],
            ],
            /,
        ) -> "ConfigMapModel.Builder": ...

        @overload
        def items(self, value_or_callback: Never = ...) -> ListBuilderContext[Item.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items if unspecified, each key-value pair in the Data field of the referenced
            ConfigMap will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the ConfigMap,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Item.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Item.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional specify whether the ConfigMap or its keys must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_mode: Annotated[Optional[int], Field(alias="defaultMode")] = None
    """
    defaultMode is optional: mode bits used to set permissions on created files by default.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    Defaults to 0644.
    Directories within the path are not affected by this setting.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    items: Optional[List[Item]] = None
    """
    items if unspecified, each key-value pair in the Data field of the referenced
    ConfigMap will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the ConfigMap,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    optional specify whether the ConfigMap or its keys must be defined
    """


class NodePublishSecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NodePublishSecretRef"]:
            return NodePublishSecretRef

        def build(self) -> "NodePublishSecretRef":
            return NodePublishSecretRef(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["NodePublishSecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NodePublishSecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NodePublishSecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NodePublishSecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NodePublishSecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """


class Csi(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Csi"]:
            return Csi

        def build(self) -> "Csi":
            return Csi(**self._attrs)

        def driver(self, value: str, /) -> Self:
            """
            driver is the name of the CSI driver that handles this volume.
            Consult with your admin for the correct name as registered in the cluster.
            """
            return self._set("driver", value)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType to mount. Ex. "ext4", "xfs", "ntfs".
            If not provided, the empty value is passed to the associated CSI driver
            which will determine the default filesystem to apply.
            """
            return self._set("fs_type", value)

        @overload
        def node_publish_secret_ref(
            self, value_or_callback: Optional[NodePublishSecretRef], /
        ) -> "Csi.Builder": ...

        @overload
        def node_publish_secret_ref(
            self,
            value_or_callback: Callable[
                [NodePublishSecretRef.Builder],
                NodePublishSecretRef.Builder | NodePublishSecretRef,
            ],
            /,
        ) -> "Csi.Builder": ...

        @overload
        def node_publish_secret_ref(
            self, value_or_callback: Never = ...
        ) -> "NodePublishSecretRef.BuilderContext": ...

        def node_publish_secret_ref(self, value_or_callback=None, /):
            """
            nodePublishSecretRef is a reference to the secret object containing
            sensitive information to pass to the CSI driver to complete the CSI
            NodePublishVolume and NodeUnpublishVolume calls.
            This field is optional, and  may be empty if no secret is required. If the
            secret object contains more than one secret, all secret references are passed.
            """
            if self._in_context and value_or_callback is None:
                context = NodePublishSecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "node_publish_secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NodePublishSecretRef.builder())
                if isinstance(output, NodePublishSecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("node_publish_secret_ref", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly specifies a read-only configuration for the volume.
            Defaults to false (read/write).
            """
            return self._set("read_only", value)

        def volume_attributes(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            volumeAttributes stores driver-specific properties that are passed to the CSI
            driver. Consult your driver's documentation for supported values.
            """
            return self._set("volume_attributes", value)

    class BuilderContext(BuilderContextBase["Csi.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Csi.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Csi."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Csi", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Csi.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    driver: str
    """
    driver is the name of the CSI driver that handles this volume.
    Consult with your admin for the correct name as registered in the cluster.
    """
    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fsType to mount. Ex. "ext4", "xfs", "ntfs".
    If not provided, the empty value is passed to the associated CSI driver
    which will determine the default filesystem to apply.
    """
    node_publish_secret_ref: Annotated[
        Optional[NodePublishSecretRef], Field(alias="nodePublishSecretRef")
    ] = None
    """
    nodePublishSecretRef is a reference to the secret object containing
    sensitive information to pass to the CSI driver to complete the CSI
    NodePublishVolume and NodeUnpublishVolume calls.
    This field is optional, and  may be empty if no secret is required. If the
    secret object contains more than one secret, all secret references are passed.
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly specifies a read-only configuration for the volume.
    Defaults to false (read/write).
    """
    volume_attributes: Annotated[Optional[Dict[str, str]], Field(alias="volumeAttributes")] = None
    """
    volumeAttributes stores driver-specific properties that are passed to the CSI
    driver. Consult your driver's documentation for supported values.
    """


class DivisorModel3(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel3":
            value = cast(int, self._value)
            return DivisorModel3(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel3.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel3."""
        return cls.BuilderContext()


class DivisorModel4(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel4":
            value = cast(str, self._value)
            return DivisorModel4(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel4.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel4."""
        return cls.BuilderContext()


class ItemModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ItemModel"]:
            return ItemModel

        def build(self) -> "ItemModel":
            return ItemModel(**self._attrs)

        @overload
        def field_ref(self, value_or_callback: Optional[FieldRef], /) -> "ItemModel.Builder": ...

        @overload
        def field_ref(
            self,
            value_or_callback: Callable[[FieldRef.Builder], FieldRef.Builder | FieldRef],
            /,
        ) -> "ItemModel.Builder": ...

        @overload
        def field_ref(self, value_or_callback: Never = ...) -> "FieldRef.BuilderContext": ...

        def field_ref(self, value_or_callback=None, /):
            """
            Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
            """
            if self._in_context and value_or_callback is None:
                context = FieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FieldRef.builder())
                if isinstance(output, FieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("field_ref", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            Optional: mode bits used to set permissions on this file, must be an octal value
            between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
            """
            return self._set("path", value)

        @overload
        def resource_field_ref(
            self, value_or_callback: Optional[ResourceFieldRef], /
        ) -> "ItemModel.Builder": ...

        @overload
        def resource_field_ref(
            self,
            value_or_callback: Callable[
                [ResourceFieldRef.Builder], ResourceFieldRef.Builder | ResourceFieldRef
            ],
            /,
        ) -> "ItemModel.Builder": ...

        @overload
        def resource_field_ref(
            self, value_or_callback: Never = ...
        ) -> "ResourceFieldRef.BuilderContext": ...

        def resource_field_ref(self, value_or_callback=None, /):
            """
            Selects a resource of the container: only resources limits and requests
            (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceFieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource_field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceFieldRef.builder())
                if isinstance(output, ResourceFieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_field_ref", value)

    class BuilderContext(BuilderContextBase["ItemModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ItemModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ItemModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ItemModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ItemModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    field_ref: Annotated[Optional[FieldRef], Field(alias="fieldRef")] = None
    """
    Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
    """
    mode: Optional[int] = None
    """
    Optional: mode bits used to set permissions on this file, must be an octal value
    between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    """
    resource_field_ref: Annotated[Optional[ResourceFieldRef], Field(alias="resourceFieldRef")] = (
        None
    )
    """
    Selects a resource of the container: only resources limits and requests
    (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    """


class DownwardApi(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DownwardApi"]:
            return DownwardApi

        def build(self) -> "DownwardApi":
            return DownwardApi(**self._attrs)

        def default_mode(self, value: Optional[int], /) -> Self:
            """
            Optional: mode bits to use on created files by default. Must be a
            Optional: mode bits used to set permissions on created files by default.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            Defaults to 0644.
            Directories within the path are not affected by this setting.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("default_mode", value)

        @overload
        def items(self, value_or_callback: List[ItemModel], /) -> "DownwardApi.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel, ItemModel.Builder]],
                GenericListBuilder[ItemModel, ItemModel.Builder] | List[ItemModel],
            ],
            /,
        ) -> "DownwardApi.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            Items is a list of downward API volume file
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

    class BuilderContext(BuilderContextBase["DownwardApi.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DownwardApi.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DownwardApi."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DownwardApi", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DownwardApi.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_mode: Annotated[Optional[int], Field(alias="defaultMode")] = None
    """
    Optional: mode bits to use on created files by default. Must be a
    Optional: mode bits used to set permissions on created files by default.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    Defaults to 0644.
    Directories within the path are not affected by this setting.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    items: Optional[List[ItemModel]] = None
    """
    Items is a list of downward API volume file
    """


class SizeLimitModel1(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def build(self) -> "SizeLimitModel1":
            value = cast(int, self._value)
            return SizeLimitModel1(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    sizeLimit is the total amount of local storage required for this EmptyDir volume.
    The size limit is also applicable for memory medium.
    The maximum usage on memory medium EmptyDir would be the minimum value between
    the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    The default is nil which means that the limit is undefined.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    """

    class BuilderContext(BuilderContextBase["SizeLimitModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SizeLimitModel1.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SizeLimitModel1."""
        return cls.BuilderContext()


class SizeLimitModel2(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def build(self) -> "SizeLimitModel2":
            value = cast(str, self._value)
            return SizeLimitModel2(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    sizeLimit is the total amount of local storage required for this EmptyDir volume.
    The size limit is also applicable for memory medium.
    The maximum usage on memory medium EmptyDir would be the minimum value between
    the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    The default is nil which means that the limit is undefined.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    """

    class BuilderContext(BuilderContextBase["SizeLimitModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SizeLimitModel2.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SizeLimitModel2."""
        return cls.BuilderContext()


class LimitsModel9(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel9":
            value = cast(int, self._value)
            return LimitsModel9(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel9.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel9.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel9."""
        return cls.BuilderContext()


class LimitsModel10(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel10":
            value = cast(str, self._value)
            return LimitsModel10(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel10.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel10.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel10."""
        return cls.BuilderContext()


class RequestsModel9(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel9":
            value = cast(int, self._value)
            return RequestsModel9(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel9.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel9.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel9."""
        return cls.BuilderContext()


class RequestsModel10(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel10":
            value = cast(str, self._value)
            return RequestsModel10(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel10.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel10.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel10."""
        return cls.BuilderContext()


class VolumeClaimTemplateModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VolumeClaimTemplateModel1"]:
            return VolumeClaimTemplateModel1

        def build(self) -> "VolumeClaimTemplateModel1":
            return VolumeClaimTemplateModel1(**self._attrs)

        def metadata(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            May contain labels and annotations that will be copied into the PVC
            when creating it. No other fields are allowed and will be rejected during
            validation.
            """
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Spec, /) -> "VolumeClaimTemplateModel1.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Callable[[Spec.Builder], Spec.Builder | Spec], /
        ) -> "VolumeClaimTemplateModel1.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "Spec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            """
            The specification for the PersistentVolumeClaim. The entire content is
            copied unchanged into the PVC that gets created from this
            template. The same fields as in a PersistentVolumeClaim
            are also valid here.
            """
            if self._in_context and value_or_callback is None:
                context = Spec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Spec.builder())
                if isinstance(output, Spec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["VolumeClaimTemplateModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VolumeClaimTemplateModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VolumeClaimTemplateModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VolumeClaimTemplateModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VolumeClaimTemplateModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    metadata: Optional[Dict[str, Any]] = None
    """
    May contain labels and annotations that will be copied into the PVC
    when creating it. No other fields are allowed and will be rejected during
    validation.
    """
    spec: Spec
    """
    The specification for the PersistentVolumeClaim. The entire content is
    copied unchanged into the PVC that gets created from this
    template. The same fields as in a PersistentVolumeClaim
    are also valid here.
    """


class Fc(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Fc"]:
            return Fc

        def build(self) -> "Fc":
            return Fc(**self._attrs)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is the filesystem type to mount.
            Must be a filesystem type supported by the host operating system.
            Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
            """
            return self._set("fs_type", value)

        def lun(self, value: Optional[int], /) -> Self:
            """
            lun is Optional: FC target lun number
            """
            return self._set("lun", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
            the ReadOnly setting in VolumeMounts.
            """
            return self._set("read_only", value)

        def target_ww_ns(self, value: Optional[List[str]], /) -> Self:
            """
            targetWWNs is Optional: FC target worldwide names (WWNs)
            """
            return self._set("target_ww_ns", value)

        def wwids(self, value: Optional[List[str]], /) -> Self:
            """
            wwids Optional: FC volume world wide identifiers (wwids)
            Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
            """
            return self._set("wwids", value)

    class BuilderContext(BuilderContextBase["Fc.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Fc.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Fc."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Fc", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Fc.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fsType is the filesystem type to mount.
    Must be a filesystem type supported by the host operating system.
    Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    """
    lun: Optional[int] = None
    """
    lun is Optional: FC target lun number
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
    the ReadOnly setting in VolumeMounts.
    """
    target_ww_ns: Annotated[Optional[List[str]], Field(alias="targetWWNs")] = None
    """
    targetWWNs is Optional: FC target worldwide names (WWNs)
    """
    wwids: Optional[List[str]] = None
    """
    wwids Optional: FC volume world wide identifiers (wwids)
    Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
    """


class FlexVolume(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FlexVolume"]:
            return FlexVolume

        def build(self) -> "FlexVolume":
            return FlexVolume(**self._attrs)

        def driver(self, value: str, /) -> Self:
            """
            driver is the name of the driver to use for this volume.
            """
            return self._set("driver", value)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is the filesystem type to mount.
            Must be a filesystem type supported by the host operating system.
            Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
            """
            return self._set("fs_type", value)

        def options(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            options is Optional: this field holds extra command options if any.
            """
            return self._set("options", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly is Optional: defaults to false (read/write). ReadOnly here will force
            the ReadOnly setting in VolumeMounts.
            """
            return self._set("read_only", value)

        @overload
        def secret_ref(
            self, value_or_callback: Optional[SecretRefModel], /
        ) -> "FlexVolume.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[
                [SecretRefModel.Builder], SecretRefModel.Builder | SecretRefModel
            ],
            /,
        ) -> "FlexVolume.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRefModel.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            secretRef is Optional: secretRef is reference to the secret object containing
            sensitive information to pass to the plugin scripts. This may be
            empty if no secret object is specified. If the secret object
            contains more than one secret, all secrets are passed to the plugin
            scripts.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRefModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRefModel.builder())
                if isinstance(output, SecretRefModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

    class BuilderContext(BuilderContextBase["FlexVolume.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FlexVolume.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FlexVolume."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FlexVolume", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FlexVolume.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    driver: str
    """
    driver is the name of the driver to use for this volume.
    """
    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fsType is the filesystem type to mount.
    Must be a filesystem type supported by the host operating system.
    Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
    """
    options: Optional[Dict[str, str]] = None
    """
    options is Optional: this field holds extra command options if any.
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly is Optional: defaults to false (read/write). ReadOnly here will force
    the ReadOnly setting in VolumeMounts.
    """
    secret_ref: Annotated[Optional[SecretRefModel], Field(alias="secretRef")] = None
    """
    secretRef is Optional: secretRef is reference to the secret object containing
    sensitive information to pass to the plugin scripts. This may be
    empty if no secret object is specified. If the secret object
    contains more than one secret, all secrets are passed to the plugin
    scripts.
    """


class Flocker(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Flocker"]:
            return Flocker

        def build(self) -> "Flocker":
            return Flocker(**self._attrs)

        def dataset_name(self, value: Optional[str], /) -> Self:
            """
            datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
            should be considered as deprecated
            """
            return self._set("dataset_name", value)

        def dataset_uuid(self, value: Optional[str], /) -> Self:
            """
            datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
            """
            return self._set("dataset_uuid", value)

    class BuilderContext(BuilderContextBase["Flocker.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Flocker.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Flocker."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Flocker", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Flocker.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    dataset_name: Annotated[Optional[str], Field(alias="datasetName")] = None
    """
    datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
    should be considered as deprecated
    """
    dataset_uuid: Annotated[Optional[str], Field(alias="datasetUUID")] = None
    """
    datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
    """


class GcePersistentDisk(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GcePersistentDisk"]:
            return GcePersistentDisk

        def build(self) -> "GcePersistentDisk":
            return GcePersistentDisk(**self._attrs)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is filesystem type of the volume that you want to mount.
            Tip: Ensure that the filesystem type is supported by the host operating system.
            Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
            """
            return self._set("fs_type", value)

        def partition(self, value: Optional[int], /) -> Self:
            """
            partition is the partition in the volume that you want to mount.
            If omitted, the default is to mount by volume name.
            Examples: For volume /dev/sda1, you specify the partition as "1".
            Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
            More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
            """
            return self._set("partition", value)

        def pd_name(self, value: str, /) -> Self:
            """
            pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
            """
            return self._set("pd_name", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly here will force the ReadOnly setting in VolumeMounts.
            Defaults to false.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
            """
            return self._set("read_only", value)

    class BuilderContext(BuilderContextBase["GcePersistentDisk.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GcePersistentDisk.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GcePersistentDisk."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GcePersistentDisk", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GcePersistentDisk.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fsType is filesystem type of the volume that you want to mount.
    Tip: Ensure that the filesystem type is supported by the host operating system.
    Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
    """
    partition: Optional[int] = None
    """
    partition is the partition in the volume that you want to mount.
    If omitted, the default is to mount by volume name.
    Examples: For volume /dev/sda1, you specify the partition as "1".
    Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
    More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
    """
    pd_name: Annotated[str, Field(alias="pdName")]
    """
    pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly here will force the ReadOnly setting in VolumeMounts.
    Defaults to false.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
    """


class GitRepo(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GitRepo"]:
            return GitRepo

        def build(self) -> "GitRepo":
            return GitRepo(**self._attrs)

        def directory(self, value: Optional[str], /) -> Self:
            """
            directory is the target directory name.
            Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
            git repository.  Otherwise, if specified, the volume will contain the git repository in
            the subdirectory with the given name.
            """
            return self._set("directory", value)

        def repository(self, value: str, /) -> Self:
            """
            repository is the URL
            """
            return self._set("repository", value)

        def revision(self, value: Optional[str], /) -> Self:
            """
            revision is the commit hash for the specified revision.
            """
            return self._set("revision", value)

    class BuilderContext(BuilderContextBase["GitRepo.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GitRepo.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GitRepo."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GitRepo", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GitRepo.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    directory: Optional[str] = None
    """
    directory is the target directory name.
    Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
    git repository.  Otherwise, if specified, the volume will contain the git repository in
    the subdirectory with the given name.
    """
    repository: str
    """
    repository is the URL
    """
    revision: Optional[str] = None
    """
    revision is the commit hash for the specified revision.
    """


class Glusterfs(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Glusterfs"]:
            return Glusterfs

        def build(self) -> "Glusterfs":
            return Glusterfs(**self._attrs)

        def endpoints(self, value: str, /) -> Self:
            """
            endpoints is the endpoint name that details Glusterfs topology.
            More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
            """
            return self._set("endpoints", value)

        def path(self, value: str, /) -> Self:
            """
            path is the Glusterfs volume path.
            More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
            """
            return self._set("path", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
            Defaults to false.
            More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
            """
            return self._set("read_only", value)

    class BuilderContext(BuilderContextBase["Glusterfs.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Glusterfs.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Glusterfs."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Glusterfs", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Glusterfs.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    endpoints: str
    """
    endpoints is the endpoint name that details Glusterfs topology.
    More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
    """
    path: str
    """
    path is the Glusterfs volume path.
    More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
    Defaults to false.
    More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
    """


class HostPath(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HostPath"]:
            return HostPath

        def build(self) -> "HostPath":
            return HostPath(**self._attrs)

        def path(self, value: str, /) -> Self:
            """
            path of the directory on the host.
            If the path is a symlink, it will follow the link to the real path.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
            """
            return self._set("path", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            type for HostPath Volume
            Defaults to ""
            More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["HostPath.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HostPath.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HostPath."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HostPath", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HostPath.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    path: str
    """
    path of the directory on the host.
    If the path is a symlink, it will follow the link to the real path.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
    """
    type: Optional[str] = None
    """
    type for HostPath Volume
    Defaults to ""
    More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
    """


class Image(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Image"]:
            return Image

        def build(self) -> "Image":
            return Image(**self._attrs)

        def pull_policy(self, value: Optional[str], /) -> Self:
            """
            Policy for pulling OCI objects. Possible values are:
            Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
            Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
            IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
            Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
            """
            return self._set("pull_policy", value)

        def reference(self, value: Optional[str], /) -> Self:
            """
            Required: Image or artifact reference to be used.
            Behaves in the same way as pod.spec.containers[*].image.
            Pull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.
            More info: https://kubernetes.io/docs/concepts/containers/images
            This field is optional to allow higher level config management to default or override
            container images in workload controllers like Deployments and StatefulSets.
            """
            return self._set("reference", value)

    class BuilderContext(BuilderContextBase["Image.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Image.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Image."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Image", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Image.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    pull_policy: Annotated[Optional[str], Field(alias="pullPolicy")] = None
    """
    Policy for pulling OCI objects. Possible values are:
    Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
    Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
    IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
    Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    """
    reference: Optional[str] = None
    """
    Required: Image or artifact reference to be used.
    Behaves in the same way as pod.spec.containers[*].image.
    Pull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.
    More info: https://kubernetes.io/docs/concepts/containers/images
    This field is optional to allow higher level config management to default or override
    container images in workload controllers like Deployments and StatefulSets.
    """


class Iscsi(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Iscsi"]:
            return Iscsi

        def build(self) -> "Iscsi":
            return Iscsi(**self._attrs)

        def chap_auth_discovery(self, value: Optional[bool], /) -> Self:
            """
            chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
            """
            return self._set("chap_auth_discovery", value)

        def chap_auth_session(self, value: Optional[bool], /) -> Self:
            """
            chapAuthSession defines whether support iSCSI Session CHAP authentication
            """
            return self._set("chap_auth_session", value)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is the filesystem type of the volume that you want to mount.
            Tip: Ensure that the filesystem type is supported by the host operating system.
            Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
            """
            return self._set("fs_type", value)

        def initiator_name(self, value: Optional[str], /) -> Self:
            """
            initiatorName is the custom iSCSI Initiator Name.
            If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
            <target portal>:<volume name> will be created for the connection.
            """
            return self._set("initiator_name", value)

        def iqn(self, value: str, /) -> Self:
            """
            iqn is the target iSCSI Qualified Name.
            """
            return self._set("iqn", value)

        def iscsi_interface(self, value: Optional[str], /) -> Self:
            """
            iscsiInterface is the interface Name that uses an iSCSI transport.
            Defaults to 'default' (tcp).
            """
            return self._set("iscsi_interface", value)

        def lun(self, value: int, /) -> Self:
            """
            lun represents iSCSI Target Lun number.
            """
            return self._set("lun", value)

        def portals(self, value: Optional[List[str]], /) -> Self:
            """
            portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
            is other than default (typically TCP ports 860 and 3260).
            """
            return self._set("portals", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly here will force the ReadOnly setting in VolumeMounts.
            Defaults to false.
            """
            return self._set("read_only", value)

        @overload
        def secret_ref(self, value_or_callback: Optional[SecretRefModel], /) -> "Iscsi.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[
                [SecretRefModel.Builder], SecretRefModel.Builder | SecretRefModel
            ],
            /,
        ) -> "Iscsi.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRefModel.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            secretRef is the CHAP Secret for iSCSI target and initiator authentication
            """
            if self._in_context and value_or_callback is None:
                context = SecretRefModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRefModel.builder())
                if isinstance(output, SecretRefModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def target_portal(self, value: str, /) -> Self:
            """
            targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
            is other than default (typically TCP ports 860 and 3260).
            """
            return self._set("target_portal", value)

    class BuilderContext(BuilderContextBase["Iscsi.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Iscsi.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Iscsi."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Iscsi", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Iscsi.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    chap_auth_discovery: Annotated[Optional[bool], Field(alias="chapAuthDiscovery")] = None
    """
    chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
    """
    chap_auth_session: Annotated[Optional[bool], Field(alias="chapAuthSession")] = None
    """
    chapAuthSession defines whether support iSCSI Session CHAP authentication
    """
    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fsType is the filesystem type of the volume that you want to mount.
    Tip: Ensure that the filesystem type is supported by the host operating system.
    Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
    """
    initiator_name: Annotated[Optional[str], Field(alias="initiatorName")] = None
    """
    initiatorName is the custom iSCSI Initiator Name.
    If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
    <target portal>:<volume name> will be created for the connection.
    """
    iqn: str
    """
    iqn is the target iSCSI Qualified Name.
    """
    iscsi_interface: Annotated[Optional[str], Field(alias="iscsiInterface")] = "default"
    """
    iscsiInterface is the interface Name that uses an iSCSI transport.
    Defaults to 'default' (tcp).
    """
    lun: int
    """
    lun represents iSCSI Target Lun number.
    """
    portals: Optional[List[str]] = None
    """
    portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
    is other than default (typically TCP ports 860 and 3260).
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly here will force the ReadOnly setting in VolumeMounts.
    Defaults to false.
    """
    secret_ref: Annotated[Optional[SecretRefModel], Field(alias="secretRef")] = None
    """
    secretRef is the CHAP Secret for iSCSI target and initiator authentication
    """
    target_portal: Annotated[str, Field(alias="targetPortal")]
    """
    targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
    is other than default (typically TCP ports 860 and 3260).
    """


class Nfs(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Nfs"]:
            return Nfs

        def build(self) -> "Nfs":
            return Nfs(**self._attrs)

        def path(self, value: str, /) -> Self:
            """
            path that is exported by the NFS server.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
            """
            return self._set("path", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly here will force the NFS export to be mounted with read-only permissions.
            Defaults to false.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
            """
            return self._set("read_only", value)

        def server(self, value: str, /) -> Self:
            """
            server is the hostname or IP address of the NFS server.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
            """
            return self._set("server", value)

    class BuilderContext(BuilderContextBase["Nfs.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Nfs.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Nfs."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Nfs", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Nfs.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    path: str
    """
    path that is exported by the NFS server.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly here will force the NFS export to be mounted with read-only permissions.
    Defaults to false.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
    """
    server: str
    """
    server is the hostname or IP address of the NFS server.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
    """


class PersistentVolumeClaim(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PersistentVolumeClaim"]:
            return PersistentVolumeClaim

        def build(self) -> "PersistentVolumeClaim":
            return PersistentVolumeClaim(**self._attrs)

        def claim_name(self, value: str, /) -> Self:
            """
            claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
            More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
            """
            return self._set("claim_name", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly Will force the ReadOnly setting in VolumeMounts.
            Default false.
            """
            return self._set("read_only", value)

    class BuilderContext(BuilderContextBase["PersistentVolumeClaim.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PersistentVolumeClaim.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PersistentVolumeClaim."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PersistentVolumeClaim", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PersistentVolumeClaim.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    claim_name: Annotated[str, Field(alias="claimName")]
    """
    claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
    More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly Will force the ReadOnly setting in VolumeMounts.
    Default false.
    """


class PhotonPersistentDisk(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PhotonPersistentDisk"]:
            return PhotonPersistentDisk

        def build(self) -> "PhotonPersistentDisk":
            return PhotonPersistentDisk(**self._attrs)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is the filesystem type to mount.
            Must be a filesystem type supported by the host operating system.
            Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
            """
            return self._set("fs_type", value)

        def pd_id(self, value: str, /) -> Self:
            """
            pdID is the ID that identifies Photon Controller persistent disk
            """
            return self._set("pd_id", value)

    class BuilderContext(BuilderContextBase["PhotonPersistentDisk.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PhotonPersistentDisk.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PhotonPersistentDisk."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PhotonPersistentDisk", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PhotonPersistentDisk.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fsType is the filesystem type to mount.
    Must be a filesystem type supported by the host operating system.
    Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    """
    pd_id: Annotated[str, Field(alias="pdID")]
    """
    pdID is the ID that identifies Photon Controller persistent disk
    """


class PortworxVolume(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PortworxVolume"]:
            return PortworxVolume

        def build(self) -> "PortworxVolume":
            return PortworxVolume(**self._attrs)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fSType represents the filesystem type to mount
            Must be a filesystem type supported by the host operating system.
            Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
            """
            return self._set("fs_type", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly defaults to false (read/write). ReadOnly here will force
            the ReadOnly setting in VolumeMounts.
            """
            return self._set("read_only", value)

        def volume_id(self, value: str, /) -> Self:
            """
            volumeID uniquely identifies a Portworx volume
            """
            return self._set("volume_id", value)

    class BuilderContext(BuilderContextBase["PortworxVolume.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PortworxVolume.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PortworxVolume."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PortworxVolume", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PortworxVolume.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fSType represents the filesystem type to mount
    Must be a filesystem type supported by the host operating system.
    Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly defaults to false (read/write). ReadOnly here will force
    the ReadOnly setting in VolumeMounts.
    """
    volume_id: Annotated[str, Field(alias="volumeID")]
    """
    volumeID uniquely identifies a Portworx volume
    """


class ClusterTrustBundle(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterTrustBundle"]:
            return ClusterTrustBundle

        def build(self) -> "ClusterTrustBundle":
            return ClusterTrustBundle(**self._attrs)

        @overload
        def label_selector(
            self, value_or_callback: Optional[LabelSelector], /
        ) -> "ClusterTrustBundle.Builder": ...

        @overload
        def label_selector(
            self,
            value_or_callback: Callable[
                [LabelSelector.Builder], LabelSelector.Builder | LabelSelector
            ],
            /,
        ) -> "ClusterTrustBundle.Builder": ...

        @overload
        def label_selector(
            self, value_or_callback: Never = ...
        ) -> "LabelSelector.BuilderContext": ...

        def label_selector(self, value_or_callback=None, /):
            """
            Select all ClusterTrustBundles that match this label selector.  Only has
            effect if signerName is set.  Mutually-exclusive with name.  If unset,
            interpreted as "match nothing".  If set but empty, interpreted as "match
            everything".
            """
            if self._in_context and value_or_callback is None:
                context = LabelSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "label_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LabelSelector.builder())
                if isinstance(output, LabelSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("label_selector", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Select a single ClusterTrustBundle by object name.  Mutually-exclusive
            with signerName and labelSelector.
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            If true, don't block pod startup if the referenced ClusterTrustBundle(s)
            aren't available.  If using name, then the named ClusterTrustBundle is
            allowed not to exist.  If using signerName, then the combination of
            signerName and labelSelector is allowed to match zero
            ClusterTrustBundles.
            """
            return self._set("optional", value)

        def path(self, value: str, /) -> Self:
            """
            Relative path from the volume root to write the bundle.
            """
            return self._set("path", value)

        def signer_name(self, value: Optional[str], /) -> Self:
            """
            Select all ClusterTrustBundles that match this signer name.
            Mutually-exclusive with name.  The contents of all selected
            ClusterTrustBundles will be unified and deduplicated.
            """
            return self._set("signer_name", value)

    class BuilderContext(BuilderContextBase["ClusterTrustBundle.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterTrustBundle.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterTrustBundle."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterTrustBundle", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterTrustBundle.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    label_selector: Annotated[Optional[LabelSelector], Field(alias="labelSelector")] = None
    """
    Select all ClusterTrustBundles that match this label selector.  Only has
    effect if signerName is set.  Mutually-exclusive with name.  If unset,
    interpreted as "match nothing".  If set but empty, interpreted as "match
    everything".
    """
    name: Optional[str] = None
    """
    Select a single ClusterTrustBundle by object name.  Mutually-exclusive
    with signerName and labelSelector.
    """
    optional: Optional[bool] = None
    """
    If true, don't block pod startup if the referenced ClusterTrustBundle(s)
    aren't available.  If using name, then the named ClusterTrustBundle is
    allowed not to exist.  If using signerName, then the combination of
    signerName and labelSelector is allowed to match zero
    ClusterTrustBundles.
    """
    path: str
    """
    Relative path from the volume root to write the bundle.
    """
    signer_name: Annotated[Optional[str], Field(alias="signerName")] = None
    """
    Select all ClusterTrustBundles that match this signer name.
    Mutually-exclusive with name.  The contents of all selected
    ClusterTrustBundles will be unified and deduplicated.
    """


class ItemModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ItemModel1"]:
            return ItemModel1

        def build(self) -> "ItemModel1":
            return ItemModel1(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key is the key to project.
            """
            return self._set("key", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            mode is Optional: mode bits used to set permissions on this file.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            path is the relative path of the file to map the key to.
            May not be an absolute path.
            May not contain the path element '..'.
            May not start with the string '..'.
            """
            return self._set("path", value)

    class BuilderContext(BuilderContextBase["ItemModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ItemModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ItemModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ItemModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ItemModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key is the key to project.
    """
    mode: Optional[int] = None
    """
    mode is Optional: mode bits used to set permissions on this file.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    path is the relative path of the file to map the key to.
    May not be an absolute path.
    May not contain the path element '..'.
    May not start with the string '..'.
    """


class ConfigMapModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapModel1"]:
            return ConfigMapModel1

        def build(self) -> "ConfigMapModel1":
            return ConfigMapModel1(**self._attrs)

        @overload
        def items(self, value_or_callback: List[ItemModel1], /) -> "ConfigMapModel1.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel1, ItemModel1.Builder]],
                GenericListBuilder[ItemModel1, ItemModel1.Builder] | List[ItemModel1],
            ],
            /,
        ) -> "ConfigMapModel1.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel1.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items if unspecified, each key-value pair in the Data field of the referenced
            ConfigMap will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the ConfigMap,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel1.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel1.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional specify whether the ConfigMap or its keys must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    items: Optional[List[ItemModel1]] = None
    """
    items if unspecified, each key-value pair in the Data field of the referenced
    ConfigMap will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the ConfigMap,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    optional specify whether the ConfigMap or its keys must be defined
    """


class DivisorModel5(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel5":
            value = cast(int, self._value)
            return DivisorModel5(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel5.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel5."""
        return cls.BuilderContext()


class DivisorModel6(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel6":
            value = cast(str, self._value)
            return DivisorModel6(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel6.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel6.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel6."""
        return cls.BuilderContext()


class ItemModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ItemModel2"]:
            return ItemModel2

        def build(self) -> "ItemModel2":
            return ItemModel2(**self._attrs)

        @overload
        def field_ref(self, value_or_callback: Optional[FieldRef], /) -> "ItemModel2.Builder": ...

        @overload
        def field_ref(
            self,
            value_or_callback: Callable[[FieldRef.Builder], FieldRef.Builder | FieldRef],
            /,
        ) -> "ItemModel2.Builder": ...

        @overload
        def field_ref(self, value_or_callback: Never = ...) -> "FieldRef.BuilderContext": ...

        def field_ref(self, value_or_callback=None, /):
            """
            Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
            """
            if self._in_context and value_or_callback is None:
                context = FieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FieldRef.builder())
                if isinstance(output, FieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("field_ref", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            Optional: mode bits used to set permissions on this file, must be an octal value
            between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
            """
            return self._set("path", value)

        @overload
        def resource_field_ref(
            self, value_or_callback: Optional[ResourceFieldRef], /
        ) -> "ItemModel2.Builder": ...

        @overload
        def resource_field_ref(
            self,
            value_or_callback: Callable[
                [ResourceFieldRef.Builder], ResourceFieldRef.Builder | ResourceFieldRef
            ],
            /,
        ) -> "ItemModel2.Builder": ...

        @overload
        def resource_field_ref(
            self, value_or_callback: Never = ...
        ) -> "ResourceFieldRef.BuilderContext": ...

        def resource_field_ref(self, value_or_callback=None, /):
            """
            Selects a resource of the container: only resources limits and requests
            (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceFieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource_field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceFieldRef.builder())
                if isinstance(output, ResourceFieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_field_ref", value)

    class BuilderContext(BuilderContextBase["ItemModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ItemModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ItemModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ItemModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ItemModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    field_ref: Annotated[Optional[FieldRef], Field(alias="fieldRef")] = None
    """
    Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
    """
    mode: Optional[int] = None
    """
    Optional: mode bits used to set permissions on this file, must be an octal value
    between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    """
    resource_field_ref: Annotated[Optional[ResourceFieldRef], Field(alias="resourceFieldRef")] = (
        None
    )
    """
    Selects a resource of the container: only resources limits and requests
    (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    """


class DownwardApiModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DownwardApiModel"]:
            return DownwardApiModel

        def build(self) -> "DownwardApiModel":
            return DownwardApiModel(**self._attrs)

        @overload
        def items(self, value_or_callback: List[ItemModel2], /) -> "DownwardApiModel.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel2, ItemModel2.Builder]],
                GenericListBuilder[ItemModel2, ItemModel2.Builder] | List[ItemModel2],
            ],
            /,
        ) -> "DownwardApiModel.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel2.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            Items is a list of DownwardAPIVolume file
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel2.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel2.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

    class BuilderContext(BuilderContextBase["DownwardApiModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DownwardApiModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DownwardApiModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DownwardApiModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DownwardApiModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    items: Optional[List[ItemModel2]] = None
    """
    Items is a list of DownwardAPIVolume file
    """


class ItemModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ItemModel3"]:
            return ItemModel3

        def build(self) -> "ItemModel3":
            return ItemModel3(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key is the key to project.
            """
            return self._set("key", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            mode is Optional: mode bits used to set permissions on this file.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            path is the relative path of the file to map the key to.
            May not be an absolute path.
            May not contain the path element '..'.
            May not start with the string '..'.
            """
            return self._set("path", value)

    class BuilderContext(BuilderContextBase["ItemModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ItemModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ItemModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ItemModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ItemModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key is the key to project.
    """
    mode: Optional[int] = None
    """
    mode is Optional: mode bits used to set permissions on this file.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    path is the relative path of the file to map the key to.
    May not be an absolute path.
    May not contain the path element '..'.
    May not start with the string '..'.
    """


class SecretModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretModel"]:
            return SecretModel

        def build(self) -> "SecretModel":
            return SecretModel(**self._attrs)

        @overload
        def items(self, value_or_callback: List[ItemModel3], /) -> "SecretModel.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel3, ItemModel3.Builder]],
                GenericListBuilder[ItemModel3, ItemModel3.Builder] | List[ItemModel3],
            ],
            /,
        ) -> "SecretModel.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel3.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items if unspecified, each key-value pair in the Data field of the referenced
            Secret will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the Secret,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel3.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel3.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional field specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["SecretModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    items: Optional[List[ItemModel3]] = None
    """
    items if unspecified, each key-value pair in the Data field of the referenced
    Secret will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the Secret,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    optional field specify whether the Secret or its key must be defined
    """


class ServiceAccountToken(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceAccountToken"]:
            return ServiceAccountToken

        def build(self) -> "ServiceAccountToken":
            return ServiceAccountToken(**self._attrs)

        def audience(self, value: Optional[str], /) -> Self:
            """
            audience is the intended audience of the token. A recipient of a token
            must identify itself with an identifier specified in the audience of the
            token, and otherwise should reject the token. The audience defaults to the
            identifier of the apiserver.
            """
            return self._set("audience", value)

        def expiration_seconds(self, value: Optional[int], /) -> Self:
            """
            expirationSeconds is the requested duration of validity of the service
            account token. As the token approaches expiration, the kubelet volume
            plugin will proactively rotate the service account token. The kubelet will
            start trying to rotate the token if the token is older than 80 percent of
            its time to live or if the token is older than 24 hours.Defaults to 1 hour
            and must be at least 10 minutes.
            """
            return self._set("expiration_seconds", value)

        def path(self, value: str, /) -> Self:
            """
            path is the path relative to the mount point of the file to project the
            token into.
            """
            return self._set("path", value)

    class BuilderContext(BuilderContextBase["ServiceAccountToken.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceAccountToken.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceAccountToken."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceAccountToken", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceAccountToken.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    audience: Optional[str] = None
    """
    audience is the intended audience of the token. A recipient of a token
    must identify itself with an identifier specified in the audience of the
    token, and otherwise should reject the token. The audience defaults to the
    identifier of the apiserver.
    """
    expiration_seconds: Annotated[Optional[int], Field(alias="expirationSeconds")] = None
    """
    expirationSeconds is the requested duration of validity of the service
    account token. As the token approaches expiration, the kubelet volume
    plugin will proactively rotate the service account token. The kubelet will
    start trying to rotate the token if the token is older than 80 percent of
    its time to live or if the token is older than 24 hours.Defaults to 1 hour
    and must be at least 10 minutes.
    """
    path: str
    """
    path is the path relative to the mount point of the file to project the
    token into.
    """


class Source(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Source"]:
            return Source

        def build(self) -> "Source":
            return Source(**self._attrs)

        @overload
        def cluster_trust_bundle(
            self, value_or_callback: Optional[ClusterTrustBundle], /
        ) -> "Source.Builder": ...

        @overload
        def cluster_trust_bundle(
            self,
            value_or_callback: Callable[
                [ClusterTrustBundle.Builder],
                ClusterTrustBundle.Builder | ClusterTrustBundle,
            ],
            /,
        ) -> "Source.Builder": ...

        @overload
        def cluster_trust_bundle(
            self, value_or_callback: Never = ...
        ) -> "ClusterTrustBundle.BuilderContext": ...

        def cluster_trust_bundle(self, value_or_callback=None, /):
            """
            ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
            of ClusterTrustBundle objects in an auto-updating file.

            Alpha, gated by the ClusterTrustBundleProjection feature gate.

            ClusterTrustBundle objects can either be selected by name, or by the
            combination of signer name and a label selector.

            Kubelet performs aggressive normalization of the PEM contents written
            into the pod filesystem.  Esoteric PEM features such as inter-block
            comments and block headers are stripped.  Certificates are deduplicated.
            The ordering of certificates within the file is arbitrary, and Kubelet
            may change the order over time.
            """
            if self._in_context and value_or_callback is None:
                context = ClusterTrustBundle.BuilderContext()
                context._parent_builder = self
                context._field_name = "cluster_trust_bundle"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterTrustBundle.builder())
                if isinstance(output, ClusterTrustBundle.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cluster_trust_bundle", value)

        @overload
        def config_map(
            self, value_or_callback: Optional[ConfigMapModel1], /
        ) -> "Source.Builder": ...

        @overload
        def config_map(
            self,
            value_or_callback: Callable[
                [ConfigMapModel1.Builder], ConfigMapModel1.Builder | ConfigMapModel1
            ],
            /,
        ) -> "Source.Builder": ...

        @overload
        def config_map(
            self, value_or_callback: Never = ...
        ) -> "ConfigMapModel1.BuilderContext": ...

        def config_map(self, value_or_callback=None, /):
            """
            configMap information about the configMap data to project
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMapModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMapModel1.builder())
                if isinstance(output, ConfigMapModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map", value)

        @overload
        def downward_api(
            self, value_or_callback: Optional[DownwardApiModel], /
        ) -> "Source.Builder": ...

        @overload
        def downward_api(
            self,
            value_or_callback: Callable[
                [DownwardApiModel.Builder], DownwardApiModel.Builder | DownwardApiModel
            ],
            /,
        ) -> "Source.Builder": ...

        @overload
        def downward_api(
            self, value_or_callback: Never = ...
        ) -> "DownwardApiModel.BuilderContext": ...

        def downward_api(self, value_or_callback=None, /):
            """
            downwardAPI information about the downwardAPI data to project
            """
            if self._in_context and value_or_callback is None:
                context = DownwardApiModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "downward_api"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DownwardApiModel.builder())
                if isinstance(output, DownwardApiModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("downward_api", value)

        @overload
        def secret(self, value_or_callback: Optional[SecretModel], /) -> "Source.Builder": ...

        @overload
        def secret(
            self,
            value_or_callback: Callable[[SecretModel.Builder], SecretModel.Builder | SecretModel],
            /,
        ) -> "Source.Builder": ...

        @overload
        def secret(self, value_or_callback: Never = ...) -> "SecretModel.BuilderContext": ...

        def secret(self, value_or_callback=None, /):
            """
            secret information about the secret data to project
            """
            if self._in_context and value_or_callback is None:
                context = SecretModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretModel.builder())
                if isinstance(output, SecretModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret", value)

        @overload
        def service_account_token(
            self, value_or_callback: Optional[ServiceAccountToken], /
        ) -> "Source.Builder": ...

        @overload
        def service_account_token(
            self,
            value_or_callback: Callable[
                [ServiceAccountToken.Builder],
                ServiceAccountToken.Builder | ServiceAccountToken,
            ],
            /,
        ) -> "Source.Builder": ...

        @overload
        def service_account_token(
            self, value_or_callback: Never = ...
        ) -> "ServiceAccountToken.BuilderContext": ...

        def service_account_token(self, value_or_callback=None, /):
            """
            serviceAccountToken is information about the serviceAccountToken data to project
            """
            if self._in_context and value_or_callback is None:
                context = ServiceAccountToken.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_account_token"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceAccountToken.builder())
                if isinstance(output, ServiceAccountToken.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_account_token", value)

    class BuilderContext(BuilderContextBase["Source.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Source.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Source."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Source", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Source.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_trust_bundle: Annotated[
        Optional[ClusterTrustBundle], Field(alias="clusterTrustBundle")
    ] = None
    """
    ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
    of ClusterTrustBundle objects in an auto-updating file.

    Alpha, gated by the ClusterTrustBundleProjection feature gate.

    ClusterTrustBundle objects can either be selected by name, or by the
    combination of signer name and a label selector.

    Kubelet performs aggressive normalization of the PEM contents written
    into the pod filesystem.  Esoteric PEM features such as inter-block
    comments and block headers are stripped.  Certificates are deduplicated.
    The ordering of certificates within the file is arbitrary, and Kubelet
    may change the order over time.
    """
    config_map: Annotated[Optional[ConfigMapModel1], Field(alias="configMap")] = None
    """
    configMap information about the configMap data to project
    """
    downward_api: Annotated[Optional[DownwardApiModel], Field(alias="downwardAPI")] = None
    """
    downwardAPI information about the downwardAPI data to project
    """
    secret: Optional[SecretModel] = None
    """
    secret information about the secret data to project
    """
    service_account_token: Annotated[
        Optional[ServiceAccountToken], Field(alias="serviceAccountToken")
    ] = None
    """
    serviceAccountToken is information about the serviceAccountToken data to project
    """


class Projected(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Projected"]:
            return Projected

        def build(self) -> "Projected":
            return Projected(**self._attrs)

        def default_mode(self, value: Optional[int], /) -> Self:
            """
            defaultMode are the mode bits used to set permissions on created files by default.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            Directories within the path are not affected by this setting.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("default_mode", value)

        @overload
        def sources(self, value_or_callback: List[Source], /) -> "Projected.Builder": ...

        @overload
        def sources(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Source, Source.Builder]],
                GenericListBuilder[Source, Source.Builder] | List[Source],
            ],
            /,
        ) -> "Projected.Builder": ...

        @overload
        def sources(self, value_or_callback: Never = ...) -> ListBuilderContext[Source.Builder]: ...

        def sources(self, value_or_callback=None, /):
            """
            sources is the list of volume projections. Each entry in this list
            handles one source.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Source.Builder]()
                context._parent_builder = self
                context._field_name = "sources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Source.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("sources", value)

    class BuilderContext(BuilderContextBase["Projected.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Projected.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Projected."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Projected", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Projected.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_mode: Annotated[Optional[int], Field(alias="defaultMode")] = None
    """
    defaultMode are the mode bits used to set permissions on created files by default.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    Directories within the path are not affected by this setting.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    sources: Optional[List[Source]] = None
    """
    sources is the list of volume projections. Each entry in this list
    handles one source.
    """


class Quobyte(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Quobyte"]:
            return Quobyte

        def build(self) -> "Quobyte":
            return Quobyte(**self._attrs)

        def group(self, value: Optional[str], /) -> Self:
            """
            group to map volume access to
            Default is no group
            """
            return self._set("group", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly here will force the Quobyte volume to be mounted with read-only permissions.
            Defaults to false.
            """
            return self._set("read_only", value)

        def registry(self, value: str, /) -> Self:
            """
            registry represents a single or multiple Quobyte Registry services
            specified as a string as host:port pair (multiple entries are separated with commas)
            which acts as the central registry for volumes
            """
            return self._set("registry", value)

        def tenant(self, value: Optional[str], /) -> Self:
            """
            tenant owning the given Quobyte volume in the Backend
            Used with dynamically provisioned Quobyte volumes, value is set by the plugin
            """
            return self._set("tenant", value)

        def user(self, value: Optional[str], /) -> Self:
            """
            user to map volume access to
            Defaults to serivceaccount user
            """
            return self._set("user", value)

        def volume(self, value: str, /) -> Self:
            """
            volume is a string that references an already created Quobyte volume by name.
            """
            return self._set("volume", value)

    class BuilderContext(BuilderContextBase["Quobyte.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Quobyte.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Quobyte."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Quobyte", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Quobyte.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    group: Optional[str] = None
    """
    group to map volume access to
    Default is no group
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly here will force the Quobyte volume to be mounted with read-only permissions.
    Defaults to false.
    """
    registry: str
    """
    registry represents a single or multiple Quobyte Registry services
    specified as a string as host:port pair (multiple entries are separated with commas)
    which acts as the central registry for volumes
    """
    tenant: Optional[str] = None
    """
    tenant owning the given Quobyte volume in the Backend
    Used with dynamically provisioned Quobyte volumes, value is set by the plugin
    """
    user: Optional[str] = None
    """
    user to map volume access to
    Defaults to serivceaccount user
    """
    volume: str
    """
    volume is a string that references an already created Quobyte volume by name.
    """


class Rbd(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Rbd"]:
            return Rbd

        def build(self) -> "Rbd":
            return Rbd(**self._attrs)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is the filesystem type of the volume that you want to mount.
            Tip: Ensure that the filesystem type is supported by the host operating system.
            Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
            """
            return self._set("fs_type", value)

        def image(self, value: str, /) -> Self:
            """
            image is the rados image name.
            More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
            """
            return self._set("image", value)

        def keyring(self, value: Optional[str], /) -> Self:
            """
            keyring is the path to key ring for RBDUser.
            Default is /etc/ceph/keyring.
            More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
            """
            return self._set("keyring", value)

        def monitors(self, value: List[str], /) -> Self:
            """
            monitors is a collection of Ceph monitors.
            More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
            """
            return self._set("monitors", value)

        def pool(self, value: Optional[str], /) -> Self:
            """
            pool is the rados pool name.
            Default is rbd.
            More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
            """
            return self._set("pool", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly here will force the ReadOnly setting in VolumeMounts.
            Defaults to false.
            More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
            """
            return self._set("read_only", value)

        @overload
        def secret_ref(self, value_or_callback: Optional[SecretRefModel], /) -> "Rbd.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[
                [SecretRefModel.Builder], SecretRefModel.Builder | SecretRefModel
            ],
            /,
        ) -> "Rbd.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRefModel.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            secretRef is name of the authentication secret for RBDUser. If provided
            overrides keyring.
            Default is nil.
            More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
            """
            if self._in_context and value_or_callback is None:
                context = SecretRefModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRefModel.builder())
                if isinstance(output, SecretRefModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def user(self, value: Optional[str], /) -> Self:
            """
            user is the rados user name.
            Default is admin.
            More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
            """
            return self._set("user", value)

    class BuilderContext(BuilderContextBase["Rbd.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Rbd.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Rbd."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Rbd", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Rbd.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fsType is the filesystem type of the volume that you want to mount.
    Tip: Ensure that the filesystem type is supported by the host operating system.
    Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
    """
    image: str
    """
    image is the rados image name.
    More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    """
    keyring: Optional[str] = "/etc/ceph/keyring"
    """
    keyring is the path to key ring for RBDUser.
    Default is /etc/ceph/keyring.
    More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    """
    monitors: List[str]
    """
    monitors is a collection of Ceph monitors.
    More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    """
    pool: Optional[str] = "rbd"
    """
    pool is the rados pool name.
    Default is rbd.
    More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly here will force the ReadOnly setting in VolumeMounts.
    Defaults to false.
    More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    """
    secret_ref: Annotated[Optional[SecretRefModel], Field(alias="secretRef")] = None
    """
    secretRef is name of the authentication secret for RBDUser. If provided
    overrides keyring.
    Default is nil.
    More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    """
    user: Optional[str] = "admin"
    """
    user is the rados user name.
    Default is admin.
    More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    """


class ScaleIo(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ScaleIo"]:
            return ScaleIo

        def build(self) -> "ScaleIo":
            return ScaleIo(**self._attrs)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is the filesystem type to mount.
            Must be a filesystem type supported by the host operating system.
            Ex. "ext4", "xfs", "ntfs".
            Default is "xfs".
            """
            return self._set("fs_type", value)

        def gateway(self, value: str, /) -> Self:
            """
            gateway is the host address of the ScaleIO API Gateway.
            """
            return self._set("gateway", value)

        def protection_domain(self, value: Optional[str], /) -> Self:
            """
            protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
            """
            return self._set("protection_domain", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly Defaults to false (read/write). ReadOnly here will force
            the ReadOnly setting in VolumeMounts.
            """
            return self._set("read_only", value)

        @overload
        def secret_ref(self, value_or_callback: SecretRefModel, /) -> "ScaleIo.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[
                [SecretRefModel.Builder], SecretRefModel.Builder | SecretRefModel
            ],
            /,
        ) -> "ScaleIo.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRefModel.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            secretRef references to the secret for ScaleIO user and other
            sensitive information. If this is not provided, Login operation will fail.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRefModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRefModel.builder())
                if isinstance(output, SecretRefModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def ssl_enabled(self, value: Optional[bool], /) -> Self:
            """
            sslEnabled Flag enable/disable SSL communication with Gateway, default false
            """
            return self._set("ssl_enabled", value)

        def storage_mode(self, value: Optional[str], /) -> Self:
            """
            storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
            Default is ThinProvisioned.
            """
            return self._set("storage_mode", value)

        def storage_pool(self, value: Optional[str], /) -> Self:
            """
            storagePool is the ScaleIO Storage Pool associated with the protection domain.
            """
            return self._set("storage_pool", value)

        def system(self, value: str, /) -> Self:
            """
            system is the name of the storage system as configured in ScaleIO.
            """
            return self._set("system", value)

        def volume_name(self, value: Optional[str], /) -> Self:
            """
            volumeName is the name of a volume already created in the ScaleIO system
            that is associated with this volume source.
            """
            return self._set("volume_name", value)

    class BuilderContext(BuilderContextBase["ScaleIo.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ScaleIo.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ScaleIo."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ScaleIo", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ScaleIo.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fs_type: Annotated[Optional[str], Field(alias="fsType")] = "xfs"
    """
    fsType is the filesystem type to mount.
    Must be a filesystem type supported by the host operating system.
    Ex. "ext4", "xfs", "ntfs".
    Default is "xfs".
    """
    gateway: str
    """
    gateway is the host address of the ScaleIO API Gateway.
    """
    protection_domain: Annotated[Optional[str], Field(alias="protectionDomain")] = None
    """
    protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly Defaults to false (read/write). ReadOnly here will force
    the ReadOnly setting in VolumeMounts.
    """
    secret_ref: Annotated[SecretRefModel, Field(alias="secretRef")]
    """
    secretRef references to the secret for ScaleIO user and other
    sensitive information. If this is not provided, Login operation will fail.
    """
    ssl_enabled: Annotated[Optional[bool], Field(alias="sslEnabled")] = None
    """
    sslEnabled Flag enable/disable SSL communication with Gateway, default false
    """
    storage_mode: Annotated[Optional[str], Field(alias="storageMode")] = "ThinProvisioned"
    """
    storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
    Default is ThinProvisioned.
    """
    storage_pool: Annotated[Optional[str], Field(alias="storagePool")] = None
    """
    storagePool is the ScaleIO Storage Pool associated with the protection domain.
    """
    system: str
    """
    system is the name of the storage system as configured in ScaleIO.
    """
    volume_name: Annotated[Optional[str], Field(alias="volumeName")] = None
    """
    volumeName is the name of a volume already created in the ScaleIO system
    that is associated with this volume source.
    """


class SecretModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretModel1"]:
            return SecretModel1

        def build(self) -> "SecretModel1":
            return SecretModel1(**self._attrs)

        def default_mode(self, value: Optional[int], /) -> Self:
            """
            defaultMode is Optional: mode bits used to set permissions on created files by default.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values
            for mode bits. Defaults to 0644.
            Directories within the path are not affected by this setting.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("default_mode", value)

        @overload
        def items(self, value_or_callback: List[ItemModel3], /) -> "SecretModel1.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel3, ItemModel3.Builder]],
                GenericListBuilder[ItemModel3, ItemModel3.Builder] | List[ItemModel3],
            ],
            /,
        ) -> "SecretModel1.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel3.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items If unspecified, each key-value pair in the Data field of the referenced
            Secret will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the Secret,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel3.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel3.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional field specify whether the Secret or its keys must be defined
            """
            return self._set("optional", value)

        def secret_name(self, value: Optional[str], /) -> Self:
            """
            secretName is the name of the secret in the pod's namespace to use.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
            """
            return self._set("secret_name", value)

    class BuilderContext(BuilderContextBase["SecretModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_mode: Annotated[Optional[int], Field(alias="defaultMode")] = None
    """
    defaultMode is Optional: mode bits used to set permissions on created files by default.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values
    for mode bits. Defaults to 0644.
    Directories within the path are not affected by this setting.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    items: Optional[List[ItemModel3]] = None
    """
    items If unspecified, each key-value pair in the Data field of the referenced
    Secret will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the Secret,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    optional: Optional[bool] = None
    """
    optional field specify whether the Secret or its keys must be defined
    """
    secret_name: Annotated[Optional[str], Field(alias="secretName")] = None
    """
    secretName is the name of the secret in the pod's namespace to use.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
    """


class Storageos(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Storageos"]:
            return Storageos

        def build(self) -> "Storageos":
            return Storageos(**self._attrs)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is the filesystem type to mount.
            Must be a filesystem type supported by the host operating system.
            Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
            """
            return self._set("fs_type", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            readOnly defaults to false (read/write). ReadOnly here will force
            the ReadOnly setting in VolumeMounts.
            """
            return self._set("read_only", value)

        @overload
        def secret_ref(
            self, value_or_callback: Optional[SecretRefModel], /
        ) -> "Storageos.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[
                [SecretRefModel.Builder], SecretRefModel.Builder | SecretRefModel
            ],
            /,
        ) -> "Storageos.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRefModel.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            secretRef specifies the secret to use for obtaining the StorageOS API
            credentials.  If not specified, default values will be attempted.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRefModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRefModel.builder())
                if isinstance(output, SecretRefModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def volume_name(self, value: Optional[str], /) -> Self:
            """
            volumeName is the human-readable name of the StorageOS volume.  Volume
            names are only unique within a namespace.
            """
            return self._set("volume_name", value)

        def volume_namespace(self, value: Optional[str], /) -> Self:
            """
            volumeNamespace specifies the scope of the volume within StorageOS.  If no
            namespace is specified then the Pod's namespace will be used.  This allows the
            Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
            Set VolumeName to any name to override the default behaviour.
            Set to "default" if you are not using namespaces within StorageOS.
            Namespaces that do not pre-exist within StorageOS will be created.
            """
            return self._set("volume_namespace", value)

    class BuilderContext(BuilderContextBase["Storageos.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Storageos.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Storageos."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Storageos", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Storageos.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fsType is the filesystem type to mount.
    Must be a filesystem type supported by the host operating system.
    Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    readOnly defaults to false (read/write). ReadOnly here will force
    the ReadOnly setting in VolumeMounts.
    """
    secret_ref: Annotated[Optional[SecretRefModel], Field(alias="secretRef")] = None
    """
    secretRef specifies the secret to use for obtaining the StorageOS API
    credentials.  If not specified, default values will be attempted.
    """
    volume_name: Annotated[Optional[str], Field(alias="volumeName")] = None
    """
    volumeName is the human-readable name of the StorageOS volume.  Volume
    names are only unique within a namespace.
    """
    volume_namespace: Annotated[Optional[str], Field(alias="volumeNamespace")] = None
    """
    volumeNamespace specifies the scope of the volume within StorageOS.  If no
    namespace is specified then the Pod's namespace will be used.  This allows the
    Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
    Set VolumeName to any name to override the default behaviour.
    Set to "default" if you are not using namespaces within StorageOS.
    Namespaces that do not pre-exist within StorageOS will be created.
    """


class VsphereVolume(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VsphereVolume"]:
            return VsphereVolume

        def build(self) -> "VsphereVolume":
            return VsphereVolume(**self._attrs)

        def fs_type(self, value: Optional[str], /) -> Self:
            """
            fsType is filesystem type to mount.
            Must be a filesystem type supported by the host operating system.
            Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
            """
            return self._set("fs_type", value)

        def storage_policy_id(self, value: Optional[str], /) -> Self:
            """
            storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
            """
            return self._set("storage_policy_id", value)

        def storage_policy_name(self, value: Optional[str], /) -> Self:
            """
            storagePolicyName is the storage Policy Based Management (SPBM) profile name.
            """
            return self._set("storage_policy_name", value)

        def volume_path(self, value: str, /) -> Self:
            """
            volumePath is the path that identifies vSphere volume vmdk
            """
            return self._set("volume_path", value)

    class BuilderContext(BuilderContextBase["VsphereVolume.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VsphereVolume.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VsphereVolume."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VsphereVolume", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VsphereVolume.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fs_type: Annotated[Optional[str], Field(alias="fsType")] = None
    """
    fsType is filesystem type to mount.
    Must be a filesystem type supported by the host operating system.
    Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    """
    storage_policy_id: Annotated[Optional[str], Field(alias="storagePolicyID")] = None
    """
    storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
    """
    storage_policy_name: Annotated[Optional[str], Field(alias="storagePolicyName")] = None
    """
    storagePolicyName is the storage Policy Based Management (SPBM) profile name.
    """
    volume_path: Annotated[str, Field(alias="volumePath")]
    """
    volumePath is the path that identifies vSphere volume vmdk
    """


class Volume(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Volume"]:
            return Volume

        def build(self) -> "Volume":
            return Volume(**self._attrs)

        @overload
        def aws_elastic_block_store(
            self, value_or_callback: Optional[AwsElasticBlockStore], /
        ) -> "Volume.Builder": ...

        @overload
        def aws_elastic_block_store(
            self,
            value_or_callback: Callable[
                [AwsElasticBlockStore.Builder],
                AwsElasticBlockStore.Builder | AwsElasticBlockStore,
            ],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def aws_elastic_block_store(
            self, value_or_callback: Never = ...
        ) -> "AwsElasticBlockStore.BuilderContext": ...

        def aws_elastic_block_store(self, value_or_callback=None, /):
            """
            awsElasticBlockStore represents an AWS Disk resource that is attached to a
            kubelet's host machine and then exposed to the pod.
            Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
            awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
            """
            if self._in_context and value_or_callback is None:
                context = AwsElasticBlockStore.BuilderContext()
                context._parent_builder = self
                context._field_name = "aws_elastic_block_store"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AwsElasticBlockStore.builder())
                if isinstance(output, AwsElasticBlockStore.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("aws_elastic_block_store", value)

        @overload
        def azure_disk(self, value_or_callback: Optional[AzureDisk], /) -> "Volume.Builder": ...

        @overload
        def azure_disk(
            self,
            value_or_callback: Callable[[AzureDisk.Builder], AzureDisk.Builder | AzureDisk],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def azure_disk(self, value_or_callback: Never = ...) -> "AzureDisk.BuilderContext": ...

        def azure_disk(self, value_or_callback=None, /):
            """
            azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
            Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
            are redirected to the disk.csi.azure.com CSI driver.
            """
            if self._in_context and value_or_callback is None:
                context = AzureDisk.BuilderContext()
                context._parent_builder = self
                context._field_name = "azure_disk"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AzureDisk.builder())
                if isinstance(output, AzureDisk.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("azure_disk", value)

        @overload
        def azure_file(self, value_or_callback: Optional[AzureFile], /) -> "Volume.Builder": ...

        @overload
        def azure_file(
            self,
            value_or_callback: Callable[[AzureFile.Builder], AzureFile.Builder | AzureFile],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def azure_file(self, value_or_callback: Never = ...) -> "AzureFile.BuilderContext": ...

        def azure_file(self, value_or_callback=None, /):
            """
            azureFile represents an Azure File Service mount on the host and bind mount to the pod.
            Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
            are redirected to the file.csi.azure.com CSI driver.
            """
            if self._in_context and value_or_callback is None:
                context = AzureFile.BuilderContext()
                context._parent_builder = self
                context._field_name = "azure_file"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AzureFile.builder())
                if isinstance(output, AzureFile.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("azure_file", value)

        @overload
        def cephfs(self, value_or_callback: Optional[Cephfs], /) -> "Volume.Builder": ...

        @overload
        def cephfs(
            self,
            value_or_callback: Callable[[Cephfs.Builder], Cephfs.Builder | Cephfs],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def cephfs(self, value_or_callback: Never = ...) -> "Cephfs.BuilderContext": ...

        def cephfs(self, value_or_callback=None, /):
            """
            cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
            Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
            """
            if self._in_context and value_or_callback is None:
                context = Cephfs.BuilderContext()
                context._parent_builder = self
                context._field_name = "cephfs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cephfs.builder())
                if isinstance(output, Cephfs.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cephfs", value)

        @overload
        def cinder(self, value_or_callback: Optional[Cinder], /) -> "Volume.Builder": ...

        @overload
        def cinder(
            self,
            value_or_callback: Callable[[Cinder.Builder], Cinder.Builder | Cinder],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def cinder(self, value_or_callback: Never = ...) -> "Cinder.BuilderContext": ...

        def cinder(self, value_or_callback=None, /):
            """
            cinder represents a cinder volume attached and mounted on kubelets host machine.
            Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
            are redirected to the cinder.csi.openstack.org CSI driver.
            More info: https://examples.k8s.io/mysql-cinder-pd/README.md
            """
            if self._in_context and value_or_callback is None:
                context = Cinder.BuilderContext()
                context._parent_builder = self
                context._field_name = "cinder"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cinder.builder())
                if isinstance(output, Cinder.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cinder", value)

        @overload
        def config_map(
            self, value_or_callback: Optional[ConfigMapModel], /
        ) -> "Volume.Builder": ...

        @overload
        def config_map(
            self,
            value_or_callback: Callable[
                [ConfigMapModel.Builder], ConfigMapModel.Builder | ConfigMapModel
            ],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def config_map(self, value_or_callback: Never = ...) -> "ConfigMapModel.BuilderContext": ...

        def config_map(self, value_or_callback=None, /):
            """
            configMap represents a configMap that should populate this volume
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMapModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMapModel.builder())
                if isinstance(output, ConfigMapModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map", value)

        @overload
        def csi(self, value_or_callback: Optional[Csi], /) -> "Volume.Builder": ...

        @overload
        def csi(
            self, value_or_callback: Callable[[Csi.Builder], Csi.Builder | Csi], /
        ) -> "Volume.Builder": ...

        @overload
        def csi(self, value_or_callback: Never = ...) -> "Csi.BuilderContext": ...

        def csi(self, value_or_callback=None, /):
            """
            csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
            """
            if self._in_context and value_or_callback is None:
                context = Csi.BuilderContext()
                context._parent_builder = self
                context._field_name = "csi"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Csi.builder())
                if isinstance(output, Csi.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("csi", value)

        @overload
        def downward_api(self, value_or_callback: Optional[DownwardApi], /) -> "Volume.Builder": ...

        @overload
        def downward_api(
            self,
            value_or_callback: Callable[[DownwardApi.Builder], DownwardApi.Builder | DownwardApi],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def downward_api(self, value_or_callback: Never = ...) -> "DownwardApi.BuilderContext": ...

        def downward_api(self, value_or_callback=None, /):
            """
            downwardAPI represents downward API about the pod that should populate this volume
            """
            if self._in_context and value_or_callback is None:
                context = DownwardApi.BuilderContext()
                context._parent_builder = self
                context._field_name = "downward_api"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DownwardApi.builder())
                if isinstance(output, DownwardApi.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("downward_api", value)

        @overload
        def empty_dir(self, value_or_callback: Optional[EmptyDir], /) -> "Volume.Builder": ...

        @overload
        def empty_dir(
            self,
            value_or_callback: Callable[[EmptyDir.Builder], EmptyDir.Builder | EmptyDir],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def empty_dir(self, value_or_callback: Never = ...) -> "EmptyDir.BuilderContext": ...

        def empty_dir(self, value_or_callback=None, /):
            """
            emptyDir represents a temporary directory that shares a pod's lifetime.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            if self._in_context and value_or_callback is None:
                context = EmptyDir.BuilderContext()
                context._parent_builder = self
                context._field_name = "empty_dir"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(EmptyDir.builder())
                if isinstance(output, EmptyDir.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("empty_dir", value)

        @overload
        def ephemeral(self, value_or_callback: Optional[Ephemeral], /) -> "Volume.Builder": ...

        @overload
        def ephemeral(
            self,
            value_or_callback: Callable[[Ephemeral.Builder], Ephemeral.Builder | Ephemeral],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def ephemeral(self, value_or_callback: Never = ...) -> "Ephemeral.BuilderContext": ...

        def ephemeral(self, value_or_callback=None, /):
            """
            ephemeral represents a volume that is handled by a cluster storage driver.
            The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
            and deleted when the pod is removed.

            Use this if:
            a) the volume is only needed while the pod runs,
            b) features of normal volumes like restoring from snapshot or capacity
               tracking are needed,
            c) the storage driver is specified through a storage class, and
            d) the storage driver supports dynamic volume provisioning through
               a PersistentVolumeClaim (see EphemeralVolumeSource for more
               information on the connection between this volume type
               and PersistentVolumeClaim).

            Use PersistentVolumeClaim or one of the vendor-specific
            APIs for volumes that persist for longer than the lifecycle
            of an individual pod.

            Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
            be used that way - see the documentation of the driver for
            more information.

            A pod can use both types of ephemeral volumes and
            persistent volumes at the same time.
            """
            if self._in_context and value_or_callback is None:
                context = Ephemeral.BuilderContext()
                context._parent_builder = self
                context._field_name = "ephemeral"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ephemeral.builder())
                if isinstance(output, Ephemeral.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ephemeral", value)

        @overload
        def fc(self, value_or_callback: Optional[Fc], /) -> "Volume.Builder": ...

        @overload
        def fc(
            self, value_or_callback: Callable[[Fc.Builder], Fc.Builder | Fc], /
        ) -> "Volume.Builder": ...

        @overload
        def fc(self, value_or_callback: Never = ...) -> "Fc.BuilderContext": ...

        def fc(self, value_or_callback=None, /):
            """
            fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
            """
            if self._in_context and value_or_callback is None:
                context = Fc.BuilderContext()
                context._parent_builder = self
                context._field_name = "fc"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Fc.builder())
                if isinstance(output, Fc.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("fc", value)

        @overload
        def flex_volume(self, value_or_callback: Optional[FlexVolume], /) -> "Volume.Builder": ...

        @overload
        def flex_volume(
            self,
            value_or_callback: Callable[[FlexVolume.Builder], FlexVolume.Builder | FlexVolume],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def flex_volume(self, value_or_callback: Never = ...) -> "FlexVolume.BuilderContext": ...

        def flex_volume(self, value_or_callback=None, /):
            """
            flexVolume represents a generic volume resource that is
            provisioned/attached using an exec based plugin.
            Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
            """
            if self._in_context and value_or_callback is None:
                context = FlexVolume.BuilderContext()
                context._parent_builder = self
                context._field_name = "flex_volume"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FlexVolume.builder())
                if isinstance(output, FlexVolume.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("flex_volume", value)

        @overload
        def flocker(self, value_or_callback: Optional[Flocker], /) -> "Volume.Builder": ...

        @overload
        def flocker(
            self,
            value_or_callback: Callable[[Flocker.Builder], Flocker.Builder | Flocker],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def flocker(self, value_or_callback: Never = ...) -> "Flocker.BuilderContext": ...

        def flocker(self, value_or_callback=None, /):
            """
            flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
            Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
            """
            if self._in_context and value_or_callback is None:
                context = Flocker.BuilderContext()
                context._parent_builder = self
                context._field_name = "flocker"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Flocker.builder())
                if isinstance(output, Flocker.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("flocker", value)

        @overload
        def gce_persistent_disk(
            self, value_or_callback: Optional[GcePersistentDisk], /
        ) -> "Volume.Builder": ...

        @overload
        def gce_persistent_disk(
            self,
            value_or_callback: Callable[
                [GcePersistentDisk.Builder],
                GcePersistentDisk.Builder | GcePersistentDisk,
            ],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def gce_persistent_disk(
            self, value_or_callback: Never = ...
        ) -> "GcePersistentDisk.BuilderContext": ...

        def gce_persistent_disk(self, value_or_callback=None, /):
            """
            gcePersistentDisk represents a GCE Disk resource that is attached to a
            kubelet's host machine and then exposed to the pod.
            Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
            gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
            """
            if self._in_context and value_or_callback is None:
                context = GcePersistentDisk.BuilderContext()
                context._parent_builder = self
                context._field_name = "gce_persistent_disk"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GcePersistentDisk.builder())
                if isinstance(output, GcePersistentDisk.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("gce_persistent_disk", value)

        @overload
        def git_repo(self, value_or_callback: Optional[GitRepo], /) -> "Volume.Builder": ...

        @overload
        def git_repo(
            self,
            value_or_callback: Callable[[GitRepo.Builder], GitRepo.Builder | GitRepo],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def git_repo(self, value_or_callback: Never = ...) -> "GitRepo.BuilderContext": ...

        def git_repo(self, value_or_callback=None, /):
            """
            gitRepo represents a git repository at a particular revision.
            Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
            EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
            into the Pod's container.
            """
            if self._in_context and value_or_callback is None:
                context = GitRepo.BuilderContext()
                context._parent_builder = self
                context._field_name = "git_repo"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GitRepo.builder())
                if isinstance(output, GitRepo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("git_repo", value)

        @overload
        def glusterfs(self, value_or_callback: Optional[Glusterfs], /) -> "Volume.Builder": ...

        @overload
        def glusterfs(
            self,
            value_or_callback: Callable[[Glusterfs.Builder], Glusterfs.Builder | Glusterfs],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def glusterfs(self, value_or_callback: Never = ...) -> "Glusterfs.BuilderContext": ...

        def glusterfs(self, value_or_callback=None, /):
            """
            glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
            Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
            More info: https://examples.k8s.io/volumes/glusterfs/README.md
            """
            if self._in_context and value_or_callback is None:
                context = Glusterfs.BuilderContext()
                context._parent_builder = self
                context._field_name = "glusterfs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Glusterfs.builder())
                if isinstance(output, Glusterfs.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("glusterfs", value)

        @overload
        def host_path(self, value_or_callback: Optional[HostPath], /) -> "Volume.Builder": ...

        @overload
        def host_path(
            self,
            value_or_callback: Callable[[HostPath.Builder], HostPath.Builder | HostPath],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def host_path(self, value_or_callback: Never = ...) -> "HostPath.BuilderContext": ...

        def host_path(self, value_or_callback=None, /):
            """
            hostPath represents a pre-existing file or directory on the host
            machine that is directly exposed to the container. This is generally
            used for system agents or other privileged things that are allowed
            to see the host machine. Most containers will NOT need this.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
            """
            if self._in_context and value_or_callback is None:
                context = HostPath.BuilderContext()
                context._parent_builder = self
                context._field_name = "host_path"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HostPath.builder())
                if isinstance(output, HostPath.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("host_path", value)

        @overload
        def image(self, value_or_callback: Optional[Image], /) -> "Volume.Builder": ...

        @overload
        def image(
            self, value_or_callback: Callable[[Image.Builder], Image.Builder | Image], /
        ) -> "Volume.Builder": ...

        @overload
        def image(self, value_or_callback: Never = ...) -> "Image.BuilderContext": ...

        def image(self, value_or_callback=None, /):
            """
            image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
            The volume is resolved at pod startup depending on which PullPolicy value is provided:

            - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
            - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
            - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.

            The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
            A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
            The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
            The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
            The volume will be mounted read-only (ro) and non-executable files (noexec).
            Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath).
            The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
            """
            if self._in_context and value_or_callback is None:
                context = Image.BuilderContext()
                context._parent_builder = self
                context._field_name = "image"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Image.builder())
                if isinstance(output, Image.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("image", value)

        @overload
        def iscsi(self, value_or_callback: Optional[Iscsi], /) -> "Volume.Builder": ...

        @overload
        def iscsi(
            self, value_or_callback: Callable[[Iscsi.Builder], Iscsi.Builder | Iscsi], /
        ) -> "Volume.Builder": ...

        @overload
        def iscsi(self, value_or_callback: Never = ...) -> "Iscsi.BuilderContext": ...

        def iscsi(self, value_or_callback=None, /):
            """
            iscsi represents an ISCSI Disk resource that is attached to a
            kubelet's host machine and then exposed to the pod.
            More info: https://examples.k8s.io/volumes/iscsi/README.md
            """
            if self._in_context and value_or_callback is None:
                context = Iscsi.BuilderContext()
                context._parent_builder = self
                context._field_name = "iscsi"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Iscsi.builder())
                if isinstance(output, Iscsi.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("iscsi", value)

        def name(self, value: str, /) -> Self:
            """
            name of the volume.
            Must be a DNS_LABEL and unique within the pod.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        @overload
        def nfs(self, value_or_callback: Optional[Nfs], /) -> "Volume.Builder": ...

        @overload
        def nfs(
            self, value_or_callback: Callable[[Nfs.Builder], Nfs.Builder | Nfs], /
        ) -> "Volume.Builder": ...

        @overload
        def nfs(self, value_or_callback: Never = ...) -> "Nfs.BuilderContext": ...

        def nfs(self, value_or_callback=None, /):
            """
            nfs represents an NFS mount on the host that shares a pod's lifetime
            More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
            """
            if self._in_context and value_or_callback is None:
                context = Nfs.BuilderContext()
                context._parent_builder = self
                context._field_name = "nfs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Nfs.builder())
                if isinstance(output, Nfs.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("nfs", value)

        @overload
        def persistent_volume_claim(
            self, value_or_callback: Optional[PersistentVolumeClaim], /
        ) -> "Volume.Builder": ...

        @overload
        def persistent_volume_claim(
            self,
            value_or_callback: Callable[
                [PersistentVolumeClaim.Builder],
                PersistentVolumeClaim.Builder | PersistentVolumeClaim,
            ],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def persistent_volume_claim(
            self, value_or_callback: Never = ...
        ) -> "PersistentVolumeClaim.BuilderContext": ...

        def persistent_volume_claim(self, value_or_callback=None, /):
            """
            persistentVolumeClaimVolumeSource represents a reference to a
            PersistentVolumeClaim in the same namespace.
            More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
            """
            if self._in_context and value_or_callback is None:
                context = PersistentVolumeClaim.BuilderContext()
                context._parent_builder = self
                context._field_name = "persistent_volume_claim"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PersistentVolumeClaim.builder())
                if isinstance(output, PersistentVolumeClaim.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("persistent_volume_claim", value)

        @overload
        def photon_persistent_disk(
            self, value_or_callback: Optional[PhotonPersistentDisk], /
        ) -> "Volume.Builder": ...

        @overload
        def photon_persistent_disk(
            self,
            value_or_callback: Callable[
                [PhotonPersistentDisk.Builder],
                PhotonPersistentDisk.Builder | PhotonPersistentDisk,
            ],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def photon_persistent_disk(
            self, value_or_callback: Never = ...
        ) -> "PhotonPersistentDisk.BuilderContext": ...

        def photon_persistent_disk(self, value_or_callback=None, /):
            """
            photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
            Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
            """
            if self._in_context and value_or_callback is None:
                context = PhotonPersistentDisk.BuilderContext()
                context._parent_builder = self
                context._field_name = "photon_persistent_disk"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PhotonPersistentDisk.builder())
                if isinstance(output, PhotonPersistentDisk.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("photon_persistent_disk", value)

        @overload
        def portworx_volume(
            self, value_or_callback: Optional[PortworxVolume], /
        ) -> "Volume.Builder": ...

        @overload
        def portworx_volume(
            self,
            value_or_callback: Callable[
                [PortworxVolume.Builder], PortworxVolume.Builder | PortworxVolume
            ],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def portworx_volume(
            self, value_or_callback: Never = ...
        ) -> "PortworxVolume.BuilderContext": ...

        def portworx_volume(self, value_or_callback=None, /):
            """
            portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
            Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
            are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
            is on.
            """
            if self._in_context and value_or_callback is None:
                context = PortworxVolume.BuilderContext()
                context._parent_builder = self
                context._field_name = "portworx_volume"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PortworxVolume.builder())
                if isinstance(output, PortworxVolume.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("portworx_volume", value)

        @overload
        def projected(self, value_or_callback: Optional[Projected], /) -> "Volume.Builder": ...

        @overload
        def projected(
            self,
            value_or_callback: Callable[[Projected.Builder], Projected.Builder | Projected],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def projected(self, value_or_callback: Never = ...) -> "Projected.BuilderContext": ...

        def projected(self, value_or_callback=None, /):
            """
            projected items for all in one resources secrets, configmaps, and downward API
            """
            if self._in_context and value_or_callback is None:
                context = Projected.BuilderContext()
                context._parent_builder = self
                context._field_name = "projected"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Projected.builder())
                if isinstance(output, Projected.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("projected", value)

        @overload
        def quobyte(self, value_or_callback: Optional[Quobyte], /) -> "Volume.Builder": ...

        @overload
        def quobyte(
            self,
            value_or_callback: Callable[[Quobyte.Builder], Quobyte.Builder | Quobyte],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def quobyte(self, value_or_callback: Never = ...) -> "Quobyte.BuilderContext": ...

        def quobyte(self, value_or_callback=None, /):
            """
            quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
            Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
            """
            if self._in_context and value_or_callback is None:
                context = Quobyte.BuilderContext()
                context._parent_builder = self
                context._field_name = "quobyte"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Quobyte.builder())
                if isinstance(output, Quobyte.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("quobyte", value)

        @overload
        def rbd(self, value_or_callback: Optional[Rbd], /) -> "Volume.Builder": ...

        @overload
        def rbd(
            self, value_or_callback: Callable[[Rbd.Builder], Rbd.Builder | Rbd], /
        ) -> "Volume.Builder": ...

        @overload
        def rbd(self, value_or_callback: Never = ...) -> "Rbd.BuilderContext": ...

        def rbd(self, value_or_callback=None, /):
            """
            rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
            Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
            More info: https://examples.k8s.io/volumes/rbd/README.md
            """
            if self._in_context and value_or_callback is None:
                context = Rbd.BuilderContext()
                context._parent_builder = self
                context._field_name = "rbd"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Rbd.builder())
                if isinstance(output, Rbd.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("rbd", value)

        @overload
        def scale_io(self, value_or_callback: Optional[ScaleIo], /) -> "Volume.Builder": ...

        @overload
        def scale_io(
            self,
            value_or_callback: Callable[[ScaleIo.Builder], ScaleIo.Builder | ScaleIo],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def scale_io(self, value_or_callback: Never = ...) -> "ScaleIo.BuilderContext": ...

        def scale_io(self, value_or_callback=None, /):
            """
            scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
            Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
            """
            if self._in_context and value_or_callback is None:
                context = ScaleIo.BuilderContext()
                context._parent_builder = self
                context._field_name = "scale_io"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ScaleIo.builder())
                if isinstance(output, ScaleIo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("scale_io", value)

        @overload
        def secret(self, value_or_callback: Optional[SecretModel1], /) -> "Volume.Builder": ...

        @overload
        def secret(
            self,
            value_or_callback: Callable[
                [SecretModel1.Builder], SecretModel1.Builder | SecretModel1
            ],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def secret(self, value_or_callback: Never = ...) -> "SecretModel1.BuilderContext": ...

        def secret(self, value_or_callback=None, /):
            """
            secret represents a secret that should populate this volume.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
            """
            if self._in_context and value_or_callback is None:
                context = SecretModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretModel1.builder())
                if isinstance(output, SecretModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret", value)

        @overload
        def storageos(self, value_or_callback: Optional[Storageos], /) -> "Volume.Builder": ...

        @overload
        def storageos(
            self,
            value_or_callback: Callable[[Storageos.Builder], Storageos.Builder | Storageos],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def storageos(self, value_or_callback: Never = ...) -> "Storageos.BuilderContext": ...

        def storageos(self, value_or_callback=None, /):
            """
            storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
            Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
            """
            if self._in_context and value_or_callback is None:
                context = Storageos.BuilderContext()
                context._parent_builder = self
                context._field_name = "storageos"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Storageos.builder())
                if isinstance(output, Storageos.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("storageos", value)

        @overload
        def vsphere_volume(
            self, value_or_callback: Optional[VsphereVolume], /
        ) -> "Volume.Builder": ...

        @overload
        def vsphere_volume(
            self,
            value_or_callback: Callable[
                [VsphereVolume.Builder], VsphereVolume.Builder | VsphereVolume
            ],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def vsphere_volume(
            self, value_or_callback: Never = ...
        ) -> "VsphereVolume.BuilderContext": ...

        def vsphere_volume(self, value_or_callback=None, /):
            """
            vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
            Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
            are redirected to the csi.vsphere.vmware.com CSI driver.
            """
            if self._in_context and value_or_callback is None:
                context = VsphereVolume.BuilderContext()
                context._parent_builder = self
                context._field_name = "vsphere_volume"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VsphereVolume.builder())
                if isinstance(output, VsphereVolume.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("vsphere_volume", value)

    class BuilderContext(BuilderContextBase["Volume.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Volume.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Volume."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Volume", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Volume.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    aws_elastic_block_store: Annotated[
        Optional[AwsElasticBlockStore], Field(alias="awsElasticBlockStore")
    ] = None
    """
    awsElasticBlockStore represents an AWS Disk resource that is attached to a
    kubelet's host machine and then exposed to the pod.
    Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
    awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
    """
    azure_disk: Annotated[Optional[AzureDisk], Field(alias="azureDisk")] = None
    """
    azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
    Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
    are redirected to the disk.csi.azure.com CSI driver.
    """
    azure_file: Annotated[Optional[AzureFile], Field(alias="azureFile")] = None
    """
    azureFile represents an Azure File Service mount on the host and bind mount to the pod.
    Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
    are redirected to the file.csi.azure.com CSI driver.
    """
    cephfs: Optional[Cephfs] = None
    """
    cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
    Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
    """
    cinder: Optional[Cinder] = None
    """
    cinder represents a cinder volume attached and mounted on kubelets host machine.
    Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
    are redirected to the cinder.csi.openstack.org CSI driver.
    More info: https://examples.k8s.io/mysql-cinder-pd/README.md
    """
    config_map: Annotated[Optional[ConfigMapModel], Field(alias="configMap")] = None
    """
    configMap represents a configMap that should populate this volume
    """
    csi: Optional[Csi] = None
    """
    csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
    """
    downward_api: Annotated[Optional[DownwardApi], Field(alias="downwardAPI")] = None
    """
    downwardAPI represents downward API about the pod that should populate this volume
    """
    empty_dir: Annotated[Optional[EmptyDir], Field(alias="emptyDir")] = None
    """
    emptyDir represents a temporary directory that shares a pod's lifetime.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    """
    ephemeral: Optional[Ephemeral] = None
    """
    ephemeral represents a volume that is handled by a cluster storage driver.
    The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
    and deleted when the pod is removed.

    Use this if:
    a) the volume is only needed while the pod runs,
    b) features of normal volumes like restoring from snapshot or capacity
       tracking are needed,
    c) the storage driver is specified through a storage class, and
    d) the storage driver supports dynamic volume provisioning through
       a PersistentVolumeClaim (see EphemeralVolumeSource for more
       information on the connection between this volume type
       and PersistentVolumeClaim).

    Use PersistentVolumeClaim or one of the vendor-specific
    APIs for volumes that persist for longer than the lifecycle
    of an individual pod.

    Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
    be used that way - see the documentation of the driver for
    more information.

    A pod can use both types of ephemeral volumes and
    persistent volumes at the same time.
    """
    fc: Optional[Fc] = None
    """
    fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
    """
    flex_volume: Annotated[Optional[FlexVolume], Field(alias="flexVolume")] = None
    """
    flexVolume represents a generic volume resource that is
    provisioned/attached using an exec based plugin.
    Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
    """
    flocker: Optional[Flocker] = None
    """
    flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
    Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
    """
    gce_persistent_disk: Annotated[
        Optional[GcePersistentDisk], Field(alias="gcePersistentDisk")
    ] = None
    """
    gcePersistentDisk represents a GCE Disk resource that is attached to a
    kubelet's host machine and then exposed to the pod.
    Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
    gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
    """
    git_repo: Annotated[Optional[GitRepo], Field(alias="gitRepo")] = None
    """
    gitRepo represents a git repository at a particular revision.
    Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
    EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
    into the Pod's container.
    """
    glusterfs: Optional[Glusterfs] = None
    """
    glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
    Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
    More info: https://examples.k8s.io/volumes/glusterfs/README.md
    """
    host_path: Annotated[Optional[HostPath], Field(alias="hostPath")] = None
    """
    hostPath represents a pre-existing file or directory on the host
    machine that is directly exposed to the container. This is generally
    used for system agents or other privileged things that are allowed
    to see the host machine. Most containers will NOT need this.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
    """
    image: Optional[Image] = None
    """
    image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
    The volume is resolved at pod startup depending on which PullPolicy value is provided:

    - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
    - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
    - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.

    The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
    A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
    The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
    The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
    The volume will be mounted read-only (ro) and non-executable files (noexec).
    Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath).
    The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
    """
    iscsi: Optional[Iscsi] = None
    """
    iscsi represents an ISCSI Disk resource that is attached to a
    kubelet's host machine and then exposed to the pod.
    More info: https://examples.k8s.io/volumes/iscsi/README.md
    """
    name: str
    """
    name of the volume.
    Must be a DNS_LABEL and unique within the pod.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    nfs: Optional[Nfs] = None
    """
    nfs represents an NFS mount on the host that shares a pod's lifetime
    More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
    """
    persistent_volume_claim: Annotated[
        Optional[PersistentVolumeClaim], Field(alias="persistentVolumeClaim")
    ] = None
    """
    persistentVolumeClaimVolumeSource represents a reference to a
    PersistentVolumeClaim in the same namespace.
    More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
    """
    photon_persistent_disk: Annotated[
        Optional[PhotonPersistentDisk], Field(alias="photonPersistentDisk")
    ] = None
    """
    photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
    Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
    """
    portworx_volume: Annotated[Optional[PortworxVolume], Field(alias="portworxVolume")] = None
    """
    portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
    Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
    are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
    is on.
    """
    projected: Optional[Projected] = None
    """
    projected items for all in one resources secrets, configmaps, and downward API
    """
    quobyte: Optional[Quobyte] = None
    """
    quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
    Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
    """
    rbd: Optional[Rbd] = None
    """
    rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
    Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
    More info: https://examples.k8s.io/volumes/rbd/README.md
    """
    scale_io: Annotated[Optional[ScaleIo], Field(alias="scaleIO")] = None
    """
    scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
    Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
    """
    secret: Optional[SecretModel1] = None
    """
    secret represents a secret that should populate this volume.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
    """
    storageos: Optional[Storageos] = None
    """
    storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
    Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
    """
    vsphere_volume: Annotated[Optional[VsphereVolume], Field(alias="vsphereVolume")] = None
    """
    vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
    Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
    are redirected to the csi.vsphere.vmware.com CSI driver.
    """


class Headers(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Headers"]:
            return Headers

        def build(self) -> "Headers":
            return Headers(**self._attrs)

        def content_security_policy(self, value: Optional[str], /) -> Self:
            """
            Set the Content-Security-Policy header to HTTP responses.
            Unset if blank.
            """
            return self._set("content_security_policy", value)

        def strict_transport_security(self, value: Optional[str], /) -> Self:
            """
            Set the Strict-Transport-Security header to HTTP responses.
            Unset if blank.
            Please make sure that you use this with care as this header might force
            browsers to load Prometheus and the other applications hosted on the same
            domain and subdomains over HTTPS.
            https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security
            """
            return self._set("strict_transport_security", value)

        def x_content_type_options(self, value: Optional[Literal["", "NoSniff"]], /) -> Self:
            """
            Set the X-Content-Type-Options header to HTTP responses.
            Unset if blank. Accepted value is nosniff.
            https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
            """
            return self._set("x_content_type_options", value)

        def x_frame_options(self, value: Optional[Literal["", "Deny", "SameOrigin"]], /) -> Self:
            """
            Set the X-Frame-Options header to HTTP responses.
            Unset if blank. Accepted values are deny and sameorigin.
            https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
            """
            return self._set("x_frame_options", value)

        def x_xss_protection(self, value: Optional[str], /) -> Self:
            """
            Set the X-XSS-Protection header to all responses.
            Unset if blank.
            https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection
            """
            return self._set("x_xss_protection", value)

    class BuilderContext(BuilderContextBase["Headers.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Headers.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Headers."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Headers", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Headers.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    content_security_policy: Annotated[Optional[str], Field(alias="contentSecurityPolicy")] = None
    """
    Set the Content-Security-Policy header to HTTP responses.
    Unset if blank.
    """
    strict_transport_security: Annotated[Optional[str], Field(alias="strictTransportSecurity")] = (
        None
    )
    """
    Set the Strict-Transport-Security header to HTTP responses.
    Unset if blank.
    Please make sure that you use this with care as this header might force
    browsers to load Prometheus and the other applications hosted on the same
    domain and subdomains over HTTPS.
    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security
    """
    x_content_type_options: Annotated[
        Optional[Literal["", "NoSniff"]], Field(alias="xContentTypeOptions")
    ] = None
    """
    Set the X-Content-Type-Options header to HTTP responses.
    Unset if blank. Accepted value is nosniff.
    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
    """
    x_frame_options: Annotated[
        Optional[Literal["", "Deny", "SameOrigin"]], Field(alias="xFrameOptions")
    ] = None
    """
    Set the X-Frame-Options header to HTTP responses.
    Unset if blank. Accepted values are deny and sameorigin.
    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
    """
    x_xss_protection: Annotated[Optional[str], Field(alias="xXSSProtection")] = None
    """
    Set the X-XSS-Protection header to all responses.
    Unset if blank.
    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection
    """


class HttpConfigModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HttpConfigModel"]:
            return HttpConfigModel

        def build(self) -> "HttpConfigModel":
            return HttpConfigModel(**self._attrs)

        @overload
        def headers(self, value_or_callback: Optional[Headers], /) -> "HttpConfigModel.Builder": ...

        @overload
        def headers(
            self,
            value_or_callback: Callable[[Headers.Builder], Headers.Builder | Headers],
            /,
        ) -> "HttpConfigModel.Builder": ...

        @overload
        def headers(self, value_or_callback: Never = ...) -> "Headers.BuilderContext": ...

        def headers(self, value_or_callback=None, /):
            """
            List of headers that can be added to HTTP responses.
            """
            if self._in_context and value_or_callback is None:
                context = Headers.BuilderContext()
                context._parent_builder = self
                context._field_name = "headers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Headers.builder())
                if isinstance(output, Headers.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("headers", value)

        def http2(self, value: Optional[bool], /) -> Self:
            """
            Enable HTTP/2 support. Note that HTTP/2 is only supported with TLS.
            When TLSConfig is not configured, HTTP/2 will be disabled.
            Whenever the value of the field changes, a rolling update will be triggered.
            """
            return self._set("http2", value)

    class BuilderContext(BuilderContextBase["HttpConfigModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HttpConfigModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HttpConfigModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HttpConfigModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HttpConfigModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    headers: Optional[Headers] = None
    """
    List of headers that can be added to HTTP responses.
    """
    http2: Optional[bool] = None
    """
    Enable HTTP/2 support. Note that HTTP/2 is only supported with TLS.
    When TLSConfig is not configured, HTTP/2 will be disabled.
    Whenever the value of the field changes, a rolling update will be triggered.
    """


class ConfigMapModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapModel2"]:
            return ConfigMapModel2

        def build(self) -> "ConfigMapModel2":
            return ConfigMapModel2(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key to select.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the ConfigMap or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key to select.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the ConfigMap or its key must be defined
    """


class SecretModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretModel2"]:
            return SecretModel2

        def build(self) -> "SecretModel2":
            return SecretModel2(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["SecretModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class ClientCa(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClientCa"]:
            return ClientCa

        def build(self) -> "ClientCa":
            return ClientCa(**self._attrs)

        @overload
        def config_map(
            self, value_or_callback: Optional[ConfigMapModel2], /
        ) -> "ClientCa.Builder": ...

        @overload
        def config_map(
            self,
            value_or_callback: Callable[
                [ConfigMapModel2.Builder], ConfigMapModel2.Builder | ConfigMapModel2
            ],
            /,
        ) -> "ClientCa.Builder": ...

        @overload
        def config_map(
            self, value_or_callback: Never = ...
        ) -> "ConfigMapModel2.BuilderContext": ...

        def config_map(self, value_or_callback=None, /):
            """
            ConfigMap containing data to use for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMapModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMapModel2.builder())
                if isinstance(output, ConfigMapModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map", value)

        @overload
        def secret(self, value_or_callback: Optional[SecretModel2], /) -> "ClientCa.Builder": ...

        @overload
        def secret(
            self,
            value_or_callback: Callable[
                [SecretModel2.Builder], SecretModel2.Builder | SecretModel2
            ],
            /,
        ) -> "ClientCa.Builder": ...

        @overload
        def secret(self, value_or_callback: Never = ...) -> "SecretModel2.BuilderContext": ...

        def secret(self, value_or_callback=None, /):
            """
            Secret containing data to use for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = SecretModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretModel2.builder())
                if isinstance(output, SecretModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret", value)

    class BuilderContext(BuilderContextBase["ClientCa.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClientCa.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClientCa."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClientCa", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClientCa.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_map: Annotated[Optional[ConfigMapModel2], Field(alias="configMap")] = None
    """
    ConfigMap containing data to use for the targets.
    """
    secret: Optional[SecretModel2] = None
    """
    Secret containing data to use for the targets.
    """


class TlsConfigModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsConfigModel"]:
            return TlsConfigModel

        def build(self) -> "TlsConfigModel":
            return TlsConfigModel(**self._attrs)

        @overload
        def cert(self, value_or_callback: Optional[Cert], /) -> "TlsConfigModel.Builder": ...

        @overload
        def cert(
            self, value_or_callback: Callable[[Cert.Builder], Cert.Builder | Cert], /
        ) -> "TlsConfigModel.Builder": ...

        @overload
        def cert(self, value_or_callback: Never = ...) -> "Cert.BuilderContext": ...

        def cert(self, value_or_callback=None, /):
            """
            Secret or ConfigMap containing the TLS certificate for the web server.

            Either `keySecret` or `keyFile` must be defined.

            It is mutually exclusive with `certFile`.
            """
            if self._in_context and value_or_callback is None:
                context = Cert.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cert.builder())
                if isinstance(output, Cert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert", value)

        def cert_file(self, value: Optional[str], /) -> Self:
            """
            Path to the TLS certificate file in the container for the web server.

            Either `keySecret` or `keyFile` must be defined.

            It is mutually exclusive with `cert`.
            """
            return self._set("cert_file", value)

        def cipher_suites(self, value: Optional[List[str]], /) -> Self:
            """
            List of supported cipher suites for TLS versions up to TLS 1.2.

            If not defined, the Go default cipher suites are used.
            Available cipher suites are documented in the Go documentation:
            https://golang.org/pkg/crypto/tls/#pkg-constants
            """
            return self._set("cipher_suites", value)

        @overload
        def client_ca(
            self, value_or_callback: Optional[ClientCa], /
        ) -> "TlsConfigModel.Builder": ...

        @overload
        def client_ca(
            self,
            value_or_callback: Callable[[ClientCa.Builder], ClientCa.Builder | ClientCa],
            /,
        ) -> "TlsConfigModel.Builder": ...

        @overload
        def client_ca(self, value_or_callback: Never = ...) -> "ClientCa.BuilderContext": ...

        def client_ca(self, value_or_callback=None, /):
            """
            Secret or ConfigMap containing the CA certificate for client certificate
            authentication to the server.

            It is mutually exclusive with `clientCAFile`.
            """
            if self._in_context and value_or_callback is None:
                context = ClientCa.BuilderContext()
                context._parent_builder = self
                context._field_name = "client_ca"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClientCa.builder())
                if isinstance(output, ClientCa.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("client_ca", value)

        def client_auth_type(self, value: Optional[str], /) -> Self:
            """
            The server policy for client TLS authentication.

            For more detail on clientAuth options:
            https://golang.org/pkg/crypto/tls/#ClientAuthType
            """
            return self._set("client_auth_type", value)

        def client_ca_file(self, value: Optional[str], /) -> Self:
            """
            Path to the CA certificate file for client certificate authentication to
            the server.

            It is mutually exclusive with `client_ca`.
            """
            return self._set("client_ca_file", value)

        def curve_preferences(self, value: Optional[List[str]], /) -> Self:
            """
            Elliptic curves that will be used in an ECDHE handshake, in preference
            order.

            Available curves are documented in the Go documentation:
            https://golang.org/pkg/crypto/tls/#CurveID
            """
            return self._set("curve_preferences", value)

        def key_file(self, value: Optional[str], /) -> Self:
            """
            Path to the TLS private key file in the container for the web server.

            If defined, either `cert` or `certFile` must be defined.

            It is mutually exclusive with `keySecret`.
            """
            return self._set("key_file", value)

        @overload
        def key_secret(
            self, value_or_callback: Optional[KeySecret], /
        ) -> "TlsConfigModel.Builder": ...

        @overload
        def key_secret(
            self,
            value_or_callback: Callable[[KeySecret.Builder], KeySecret.Builder | KeySecret],
            /,
        ) -> "TlsConfigModel.Builder": ...

        @overload
        def key_secret(self, value_or_callback: Never = ...) -> "KeySecret.BuilderContext": ...

        def key_secret(self, value_or_callback=None, /):
            """
            Secret containing the TLS private key for the web server.

            Either `cert` or `certFile` must be defined.

            It is mutually exclusive with `keyFile`.
            """
            if self._in_context and value_or_callback is None:
                context = KeySecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "key_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KeySecret.builder())
                if isinstance(output, KeySecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("key_secret", value)

        def max_version(self, value: Optional[str], /) -> Self:
            """
            Maximum TLS version that is acceptable.
            """
            return self._set("max_version", value)

        def min_version(self, value: Optional[str], /) -> Self:
            """
            Minimum TLS version that is acceptable.
            """
            return self._set("min_version", value)

        def prefer_server_cipher_suites(self, value: Optional[bool], /) -> Self:
            """
            Controls whether the server selects the client's most preferred cipher
            suite, or the server's most preferred cipher suite.

            If true then the server's preference, as expressed in
            the order of elements in cipherSuites, is used.
            """
            return self._set("prefer_server_cipher_suites", value)

    class BuilderContext(BuilderContextBase["TlsConfigModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsConfigModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsConfigModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsConfigModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsConfigModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cert: Optional[Cert] = None
    """
    Secret or ConfigMap containing the TLS certificate for the web server.

    Either `keySecret` or `keyFile` must be defined.

    It is mutually exclusive with `certFile`.
    """
    cert_file: Annotated[Optional[str], Field(alias="certFile")] = None
    """
    Path to the TLS certificate file in the container for the web server.

    Either `keySecret` or `keyFile` must be defined.

    It is mutually exclusive with `cert`.
    """
    cipher_suites: Annotated[Optional[List[str]], Field(alias="cipherSuites")] = None
    """
    List of supported cipher suites for TLS versions up to TLS 1.2.

    If not defined, the Go default cipher suites are used.
    Available cipher suites are documented in the Go documentation:
    https://golang.org/pkg/crypto/tls/#pkg-constants
    """
    client_ca: Optional[ClientCa] = None
    """
    Secret or ConfigMap containing the CA certificate for client certificate
    authentication to the server.

    It is mutually exclusive with `clientCAFile`.
    """
    client_auth_type: Annotated[Optional[str], Field(alias="clientAuthType")] = None
    """
    The server policy for client TLS authentication.

    For more detail on clientAuth options:
    https://golang.org/pkg/crypto/tls/#ClientAuthType
    """
    client_ca_file: Annotated[Optional[str], Field(alias="clientCAFile")] = None
    """
    Path to the CA certificate file for client certificate authentication to
    the server.

    It is mutually exclusive with `client_ca`.
    """
    curve_preferences: Annotated[Optional[List[str]], Field(alias="curvePreferences")] = None
    """
    Elliptic curves that will be used in an ECDHE handshake, in preference
    order.

    Available curves are documented in the Go documentation:
    https://golang.org/pkg/crypto/tls/#CurveID
    """
    key_file: Annotated[Optional[str], Field(alias="keyFile")] = None
    """
    Path to the TLS private key file in the container for the web server.

    If defined, either `cert` or `certFile` must be defined.

    It is mutually exclusive with `keySecret`.
    """
    key_secret: Annotated[Optional[KeySecret], Field(alias="keySecret")] = None
    """
    Secret containing the TLS private key for the web server.

    Either `cert` or `certFile` must be defined.

    It is mutually exclusive with `keyFile`.
    """
    max_version: Annotated[Optional[str], Field(alias="maxVersion")] = None
    """
    Maximum TLS version that is acceptable.
    """
    min_version: Annotated[Optional[str], Field(alias="minVersion")] = None
    """
    Minimum TLS version that is acceptable.
    """
    prefer_server_cipher_suites: Annotated[
        Optional[bool], Field(alias="preferServerCipherSuites")
    ] = None
    """
    Controls whether the server selects the client's most preferred cipher
    suite, or the server's most preferred cipher suite.

    If true then the server's preference, as expressed in
    the order of elements in cipherSuites, is used.
    """


class Web(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Web"]:
            return Web

        def build(self) -> "Web":
            return Web(**self._attrs)

        def get_concurrency(self, value: Optional[int], /) -> Self:
            """
            Maximum number of GET requests processed concurrently. This corresponds to the
            Alertmanager's `--web.get-concurrency` flag.
            """
            return self._set("get_concurrency", value)

        @overload
        def http_config(self, value_or_callback: Optional[HttpConfigModel], /) -> "Web.Builder": ...

        @overload
        def http_config(
            self,
            value_or_callback: Callable[
                [HttpConfigModel.Builder], HttpConfigModel.Builder | HttpConfigModel
            ],
            /,
        ) -> "Web.Builder": ...

        @overload
        def http_config(
            self, value_or_callback: Never = ...
        ) -> "HttpConfigModel.BuilderContext": ...

        def http_config(self, value_or_callback=None, /):
            """
            Defines HTTP parameters for web server.
            """
            if self._in_context and value_or_callback is None:
                context = HttpConfigModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpConfigModel.builder())
                if isinstance(output, HttpConfigModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_config", value)

        def timeout(self, value: Optional[int], /) -> Self:
            """
            Timeout for HTTP requests. This corresponds to the Alertmanager's
            `--web.timeout` flag.
            """
            return self._set("timeout", value)

        @overload
        def tls_config(self, value_or_callback: Optional[TlsConfigModel], /) -> "Web.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel.Builder], TlsConfigModel.Builder | TlsConfigModel
            ],
            /,
        ) -> "Web.Builder": ...

        @overload
        def tls_config(self, value_or_callback: Never = ...) -> "TlsConfigModel.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            Defines the TLS parameters for HTTPS.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel.builder())
                if isinstance(output, TlsConfigModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["Web.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Web.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Web."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Web", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Web.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    get_concurrency: Annotated[Optional[int], Field(alias="getConcurrency")] = None
    """
    Maximum number of GET requests processed concurrently. This corresponds to the
    Alertmanager's `--web.get-concurrency` flag.
    """
    http_config: Annotated[Optional[HttpConfigModel], Field(alias="httpConfig")] = None
    """
    Defines HTTP parameters for web server.
    """
    timeout: Optional[int] = None
    """
    Timeout for HTTP requests. This corresponds to the Alertmanager's
    `--web.timeout` flag.
    """
    tls_config: Annotated[Optional[TlsConfigModel], Field(alias="tlsConfig")] = None
    """
    Defines the TLS parameters for HTTPS.
    """


class AlertmanagerSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AlertmanagerSpec"]:
            return AlertmanagerSpec

        def build(self) -> "AlertmanagerSpec":
            return AlertmanagerSpec(**self._attrs)

        def additional_peers(self, value: Optional[List[str]], /) -> Self:
            """
            AdditionalPeers allows injecting a set of additional Alertmanagers to peer with to form a highly available cluster.
            """
            return self._set("additional_peers", value)

        @overload
        def affinity(
            self, value_or_callback: Optional[Affinity], /
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def affinity(
            self,
            value_or_callback: Callable[[Affinity.Builder], Affinity.Builder | Affinity],
            /,
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def affinity(self, value_or_callback: Never = ...) -> "Affinity.BuilderContext": ...

        def affinity(self, value_or_callback=None, /):
            """
            If specified, the pod's scheduling constraints.
            """
            if self._in_context and value_or_callback is None:
                context = Affinity.BuilderContext()
                context._parent_builder = self
                context._field_name = "affinity"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Affinity.builder())
                if isinstance(output, Affinity.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("affinity", value)

        @overload
        def alertmanager_config_matcher_strategy(
            self, value_or_callback: Optional[AlertmanagerConfigMatcherStrategy], /
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def alertmanager_config_matcher_strategy(
            self,
            value_or_callback: Callable[
                [AlertmanagerConfigMatcherStrategy.Builder],
                AlertmanagerConfigMatcherStrategy.Builder | AlertmanagerConfigMatcherStrategy,
            ],
            /,
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def alertmanager_config_matcher_strategy(
            self, value_or_callback: Never = ...
        ) -> "AlertmanagerConfigMatcherStrategy.BuilderContext": ...

        def alertmanager_config_matcher_strategy(self, value_or_callback=None, /):
            """
            AlertmanagerConfigMatcherStrategy defines how AlertmanagerConfig objects
            process incoming alerts.
            """
            if self._in_context and value_or_callback is None:
                context = AlertmanagerConfigMatcherStrategy.BuilderContext()
                context._parent_builder = self
                context._field_name = "alertmanager_config_matcher_strategy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AlertmanagerConfigMatcherStrategy.builder())
                if isinstance(output, AlertmanagerConfigMatcherStrategy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("alertmanager_config_matcher_strategy", value)

        @overload
        def alertmanager_config_namespace_selector(
            self, value_or_callback: Optional[AlertmanagerConfigNamespaceSelector], /
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def alertmanager_config_namespace_selector(
            self,
            value_or_callback: Callable[
                [AlertmanagerConfigNamespaceSelector.Builder],
                AlertmanagerConfigNamespaceSelector.Builder | AlertmanagerConfigNamespaceSelector,
            ],
            /,
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def alertmanager_config_namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "AlertmanagerConfigNamespaceSelector.BuilderContext": ...

        def alertmanager_config_namespace_selector(self, value_or_callback=None, /):
            """
            Namespaces to be selected for AlertmanagerConfig discovery. If nil, only
            check own namespace.
            """
            if self._in_context and value_or_callback is None:
                context = AlertmanagerConfigNamespaceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "alertmanager_config_namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AlertmanagerConfigNamespaceSelector.builder())
                if isinstance(output, AlertmanagerConfigNamespaceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("alertmanager_config_namespace_selector", value)

        @overload
        def alertmanager_config_selector(
            self, value_or_callback: Optional[AlertmanagerConfigSelector], /
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def alertmanager_config_selector(
            self,
            value_or_callback: Callable[
                [AlertmanagerConfigSelector.Builder],
                AlertmanagerConfigSelector.Builder | AlertmanagerConfigSelector,
            ],
            /,
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def alertmanager_config_selector(
            self, value_or_callback: Never = ...
        ) -> "AlertmanagerConfigSelector.BuilderContext": ...

        def alertmanager_config_selector(self, value_or_callback=None, /):
            """
            AlertmanagerConfigs to be selected for to merge and configure Alertmanager with.
            """
            if self._in_context and value_or_callback is None:
                context = AlertmanagerConfigSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "alertmanager_config_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AlertmanagerConfigSelector.builder())
                if isinstance(output, AlertmanagerConfigSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("alertmanager_config_selector", value)

        @overload
        def alertmanager_configuration(
            self, value_or_callback: Optional[AlertmanagerConfiguration], /
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def alertmanager_configuration(
            self,
            value_or_callback: Callable[
                [AlertmanagerConfiguration.Builder],
                AlertmanagerConfiguration.Builder | AlertmanagerConfiguration,
            ],
            /,
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def alertmanager_configuration(
            self, value_or_callback: Never = ...
        ) -> "AlertmanagerConfiguration.BuilderContext": ...

        def alertmanager_configuration(self, value_or_callback=None, /):
            """
            alertmanagerConfiguration specifies the configuration of Alertmanager.

            If defined, it takes precedence over the `configSecret` field.

            This is an *experimental feature*, it may change in any upcoming release
            in a breaking way.
            """
            if self._in_context and value_or_callback is None:
                context = AlertmanagerConfiguration.BuilderContext()
                context._parent_builder = self
                context._field_name = "alertmanager_configuration"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AlertmanagerConfiguration.builder())
                if isinstance(output, AlertmanagerConfiguration.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("alertmanager_configuration", value)

        def automount_service_account_token(self, value: Optional[bool], /) -> Self:
            """
            AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in the pod.
            If the service account has `automountServiceAccountToken: true`, set the field to `false` to opt out of automounting API credentials.
            """
            return self._set("automount_service_account_token", value)

        def base_image(self, value: Optional[str], /) -> Self:
            """
            Base image that is used to deploy pods, without tag.
            Deprecated: use 'image' instead.
            """
            return self._set("base_image", value)

        def cluster_advertise_address(self, value: Optional[str], /) -> Self:
            """
            ClusterAdvertiseAddress is the explicit address to advertise in cluster.
            Needs to be provided for non RFC1918 [1] (public) addresses.
            [1] RFC1918: https://tools.ietf.org/html/rfc1918
            """
            return self._set("cluster_advertise_address", value)

        def cluster_gossip_interval(self, value: Optional[str], /) -> Self:
            """
            Interval between gossip attempts.
            """
            return self._set("cluster_gossip_interval", value)

        def cluster_label(self, value: Optional[str], /) -> Self:
            """
            Defines the identifier that uniquely identifies the Alertmanager cluster.
            You should only set it when the Alertmanager cluster includes Alertmanager instances which are external to this Alertmanager resource. In practice, the addresses of the external instances are provided via the `.spec.additionalPeers` field.
            """
            return self._set("cluster_label", value)

        def cluster_peer_timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout for cluster peering.
            """
            return self._set("cluster_peer_timeout", value)

        def cluster_pushpull_interval(self, value: Optional[str], /) -> Self:
            """
            Interval between pushpull attempts.
            """
            return self._set("cluster_pushpull_interval", value)

        def config_maps(self, value: Optional[List[str]], /) -> Self:
            """
            ConfigMaps is a list of ConfigMaps in the same namespace as the Alertmanager
            object, which shall be mounted into the Alertmanager Pods.
            Each ConfigMap is added to the StatefulSet definition as a volume named `configmap-<configmap-name>`.
            The ConfigMaps are mounted into `/etc/alertmanager/configmaps/<configmap-name>` in the 'alertmanager' container.
            """
            return self._set("config_maps", value)

        def config_secret(self, value: Optional[str], /) -> Self:
            """
            ConfigSecret is the name of a Kubernetes Secret in the same namespace as the
            Alertmanager object, which contains the configuration for this Alertmanager
            instance. If empty, it defaults to `alertmanager-<alertmanager-name>`.

            The Alertmanager configuration should be available under the
            `alertmanager.yaml` key. Additional keys from the original secret are
            copied to the generated secret and mounted into the
            `/etc/alertmanager/config` directory in the `alertmanager` container.

            If either the secret or the `alertmanager.yaml` key is missing, the
            operator provisions a minimal Alertmanager configuration with one empty
            receiver (effectively dropping alert notifications).
            """
            return self._set("config_secret", value)

        @overload
        def containers(
            self, value_or_callback: List[Container], /
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def containers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Container, Container.Builder]],
                GenericListBuilder[Container, Container.Builder] | List[Container],
            ],
            /,
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def containers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Container.Builder]: ...

        def containers(self, value_or_callback=None, /):
            """
            Containers allows injecting additional containers. This is meant to
            allow adding an authentication proxy to an Alertmanager pod.
            Containers described here modify an operator generated container if they
            share the same name and modifications are done via a strategic merge
            patch. The current container names are: `alertmanager` and
            `config-reloader`. Overriding containers is entirely outside the scope
            of what the maintainers will support and by doing so, you accept that
            this behaviour may break at any time without notice.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Container.Builder]()
                context._parent_builder = self
                context._field_name = "containers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Container.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("containers", value)

        @overload
        def dns_config(
            self, value_or_callback: Optional[DnsConfig], /
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def dns_config(
            self,
            value_or_callback: Callable[[DnsConfig.Builder], DnsConfig.Builder | DnsConfig],
            /,
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def dns_config(self, value_or_callback: Never = ...) -> "DnsConfig.BuilderContext": ...

        def dns_config(self, value_or_callback=None, /):
            """
            Defines the DNS configuration for the pods.
            """
            if self._in_context and value_or_callback is None:
                context = DnsConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "dns_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DnsConfig.builder())
                if isinstance(output, DnsConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("dns_config", value)

        def dns_policy(
            self,
            value: Optional[Literal["ClusterFirstWithHostNet", "ClusterFirst", "Default", "None"]],
            /,
        ) -> Self:
            """
            Defines the DNS policy for the pods.
            """
            return self._set("dns_policy", value)

        def enable_features(self, value: Optional[List[str]], /) -> Self:
            """
            Enable access to Alertmanager feature flags. By default, no features are enabled.
            Enabling features which are disabled by default is entirely outside the
            scope of what the maintainers will support and by doing so, you accept
            that this behaviour may break at any time without notice.

            It requires Alertmanager >= 0.27.0.
            """
            return self._set("enable_features", value)

        def external_url(self, value: Optional[str], /) -> Self:
            """
            The external URL the Alertmanager instances will be available under. This is
            necessary to generate correct URLs. This is necessary if Alertmanager is not
            served from root of a DNS name.
            """
            return self._set("external_url", value)

        def force_enable_cluster_mode(self, value: Optional[bool], /) -> Self:
            """
            ForceEnableClusterMode ensures Alertmanager does not deactivate the cluster mode when running with a single replica.
            Use case is e.g. spanning an Alertmanager cluster across Kubernetes clusters with a single replica in each.
            """
            return self._set("force_enable_cluster_mode", value)

        @overload
        def host_aliases(
            self, value_or_callback: List[HostAliase], /
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def host_aliases(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[HostAliase, HostAliase.Builder]],
                GenericListBuilder[HostAliase, HostAliase.Builder] | List[HostAliase],
            ],
            /,
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def host_aliases(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[HostAliase.Builder]: ...

        def host_aliases(self, value_or_callback=None, /):
            """
            Pods' hostAliases configuration
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[HostAliase.Builder]()
                context._parent_builder = self
                context._field_name = "host_aliases"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HostAliase.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("host_aliases", value)

        def image(self, value: Optional[str], /) -> Self:
            """
            Image if specified has precedence over baseImage, tag and sha
            combinations. Specifying the version is still necessary to ensure the
            Prometheus Operator knows what version of Alertmanager is being
            configured.
            """
            return self._set("image", value)

        def image_pull_policy(
            self, value: Optional[Literal["", "Always", "Never", "IfNotPresent"]], /
        ) -> Self:
            """
            Image pull policy for the 'alertmanager', 'init-config-reloader' and 'config-reloader' containers.
            See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
            """
            return self._set("image_pull_policy", value)

        @overload
        def image_pull_secrets(
            self, value_or_callback: List[ImagePullSecret], /
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def image_pull_secrets(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ImagePullSecret, ImagePullSecret.Builder]],
                GenericListBuilder[ImagePullSecret, ImagePullSecret.Builder]
                | List[ImagePullSecret],
            ],
            /,
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def image_pull_secrets(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ImagePullSecret.Builder]: ...

        def image_pull_secrets(self, value_or_callback=None, /):
            """
            An optional list of references to secrets in the same namespace
            to use for pulling prometheus and alertmanager images from registries
            see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ImagePullSecret.Builder]()
                context._parent_builder = self
                context._field_name = "image_pull_secrets"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImagePullSecret.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("image_pull_secrets", value)

        @overload
        def init_containers(
            self, value_or_callback: List[InitContainer], /
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def init_containers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[InitContainer, InitContainer.Builder]],
                GenericListBuilder[InitContainer, InitContainer.Builder] | List[InitContainer],
            ],
            /,
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def init_containers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[InitContainer.Builder]: ...

        def init_containers(self, value_or_callback=None, /):
            """
            InitContainers allows adding initContainers to the pod definition. Those can be used to e.g.
            fetch secrets for injection into the Alertmanager configuration from external sources. Any
            errors during the execution of an initContainer will lead to a restart of the Pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
            InitContainers described here modify an operator
            generated init containers if they share the same name and modifications are
            done via a strategic merge patch. The current init container name is:
            `init-config-reloader`. Overriding init containers is entirely outside the
            scope of what the maintainers will support and by doing so, you accept that
            this behaviour may break at any time without notice.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[InitContainer.Builder]()
                context._parent_builder = self
                context._field_name = "init_containers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitContainer.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_containers", value)

        def listen_local(self, value: Optional[bool], /) -> Self:
            """
            ListenLocal makes the Alertmanager server listen on loopback, so that it
            does not bind against the Pod IP. Note this is only for the Alertmanager
            UI, not the gossip communication.
            """
            return self._set("listen_local", value)

        def log_format(self, value: Optional[Literal["", "logfmt", "json"]], /) -> Self:
            """
            Log format for Alertmanager to be configured with.
            """
            return self._set("log_format", value)

        def log_level(
            self, value: Optional[Literal["", "debug", "info", "warn", "error"]], /
        ) -> Self:
            """
            Log level for Alertmanager to be configured with.
            """
            return self._set("log_level", value)

        def min_ready_seconds(self, value: Optional[int], /) -> Self:
            """
            Minimum number of seconds for which a newly created pod should be ready
            without any of its container crashing for it to be considered available.
            Defaults to 0 (pod will be considered available as soon as it is ready)
            This is an alpha field from kubernetes 1.22 until 1.24 which requires enabling the StatefulSetMinReadySeconds feature gate.
            """
            return self._set("min_ready_seconds", value)

        def node_selector(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Define which Nodes the Pods are scheduled on.
            """
            return self._set("node_selector", value)

        def paused(self, value: Optional[bool], /) -> Self:
            """
            If set to true all actions on the underlying managed objects are not
            goint to be performed, except for delete actions.
            """
            return self._set("paused", value)

        @overload
        def persistent_volume_claim_retention_policy(
            self, value_or_callback: Optional[PersistentVolumeClaimRetentionPolicy], /
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def persistent_volume_claim_retention_policy(
            self,
            value_or_callback: Callable[
                [PersistentVolumeClaimRetentionPolicy.Builder],
                PersistentVolumeClaimRetentionPolicy.Builder | PersistentVolumeClaimRetentionPolicy,
            ],
            /,
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def persistent_volume_claim_retention_policy(
            self, value_or_callback: Never = ...
        ) -> "PersistentVolumeClaimRetentionPolicy.BuilderContext": ...

        def persistent_volume_claim_retention_policy(self, value_or_callback=None, /):
            """
            The field controls if and how PVCs are deleted during the lifecycle of a StatefulSet.
            The default behavior is all PVCs are retained.
            This is an alpha field from kubernetes 1.23 until 1.26 and a beta field from 1.26.
            It requires enabling the StatefulSetAutoDeletePVC feature gate.
            """
            if self._in_context and value_or_callback is None:
                context = PersistentVolumeClaimRetentionPolicy.BuilderContext()
                context._parent_builder = self
                context._field_name = "persistent_volume_claim_retention_policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PersistentVolumeClaimRetentionPolicy.builder())
                if isinstance(output, PersistentVolumeClaimRetentionPolicy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("persistent_volume_claim_retention_policy", value)

        @overload
        def pod_metadata(
            self, value_or_callback: Optional[PodMetadata], /
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def pod_metadata(
            self,
            value_or_callback: Callable[[PodMetadata.Builder], PodMetadata.Builder | PodMetadata],
            /,
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def pod_metadata(self, value_or_callback: Never = ...) -> "PodMetadata.BuilderContext": ...

        def pod_metadata(self, value_or_callback=None, /):
            """
            PodMetadata configures labels and annotations which are propagated to the Alertmanager pods.

            The following items are reserved and cannot be overridden:
            * "alertmanager" label, set to the name of the Alertmanager instance.
            * "app.kubernetes.io/instance" label, set to the name of the Alertmanager instance.
            * "app.kubernetes.io/managed-by" label, set to "prometheus-operator".
            * "app.kubernetes.io/name" label, set to "alertmanager".
            * "app.kubernetes.io/version" label, set to the Alertmanager version.
            * "kubectl.kubernetes.io/default-container" annotation, set to "alertmanager".
            """
            if self._in_context and value_or_callback is None:
                context = PodMetadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "pod_metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodMetadata.builder())
                if isinstance(output, PodMetadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("pod_metadata", value)

        def port_name(self, value: Optional[str], /) -> Self:
            """
            Port name used for the pods and governing service.
            Defaults to `web`.
            """
            return self._set("port_name", value)

        def priority_class_name(self, value: Optional[str], /) -> Self:
            """
            Priority class assigned to the Pods
            """
            return self._set("priority_class_name", value)

        def replicas(self, value: Optional[int], /) -> Self:
            """
            Size is the expected size of the alertmanager cluster. The controller will
            eventually make the size of the running cluster equal to the expected
            size.
            """
            return self._set("replicas", value)

        @overload
        def resources(
            self, value_or_callback: Optional[Resources], /
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            Define resources requests and limits for single Pods.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def retention(self, value: Optional[str], /) -> Self:
            """
            Time duration Alertmanager shall retain data for. Default is '120h',
            and must match the regular expression `[0-9]+(ms|s|m|h)` (milliseconds seconds minutes hours).
            """
            return self._set("retention", value)

        def route_prefix(self, value: Optional[str], /) -> Self:
            """
            The route prefix Alertmanager registers HTTP handlers for. This is useful,
            if using ExternalURL and a proxy is rewriting HTTP routes of a request,
            and the actual ExternalURL is still true, but the server serves requests
            under a different route prefix. For example for use with `kubectl proxy`.
            """
            return self._set("route_prefix", value)

        def secrets(self, value: Optional[List[str]], /) -> Self:
            """
            Secrets is a list of Secrets in the same namespace as the Alertmanager
            object, which shall be mounted into the Alertmanager Pods.
            Each Secret is added to the StatefulSet definition as a volume named `secret-<secret-name>`.
            The Secrets are mounted into `/etc/alertmanager/secrets/<secret-name>` in the 'alertmanager' container.
            """
            return self._set("secrets", value)

        @overload
        def security_context(
            self, value_or_callback: Optional[SecurityContextModel], /
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def security_context(
            self,
            value_or_callback: Callable[
                [SecurityContextModel.Builder],
                SecurityContextModel.Builder | SecurityContextModel,
            ],
            /,
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def security_context(
            self, value_or_callback: Never = ...
        ) -> "SecurityContextModel.BuilderContext": ...

        def security_context(self, value_or_callback=None, /):
            """
            SecurityContext holds pod-level security attributes and common container settings.
            This defaults to the default PodSecurityContext.
            """
            if self._in_context and value_or_callback is None:
                context = SecurityContextModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "security_context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecurityContextModel.builder())
                if isinstance(output, SecurityContextModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("security_context", value)

        def service_account_name(self, value: Optional[str], /) -> Self:
            """
            ServiceAccountName is the name of the ServiceAccount to use to run the
            Prometheus Pods.
            """
            return self._set("service_account_name", value)

        def sha(self, value: Optional[str], /) -> Self:
            """
            SHA of Alertmanager container image to be deployed. Defaults to the value of `version`.
            Similar to a tag, but the SHA explicitly deploys an immutable container image.
            Version and Tag are ignored if SHA is set.
            Deprecated: use 'image' instead. The image digest can be specified as part of the image URL.
            """
            return self._set("sha", value)

        @overload
        def storage(
            self, value_or_callback: Optional[Storage], /
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def storage(
            self,
            value_or_callback: Callable[[Storage.Builder], Storage.Builder | Storage],
            /,
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def storage(self, value_or_callback: Never = ...) -> "Storage.BuilderContext": ...

        def storage(self, value_or_callback=None, /):
            """
            Storage is the definition of how storage will be used by the Alertmanager
            instances.
            """
            if self._in_context and value_or_callback is None:
                context = Storage.BuilderContext()
                context._parent_builder = self
                context._field_name = "storage"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Storage.builder())
                if isinstance(output, Storage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("storage", value)

        def tag(self, value: Optional[str], /) -> Self:
            """
            Tag of Alertmanager container image to be deployed. Defaults to the value of `version`.
            Version is ignored if Tag is set.
            Deprecated: use 'image' instead. The image tag can be specified as part of the image URL.
            """
            return self._set("tag", value)

        @overload
        def tolerations(
            self, value_or_callback: List[Toleration], /
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def tolerations(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Toleration, Toleration.Builder]],
                GenericListBuilder[Toleration, Toleration.Builder] | List[Toleration],
            ],
            /,
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def tolerations(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Toleration.Builder]: ...

        def tolerations(self, value_or_callback=None, /):
            """
            If specified, the pod's tolerations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Toleration.Builder]()
                context._parent_builder = self
                context._field_name = "tolerations"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Toleration.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("tolerations", value)

        @overload
        def topology_spread_constraints(
            self, value_or_callback: List[TopologySpreadConstraint], /
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def topology_spread_constraints(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[TopologySpreadConstraint, TopologySpreadConstraint.Builder]],
                GenericListBuilder[TopologySpreadConstraint, TopologySpreadConstraint.Builder]
                | List[TopologySpreadConstraint],
            ],
            /,
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def topology_spread_constraints(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[TopologySpreadConstraint.Builder]: ...

        def topology_spread_constraints(self, value_or_callback=None, /):
            """
            If specified, the pod's topology spread constraints.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[TopologySpreadConstraint.Builder]()
                context._parent_builder = self
                context._field_name = "topology_spread_constraints"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TopologySpreadConstraint.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("topology_spread_constraints", value)

        def version(self, value: Optional[str], /) -> Self:
            """
            Version the cluster should be on.
            """
            return self._set("version", value)

        @overload
        def volume_mounts(
            self, value_or_callback: List[VolumeMount], /
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def volume_mounts(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[VolumeMount, VolumeMount.Builder]],
                GenericListBuilder[VolumeMount, VolumeMount.Builder] | List[VolumeMount],
            ],
            /,
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def volume_mounts(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[VolumeMount.Builder]: ...

        def volume_mounts(self, value_or_callback=None, /):
            """
            VolumeMounts allows configuration of additional VolumeMounts on the output StatefulSet definition.
            VolumeMounts specified will be appended to other VolumeMounts in the alertmanager container,
            that are generated as a result of StorageSpec objects.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[VolumeMount.Builder]()
                context._parent_builder = self
                context._field_name = "volume_mounts"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VolumeMount.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("volume_mounts", value)

        @overload
        def volumes(self, value_or_callback: List[Volume], /) -> "AlertmanagerSpec.Builder": ...

        @overload
        def volumes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Volume, Volume.Builder]],
                GenericListBuilder[Volume, Volume.Builder] | List[Volume],
            ],
            /,
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def volumes(self, value_or_callback: Never = ...) -> ListBuilderContext[Volume.Builder]: ...

        def volumes(self, value_or_callback=None, /):
            """
            Volumes allows configuration of additional volumes on the output StatefulSet definition.
            Volumes specified will be appended to other volumes that are generated as a result of
            StorageSpec objects.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Volume.Builder]()
                context._parent_builder = self
                context._field_name = "volumes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Volume.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("volumes", value)

        @overload
        def web(self, value_or_callback: Optional[Web], /) -> "AlertmanagerSpec.Builder": ...

        @overload
        def web(
            self, value_or_callback: Callable[[Web.Builder], Web.Builder | Web], /
        ) -> "AlertmanagerSpec.Builder": ...

        @overload
        def web(self, value_or_callback: Never = ...) -> "Web.BuilderContext": ...

        def web(self, value_or_callback=None, /):
            """
            Defines the web command line flags when starting Alertmanager.
            """
            if self._in_context and value_or_callback is None:
                context = Web.BuilderContext()
                context._parent_builder = self
                context._field_name = "web"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Web.builder())
                if isinstance(output, Web.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("web", value)

    class BuilderContext(BuilderContextBase["AlertmanagerSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AlertmanagerSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AlertmanagerSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AlertmanagerSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AlertmanagerSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    additional_peers: Annotated[Optional[List[str]], Field(alias="additionalPeers")] = None
    """
    AdditionalPeers allows injecting a set of additional Alertmanagers to peer with to form a highly available cluster.
    """
    affinity: Optional[Affinity] = None
    """
    If specified, the pod's scheduling constraints.
    """
    alertmanager_config_matcher_strategy: Annotated[
        Optional[AlertmanagerConfigMatcherStrategy],
        Field(alias="alertmanagerConfigMatcherStrategy"),
    ] = None
    """
    AlertmanagerConfigMatcherStrategy defines how AlertmanagerConfig objects
    process incoming alerts.
    """
    alertmanager_config_namespace_selector: Annotated[
        Optional[AlertmanagerConfigNamespaceSelector],
        Field(alias="alertmanagerConfigNamespaceSelector"),
    ] = None
    """
    Namespaces to be selected for AlertmanagerConfig discovery. If nil, only
    check own namespace.
    """
    alertmanager_config_selector: Annotated[
        Optional[AlertmanagerConfigSelector], Field(alias="alertmanagerConfigSelector")
    ] = None
    """
    AlertmanagerConfigs to be selected for to merge and configure Alertmanager with.
    """
    alertmanager_configuration: Annotated[
        Optional[AlertmanagerConfiguration], Field(alias="alertmanagerConfiguration")
    ] = None
    """
    alertmanagerConfiguration specifies the configuration of Alertmanager.

    If defined, it takes precedence over the `configSecret` field.

    This is an *experimental feature*, it may change in any upcoming release
    in a breaking way.
    """
    automount_service_account_token: Annotated[
        Optional[bool], Field(alias="automountServiceAccountToken")
    ] = None
    """
    AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in the pod.
    If the service account has `automountServiceAccountToken: true`, set the field to `false` to opt out of automounting API credentials.
    """
    base_image: Annotated[Optional[str], Field(alias="baseImage")] = None
    """
    Base image that is used to deploy pods, without tag.
    Deprecated: use 'image' instead.
    """
    cluster_advertise_address: Annotated[Optional[str], Field(alias="clusterAdvertiseAddress")] = (
        None
    )
    """
    ClusterAdvertiseAddress is the explicit address to advertise in cluster.
    Needs to be provided for non RFC1918 [1] (public) addresses.
    [1] RFC1918: https://tools.ietf.org/html/rfc1918
    """
    cluster_gossip_interval: Annotated[
        Optional[str],
        Field(
            alias="clusterGossipInterval",
            pattern="^(0|(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Interval between gossip attempts.
    """
    cluster_label: Annotated[Optional[str], Field(alias="clusterLabel")] = None
    """
    Defines the identifier that uniquely identifies the Alertmanager cluster.
    You should only set it when the Alertmanager cluster includes Alertmanager instances which are external to this Alertmanager resource. In practice, the addresses of the external instances are provided via the `.spec.additionalPeers` field.
    """
    cluster_peer_timeout: Annotated[
        Optional[str],
        Field(
            alias="clusterPeerTimeout",
            pattern="^(0|(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Timeout for cluster peering.
    """
    cluster_pushpull_interval: Annotated[
        Optional[str],
        Field(
            alias="clusterPushpullInterval",
            pattern="^(0|(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Interval between pushpull attempts.
    """
    config_maps: Annotated[Optional[List[str]], Field(alias="configMaps")] = None
    """
    ConfigMaps is a list of ConfigMaps in the same namespace as the Alertmanager
    object, which shall be mounted into the Alertmanager Pods.
    Each ConfigMap is added to the StatefulSet definition as a volume named `configmap-<configmap-name>`.
    The ConfigMaps are mounted into `/etc/alertmanager/configmaps/<configmap-name>` in the 'alertmanager' container.
    """
    config_secret: Annotated[Optional[str], Field(alias="configSecret")] = None
    """
    ConfigSecret is the name of a Kubernetes Secret in the same namespace as the
    Alertmanager object, which contains the configuration for this Alertmanager
    instance. If empty, it defaults to `alertmanager-<alertmanager-name>`.

    The Alertmanager configuration should be available under the
    `alertmanager.yaml` key. Additional keys from the original secret are
    copied to the generated secret and mounted into the
    `/etc/alertmanager/config` directory in the `alertmanager` container.

    If either the secret or the `alertmanager.yaml` key is missing, the
    operator provisions a minimal Alertmanager configuration with one empty
    receiver (effectively dropping alert notifications).
    """
    containers: Optional[List[Container]] = None
    """
    Containers allows injecting additional containers. This is meant to
    allow adding an authentication proxy to an Alertmanager pod.
    Containers described here modify an operator generated container if they
    share the same name and modifications are done via a strategic merge
    patch. The current container names are: `alertmanager` and
    `config-reloader`. Overriding containers is entirely outside the scope
    of what the maintainers will support and by doing so, you accept that
    this behaviour may break at any time without notice.
    """
    dns_config: Annotated[Optional[DnsConfig], Field(alias="dnsConfig")] = None
    """
    Defines the DNS configuration for the pods.
    """
    dns_policy: Annotated[
        Optional[Literal["ClusterFirstWithHostNet", "ClusterFirst", "Default", "None"]],
        Field(alias="dnsPolicy"),
    ] = None
    """
    Defines the DNS policy for the pods.
    """
    enable_features: Annotated[Optional[List[str]], Field(alias="enableFeatures")] = None
    """
    Enable access to Alertmanager feature flags. By default, no features are enabled.
    Enabling features which are disabled by default is entirely outside the
    scope of what the maintainers will support and by doing so, you accept
    that this behaviour may break at any time without notice.

    It requires Alertmanager >= 0.27.0.
    """
    external_url: Annotated[Optional[str], Field(alias="externalUrl")] = None
    """
    The external URL the Alertmanager instances will be available under. This is
    necessary to generate correct URLs. This is necessary if Alertmanager is not
    served from root of a DNS name.
    """
    force_enable_cluster_mode: Annotated[Optional[bool], Field(alias="forceEnableClusterMode")] = (
        None
    )
    """
    ForceEnableClusterMode ensures Alertmanager does not deactivate the cluster mode when running with a single replica.
    Use case is e.g. spanning an Alertmanager cluster across Kubernetes clusters with a single replica in each.
    """
    host_aliases: Annotated[Optional[List[HostAliase]], Field(alias="hostAliases")] = None
    """
    Pods' hostAliases configuration
    """
    image: Optional[str] = None
    """
    Image if specified has precedence over baseImage, tag and sha
    combinations. Specifying the version is still necessary to ensure the
    Prometheus Operator knows what version of Alertmanager is being
    configured.
    """
    image_pull_policy: Annotated[
        Optional[Literal["", "Always", "Never", "IfNotPresent"]],
        Field(alias="imagePullPolicy"),
    ] = None
    """
    Image pull policy for the 'alertmanager', 'init-config-reloader' and 'config-reloader' containers.
    See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
    """
    image_pull_secrets: Annotated[
        Optional[List[ImagePullSecret]], Field(alias="imagePullSecrets")
    ] = None
    """
    An optional list of references to secrets in the same namespace
    to use for pulling prometheus and alertmanager images from registries
    see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
    """
    init_containers: Annotated[Optional[List[InitContainer]], Field(alias="initContainers")] = None
    """
    InitContainers allows adding initContainers to the pod definition. Those can be used to e.g.
    fetch secrets for injection into the Alertmanager configuration from external sources. Any
    errors during the execution of an initContainer will lead to a restart of the Pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
    InitContainers described here modify an operator
    generated init containers if they share the same name and modifications are
    done via a strategic merge patch. The current init container name is:
    `init-config-reloader`. Overriding init containers is entirely outside the
    scope of what the maintainers will support and by doing so, you accept that
    this behaviour may break at any time without notice.
    """
    listen_local: Annotated[Optional[bool], Field(alias="listenLocal")] = None
    """
    ListenLocal makes the Alertmanager server listen on loopback, so that it
    does not bind against the Pod IP. Note this is only for the Alertmanager
    UI, not the gossip communication.
    """
    log_format: Annotated[Optional[Literal["", "logfmt", "json"]], Field(alias="logFormat")] = None
    """
    Log format for Alertmanager to be configured with.
    """
    log_level: Annotated[
        Optional[Literal["", "debug", "info", "warn", "error"]], Field(alias="logLevel")
    ] = None
    """
    Log level for Alertmanager to be configured with.
    """
    min_ready_seconds: Annotated[Optional[int], Field(alias="minReadySeconds")] = None
    """
    Minimum number of seconds for which a newly created pod should be ready
    without any of its container crashing for it to be considered available.
    Defaults to 0 (pod will be considered available as soon as it is ready)
    This is an alpha field from kubernetes 1.22 until 1.24 which requires enabling the StatefulSetMinReadySeconds feature gate.
    """
    node_selector: Annotated[Optional[Dict[str, str]], Field(alias="nodeSelector")] = None
    """
    Define which Nodes the Pods are scheduled on.
    """
    paused: Optional[bool] = None
    """
    If set to true all actions on the underlying managed objects are not
    goint to be performed, except for delete actions.
    """
    persistent_volume_claim_retention_policy: Annotated[
        Optional[PersistentVolumeClaimRetentionPolicy],
        Field(alias="persistentVolumeClaimRetentionPolicy"),
    ] = None
    """
    The field controls if and how PVCs are deleted during the lifecycle of a StatefulSet.
    The default behavior is all PVCs are retained.
    This is an alpha field from kubernetes 1.23 until 1.26 and a beta field from 1.26.
    It requires enabling the StatefulSetAutoDeletePVC feature gate.
    """
    pod_metadata: Annotated[Optional[PodMetadata], Field(alias="podMetadata")] = None
    """
    PodMetadata configures labels and annotations which are propagated to the Alertmanager pods.

    The following items are reserved and cannot be overridden:
    * "alertmanager" label, set to the name of the Alertmanager instance.
    * "app.kubernetes.io/instance" label, set to the name of the Alertmanager instance.
    * "app.kubernetes.io/managed-by" label, set to "prometheus-operator".
    * "app.kubernetes.io/name" label, set to "alertmanager".
    * "app.kubernetes.io/version" label, set to the Alertmanager version.
    * "kubectl.kubernetes.io/default-container" annotation, set to "alertmanager".
    """
    port_name: Annotated[Optional[str], Field(alias="portName")] = "web"
    """
    Port name used for the pods and governing service.
    Defaults to `web`.
    """
    priority_class_name: Annotated[Optional[str], Field(alias="priorityClassName")] = None
    """
    Priority class assigned to the Pods
    """
    replicas: Optional[int] = None
    """
    Size is the expected size of the alertmanager cluster. The controller will
    eventually make the size of the running cluster equal to the expected
    size.
    """
    resources: Optional[Resources] = None
    """
    Define resources requests and limits for single Pods.
    """
    retention: Annotated[
        Optional[str],
        Field(pattern="^(0|(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"),
    ] = "120h"
    """
    Time duration Alertmanager shall retain data for. Default is '120h',
    and must match the regular expression `[0-9]+(ms|s|m|h)` (milliseconds seconds minutes hours).
    """
    route_prefix: Annotated[Optional[str], Field(alias="routePrefix")] = None
    """
    The route prefix Alertmanager registers HTTP handlers for. This is useful,
    if using ExternalURL and a proxy is rewriting HTTP routes of a request,
    and the actual ExternalURL is still true, but the server serves requests
    under a different route prefix. For example for use with `kubectl proxy`.
    """
    secrets: Optional[List[str]] = None
    """
    Secrets is a list of Secrets in the same namespace as the Alertmanager
    object, which shall be mounted into the Alertmanager Pods.
    Each Secret is added to the StatefulSet definition as a volume named `secret-<secret-name>`.
    The Secrets are mounted into `/etc/alertmanager/secrets/<secret-name>` in the 'alertmanager' container.
    """
    security_context: Annotated[Optional[SecurityContextModel], Field(alias="securityContext")] = (
        None
    )
    """
    SecurityContext holds pod-level security attributes and common container settings.
    This defaults to the default PodSecurityContext.
    """
    service_account_name: Annotated[Optional[str], Field(alias="serviceAccountName")] = None
    """
    ServiceAccountName is the name of the ServiceAccount to use to run the
    Prometheus Pods.
    """
    sha: Optional[str] = None
    """
    SHA of Alertmanager container image to be deployed. Defaults to the value of `version`.
    Similar to a tag, but the SHA explicitly deploys an immutable container image.
    Version and Tag are ignored if SHA is set.
    Deprecated: use 'image' instead. The image digest can be specified as part of the image URL.
    """
    storage: Optional[Storage] = None
    """
    Storage is the definition of how storage will be used by the Alertmanager
    instances.
    """
    tag: Optional[str] = None
    """
    Tag of Alertmanager container image to be deployed. Defaults to the value of `version`.
    Version is ignored if Tag is set.
    Deprecated: use 'image' instead. The image tag can be specified as part of the image URL.
    """
    tolerations: Optional[List[Toleration]] = None
    """
    If specified, the pod's tolerations.
    """
    topology_spread_constraints: Annotated[
        Optional[List[TopologySpreadConstraint]],
        Field(alias="topologySpreadConstraints"),
    ] = None
    """
    If specified, the pod's topology spread constraints.
    """
    version: Optional[str] = None
    """
    Version the cluster should be on.
    """
    volume_mounts: Annotated[Optional[List[VolumeMount]], Field(alias="volumeMounts")] = None
    """
    VolumeMounts allows configuration of additional VolumeMounts on the output StatefulSet definition.
    VolumeMounts specified will be appended to other VolumeMounts in the alertmanager container,
    that are generated as a result of StorageSpec objects.
    """
    volumes: Optional[List[Volume]] = None
    """
    Volumes allows configuration of additional volumes on the output StatefulSet definition.
    Volumes specified will be appended to other volumes that are generated as a result of
    StorageSpec objects.
    """
    web: Optional[Web] = None
    """
    Defines the web command line flags when starting Alertmanager.
    """


class ConditionModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConditionModel"]:
            return ConditionModel

        def build(self) -> "ConditionModel":
            return ConditionModel(**self._attrs)

        def last_transition_time(self, value: datetime, /) -> Self:
            """
            lastTransitionTime is the time of the last update to the current status property.
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Human-readable message indicating details for the condition's last transition.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration represents the .metadata.generation that the
            condition was set based upon. For instance, if `.metadata.generation` is
            currently 12, but the `.status.conditions[].observedGeneration` is 9, the
            condition is out of date with respect to the current state of the
            instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            Reason for the condition's last transition.
            """
            return self._set("reason", value)

        def status(self, value: str, /) -> Self:
            """
            Status of the condition.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of the condition being reported.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["ConditionModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConditionModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConditionModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConditionModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConditionModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[datetime, Field(alias="lastTransitionTime")]
    """
    lastTransitionTime is the time of the last update to the current status property.
    """
    message: Optional[str] = None
    """
    Human-readable message indicating details for the condition's last transition.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration represents the .metadata.generation that the
    condition was set based upon. For instance, if `.metadata.generation` is
    currently 12, but the `.status.conditions[].observedGeneration` is 9, the
    condition is out of date with respect to the current state of the
    instance.
    """
    reason: Optional[str] = None
    """
    Reason for the condition's last transition.
    """
    status: Annotated[str, Field(min_length=1)]
    """
    Status of the condition.
    """
    type: Annotated[str, Field(min_length=1)]
    """
    Type of the condition being reported.
    """


class AlertmanagerStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AlertmanagerStatus"]:
            return AlertmanagerStatus

        def build(self) -> "AlertmanagerStatus":
            return AlertmanagerStatus(**self._attrs)

        def available_replicas(self, value: int, /) -> Self:
            """
            Total number of available pods (ready for at least minReadySeconds)
            targeted by this Alertmanager cluster.
            """
            return self._set("available_replicas", value)

        @overload
        def conditions(
            self, value_or_callback: List[ConditionModel], /
        ) -> "AlertmanagerStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ConditionModel, ConditionModel.Builder]],
                GenericListBuilder[ConditionModel, ConditionModel.Builder] | List[ConditionModel],
            ],
            /,
        ) -> "AlertmanagerStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ConditionModel.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            The current state of the Alertmanager object.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ConditionModel.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConditionModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def paused(self, value: bool, /) -> Self:
            """
            Represents whether any actions on the underlying managed objects are
            being performed. Only delete actions will be performed.
            """
            return self._set("paused", value)

        def replicas(self, value: int, /) -> Self:
            """
            Total number of non-terminated pods targeted by this Alertmanager
            object (their labels match the selector).
            """
            return self._set("replicas", value)

        def selector(self, value: Optional[str], /) -> Self:
            """
            The selector used to match the pods targeted by this Alertmanager object.
            """
            return self._set("selector", value)

        def unavailable_replicas(self, value: int, /) -> Self:
            """
            Total number of unavailable pods targeted by this Alertmanager object.
            """
            return self._set("unavailable_replicas", value)

        def updated_replicas(self, value: int, /) -> Self:
            """
            Total number of non-terminated pods targeted by this Alertmanager
            object that have the desired version spec.
            """
            return self._set("updated_replicas", value)

    class BuilderContext(BuilderContextBase["AlertmanagerStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AlertmanagerStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AlertmanagerStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AlertmanagerStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AlertmanagerStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    available_replicas: Annotated[int, Field(alias="availableReplicas")]
    """
    Total number of available pods (ready for at least minReadySeconds)
    targeted by this Alertmanager cluster.
    """
    conditions: Optional[List[ConditionModel]] = None
    """
    The current state of the Alertmanager object.
    """
    paused: bool
    """
    Represents whether any actions on the underlying managed objects are
    being performed. Only delete actions will be performed.
    """
    replicas: int
    """
    Total number of non-terminated pods targeted by this Alertmanager
    object (their labels match the selector).
    """
    selector: Optional[str] = None
    """
    The selector used to match the pods targeted by this Alertmanager object.
    """
    unavailable_replicas: Annotated[int, Field(alias="unavailableReplicas")]
    """
    Total number of unavailable pods targeted by this Alertmanager object.
    """
    updated_replicas: Annotated[int, Field(alias="updatedReplicas")]
    """
    Total number of non-terminated pods targeted by this Alertmanager
    object that have the desired version spec.
    """


class AttachMetadata(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AttachMetadata"]:
            return AttachMetadata

        def build(self) -> "AttachMetadata":
            return AttachMetadata(**self._attrs)

        def node(self, value: Optional[bool], /) -> Self:
            """
            When set to true, Prometheus attaches node metadata to the discovered
            targets.

            The Prometheus service account must have the `list` and `watch`
            permissions on the `Nodes` objects.
            """
            return self._set("node", value)

    class BuilderContext(BuilderContextBase["AttachMetadata.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AttachMetadata.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AttachMetadata."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AttachMetadata", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AttachMetadata.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    node: Optional[bool] = None
    """
    When set to true, Prometheus attaches node metadata to the discovered
    targets.

    The Prometheus service account must have the `list` and `watch`
    permissions on the `Nodes` objects.
    """


class NamespaceSelectorModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NamespaceSelectorModel"]:
            return NamespaceSelectorModel

        def build(self) -> "NamespaceSelectorModel":
            return NamespaceSelectorModel(**self._attrs)

        def any(self, value: Optional[bool], /) -> Self:
            """
            Boolean describing whether all namespaces are selected in contrast to a
            list restricting them.
            """
            return self._set("any", value)

        def match_names(self, value: Optional[List[str]], /) -> Self:
            """
            List of namespace names to select from.
            """
            return self._set("match_names", value)

    class BuilderContext(BuilderContextBase["NamespaceSelectorModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NamespaceSelectorModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NamespaceSelectorModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NamespaceSelectorModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamespaceSelectorModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    any: Optional[bool] = None
    """
    Boolean describing whether all namespaces are selected in contrast to a
    list restricting them.
    """
    match_names: Annotated[Optional[List[str]], Field(alias="matchNames")] = None
    """
    List of namespace names to select from.
    """


class NativeHistogramMinBucketFactor(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            If the growth factor of one bucket to the next is smaller than this,
            buckets will be merged to increase the factor sufficiently.
            It requires Prometheus >= v2.50.0.
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            If the growth factor of one bucket to the next is smaller than this,
            buckets will be merged to increase the factor sufficiently.
            It requires Prometheus >= v2.50.0.
            """
            self._value = value
            return self

        def build(self) -> "NativeHistogramMinBucketFactor":
            value = cast(int, self._value)
            return NativeHistogramMinBucketFactor(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    If the growth factor of one bucket to the next is smaller than this,
    buckets will be merged to increase the factor sufficiently.
    It requires Prometheus >= v2.50.0.
    """

    class BuilderContext(BuilderContextBase["NativeHistogramMinBucketFactor.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NativeHistogramMinBucketFactor.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NativeHistogramMinBucketFactor."""
        return cls.BuilderContext()


class NativeHistogramMinBucketFactorModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            If the growth factor of one bucket to the next is smaller than this,
            buckets will be merged to increase the factor sufficiently.
            It requires Prometheus >= v2.50.0.
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            If the growth factor of one bucket to the next is smaller than this,
            buckets will be merged to increase the factor sufficiently.
            It requires Prometheus >= v2.50.0.
            """
            self._value = value
            return self

        def build(self) -> "NativeHistogramMinBucketFactorModel":
            value = cast(str, self._value)
            return NativeHistogramMinBucketFactorModel(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    If the growth factor of one bucket to the next is smaller than this,
    buckets will be merged to increase the factor sufficiently.
    It requires Prometheus >= v2.50.0.
    """

    class BuilderContext(BuilderContextBase["NativeHistogramMinBucketFactorModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NativeHistogramMinBucketFactorModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NativeHistogramMinBucketFactorModel."""
        return cls.BuilderContext()


class SourceLabel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            LabelName is a valid Prometheus label name which may only contain ASCII
            letters, numbers, as well as underscores.
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            LabelName is a valid Prometheus label name which may only contain ASCII
            letters, numbers, as well as underscores.
            """
            self._value = value
            return self

        def build(self) -> "SourceLabel":
            value = cast(str, self._value)
            return SourceLabel(value)

    root: Annotated[str, Field(pattern="^[a-zA-Z_][a-zA-Z0-9_]*$")]
    """
    LabelName is a valid Prometheus label name which may only contain ASCII
    letters, numbers, as well as underscores.
    """

    class BuilderContext(BuilderContextBase["SourceLabel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SourceLabel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SourceLabel."""
        return cls.BuilderContext()


class MetricRelabeling(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MetricRelabeling"]:
            return MetricRelabeling

        def build(self) -> "MetricRelabeling":
            return MetricRelabeling(**self._attrs)

        def action(
            self,
            value: Optional[
                Literal[
                    "replace",
                    "Replace",
                    "keep",
                    "Keep",
                    "drop",
                    "Drop",
                    "hashmod",
                    "HashMod",
                    "labelmap",
                    "LabelMap",
                    "labeldrop",
                    "LabelDrop",
                    "labelkeep",
                    "LabelKeep",
                    "lowercase",
                    "Lowercase",
                    "uppercase",
                    "Uppercase",
                    "keepequal",
                    "KeepEqual",
                    "dropequal",
                    "DropEqual",
                ]
            ],
            /,
        ) -> Self:
            """
            Action to perform based on the regex matching.

            `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
            `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.

            Default: "Replace"
            """
            return self._set("action", value)

        def modulus(self, value: Optional[int], /) -> Self:
            """
            Modulus to take of the hash of the source label values.

            Only applicable when the action is `HashMod`.
            """
            return self._set("modulus", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            Regular expression against which the extracted value is matched.
            """
            return self._set("regex", value)

        def replacement(self, value: Optional[str], /) -> Self:
            """
            Replacement value against which a Replace action is performed if the
            regular expression matches.

            Regex capture groups are available.
            """
            return self._set("replacement", value)

        def separator(self, value: Optional[str], /) -> Self:
            """
            Separator is the string between concatenated SourceLabels.
            """
            return self._set("separator", value)

        @overload
        def source_labels(
            self, value_or_callback: List[SourceLabel], /
        ) -> "MetricRelabeling.Builder": ...

        @overload
        def source_labels(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[SourceLabel, SourceLabel.Builder]],
                GenericListBuilder[SourceLabel, SourceLabel.Builder] | List[SourceLabel],
            ],
            /,
        ) -> "MetricRelabeling.Builder": ...

        @overload
        def source_labels(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[SourceLabel.Builder]: ...

        def source_labels(self, value_or_callback=None, /):
            """
            The source labels select values from existing labels. Their content is
            concatenated using the configured Separator and matched against the
            configured regular expression.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[SourceLabel.Builder]()
                context._parent_builder = self
                context._field_name = "source_labels"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SourceLabel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("source_labels", value)

        def target_label(self, value: Optional[str], /) -> Self:
            """
            Label to which the resulting string is written in a replacement.

            It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
            `KeepEqual` and `DropEqual` actions.

            Regex capture groups are available.
            """
            return self._set("target_label", value)

    class BuilderContext(BuilderContextBase["MetricRelabeling.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MetricRelabeling.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MetricRelabeling."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MetricRelabeling", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MetricRelabeling.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    action: Optional[
        Literal[
            "replace",
            "Replace",
            "keep",
            "Keep",
            "drop",
            "Drop",
            "hashmod",
            "HashMod",
            "labelmap",
            "LabelMap",
            "labeldrop",
            "LabelDrop",
            "labelkeep",
            "LabelKeep",
            "lowercase",
            "Lowercase",
            "uppercase",
            "Uppercase",
            "keepequal",
            "KeepEqual",
            "dropequal",
            "DropEqual",
        ]
    ] = "replace"
    """
    Action to perform based on the regex matching.

    `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
    `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.

    Default: "Replace"
    """
    modulus: Optional[int] = None
    """
    Modulus to take of the hash of the source label values.

    Only applicable when the action is `HashMod`.
    """
    regex: Optional[str] = None
    """
    Regular expression against which the extracted value is matched.
    """
    replacement: Optional[str] = None
    """
    Replacement value against which a Replace action is performed if the
    regular expression matches.

    Regex capture groups are available.
    """
    separator: Optional[str] = None
    """
    Separator is the string between concatenated SourceLabels.
    """
    source_labels: Annotated[Optional[List[SourceLabel]], Field(alias="sourceLabels")] = None
    """
    The source labels select values from existing labels. Their content is
    concatenated using the configured Separator and matched against the
    configured regular expression.
    """
    target_label: Annotated[Optional[str], Field(alias="targetLabel")] = None
    """
    Label to which the resulting string is written in a replacement.

    It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
    `KeepEqual` and `DropEqual` actions.

    Regex capture groups are available.
    """


class TlsConfigModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsConfigModel1"]:
            return TlsConfigModel1

        def build(self) -> "TlsConfigModel1":
            return TlsConfigModel1(**self._attrs)

        @overload
        def ca(self, value_or_callback: Optional[Ca], /) -> "TlsConfigModel1.Builder": ...

        @overload
        def ca(
            self, value_or_callback: Callable[[Ca.Builder], Ca.Builder | Ca], /
        ) -> "TlsConfigModel1.Builder": ...

        @overload
        def ca(self, value_or_callback: Never = ...) -> "Ca.BuilderContext": ...

        def ca(self, value_or_callback=None, /):
            """
            Certificate authority used when verifying server certificates.
            """
            if self._in_context and value_or_callback is None:
                context = Ca.BuilderContext()
                context._parent_builder = self
                context._field_name = "ca"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ca.builder())
                if isinstance(output, Ca.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ca", value)

        @overload
        def cert(self, value_or_callback: Optional[Cert], /) -> "TlsConfigModel1.Builder": ...

        @overload
        def cert(
            self, value_or_callback: Callable[[Cert.Builder], Cert.Builder | Cert], /
        ) -> "TlsConfigModel1.Builder": ...

        @overload
        def cert(self, value_or_callback: Never = ...) -> "Cert.BuilderContext": ...

        def cert(self, value_or_callback=None, /):
            """
            Client certificate to present when doing client-authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Cert.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cert.builder())
                if isinstance(output, Cert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert", value)

        def insecure_skip_verify(self, value: Optional[bool], /) -> Self:
            """
            Disable target certificate validation.
            """
            return self._set("insecure_skip_verify", value)

        @overload
        def key_secret(
            self, value_or_callback: Optional[KeySecret], /
        ) -> "TlsConfigModel1.Builder": ...

        @overload
        def key_secret(
            self,
            value_or_callback: Callable[[KeySecret.Builder], KeySecret.Builder | KeySecret],
            /,
        ) -> "TlsConfigModel1.Builder": ...

        @overload
        def key_secret(self, value_or_callback: Never = ...) -> "KeySecret.BuilderContext": ...

        def key_secret(self, value_or_callback=None, /):
            """
            Secret containing the client key file for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = KeySecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "key_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KeySecret.builder())
                if isinstance(output, KeySecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("key_secret", value)

        def max_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Maximum acceptable TLS version.

            It requires Prometheus >= v2.41.0.
            """
            return self._set("max_version", value)

        def min_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Minimum acceptable TLS version.

            It requires Prometheus >= v2.35.0.
            """
            return self._set("min_version", value)

        def server_name(self, value: Optional[str], /) -> Self:
            """
            Used to verify the hostname for the targets.
            """
            return self._set("server_name", value)

    class BuilderContext(BuilderContextBase["TlsConfigModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsConfigModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsConfigModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsConfigModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsConfigModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca: Optional[Ca] = None
    """
    Certificate authority used when verifying server certificates.
    """
    cert: Optional[Cert] = None
    """
    Client certificate to present when doing client-authentication.
    """
    insecure_skip_verify: Annotated[Optional[bool], Field(alias="insecureSkipVerify")] = None
    """
    Disable target certificate validation.
    """
    key_secret: Annotated[Optional[KeySecret], Field(alias="keySecret")] = None
    """
    Secret containing the client key file for the targets.
    """
    max_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="maxVersion")
    ] = None
    """
    Maximum acceptable TLS version.

    It requires Prometheus >= v2.41.0.
    """
    min_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="minVersion")
    ] = None
    """
    Minimum acceptable TLS version.

    It requires Prometheus >= v2.35.0.
    """
    server_name: Annotated[Optional[str], Field(alias="serverName")] = None
    """
    Used to verify the hostname for the targets.
    """


class Relabeling(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Relabeling"]:
            return Relabeling

        def build(self) -> "Relabeling":
            return Relabeling(**self._attrs)

        def action(
            self,
            value: Optional[
                Literal[
                    "replace",
                    "Replace",
                    "keep",
                    "Keep",
                    "drop",
                    "Drop",
                    "hashmod",
                    "HashMod",
                    "labelmap",
                    "LabelMap",
                    "labeldrop",
                    "LabelDrop",
                    "labelkeep",
                    "LabelKeep",
                    "lowercase",
                    "Lowercase",
                    "uppercase",
                    "Uppercase",
                    "keepequal",
                    "KeepEqual",
                    "dropequal",
                    "DropEqual",
                ]
            ],
            /,
        ) -> Self:
            """
            Action to perform based on the regex matching.

            `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
            `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.

            Default: "Replace"
            """
            return self._set("action", value)

        def modulus(self, value: Optional[int], /) -> Self:
            """
            Modulus to take of the hash of the source label values.

            Only applicable when the action is `HashMod`.
            """
            return self._set("modulus", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            Regular expression against which the extracted value is matched.
            """
            return self._set("regex", value)

        def replacement(self, value: Optional[str], /) -> Self:
            """
            Replacement value against which a Replace action is performed if the
            regular expression matches.

            Regex capture groups are available.
            """
            return self._set("replacement", value)

        def separator(self, value: Optional[str], /) -> Self:
            """
            Separator is the string between concatenated SourceLabels.
            """
            return self._set("separator", value)

        @overload
        def source_labels(
            self, value_or_callback: List[SourceLabel], /
        ) -> "Relabeling.Builder": ...

        @overload
        def source_labels(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[SourceLabel, SourceLabel.Builder]],
                GenericListBuilder[SourceLabel, SourceLabel.Builder] | List[SourceLabel],
            ],
            /,
        ) -> "Relabeling.Builder": ...

        @overload
        def source_labels(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[SourceLabel.Builder]: ...

        def source_labels(self, value_or_callback=None, /):
            """
            The source labels select values from existing labels. Their content is
            concatenated using the configured Separator and matched against the
            configured regular expression.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[SourceLabel.Builder]()
                context._parent_builder = self
                context._field_name = "source_labels"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SourceLabel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("source_labels", value)

        def target_label(self, value: Optional[str], /) -> Self:
            """
            Label to which the resulting string is written in a replacement.

            It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
            `KeepEqual` and `DropEqual` actions.

            Regex capture groups are available.
            """
            return self._set("target_label", value)

    class BuilderContext(BuilderContextBase["Relabeling.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Relabeling.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Relabeling."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Relabeling", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Relabeling.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    action: Optional[
        Literal[
            "replace",
            "Replace",
            "keep",
            "Keep",
            "drop",
            "Drop",
            "hashmod",
            "HashMod",
            "labelmap",
            "LabelMap",
            "labeldrop",
            "LabelDrop",
            "labelkeep",
            "LabelKeep",
            "lowercase",
            "Lowercase",
            "uppercase",
            "Uppercase",
            "keepequal",
            "KeepEqual",
            "dropequal",
            "DropEqual",
        ]
    ] = "replace"
    """
    Action to perform based on the regex matching.

    `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
    `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.

    Default: "Replace"
    """
    modulus: Optional[int] = None
    """
    Modulus to take of the hash of the source label values.

    Only applicable when the action is `HashMod`.
    """
    regex: Optional[str] = None
    """
    Regular expression against which the extracted value is matched.
    """
    replacement: Optional[str] = None
    """
    Replacement value against which a Replace action is performed if the
    regular expression matches.

    Regex capture groups are available.
    """
    separator: Optional[str] = None
    """
    Separator is the string between concatenated SourceLabels.
    """
    source_labels: Annotated[Optional[List[SourceLabel]], Field(alias="sourceLabels")] = None
    """
    The source labels select values from existing labels. Their content is
    concatenated using the configured Separator and matched against the
    configured regular expression.
    """
    target_label: Annotated[Optional[str], Field(alias="targetLabel")] = None
    """
    Label to which the resulting string is written in a replacement.

    It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
    `KeepEqual` and `DropEqual` actions.

    Regex capture groups are available.
    """


class PodMetricsEndpoint(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodMetricsEndpoint"]:
            return PodMetricsEndpoint

        def build(self) -> "PodMetricsEndpoint":
            return PodMetricsEndpoint(**self._attrs)

        @overload
        def authorization(
            self, value_or_callback: Optional[Authorization], /
        ) -> "PodMetricsEndpoint.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [Authorization.Builder], Authorization.Builder | Authorization
            ],
            /,
        ) -> "PodMetricsEndpoint.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "Authorization.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            `authorization` configures the Authorization header credentials to use when
            scraping the target.

            Cannot be set at the same time as `basicAuth`, or `oauth2`.
            """
            if self._in_context and value_or_callback is None:
                context = Authorization.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Authorization.builder())
                if isinstance(output, Authorization.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def basic_auth(
            self, value_or_callback: Optional[BasicAuth], /
        ) -> "PodMetricsEndpoint.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "PodMetricsEndpoint.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            `basicAuth` configures the Basic Authentication credentials to use when
            scraping the target.

            Cannot be set at the same time as `authorization`, or `oauth2`.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        @overload
        def bearer_token_secret(
            self, value_or_callback: Optional[BearerTokenSecret], /
        ) -> "PodMetricsEndpoint.Builder": ...

        @overload
        def bearer_token_secret(
            self,
            value_or_callback: Callable[
                [BearerTokenSecret.Builder],
                BearerTokenSecret.Builder | BearerTokenSecret,
            ],
            /,
        ) -> "PodMetricsEndpoint.Builder": ...

        @overload
        def bearer_token_secret(
            self, value_or_callback: Never = ...
        ) -> "BearerTokenSecret.BuilderContext": ...

        def bearer_token_secret(self, value_or_callback=None, /):
            """
            `bearerTokenSecret` specifies a key of a Secret containing the bearer
            token for scraping targets. The secret needs to be in the same namespace
            as the PodMonitor object and readable by the Prometheus Operator.

            Deprecated: use `authorization` instead.
            """
            if self._in_context and value_or_callback is None:
                context = BearerTokenSecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "bearer_token_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BearerTokenSecret.builder())
                if isinstance(output, BearerTokenSecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("bearer_token_secret", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            `enableHttp2` can be used to disable HTTP2 when scraping the target.
            """
            return self._set("enable_http2", value)

        def filter_running(self, value: Optional[bool], /) -> Self:
            """
            When true, the pods which are not running (e.g. either in Failed or
            Succeeded state) are dropped during the target discovery.

            If unset, the filtering is enabled.

            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase
            """
            return self._set("filter_running", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            `followRedirects` defines whether the scrape requests should follow HTTP
            3xx redirects.
            """
            return self._set("follow_redirects", value)

        def honor_labels(self, value: Optional[bool], /) -> Self:
            """
            When true, `honorLabels` preserves the metric's labels when they collide
            with the target's labels.
            """
            return self._set("honor_labels", value)

        def honor_timestamps(self, value: Optional[bool], /) -> Self:
            """
            `honorTimestamps` controls whether Prometheus preserves the timestamps
            when exposed by the target.
            """
            return self._set("honor_timestamps", value)

        def interval(self, value: Optional[str], /) -> Self:
            """
            Interval at which Prometheus scrapes the metrics from the target.

            If empty, Prometheus uses the global scrape interval.
            """
            return self._set("interval", value)

        @overload
        def metric_relabelings(
            self, value_or_callback: List[MetricRelabeling], /
        ) -> "PodMetricsEndpoint.Builder": ...

        @overload
        def metric_relabelings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MetricRelabeling, MetricRelabeling.Builder]],
                GenericListBuilder[MetricRelabeling, MetricRelabeling.Builder]
                | List[MetricRelabeling],
            ],
            /,
        ) -> "PodMetricsEndpoint.Builder": ...

        @overload
        def metric_relabelings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MetricRelabeling.Builder]: ...

        def metric_relabelings(self, value_or_callback=None, /):
            """
            `metricRelabelings` configures the relabeling rules to apply to the
            samples before ingestion.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MetricRelabeling.Builder]()
                context._parent_builder = self
                context._field_name = "metric_relabelings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MetricRelabeling.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("metric_relabelings", value)

        @overload
        def oauth2(
            self, value_or_callback: Optional[Oauth2], /
        ) -> "PodMetricsEndpoint.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "PodMetricsEndpoint.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            `oauth2` configures the OAuth2 settings to use when scraping the target.

            It requires Prometheus >= 2.27.0.

            Cannot be set at the same time as `authorization`, or `basicAuth`.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        def params(self, value: Optional[Dict[str, List[str]]], /) -> Self:
            """
            `params` define optional HTTP URL parameters.
            """
            return self._set("params", value)

        def path(self, value: Optional[str], /) -> Self:
            """
            HTTP path from which to scrape for metrics.

            If empty, Prometheus uses the default value (e.g. `/metrics`).
            """
            return self._set("path", value)

        def port(self, value: Optional[str], /) -> Self:
            """
            The `Pod` port name which exposes the endpoint.

            It takes precedence over the `portNumber` and `targetPort` fields.
            """
            return self._set("port", value)

        def port_number(self, value: Optional[int], /) -> Self:
            """
            The `Pod` port number which exposes the endpoint.
            """
            return self._set("port_number", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` configures the HTTP Proxy URL (e.g.
            "http://proxyserver:2195") to go through when scraping the target.
            """
            return self._set("proxy_url", value)

        @overload
        def relabelings(
            self, value_or_callback: List[Relabeling], /
        ) -> "PodMetricsEndpoint.Builder": ...

        @overload
        def relabelings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Relabeling, Relabeling.Builder]],
                GenericListBuilder[Relabeling, Relabeling.Builder] | List[Relabeling],
            ],
            /,
        ) -> "PodMetricsEndpoint.Builder": ...

        @overload
        def relabelings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Relabeling.Builder]: ...

        def relabelings(self, value_or_callback=None, /):
            """
            `relabelings` configures the relabeling rules to apply the target's
            metadata labels.

            The Operator automatically adds relabelings for a few standard Kubernetes fields.

            The original scrape job's name is available via the `__tmp_prometheus_job_name` label.

            More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Relabeling.Builder]()
                context._parent_builder = self
                context._field_name = "relabelings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Relabeling.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("relabelings", value)

        def scheme(self, value: Optional[Literal["http", "https"]], /) -> Self:
            """
            HTTP scheme to use for scraping.

            `http` and `https` are the expected values unless you rewrite the
            `__scheme__` label via relabeling.

            If empty, Prometheus uses the default value `http`.
            """
            return self._set("scheme", value)

        def scrape_timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout after which Prometheus considers the scrape to be failed.

            If empty, Prometheus uses the global scrape timeout unless it is less
            than the target's scrape interval value in which the latter is used.
            The value cannot be greater than the scrape interval otherwise the operator will reject the resource.
            """
            return self._set("scrape_timeout", value)

        def target_port(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Name or number of the target port of the `Pod` object behind the Service, the
            port must be specified with container port property.

            Deprecated: use 'port' or 'portNumber' instead.
            """
            return self._set("target_port", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel1], /
        ) -> "PodMetricsEndpoint.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel1.Builder], TlsConfigModel1.Builder | TlsConfigModel1
            ],
            /,
        ) -> "PodMetricsEndpoint.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel1.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration to use when scraping the target.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel1.builder())
                if isinstance(output, TlsConfigModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

        def track_timestamps_staleness(self, value: Optional[bool], /) -> Self:
            """
            `trackTimestampsStaleness` defines whether Prometheus tracks staleness of
            the metrics that have an explicit timestamp present in scraped data.
            Has no effect if `honorTimestamps` is false.

            It requires Prometheus >= v2.48.0.
            """
            return self._set("track_timestamps_staleness", value)

    class BuilderContext(BuilderContextBase["PodMetricsEndpoint.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodMetricsEndpoint.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodMetricsEndpoint."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodMetricsEndpoint", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodMetricsEndpoint.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authorization: Optional[Authorization] = None
    """
    `authorization` configures the Authorization header credentials to use when
    scraping the target.

    Cannot be set at the same time as `basicAuth`, or `oauth2`.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    `basicAuth` configures the Basic Authentication credentials to use when
    scraping the target.

    Cannot be set at the same time as `authorization`, or `oauth2`.
    """
    bearer_token_secret: Annotated[
        Optional[BearerTokenSecret], Field(alias="bearerTokenSecret")
    ] = None
    """
    `bearerTokenSecret` specifies a key of a Secret containing the bearer
    token for scraping targets. The secret needs to be in the same namespace
    as the PodMonitor object and readable by the Prometheus Operator.

    Deprecated: use `authorization` instead.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHttp2")] = None
    """
    `enableHttp2` can be used to disable HTTP2 when scraping the target.
    """
    filter_running: Annotated[Optional[bool], Field(alias="filterRunning")] = None
    """
    When true, the pods which are not running (e.g. either in Failed or
    Succeeded state) are dropped during the target discovery.

    If unset, the filtering is enabled.

    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    `followRedirects` defines whether the scrape requests should follow HTTP
    3xx redirects.
    """
    honor_labels: Annotated[Optional[bool], Field(alias="honorLabels")] = None
    """
    When true, `honorLabels` preserves the metric's labels when they collide
    with the target's labels.
    """
    honor_timestamps: Annotated[Optional[bool], Field(alias="honorTimestamps")] = None
    """
    `honorTimestamps` controls whether Prometheus preserves the timestamps
    when exposed by the target.
    """
    interval: Annotated[
        Optional[str],
        Field(
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"
        ),
    ] = None
    """
    Interval at which Prometheus scrapes the metrics from the target.

    If empty, Prometheus uses the global scrape interval.
    """
    metric_relabelings: Annotated[
        Optional[List[MetricRelabeling]], Field(alias="metricRelabelings")
    ] = None
    """
    `metricRelabelings` configures the relabeling rules to apply to the
    samples before ingestion.
    """
    oauth2: Optional[Oauth2] = None
    """
    `oauth2` configures the OAuth2 settings to use when scraping the target.

    It requires Prometheus >= 2.27.0.

    Cannot be set at the same time as `authorization`, or `basicAuth`.
    """
    params: Optional[Dict[str, List[str]]] = None
    """
    `params` define optional HTTP URL parameters.
    """
    path: Optional[str] = None
    """
    HTTP path from which to scrape for metrics.

    If empty, Prometheus uses the default value (e.g. `/metrics`).
    """
    port: Optional[str] = None
    """
    The `Pod` port name which exposes the endpoint.

    It takes precedence over the `portNumber` and `targetPort` fields.
    """
    port_number: Annotated[Optional[int], Field(alias="portNumber", ge=1, le=65535)] = None
    """
    The `Pod` port number which exposes the endpoint.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl")] = None
    """
    `proxyURL` configures the HTTP Proxy URL (e.g.
    "http://proxyserver:2195") to go through when scraping the target.
    """
    relabelings: Optional[List[Relabeling]] = None
    """
    `relabelings` configures the relabeling rules to apply the target's
    metadata labels.

    The Operator automatically adds relabelings for a few standard Kubernetes fields.

    The original scrape job's name is available via the `__tmp_prometheus_job_name` label.

    More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
    """
    scheme: Optional[Literal["http", "https"]] = None
    """
    HTTP scheme to use for scraping.

    `http` and `https` are the expected values unless you rewrite the
    `__scheme__` label via relabeling.

    If empty, Prometheus uses the default value `http`.
    """
    scrape_timeout: Annotated[
        Optional[str],
        Field(
            alias="scrapeTimeout",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Timeout after which Prometheus considers the scrape to be failed.

    If empty, Prometheus uses the global scrape timeout unless it is less
    than the target's scrape interval value in which the latter is used.
    The value cannot be greater than the scrape interval otherwise the operator will reject the resource.
    """
    target_port: Annotated[Optional[Union[int, str]], Field(alias="targetPort")] = None
    """
    Name or number of the target port of the `Pod` object behind the Service, the
    port must be specified with container port property.

    Deprecated: use 'port' or 'portNumber' instead.
    """
    tls_config: Annotated[Optional[TlsConfigModel1], Field(alias="tlsConfig")] = None
    """
    TLS configuration to use when scraping the target.
    """
    track_timestamps_staleness: Annotated[
        Optional[bool], Field(alias="trackTimestampsStaleness")
    ] = None
    """
    `trackTimestampsStaleness` defines whether Prometheus tracks staleness of
    the metrics that have an explicit timestamp present in scraped data.
    Has no effect if `honorTimestamps` is false.

    It requires Prometheus >= v2.48.0.
    """


class PodMonitorSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodMonitorSpec"]:
            return PodMonitorSpec

        def build(self) -> "PodMonitorSpec":
            return PodMonitorSpec(**self._attrs)

        @overload
        def attach_metadata(
            self, value_or_callback: Optional[AttachMetadata], /
        ) -> "PodMonitorSpec.Builder": ...

        @overload
        def attach_metadata(
            self,
            value_or_callback: Callable[
                [AttachMetadata.Builder], AttachMetadata.Builder | AttachMetadata
            ],
            /,
        ) -> "PodMonitorSpec.Builder": ...

        @overload
        def attach_metadata(
            self, value_or_callback: Never = ...
        ) -> "AttachMetadata.BuilderContext": ...

        def attach_metadata(self, value_or_callback=None, /):
            """
            `attachMetadata` defines additional metadata which is added to the
            discovered targets.

            It requires Prometheus >= v2.35.0.
            """
            if self._in_context and value_or_callback is None:
                context = AttachMetadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "attach_metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AttachMetadata.builder())
                if isinstance(output, AttachMetadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("attach_metadata", value)

        def body_size_limit(self, value: Optional[str], /) -> Self:
            """
            When defined, bodySizeLimit specifies a job level limit on the size
            of uncompressed response body that will be accepted by Prometheus.

            It requires Prometheus >= v2.28.0.
            """
            return self._set("body_size_limit", value)

        def fallback_scrape_protocol(
            self,
            value: Optional[
                Literal[
                    "PrometheusProto",
                    "OpenMetricsText0.0.1",
                    "OpenMetricsText1.0.0",
                    "PrometheusText0.0.4",
                    "PrometheusText1.0.0",
                ]
            ],
            /,
        ) -> Self:
            """
            The protocol to use if a scrape returns blank, unparseable, or otherwise invalid Content-Type.

            It requires Prometheus >= v3.0.0.
            """
            return self._set("fallback_scrape_protocol", value)

        def job_label(self, value: Optional[str], /) -> Self:
            """
            The label to use to retrieve the job name from.
            `jobLabel` selects the label from the associated Kubernetes `Pod`
            object which will be used as the `job` label for all metrics.

            For example if `jobLabel` is set to `foo` and the Kubernetes `Pod`
            object is labeled with `foo: bar`, then Prometheus adds the `job="bar"`
            label to all ingested metrics.

            If the value of this field is empty, the `job` label of the metrics
            defaults to the namespace and name of the PodMonitor object (e.g. `<namespace>/<name>`).
            """
            return self._set("job_label", value)

        def keep_dropped_targets(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on the number of targets dropped by relabeling
            that will be kept in memory. 0 means no limit.

            It requires Prometheus >= v2.47.0.
            """
            return self._set("keep_dropped_targets", value)

        def label_limit(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on number of labels that will be accepted for a sample.

            It requires Prometheus >= v2.27.0.
            """
            return self._set("label_limit", value)

        def label_name_length_limit(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on length of labels name that will be accepted for a sample.

            It requires Prometheus >= v2.27.0.
            """
            return self._set("label_name_length_limit", value)

        def label_value_length_limit(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on length of labels value that will be accepted for a sample.

            It requires Prometheus >= v2.27.0.
            """
            return self._set("label_value_length_limit", value)

        @overload
        def namespace_selector(
            self, value_or_callback: Optional[NamespaceSelectorModel], /
        ) -> "PodMonitorSpec.Builder": ...

        @overload
        def namespace_selector(
            self,
            value_or_callback: Callable[
                [NamespaceSelectorModel.Builder],
                NamespaceSelectorModel.Builder | NamespaceSelectorModel,
            ],
            /,
        ) -> "PodMonitorSpec.Builder": ...

        @overload
        def namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "NamespaceSelectorModel.BuilderContext": ...

        def namespace_selector(self, value_or_callback=None, /):
            """
            `namespaceSelector` defines in which namespace(s) Prometheus should discover the pods.
            By default, the pods are discovered in the same namespace as the `PodMonitor` object but it is possible to select pods across different/all namespaces.
            """
            if self._in_context and value_or_callback is None:
                context = NamespaceSelectorModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamespaceSelectorModel.builder())
                if isinstance(output, NamespaceSelectorModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("namespace_selector", value)

        def native_histogram_bucket_limit(self, value: Optional[int], /) -> Self:
            """
            If there are more than this many buckets in a native histogram,
            buckets will be merged to stay within the limit.
            It requires Prometheus >= v2.45.0.
            """
            return self._set("native_histogram_bucket_limit", value)

        def native_histogram_min_bucket_factor(
            self,
            value: Optional[
                Union[NativeHistogramMinBucketFactor, NativeHistogramMinBucketFactorModel]
            ],
            /,
        ) -> Self:
            """
            If the growth factor of one bucket to the next is smaller than this,
            buckets will be merged to increase the factor sufficiently.
            It requires Prometheus >= v2.50.0.
            """
            return self._set("native_histogram_min_bucket_factor", value)

        @overload
        def pod_metrics_endpoints(
            self, value_or_callback: List[PodMetricsEndpoint], /
        ) -> "PodMonitorSpec.Builder": ...

        @overload
        def pod_metrics_endpoints(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PodMetricsEndpoint, PodMetricsEndpoint.Builder]],
                GenericListBuilder[PodMetricsEndpoint, PodMetricsEndpoint.Builder]
                | List[PodMetricsEndpoint],
            ],
            /,
        ) -> "PodMonitorSpec.Builder": ...

        @overload
        def pod_metrics_endpoints(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PodMetricsEndpoint.Builder]: ...

        def pod_metrics_endpoints(self, value_or_callback=None, /):
            """
            Defines how to scrape metrics from the selected pods.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PodMetricsEndpoint.Builder]()
                context._parent_builder = self
                context._field_name = "pod_metrics_endpoints"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodMetricsEndpoint.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("pod_metrics_endpoints", value)

        def pod_target_labels(self, value: Optional[List[str]], /) -> Self:
            """
            `podTargetLabels` defines the labels which are transferred from the
            associated Kubernetes `Pod` object onto the ingested metrics.
            """
            return self._set("pod_target_labels", value)

        def sample_limit(self, value: Optional[int], /) -> Self:
            """
            `sampleLimit` defines a per-scrape limit on the number of scraped samples
            that will be accepted.
            """
            return self._set("sample_limit", value)

        def scrape_class(self, value: Optional[str], /) -> Self:
            """
            The scrape class to apply.
            """
            return self._set("scrape_class", value)

        def scrape_classic_histograms(self, value: Optional[bool], /) -> Self:
            """
            Whether to scrape a classic histogram that is also exposed as a native histogram.
            It requires Prometheus >= v2.45.0.
            """
            return self._set("scrape_classic_histograms", value)

        def scrape_protocols(
            self,
            value: Optional[
                List[
                    Literal[
                        "PrometheusProto",
                        "OpenMetricsText0.0.1",
                        "OpenMetricsText1.0.0",
                        "PrometheusText0.0.4",
                        "PrometheusText1.0.0",
                    ]
                ]
            ],
            /,
        ) -> Self:
            """
            `scrapeProtocols` defines the protocols to negotiate during a scrape. It tells clients the
            protocols supported by Prometheus in order of preference (from most to least preferred).

            If unset, Prometheus uses its default value.

            It requires Prometheus >= v2.49.0.
            """
            return self._set("scrape_protocols", value)

        @overload
        def selector(self, value_or_callback: Selector, /) -> "PodMonitorSpec.Builder": ...

        @overload
        def selector(
            self,
            value_or_callback: Callable[[Selector.Builder], Selector.Builder | Selector],
            /,
        ) -> "PodMonitorSpec.Builder": ...

        @overload
        def selector(self, value_or_callback: Never = ...) -> "Selector.BuilderContext": ...

        def selector(self, value_or_callback=None, /):
            """
            Label selector to select the Kubernetes `Pod` objects to scrape metrics from.
            """
            if self._in_context and value_or_callback is None:
                context = Selector.BuilderContext()
                context._parent_builder = self
                context._field_name = "selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Selector.builder())
                if isinstance(output, Selector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("selector", value)

        def selector_mechanism(
            self, value: Optional[Literal["RelabelConfig", "RoleSelector"]], /
        ) -> Self:
            """
            Mechanism used to select the endpoints to scrape.
            By default, the selection process relies on relabel configurations to filter the discovered targets.
            Alternatively, you can opt in for role selectors, which may offer better efficiency in large clusters.
            Which strategy is best for your use case needs to be carefully evaluated.

            It requires Prometheus >= v2.17.0.
            """
            return self._set("selector_mechanism", value)

        def target_limit(self, value: Optional[int], /) -> Self:
            """
            `targetLimit` defines a limit on the number of scraped targets that will
            be accepted.
            """
            return self._set("target_limit", value)

    class BuilderContext(BuilderContextBase["PodMonitorSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodMonitorSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodMonitorSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodMonitorSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodMonitorSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    attach_metadata: Annotated[Optional[AttachMetadata], Field(alias="attachMetadata")] = None
    """
    `attachMetadata` defines additional metadata which is added to the
    discovered targets.

    It requires Prometheus >= v2.35.0.
    """
    body_size_limit: Annotated[
        Optional[str],
        Field(alias="bodySizeLimit", pattern="(^0|([0-9]*[.])?[0-9]+((K|M|G|T|E|P)i?)?B)$"),
    ] = None
    """
    When defined, bodySizeLimit specifies a job level limit on the size
    of uncompressed response body that will be accepted by Prometheus.

    It requires Prometheus >= v2.28.0.
    """
    fallback_scrape_protocol: Annotated[
        Optional[
            Literal[
                "PrometheusProto",
                "OpenMetricsText0.0.1",
                "OpenMetricsText1.0.0",
                "PrometheusText0.0.4",
                "PrometheusText1.0.0",
            ]
        ],
        Field(alias="fallbackScrapeProtocol"),
    ] = None
    """
    The protocol to use if a scrape returns blank, unparseable, or otherwise invalid Content-Type.

    It requires Prometheus >= v3.0.0.
    """
    job_label: Annotated[Optional[str], Field(alias="jobLabel")] = None
    """
    The label to use to retrieve the job name from.
    `jobLabel` selects the label from the associated Kubernetes `Pod`
    object which will be used as the `job` label for all metrics.

    For example if `jobLabel` is set to `foo` and the Kubernetes `Pod`
    object is labeled with `foo: bar`, then Prometheus adds the `job="bar"`
    label to all ingested metrics.

    If the value of this field is empty, the `job` label of the metrics
    defaults to the namespace and name of the PodMonitor object (e.g. `<namespace>/<name>`).
    """
    keep_dropped_targets: Annotated[Optional[int], Field(alias="keepDroppedTargets")] = None
    """
    Per-scrape limit on the number of targets dropped by relabeling
    that will be kept in memory. 0 means no limit.

    It requires Prometheus >= v2.47.0.
    """
    label_limit: Annotated[Optional[int], Field(alias="labelLimit")] = None
    """
    Per-scrape limit on number of labels that will be accepted for a sample.

    It requires Prometheus >= v2.27.0.
    """
    label_name_length_limit: Annotated[Optional[int], Field(alias="labelNameLengthLimit")] = None
    """
    Per-scrape limit on length of labels name that will be accepted for a sample.

    It requires Prometheus >= v2.27.0.
    """
    label_value_length_limit: Annotated[Optional[int], Field(alias="labelValueLengthLimit")] = None
    """
    Per-scrape limit on length of labels value that will be accepted for a sample.

    It requires Prometheus >= v2.27.0.
    """
    namespace_selector: Annotated[
        Optional[NamespaceSelectorModel], Field(alias="namespaceSelector")
    ] = None
    """
    `namespaceSelector` defines in which namespace(s) Prometheus should discover the pods.
    By default, the pods are discovered in the same namespace as the `PodMonitor` object but it is possible to select pods across different/all namespaces.
    """
    native_histogram_bucket_limit: Annotated[
        Optional[int], Field(alias="nativeHistogramBucketLimit")
    ] = None
    """
    If there are more than this many buckets in a native histogram,
    buckets will be merged to stay within the limit.
    It requires Prometheus >= v2.45.0.
    """
    native_histogram_min_bucket_factor: Annotated[
        Optional[Union[NativeHistogramMinBucketFactor, NativeHistogramMinBucketFactorModel]],
        Field(alias="nativeHistogramMinBucketFactor"),
    ] = None
    """
    If the growth factor of one bucket to the next is smaller than this,
    buckets will be merged to increase the factor sufficiently.
    It requires Prometheus >= v2.50.0.
    """
    pod_metrics_endpoints: Annotated[
        Optional[List[PodMetricsEndpoint]], Field(alias="podMetricsEndpoints")
    ] = None
    """
    Defines how to scrape metrics from the selected pods.
    """
    pod_target_labels: Annotated[Optional[List[str]], Field(alias="podTargetLabels")] = None
    """
    `podTargetLabels` defines the labels which are transferred from the
    associated Kubernetes `Pod` object onto the ingested metrics.
    """
    sample_limit: Annotated[Optional[int], Field(alias="sampleLimit")] = None
    """
    `sampleLimit` defines a per-scrape limit on the number of scraped samples
    that will be accepted.
    """
    scrape_class: Annotated[Optional[str], Field(alias="scrapeClass", min_length=1)] = None
    """
    The scrape class to apply.
    """
    scrape_classic_histograms: Annotated[Optional[bool], Field(alias="scrapeClassicHistograms")] = (
        None
    )
    """
    Whether to scrape a classic histogram that is also exposed as a native histogram.
    It requires Prometheus >= v2.45.0.
    """
    scrape_protocols: Annotated[
        Optional[
            List[
                Literal[
                    "PrometheusProto",
                    "OpenMetricsText0.0.1",
                    "OpenMetricsText1.0.0",
                    "PrometheusText0.0.4",
                    "PrometheusText1.0.0",
                ]
            ]
        ],
        Field(alias="scrapeProtocols"),
    ] = None
    """
    `scrapeProtocols` defines the protocols to negotiate during a scrape. It tells clients the
    protocols supported by Prometheus in order of preference (from most to least preferred).

    If unset, Prometheus uses its default value.

    It requires Prometheus >= v2.49.0.
    """
    selector: Selector
    """
    Label selector to select the Kubernetes `Pod` objects to scrape metrics from.
    """
    selector_mechanism: Annotated[
        Optional[Literal["RelabelConfig", "RoleSelector"]],
        Field(alias="selectorMechanism"),
    ] = None
    """
    Mechanism used to select the endpoints to scrape.
    By default, the selection process relies on relabel configurations to filter the discovered targets.
    Alternatively, you can opt in for role selectors, which may offer better efficiency in large clusters.
    Which strategy is best for your use case needs to be carefully evaluated.

    It requires Prometheus >= v2.17.0.
    """
    target_limit: Annotated[Optional[int], Field(alias="targetLimit")] = None
    """
    `targetLimit` defines a limit on the number of scraped targets that will
    be accepted.
    """


class NativeHistogramMinBucketFactorModel1(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            If the growth factor of one bucket to the next is smaller than this,
            buckets will be merged to increase the factor sufficiently.
            It requires Prometheus >= v2.50.0.
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            If the growth factor of one bucket to the next is smaller than this,
            buckets will be merged to increase the factor sufficiently.
            It requires Prometheus >= v2.50.0.
            """
            self._value = value
            return self

        def build(self) -> "NativeHistogramMinBucketFactorModel1":
            value = cast(int, self._value)
            return NativeHistogramMinBucketFactorModel1(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    If the growth factor of one bucket to the next is smaller than this,
    buckets will be merged to increase the factor sufficiently.
    It requires Prometheus >= v2.50.0.
    """

    class BuilderContext(BuilderContextBase["NativeHistogramMinBucketFactorModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NativeHistogramMinBucketFactorModel1.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NativeHistogramMinBucketFactorModel1."""
        return cls.BuilderContext()


class NativeHistogramMinBucketFactorModel2(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            If the growth factor of one bucket to the next is smaller than this,
            buckets will be merged to increase the factor sufficiently.
            It requires Prometheus >= v2.50.0.
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            If the growth factor of one bucket to the next is smaller than this,
            buckets will be merged to increase the factor sufficiently.
            It requires Prometheus >= v2.50.0.
            """
            self._value = value
            return self

        def build(self) -> "NativeHistogramMinBucketFactorModel2":
            value = cast(str, self._value)
            return NativeHistogramMinBucketFactorModel2(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    If the growth factor of one bucket to the next is smaller than this,
    buckets will be merged to increase the factor sufficiently.
    It requires Prometheus >= v2.50.0.
    """

    class BuilderContext(BuilderContextBase["NativeHistogramMinBucketFactorModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NativeHistogramMinBucketFactorModel2.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NativeHistogramMinBucketFactorModel2."""
        return cls.BuilderContext()


class Prober(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Prober"]:
            return Prober

        def build(self) -> "Prober":
            return Prober(**self._attrs)

        def path(self, value: Optional[str], /) -> Self:
            """
            Path to collect metrics from.
            Defaults to `/probe`.
            """
            return self._set("path", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            Optional ProxyURL.
            """
            return self._set("proxy_url", value)

        def scheme(self, value: Optional[Literal["http", "https"]], /) -> Self:
            """
            HTTP scheme to use for scraping.
            `http` and `https` are the expected values unless you rewrite the `__scheme__` label via relabeling.
            If empty, Prometheus uses the default value `http`.
            """
            return self._set("scheme", value)

        def url(self, value: str, /) -> Self:
            """
            Mandatory URL of the prober.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["Prober.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Prober.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Prober."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Prober", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Prober.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    path: Optional[str] = "/probe"
    """
    Path to collect metrics from.
    Defaults to `/probe`.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl")] = None
    """
    Optional ProxyURL.
    """
    scheme: Optional[Literal["http", "https"]] = None
    """
    HTTP scheme to use for scraping.
    `http` and `https` are the expected values unless you rewrite the `__scheme__` label via relabeling.
    If empty, Prometheus uses the default value `http`.
    """
    url: str
    """
    Mandatory URL of the prober.
    """


class RelabelingConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RelabelingConfig"]:
            return RelabelingConfig

        def build(self) -> "RelabelingConfig":
            return RelabelingConfig(**self._attrs)

        def action(
            self,
            value: Optional[
                Literal[
                    "replace",
                    "Replace",
                    "keep",
                    "Keep",
                    "drop",
                    "Drop",
                    "hashmod",
                    "HashMod",
                    "labelmap",
                    "LabelMap",
                    "labeldrop",
                    "LabelDrop",
                    "labelkeep",
                    "LabelKeep",
                    "lowercase",
                    "Lowercase",
                    "uppercase",
                    "Uppercase",
                    "keepequal",
                    "KeepEqual",
                    "dropequal",
                    "DropEqual",
                ]
            ],
            /,
        ) -> Self:
            """
            Action to perform based on the regex matching.

            `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
            `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.

            Default: "Replace"
            """
            return self._set("action", value)

        def modulus(self, value: Optional[int], /) -> Self:
            """
            Modulus to take of the hash of the source label values.

            Only applicable when the action is `HashMod`.
            """
            return self._set("modulus", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            Regular expression against which the extracted value is matched.
            """
            return self._set("regex", value)

        def replacement(self, value: Optional[str], /) -> Self:
            """
            Replacement value against which a Replace action is performed if the
            regular expression matches.

            Regex capture groups are available.
            """
            return self._set("replacement", value)

        def separator(self, value: Optional[str], /) -> Self:
            """
            Separator is the string between concatenated SourceLabels.
            """
            return self._set("separator", value)

        @overload
        def source_labels(
            self, value_or_callback: List[SourceLabel], /
        ) -> "RelabelingConfig.Builder": ...

        @overload
        def source_labels(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[SourceLabel, SourceLabel.Builder]],
                GenericListBuilder[SourceLabel, SourceLabel.Builder] | List[SourceLabel],
            ],
            /,
        ) -> "RelabelingConfig.Builder": ...

        @overload
        def source_labels(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[SourceLabel.Builder]: ...

        def source_labels(self, value_or_callback=None, /):
            """
            The source labels select values from existing labels. Their content is
            concatenated using the configured Separator and matched against the
            configured regular expression.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[SourceLabel.Builder]()
                context._parent_builder = self
                context._field_name = "source_labels"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SourceLabel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("source_labels", value)

        def target_label(self, value: Optional[str], /) -> Self:
            """
            Label to which the resulting string is written in a replacement.

            It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
            `KeepEqual` and `DropEqual` actions.

            Regex capture groups are available.
            """
            return self._set("target_label", value)

    class BuilderContext(BuilderContextBase["RelabelingConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RelabelingConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RelabelingConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RelabelingConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RelabelingConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    action: Optional[
        Literal[
            "replace",
            "Replace",
            "keep",
            "Keep",
            "drop",
            "Drop",
            "hashmod",
            "HashMod",
            "labelmap",
            "LabelMap",
            "labeldrop",
            "LabelDrop",
            "labelkeep",
            "LabelKeep",
            "lowercase",
            "Lowercase",
            "uppercase",
            "Uppercase",
            "keepequal",
            "KeepEqual",
            "dropequal",
            "DropEqual",
        ]
    ] = "replace"
    """
    Action to perform based on the regex matching.

    `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
    `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.

    Default: "Replace"
    """
    modulus: Optional[int] = None
    """
    Modulus to take of the hash of the source label values.

    Only applicable when the action is `HashMod`.
    """
    regex: Optional[str] = None
    """
    Regular expression against which the extracted value is matched.
    """
    replacement: Optional[str] = None
    """
    Replacement value against which a Replace action is performed if the
    regular expression matches.

    Regex capture groups are available.
    """
    separator: Optional[str] = None
    """
    Separator is the string between concatenated SourceLabels.
    """
    source_labels: Annotated[Optional[List[SourceLabel]], Field(alias="sourceLabels")] = None
    """
    The source labels select values from existing labels. Their content is
    concatenated using the configured Separator and matched against the
    configured regular expression.
    """
    target_label: Annotated[Optional[str], Field(alias="targetLabel")] = None
    """
    Label to which the resulting string is written in a replacement.

    It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
    `KeepEqual` and `DropEqual` actions.

    Regex capture groups are available.
    """


class Ingress(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ingress"]:
            return Ingress

        def build(self) -> "Ingress":
            return Ingress(**self._attrs)

        @overload
        def namespace_selector(
            self, value_or_callback: Optional[NamespaceSelectorModel], /
        ) -> "Ingress.Builder": ...

        @overload
        def namespace_selector(
            self,
            value_or_callback: Callable[
                [NamespaceSelectorModel.Builder],
                NamespaceSelectorModel.Builder | NamespaceSelectorModel,
            ],
            /,
        ) -> "Ingress.Builder": ...

        @overload
        def namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "NamespaceSelectorModel.BuilderContext": ...

        def namespace_selector(self, value_or_callback=None, /):
            """
            From which namespaces to select Ingress objects.
            """
            if self._in_context and value_or_callback is None:
                context = NamespaceSelectorModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamespaceSelectorModel.builder())
                if isinstance(output, NamespaceSelectorModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("namespace_selector", value)

        @overload
        def relabeling_configs(
            self, value_or_callback: List[RelabelingConfig], /
        ) -> "Ingress.Builder": ...

        @overload
        def relabeling_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[RelabelingConfig, RelabelingConfig.Builder]],
                GenericListBuilder[RelabelingConfig, RelabelingConfig.Builder]
                | List[RelabelingConfig],
            ],
            /,
        ) -> "Ingress.Builder": ...

        @overload
        def relabeling_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[RelabelingConfig.Builder]: ...

        def relabeling_configs(self, value_or_callback=None, /):
            """
            RelabelConfigs to apply to the label set of the target before it gets
            scraped.
            The original ingress address is available via the
            `__tmp_prometheus_ingress_address` label. It can be used to customize the
            probed URL.
            The original scrape job's name is available via the `__tmp_prometheus_job_name` label.
            More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[RelabelingConfig.Builder]()
                context._parent_builder = self
                context._field_name = "relabeling_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RelabelingConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("relabeling_configs", value)

        @overload
        def selector(self, value_or_callback: Optional[Selector], /) -> "Ingress.Builder": ...

        @overload
        def selector(
            self,
            value_or_callback: Callable[[Selector.Builder], Selector.Builder | Selector],
            /,
        ) -> "Ingress.Builder": ...

        @overload
        def selector(self, value_or_callback: Never = ...) -> "Selector.BuilderContext": ...

        def selector(self, value_or_callback=None, /):
            """
            Selector to select the Ingress objects.
            """
            if self._in_context and value_or_callback is None:
                context = Selector.BuilderContext()
                context._parent_builder = self
                context._field_name = "selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Selector.builder())
                if isinstance(output, Selector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("selector", value)

    class BuilderContext(BuilderContextBase["Ingress.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ingress.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ingress."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ingress", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ingress.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    namespace_selector: Annotated[
        Optional[NamespaceSelectorModel], Field(alias="namespaceSelector")
    ] = None
    """
    From which namespaces to select Ingress objects.
    """
    relabeling_configs: Annotated[
        Optional[List[RelabelingConfig]], Field(alias="relabelingConfigs")
    ] = None
    """
    RelabelConfigs to apply to the label set of the target before it gets
    scraped.
    The original ingress address is available via the
    `__tmp_prometheus_ingress_address` label. It can be used to customize the
    probed URL.
    The original scrape job's name is available via the `__tmp_prometheus_job_name` label.
    More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
    """
    selector: Optional[Selector] = None
    """
    Selector to select the Ingress objects.
    """


class StaticConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StaticConfig"]:
            return StaticConfig

        def build(self) -> "StaticConfig":
            return StaticConfig(**self._attrs)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Labels assigned to all metrics scraped from the targets.
            """
            return self._set("labels", value)

        @overload
        def relabeling_configs(
            self, value_or_callback: List[RelabelingConfig], /
        ) -> "StaticConfig.Builder": ...

        @overload
        def relabeling_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[RelabelingConfig, RelabelingConfig.Builder]],
                GenericListBuilder[RelabelingConfig, RelabelingConfig.Builder]
                | List[RelabelingConfig],
            ],
            /,
        ) -> "StaticConfig.Builder": ...

        @overload
        def relabeling_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[RelabelingConfig.Builder]: ...

        def relabeling_configs(self, value_or_callback=None, /):
            """
            RelabelConfigs to apply to the label set of the targets before it gets
            scraped.
            More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[RelabelingConfig.Builder]()
                context._parent_builder = self
                context._field_name = "relabeling_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RelabelingConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("relabeling_configs", value)

        def static(self, value: Optional[List[str]], /) -> Self:
            """
            The list of hosts to probe.
            """
            return self._set("static", value)

    class BuilderContext(BuilderContextBase["StaticConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StaticConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StaticConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StaticConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StaticConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    labels: Optional[Dict[str, str]] = None
    """
    Labels assigned to all metrics scraped from the targets.
    """
    relabeling_configs: Annotated[
        Optional[List[RelabelingConfig]], Field(alias="relabelingConfigs")
    ] = None
    """
    RelabelConfigs to apply to the label set of the targets before it gets
    scraped.
    More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
    """
    static: Optional[List[str]] = None
    """
    The list of hosts to probe.
    """


class Targets(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Targets"]:
            return Targets

        def build(self) -> "Targets":
            return Targets(**self._attrs)

        @overload
        def ingress(self, value_or_callback: Optional[Ingress], /) -> "Targets.Builder": ...

        @overload
        def ingress(
            self,
            value_or_callback: Callable[[Ingress.Builder], Ingress.Builder | Ingress],
            /,
        ) -> "Targets.Builder": ...

        @overload
        def ingress(self, value_or_callback: Never = ...) -> "Ingress.BuilderContext": ...

        def ingress(self, value_or_callback=None, /):
            """
            ingress defines the Ingress objects to probe and the relabeling
            configuration.
            If `staticConfig` is also defined, `staticConfig` takes precedence.
            """
            if self._in_context and value_or_callback is None:
                context = Ingress.BuilderContext()
                context._parent_builder = self
                context._field_name = "ingress"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ingress.builder())
                if isinstance(output, Ingress.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ingress", value)

        @overload
        def static_config(
            self, value_or_callback: Optional[StaticConfig], /
        ) -> "Targets.Builder": ...

        @overload
        def static_config(
            self,
            value_or_callback: Callable[
                [StaticConfig.Builder], StaticConfig.Builder | StaticConfig
            ],
            /,
        ) -> "Targets.Builder": ...

        @overload
        def static_config(
            self, value_or_callback: Never = ...
        ) -> "StaticConfig.BuilderContext": ...

        def static_config(self, value_or_callback=None, /):
            """
            staticConfig defines the static list of targets to probe and the
            relabeling configuration.
            If `ingress` is also defined, `staticConfig` takes precedence.
            More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#static_config.
            """
            if self._in_context and value_or_callback is None:
                context = StaticConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "static_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(StaticConfig.builder())
                if isinstance(output, StaticConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("static_config", value)

    class BuilderContext(BuilderContextBase["Targets.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Targets.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Targets."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Targets", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Targets.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ingress: Optional[Ingress] = None
    """
    ingress defines the Ingress objects to probe and the relabeling
    configuration.
    If `staticConfig` is also defined, `staticConfig` takes precedence.
    """
    static_config: Annotated[Optional[StaticConfig], Field(alias="staticConfig")] = None
    """
    staticConfig defines the static list of targets to probe and the
    relabeling configuration.
    If `ingress` is also defined, `staticConfig` takes precedence.
    More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#static_config.
    """


class ProbeSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProbeSpec"]:
            return ProbeSpec

        def build(self) -> "ProbeSpec":
            return ProbeSpec(**self._attrs)

        @overload
        def authorization(
            self, value_or_callback: Optional[Authorization], /
        ) -> "ProbeSpec.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [Authorization.Builder], Authorization.Builder | Authorization
            ],
            /,
        ) -> "ProbeSpec.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "Authorization.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization section for this endpoint
            """
            if self._in_context and value_or_callback is None:
                context = Authorization.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Authorization.builder())
                if isinstance(output, Authorization.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def basic_auth(self, value_or_callback: Optional[BasicAuth], /) -> "ProbeSpec.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "ProbeSpec.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            BasicAuth allow an endpoint to authenticate over basic authentication.
            More info: https://prometheus.io/docs/operating/configuration/#endpoint
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        @overload
        def bearer_token_secret(
            self, value_or_callback: Optional[BearerTokenSecret], /
        ) -> "ProbeSpec.Builder": ...

        @overload
        def bearer_token_secret(
            self,
            value_or_callback: Callable[
                [BearerTokenSecret.Builder],
                BearerTokenSecret.Builder | BearerTokenSecret,
            ],
            /,
        ) -> "ProbeSpec.Builder": ...

        @overload
        def bearer_token_secret(
            self, value_or_callback: Never = ...
        ) -> "BearerTokenSecret.BuilderContext": ...

        def bearer_token_secret(self, value_or_callback=None, /):
            """
            Secret to mount to read bearer token for scraping targets. The secret
            needs to be in the same namespace as the probe and accessible by
            the Prometheus Operator.
            """
            if self._in_context and value_or_callback is None:
                context = BearerTokenSecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "bearer_token_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BearerTokenSecret.builder())
                if isinstance(output, BearerTokenSecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("bearer_token_secret", value)

        def fallback_scrape_protocol(
            self,
            value: Optional[
                Literal[
                    "PrometheusProto",
                    "OpenMetricsText0.0.1",
                    "OpenMetricsText1.0.0",
                    "PrometheusText0.0.4",
                    "PrometheusText1.0.0",
                ]
            ],
            /,
        ) -> Self:
            """
            The protocol to use if a scrape returns blank, unparseable, or otherwise invalid Content-Type.

            It requires Prometheus >= v3.0.0.
            """
            return self._set("fallback_scrape_protocol", value)

        def interval(self, value: Optional[str], /) -> Self:
            """
            Interval at which targets are probed using the configured prober.
            If not specified Prometheus' global scrape interval is used.
            """
            return self._set("interval", value)

        def job_name(self, value: Optional[str], /) -> Self:
            """
            The job name assigned to scraped metrics by default.
            """
            return self._set("job_name", value)

        def keep_dropped_targets(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on the number of targets dropped by relabeling
            that will be kept in memory. 0 means no limit.

            It requires Prometheus >= v2.47.0.
            """
            return self._set("keep_dropped_targets", value)

        def label_limit(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on number of labels that will be accepted for a sample.
            Only valid in Prometheus versions 2.27.0 and newer.
            """
            return self._set("label_limit", value)

        def label_name_length_limit(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on length of labels name that will be accepted for a sample.
            Only valid in Prometheus versions 2.27.0 and newer.
            """
            return self._set("label_name_length_limit", value)

        def label_value_length_limit(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on length of labels value that will be accepted for a sample.
            Only valid in Prometheus versions 2.27.0 and newer.
            """
            return self._set("label_value_length_limit", value)

        @overload
        def metric_relabelings(
            self, value_or_callback: List[MetricRelabeling], /
        ) -> "ProbeSpec.Builder": ...

        @overload
        def metric_relabelings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MetricRelabeling, MetricRelabeling.Builder]],
                GenericListBuilder[MetricRelabeling, MetricRelabeling.Builder]
                | List[MetricRelabeling],
            ],
            /,
        ) -> "ProbeSpec.Builder": ...

        @overload
        def metric_relabelings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MetricRelabeling.Builder]: ...

        def metric_relabelings(self, value_or_callback=None, /):
            """
            MetricRelabelConfigs to apply to samples before ingestion.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MetricRelabeling.Builder]()
                context._parent_builder = self
                context._field_name = "metric_relabelings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MetricRelabeling.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("metric_relabelings", value)

        def module(self, value: Optional[str], /) -> Self:
            """
            The module to use for probing specifying how to probe the target.
            Example module configuring in the blackbox exporter:
            https://github.com/prometheus/blackbox_exporter/blob/master/example.yml
            """
            return self._set("module", value)

        def native_histogram_bucket_limit(self, value: Optional[int], /) -> Self:
            """
            If there are more than this many buckets in a native histogram,
            buckets will be merged to stay within the limit.
            It requires Prometheus >= v2.45.0.
            """
            return self._set("native_histogram_bucket_limit", value)

        def native_histogram_min_bucket_factor(
            self,
            value: Optional[
                Union[
                    NativeHistogramMinBucketFactorModel1,
                    NativeHistogramMinBucketFactorModel2,
                ]
            ],
            /,
        ) -> Self:
            """
            If the growth factor of one bucket to the next is smaller than this,
            buckets will be merged to increase the factor sufficiently.
            It requires Prometheus >= v2.50.0.
            """
            return self._set("native_histogram_min_bucket_factor", value)

        @overload
        def oauth2(self, value_or_callback: Optional[Oauth2], /) -> "ProbeSpec.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "ProbeSpec.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        @overload
        def prober(self, value_or_callback: Optional[Prober], /) -> "ProbeSpec.Builder": ...

        @overload
        def prober(
            self,
            value_or_callback: Callable[[Prober.Builder], Prober.Builder | Prober],
            /,
        ) -> "ProbeSpec.Builder": ...

        @overload
        def prober(self, value_or_callback: Never = ...) -> "Prober.BuilderContext": ...

        def prober(self, value_or_callback=None, /):
            """
            Specification for the prober to use for probing targets.
            The prober.URL parameter is required. Targets cannot be probed if left empty.
            """
            if self._in_context and value_or_callback is None:
                context = Prober.BuilderContext()
                context._parent_builder = self
                context._field_name = "prober"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Prober.builder())
                if isinstance(output, Prober.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("prober", value)

        def sample_limit(self, value: Optional[int], /) -> Self:
            """
            SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
            """
            return self._set("sample_limit", value)

        def scrape_class(self, value: Optional[str], /) -> Self:
            """
            The scrape class to apply.
            """
            return self._set("scrape_class", value)

        def scrape_classic_histograms(self, value: Optional[bool], /) -> Self:
            """
            Whether to scrape a classic histogram that is also exposed as a native histogram.
            It requires Prometheus >= v2.45.0.
            """
            return self._set("scrape_classic_histograms", value)

        def scrape_protocols(
            self,
            value: Optional[
                List[
                    Literal[
                        "PrometheusProto",
                        "OpenMetricsText0.0.1",
                        "OpenMetricsText1.0.0",
                        "PrometheusText0.0.4",
                        "PrometheusText1.0.0",
                    ]
                ]
            ],
            /,
        ) -> Self:
            """
            `scrapeProtocols` defines the protocols to negotiate during a scrape. It tells clients the
            protocols supported by Prometheus in order of preference (from most to least preferred).

            If unset, Prometheus uses its default value.

            It requires Prometheus >= v2.49.0.
            """
            return self._set("scrape_protocols", value)

        def scrape_timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout for scraping metrics from the Prometheus exporter.
            If not specified, the Prometheus global scrape timeout is used.
            The value cannot be greater than the scrape interval otherwise the operator will reject the resource.
            """
            return self._set("scrape_timeout", value)

        def target_limit(self, value: Optional[int], /) -> Self:
            """
            TargetLimit defines a limit on the number of scraped targets that will be accepted.
            """
            return self._set("target_limit", value)

        @overload
        def targets(self, value_or_callback: Optional[Targets], /) -> "ProbeSpec.Builder": ...

        @overload
        def targets(
            self,
            value_or_callback: Callable[[Targets.Builder], Targets.Builder | Targets],
            /,
        ) -> "ProbeSpec.Builder": ...

        @overload
        def targets(self, value_or_callback: Never = ...) -> "Targets.BuilderContext": ...

        def targets(self, value_or_callback=None, /):
            """
            Targets defines a set of static or dynamically discovered targets to probe.
            """
            if self._in_context and value_or_callback is None:
                context = Targets.BuilderContext()
                context._parent_builder = self
                context._field_name = "targets"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Targets.builder())
                if isinstance(output, Targets.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("targets", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel1], /
        ) -> "ProbeSpec.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel1.Builder], TlsConfigModel1.Builder | TlsConfigModel1
            ],
            /,
        ) -> "ProbeSpec.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel1.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration to use when scraping the endpoint.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel1.builder())
                if isinstance(output, TlsConfigModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["ProbeSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProbeSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProbeSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProbeSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProbeSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authorization: Optional[Authorization] = None
    """
    Authorization section for this endpoint
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    BasicAuth allow an endpoint to authenticate over basic authentication.
    More info: https://prometheus.io/docs/operating/configuration/#endpoint
    """
    bearer_token_secret: Annotated[
        Optional[BearerTokenSecret], Field(alias="bearerTokenSecret")
    ] = None
    """
    Secret to mount to read bearer token for scraping targets. The secret
    needs to be in the same namespace as the probe and accessible by
    the Prometheus Operator.
    """
    fallback_scrape_protocol: Annotated[
        Optional[
            Literal[
                "PrometheusProto",
                "OpenMetricsText0.0.1",
                "OpenMetricsText1.0.0",
                "PrometheusText0.0.4",
                "PrometheusText1.0.0",
            ]
        ],
        Field(alias="fallbackScrapeProtocol"),
    ] = None
    """
    The protocol to use if a scrape returns blank, unparseable, or otherwise invalid Content-Type.

    It requires Prometheus >= v3.0.0.
    """
    interval: Annotated[
        Optional[str],
        Field(
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"
        ),
    ] = None
    """
    Interval at which targets are probed using the configured prober.
    If not specified Prometheus' global scrape interval is used.
    """
    job_name: Annotated[Optional[str], Field(alias="jobName")] = None
    """
    The job name assigned to scraped metrics by default.
    """
    keep_dropped_targets: Annotated[Optional[int], Field(alias="keepDroppedTargets")] = None
    """
    Per-scrape limit on the number of targets dropped by relabeling
    that will be kept in memory. 0 means no limit.

    It requires Prometheus >= v2.47.0.
    """
    label_limit: Annotated[Optional[int], Field(alias="labelLimit")] = None
    """
    Per-scrape limit on number of labels that will be accepted for a sample.
    Only valid in Prometheus versions 2.27.0 and newer.
    """
    label_name_length_limit: Annotated[Optional[int], Field(alias="labelNameLengthLimit")] = None
    """
    Per-scrape limit on length of labels name that will be accepted for a sample.
    Only valid in Prometheus versions 2.27.0 and newer.
    """
    label_value_length_limit: Annotated[Optional[int], Field(alias="labelValueLengthLimit")] = None
    """
    Per-scrape limit on length of labels value that will be accepted for a sample.
    Only valid in Prometheus versions 2.27.0 and newer.
    """
    metric_relabelings: Annotated[
        Optional[List[MetricRelabeling]], Field(alias="metricRelabelings")
    ] = None
    """
    MetricRelabelConfigs to apply to samples before ingestion.
    """
    module: Optional[str] = None
    """
    The module to use for probing specifying how to probe the target.
    Example module configuring in the blackbox exporter:
    https://github.com/prometheus/blackbox_exporter/blob/master/example.yml
    """
    native_histogram_bucket_limit: Annotated[
        Optional[int], Field(alias="nativeHistogramBucketLimit")
    ] = None
    """
    If there are more than this many buckets in a native histogram,
    buckets will be merged to stay within the limit.
    It requires Prometheus >= v2.45.0.
    """
    native_histogram_min_bucket_factor: Annotated[
        Optional[
            Union[
                NativeHistogramMinBucketFactorModel1,
                NativeHistogramMinBucketFactorModel2,
            ]
        ],
        Field(alias="nativeHistogramMinBucketFactor"),
    ] = None
    """
    If the growth factor of one bucket to the next is smaller than this,
    buckets will be merged to increase the factor sufficiently.
    It requires Prometheus >= v2.50.0.
    """
    oauth2: Optional[Oauth2] = None
    """
    OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
    """
    prober: Optional[Prober] = None
    """
    Specification for the prober to use for probing targets.
    The prober.URL parameter is required. Targets cannot be probed if left empty.
    """
    sample_limit: Annotated[Optional[int], Field(alias="sampleLimit")] = None
    """
    SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
    """
    scrape_class: Annotated[Optional[str], Field(alias="scrapeClass", min_length=1)] = None
    """
    The scrape class to apply.
    """
    scrape_classic_histograms: Annotated[Optional[bool], Field(alias="scrapeClassicHistograms")] = (
        None
    )
    """
    Whether to scrape a classic histogram that is also exposed as a native histogram.
    It requires Prometheus >= v2.45.0.
    """
    scrape_protocols: Annotated[
        Optional[
            List[
                Literal[
                    "PrometheusProto",
                    "OpenMetricsText0.0.1",
                    "OpenMetricsText1.0.0",
                    "PrometheusText0.0.4",
                    "PrometheusText1.0.0",
                ]
            ]
        ],
        Field(alias="scrapeProtocols"),
    ] = None
    """
    `scrapeProtocols` defines the protocols to negotiate during a scrape. It tells clients the
    protocols supported by Prometheus in order of preference (from most to least preferred).

    If unset, Prometheus uses its default value.

    It requires Prometheus >= v2.49.0.
    """
    scrape_timeout: Annotated[
        Optional[str],
        Field(
            alias="scrapeTimeout",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Timeout for scraping metrics from the Prometheus exporter.
    If not specified, the Prometheus global scrape timeout is used.
    The value cannot be greater than the scrape interval otherwise the operator will reject the resource.
    """
    target_limit: Annotated[Optional[int], Field(alias="targetLimit")] = None
    """
    TargetLimit defines a limit on the number of scraped targets that will be accepted.
    """
    targets: Optional[Targets] = None
    """
    Targets defines a set of static or dynamically discovered targets to probe.
    """
    tls_config: Annotated[Optional[TlsConfigModel1], Field(alias="tlsConfig")] = None
    """
    TLS configuration to use when scraping the endpoint.
    """


class AdditionalAlertManagerConfigs(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AdditionalAlertManagerConfigs"]:
            return AdditionalAlertManagerConfigs

        def build(self) -> "AdditionalAlertManagerConfigs":
            return AdditionalAlertManagerConfigs(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["AdditionalAlertManagerConfigs.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AdditionalAlertManagerConfigs.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AdditionalAlertManagerConfigs."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AdditionalAlertManagerConfigs", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AdditionalAlertManagerConfigs.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class AdditionalAlertRelabelConfigs(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AdditionalAlertRelabelConfigs"]:
            return AdditionalAlertRelabelConfigs

        def build(self) -> "AdditionalAlertRelabelConfigs":
            return AdditionalAlertRelabelConfigs(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["AdditionalAlertRelabelConfigs.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AdditionalAlertRelabelConfigs.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AdditionalAlertRelabelConfigs."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AdditionalAlertRelabelConfigs", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AdditionalAlertRelabelConfigs.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class AdditionalArg(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AdditionalArg"]:
            return AdditionalArg

        def build(self) -> "AdditionalArg":
            return AdditionalArg(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the argument, e.g. "scrape.discovery-reload-interval".
            """
            return self._set("name", value)

        def value(self, value: Optional[str], /) -> Self:
            """
            Argument value, e.g. 30s. Can be empty for name-only arguments (e.g. --storage.tsdb.no-lockfile)
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AdditionalArg.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AdditionalArg.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AdditionalArg."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AdditionalArg", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AdditionalArg.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Annotated[str, Field(min_length=1)]
    """
    Name of the argument, e.g. "scrape.discovery-reload-interval".
    """
    value: Optional[str] = None
    """
    Argument value, e.g. 30s. Can be empty for name-only arguments (e.g. --storage.tsdb.no-lockfile)
    """


class AdditionalScrapeConfigs(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AdditionalScrapeConfigs"]:
            return AdditionalScrapeConfigs

        def build(self) -> "AdditionalScrapeConfigs":
            return AdditionalScrapeConfigs(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["AdditionalScrapeConfigs.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AdditionalScrapeConfigs.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AdditionalScrapeConfigs."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AdditionalScrapeConfigs", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AdditionalScrapeConfigs.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class MatchExpressionModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchExpressionModel1"]:
            return MatchExpressionModel1

        def build(self) -> "MatchExpressionModel1":
            return MatchExpressionModel1(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The label key that the selector applies to.
            """
            return self._set("key", value)

        def operator(self, value: str, /) -> Self:
            """
            Represents a key's relationship to a set of values.
            Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
            """
            return self._set("operator", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            An array of string values. If the operator is In or NotIn,
            the values array must be non-empty. If the operator is Exists or DoesNotExist,
            the values array must be empty. If the operator is Gt or Lt, the values
            array must have a single element, which will be interpreted as an integer.
            This array is replaced during a strategic merge patch.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["MatchExpressionModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchExpressionModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchExpressionModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchExpressionModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchExpressionModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The label key that the selector applies to.
    """
    operator: str
    """
    Represents a key's relationship to a set of values.
    Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    """
    values: Optional[List[str]] = None
    """
    An array of string values. If the operator is In or NotIn,
    the values array must be non-empty. If the operator is Exists or DoesNotExist,
    the values array must be empty. If the operator is Gt or Lt, the values
    array must have a single element, which will be interpreted as an integer.
    This array is replaced during a strategic merge patch.
    """


class PreferredDuringSchedulingIgnoredDuringExecutionModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PreferredDuringSchedulingIgnoredDuringExecutionModel1"]:
            return PreferredDuringSchedulingIgnoredDuringExecutionModel1

        def build(self) -> "PreferredDuringSchedulingIgnoredDuringExecutionModel1":
            return PreferredDuringSchedulingIgnoredDuringExecutionModel1(**self._attrs)

        @overload
        def preference(
            self, value_or_callback: Preference, /
        ) -> "PreferredDuringSchedulingIgnoredDuringExecutionModel1.Builder": ...

        @overload
        def preference(
            self,
            value_or_callback: Callable[[Preference.Builder], Preference.Builder | Preference],
            /,
        ) -> "PreferredDuringSchedulingIgnoredDuringExecutionModel1.Builder": ...

        @overload
        def preference(self, value_or_callback: Never = ...) -> "Preference.BuilderContext": ...

        def preference(self, value_or_callback=None, /):
            """
            A node selector term, associated with the corresponding weight.
            """
            if self._in_context and value_or_callback is None:
                context = Preference.BuilderContext()
                context._parent_builder = self
                context._field_name = "preference"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Preference.builder())
                if isinstance(output, Preference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("preference", value)

        def weight(self, value: int, /) -> Self:
            """
            Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
            """
            return self._set("weight", value)

    class BuilderContext(
        BuilderContextBase["PreferredDuringSchedulingIgnoredDuringExecutionModel1.Builder"]
    ):
        def model_post_init(self, __context) -> None:
            self._builder = PreferredDuringSchedulingIgnoredDuringExecutionModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PreferredDuringSchedulingIgnoredDuringExecutionModel1."""
        return cls.BuilderContext()

    class ListBuilder(
        GenericListBuilder["PreferredDuringSchedulingIgnoredDuringExecutionModel1", Builder]
    ):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PreferredDuringSchedulingIgnoredDuringExecutionModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    preference: Preference
    """
    A node selector term, associated with the corresponding weight.
    """
    weight: int
    """
    Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
    """


class RequiredDuringSchedulingIgnoredDuringExecutionModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RequiredDuringSchedulingIgnoredDuringExecutionModel1"]:
            return RequiredDuringSchedulingIgnoredDuringExecutionModel1

        def build(self) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel1":
            return RequiredDuringSchedulingIgnoredDuringExecutionModel1(**self._attrs)

        @overload
        def node_selector_terms(
            self, value_or_callback: List[NodeSelectorTerm], /
        ) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel1.Builder": ...

        @overload
        def node_selector_terms(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[NodeSelectorTerm, NodeSelectorTerm.Builder]],
                GenericListBuilder[NodeSelectorTerm, NodeSelectorTerm.Builder]
                | List[NodeSelectorTerm],
            ],
            /,
        ) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel1.Builder": ...

        @overload
        def node_selector_terms(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[NodeSelectorTerm.Builder]: ...

        def node_selector_terms(self, value_or_callback=None, /):
            """
            Required. A list of node selector terms. The terms are ORed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[NodeSelectorTerm.Builder]()
                context._parent_builder = self
                context._field_name = "node_selector_terms"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NodeSelectorTerm.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("node_selector_terms", value)

    class BuilderContext(
        BuilderContextBase["RequiredDuringSchedulingIgnoredDuringExecutionModel1.Builder"]
    ):
        def model_post_init(self, __context) -> None:
            self._builder = RequiredDuringSchedulingIgnoredDuringExecutionModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequiredDuringSchedulingIgnoredDuringExecutionModel1."""
        return cls.BuilderContext()

    class ListBuilder(
        GenericListBuilder["RequiredDuringSchedulingIgnoredDuringExecutionModel1", Builder]
    ):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RequiredDuringSchedulingIgnoredDuringExecutionModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    node_selector_terms: Annotated[List[NodeSelectorTerm], Field(alias="nodeSelectorTerms")]
    """
    Required. A list of node selector terms. The terms are ORed.
    """


class MatchExpressionModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchExpressionModel2"]:
            return MatchExpressionModel2

        def build(self) -> "MatchExpressionModel2":
            return MatchExpressionModel2(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key is the label key that the selector applies to.
            """
            return self._set("key", value)

        def operator(self, value: str, /) -> Self:
            """
            operator represents a key's relationship to a set of values.
            Valid operators are In, NotIn, Exists and DoesNotExist.
            """
            return self._set("operator", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            values is an array of string values. If the operator is In or NotIn,
            the values array must be non-empty. If the operator is Exists or DoesNotExist,
            the values array must be empty. This array is replaced during a strategic
            merge patch.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["MatchExpressionModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchExpressionModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchExpressionModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchExpressionModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchExpressionModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key is the label key that the selector applies to.
    """
    operator: str
    """
    operator represents a key's relationship to a set of values.
    Valid operators are In, NotIn, Exists and DoesNotExist.
    """
    values: Optional[List[str]] = None
    """
    values is an array of string values. If the operator is In or NotIn,
    the values array must be non-empty. If the operator is Exists or DoesNotExist,
    the values array must be empty. This array is replaced during a strategic
    merge patch.
    """


class NamespaceSelectorModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NamespaceSelectorModel1"]:
            return NamespaceSelectorModel1

        def build(self) -> "NamespaceSelectorModel1":
            return NamespaceSelectorModel1(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel2], /
        ) -> "NamespaceSelectorModel1.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel2, MatchExpressionModel2.Builder]],
                GenericListBuilder[MatchExpressionModel2, MatchExpressionModel2.Builder]
                | List[MatchExpressionModel2],
            ],
            /,
        ) -> "NamespaceSelectorModel1.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel2.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel2.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel2.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["NamespaceSelectorModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NamespaceSelectorModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NamespaceSelectorModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NamespaceSelectorModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamespaceSelectorModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel2]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class PreferredDuringSchedulingIgnoredDuringExecutionModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PreferredDuringSchedulingIgnoredDuringExecutionModel2"]:
            return PreferredDuringSchedulingIgnoredDuringExecutionModel2

        def build(self) -> "PreferredDuringSchedulingIgnoredDuringExecutionModel2":
            return PreferredDuringSchedulingIgnoredDuringExecutionModel2(**self._attrs)

        @overload
        def pod_affinity_term(
            self, value_or_callback: PodAffinityTerm, /
        ) -> "PreferredDuringSchedulingIgnoredDuringExecutionModel2.Builder": ...

        @overload
        def pod_affinity_term(
            self,
            value_or_callback: Callable[
                [PodAffinityTerm.Builder], PodAffinityTerm.Builder | PodAffinityTerm
            ],
            /,
        ) -> "PreferredDuringSchedulingIgnoredDuringExecutionModel2.Builder": ...

        @overload
        def pod_affinity_term(
            self, value_or_callback: Never = ...
        ) -> "PodAffinityTerm.BuilderContext": ...

        def pod_affinity_term(self, value_or_callback=None, /):
            """
            Required. A pod affinity term, associated with the corresponding weight.
            """
            if self._in_context and value_or_callback is None:
                context = PodAffinityTerm.BuilderContext()
                context._parent_builder = self
                context._field_name = "pod_affinity_term"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodAffinityTerm.builder())
                if isinstance(output, PodAffinityTerm.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("pod_affinity_term", value)

        def weight(self, value: int, /) -> Self:
            """
            weight associated with matching the corresponding podAffinityTerm,
            in the range 1-100.
            """
            return self._set("weight", value)

    class BuilderContext(
        BuilderContextBase["PreferredDuringSchedulingIgnoredDuringExecutionModel2.Builder"]
    ):
        def model_post_init(self, __context) -> None:
            self._builder = PreferredDuringSchedulingIgnoredDuringExecutionModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PreferredDuringSchedulingIgnoredDuringExecutionModel2."""
        return cls.BuilderContext()

    class ListBuilder(
        GenericListBuilder["PreferredDuringSchedulingIgnoredDuringExecutionModel2", Builder]
    ):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PreferredDuringSchedulingIgnoredDuringExecutionModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    pod_affinity_term: Annotated[PodAffinityTerm, Field(alias="podAffinityTerm")]
    """
    Required. A pod affinity term, associated with the corresponding weight.
    """
    weight: int
    """
    weight associated with matching the corresponding podAffinityTerm,
    in the range 1-100.
    """


class RequiredDuringSchedulingIgnoredDuringExecutionModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RequiredDuringSchedulingIgnoredDuringExecutionModel2"]:
            return RequiredDuringSchedulingIgnoredDuringExecutionModel2

        def build(self) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel2":
            return RequiredDuringSchedulingIgnoredDuringExecutionModel2(**self._attrs)

        @overload
        def label_selector(
            self, value_or_callback: Optional[LabelSelector], /
        ) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel2.Builder": ...

        @overload
        def label_selector(
            self,
            value_or_callback: Callable[
                [LabelSelector.Builder], LabelSelector.Builder | LabelSelector
            ],
            /,
        ) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel2.Builder": ...

        @overload
        def label_selector(
            self, value_or_callback: Never = ...
        ) -> "LabelSelector.BuilderContext": ...

        def label_selector(self, value_or_callback=None, /):
            """
            A label query over a set of resources, in this case pods.
            If it's null, this PodAffinityTerm matches with no Pods.
            """
            if self._in_context and value_or_callback is None:
                context = LabelSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "label_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LabelSelector.builder())
                if isinstance(output, LabelSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("label_selector", value)

        def match_label_keys(self, value: Optional[List[str]], /) -> Self:
            """
            MatchLabelKeys is a set of pod label keys to select which pods will
            be taken into consideration. The keys are used to lookup values from the
            incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
            to select the group of existing pods which pods will be taken into consideration
            for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
            pod labels will be ignored. The default value is empty.
            The same key is forbidden to exist in both matchLabelKeys and labelSelector.
            Also, matchLabelKeys cannot be set when labelSelector isn't set.
            This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
            """
            return self._set("match_label_keys", value)

        def mismatch_label_keys(self, value: Optional[List[str]], /) -> Self:
            """
            MismatchLabelKeys is a set of pod label keys to select which pods will
            be taken into consideration. The keys are used to lookup values from the
            incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
            to select the group of existing pods which pods will be taken into consideration
            for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
            pod labels will be ignored. The default value is empty.
            The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
            Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
            This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
            """
            return self._set("mismatch_label_keys", value)

        @overload
        def namespace_selector(
            self, value_or_callback: Optional[NamespaceSelectorModel1], /
        ) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel2.Builder": ...

        @overload
        def namespace_selector(
            self,
            value_or_callback: Callable[
                [NamespaceSelectorModel1.Builder],
                NamespaceSelectorModel1.Builder | NamespaceSelectorModel1,
            ],
            /,
        ) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel2.Builder": ...

        @overload
        def namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "NamespaceSelectorModel1.BuilderContext": ...

        def namespace_selector(self, value_or_callback=None, /):
            """
            A label query over the set of namespaces that the term applies to.
            The term is applied to the union of the namespaces selected by this field
            and the ones listed in the namespaces field.
            null selector and null or empty namespaces list means "this pod's namespace".
            An empty selector ({}) matches all namespaces.
            """
            if self._in_context and value_or_callback is None:
                context = NamespaceSelectorModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamespaceSelectorModel1.builder())
                if isinstance(output, NamespaceSelectorModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("namespace_selector", value)

        def namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            namespaces specifies a static list of namespace names that the term applies to.
            The term is applied to the union of the namespaces listed in this field
            and the ones selected by namespaceSelector.
            null or empty namespaces list and null namespaceSelector means "this pod's namespace".
            """
            return self._set("namespaces", value)

        def topology_key(self, value: str, /) -> Self:
            """
            This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
            the labelSelector in the specified namespaces, where co-located is defined as running on a node
            whose value of the label with key topologyKey matches that of any node on which any of the
            selected pods is running.
            Empty topologyKey is not allowed.
            """
            return self._set("topology_key", value)

    class BuilderContext(
        BuilderContextBase["RequiredDuringSchedulingIgnoredDuringExecutionModel2.Builder"]
    ):
        def model_post_init(self, __context) -> None:
            self._builder = RequiredDuringSchedulingIgnoredDuringExecutionModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequiredDuringSchedulingIgnoredDuringExecutionModel2."""
        return cls.BuilderContext()

    class ListBuilder(
        GenericListBuilder["RequiredDuringSchedulingIgnoredDuringExecutionModel2", Builder]
    ):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RequiredDuringSchedulingIgnoredDuringExecutionModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    label_selector: Annotated[Optional[LabelSelector], Field(alias="labelSelector")] = None
    """
    A label query over a set of resources, in this case pods.
    If it's null, this PodAffinityTerm matches with no Pods.
    """
    match_label_keys: Annotated[Optional[List[str]], Field(alias="matchLabelKeys")] = None
    """
    MatchLabelKeys is a set of pod label keys to select which pods will
    be taken into consideration. The keys are used to lookup values from the
    incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
    to select the group of existing pods which pods will be taken into consideration
    for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    pod labels will be ignored. The default value is empty.
    The same key is forbidden to exist in both matchLabelKeys and labelSelector.
    Also, matchLabelKeys cannot be set when labelSelector isn't set.
    This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
    """
    mismatch_label_keys: Annotated[Optional[List[str]], Field(alias="mismatchLabelKeys")] = None
    """
    MismatchLabelKeys is a set of pod label keys to select which pods will
    be taken into consideration. The keys are used to lookup values from the
    incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
    to select the group of existing pods which pods will be taken into consideration
    for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    pod labels will be ignored. The default value is empty.
    The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
    Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
    This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
    """
    namespace_selector: Annotated[
        Optional[NamespaceSelectorModel1], Field(alias="namespaceSelector")
    ] = None
    """
    A label query over the set of namespaces that the term applies to.
    The term is applied to the union of the namespaces selected by this field
    and the ones listed in the namespaces field.
    null selector and null or empty namespaces list means "this pod's namespace".
    An empty selector ({}) matches all namespaces.
    """
    namespaces: Optional[List[str]] = None
    """
    namespaces specifies a static list of namespace names that the term applies to.
    The term is applied to the union of the namespaces listed in this field
    and the ones selected by namespaceSelector.
    null or empty namespaces list and null namespaceSelector means "this pod's namespace".
    """
    topology_key: Annotated[str, Field(alias="topologyKey")]
    """
    This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
    the labelSelector in the specified namespaces, where co-located is defined as running on a node
    whose value of the label with key topologyKey matches that of any node on which any of the
    selected pods is running.
    Empty topologyKey is not allowed.
    """


class AlertRelabeling(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AlertRelabeling"]:
            return AlertRelabeling

        def build(self) -> "AlertRelabeling":
            return AlertRelabeling(**self._attrs)

        def action(
            self,
            value: Optional[
                Literal[
                    "replace",
                    "Replace",
                    "keep",
                    "Keep",
                    "drop",
                    "Drop",
                    "hashmod",
                    "HashMod",
                    "labelmap",
                    "LabelMap",
                    "labeldrop",
                    "LabelDrop",
                    "labelkeep",
                    "LabelKeep",
                    "lowercase",
                    "Lowercase",
                    "uppercase",
                    "Uppercase",
                    "keepequal",
                    "KeepEqual",
                    "dropequal",
                    "DropEqual",
                ]
            ],
            /,
        ) -> Self:
            """
            Action to perform based on the regex matching.

            `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
            `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.

            Default: "Replace"
            """
            return self._set("action", value)

        def modulus(self, value: Optional[int], /) -> Self:
            """
            Modulus to take of the hash of the source label values.

            Only applicable when the action is `HashMod`.
            """
            return self._set("modulus", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            Regular expression against which the extracted value is matched.
            """
            return self._set("regex", value)

        def replacement(self, value: Optional[str], /) -> Self:
            """
            Replacement value against which a Replace action is performed if the
            regular expression matches.

            Regex capture groups are available.
            """
            return self._set("replacement", value)

        def separator(self, value: Optional[str], /) -> Self:
            """
            Separator is the string between concatenated SourceLabels.
            """
            return self._set("separator", value)

        @overload
        def source_labels(
            self, value_or_callback: List[SourceLabel], /
        ) -> "AlertRelabeling.Builder": ...

        @overload
        def source_labels(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[SourceLabel, SourceLabel.Builder]],
                GenericListBuilder[SourceLabel, SourceLabel.Builder] | List[SourceLabel],
            ],
            /,
        ) -> "AlertRelabeling.Builder": ...

        @overload
        def source_labels(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[SourceLabel.Builder]: ...

        def source_labels(self, value_or_callback=None, /):
            """
            The source labels select values from existing labels. Their content is
            concatenated using the configured Separator and matched against the
            configured regular expression.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[SourceLabel.Builder]()
                context._parent_builder = self
                context._field_name = "source_labels"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SourceLabel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("source_labels", value)

        def target_label(self, value: Optional[str], /) -> Self:
            """
            Label to which the resulting string is written in a replacement.

            It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
            `KeepEqual` and `DropEqual` actions.

            Regex capture groups are available.
            """
            return self._set("target_label", value)

    class BuilderContext(BuilderContextBase["AlertRelabeling.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AlertRelabeling.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AlertRelabeling."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AlertRelabeling", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AlertRelabeling.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    action: Optional[
        Literal[
            "replace",
            "Replace",
            "keep",
            "Keep",
            "drop",
            "Drop",
            "hashmod",
            "HashMod",
            "labelmap",
            "LabelMap",
            "labeldrop",
            "LabelDrop",
            "labelkeep",
            "LabelKeep",
            "lowercase",
            "Lowercase",
            "uppercase",
            "Uppercase",
            "keepequal",
            "KeepEqual",
            "dropequal",
            "DropEqual",
        ]
    ] = "replace"
    """
    Action to perform based on the regex matching.

    `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
    `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.

    Default: "Replace"
    """
    modulus: Optional[int] = None
    """
    Modulus to take of the hash of the source label values.

    Only applicable when the action is `HashMod`.
    """
    regex: Optional[str] = None
    """
    Regular expression against which the extracted value is matched.
    """
    replacement: Optional[str] = None
    """
    Replacement value against which a Replace action is performed if the
    regular expression matches.

    Regex capture groups are available.
    """
    separator: Optional[str] = None
    """
    Separator is the string between concatenated SourceLabels.
    """
    source_labels: Annotated[Optional[List[SourceLabel]], Field(alias="sourceLabels")] = None
    """
    The source labels select values from existing labels. Their content is
    concatenated using the configured Separator and matched against the
    configured regular expression.
    """
    target_label: Annotated[Optional[str], Field(alias="targetLabel")] = None
    """
    Label to which the resulting string is written in a replacement.

    It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
    `KeepEqual` and `DropEqual` actions.

    Regex capture groups are available.
    """


class AccessKey(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AccessKey"]:
            return AccessKey

        def build(self) -> "AccessKey":
            return AccessKey(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["AccessKey.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AccessKey.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AccessKey."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AccessKey", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AccessKey.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class SecretKey(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretKey"]:
            return SecretKey

        def build(self) -> "SecretKey":
            return SecretKey(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["SecretKey.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretKey.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretKey."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretKey", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretKey.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class Sigv4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Sigv4"]:
            return Sigv4

        def build(self) -> "Sigv4":
            return Sigv4(**self._attrs)

        @overload
        def access_key(self, value_or_callback: Optional[AccessKey], /) -> "Sigv4.Builder": ...

        @overload
        def access_key(
            self,
            value_or_callback: Callable[[AccessKey.Builder], AccessKey.Builder | AccessKey],
            /,
        ) -> "Sigv4.Builder": ...

        @overload
        def access_key(self, value_or_callback: Never = ...) -> "AccessKey.BuilderContext": ...

        def access_key(self, value_or_callback=None, /):
            """
            AccessKey is the AWS API key. If not specified, the environment variable
            `AWS_ACCESS_KEY_ID` is used.
            """
            if self._in_context and value_or_callback is None:
                context = AccessKey.BuilderContext()
                context._parent_builder = self
                context._field_name = "access_key"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AccessKey.builder())
                if isinstance(output, AccessKey.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("access_key", value)

        def profile(self, value: Optional[str], /) -> Self:
            """
            Profile is the named AWS profile used to authenticate.
            """
            return self._set("profile", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            Region is the AWS region. If blank, the region from the default credentials chain used.
            """
            return self._set("region", value)

        def role_arn(self, value: Optional[str], /) -> Self:
            """
            RoleArn is the named AWS profile used to authenticate.
            """
            return self._set("role_arn", value)

        @overload
        def secret_key(self, value_or_callback: Optional[SecretKey], /) -> "Sigv4.Builder": ...

        @overload
        def secret_key(
            self,
            value_or_callback: Callable[[SecretKey.Builder], SecretKey.Builder | SecretKey],
            /,
        ) -> "Sigv4.Builder": ...

        @overload
        def secret_key(self, value_or_callback: Never = ...) -> "SecretKey.BuilderContext": ...

        def secret_key(self, value_or_callback=None, /):
            """
            SecretKey is the AWS API secret. If not specified, the environment
            variable `AWS_SECRET_ACCESS_KEY` is used.
            """
            if self._in_context and value_or_callback is None:
                context = SecretKey.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_key"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretKey.builder())
                if isinstance(output, SecretKey.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_key", value)

    class BuilderContext(BuilderContextBase["Sigv4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Sigv4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Sigv4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Sigv4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Sigv4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_key: Annotated[Optional[AccessKey], Field(alias="accessKey")] = None
    """
    AccessKey is the AWS API key. If not specified, the environment variable
    `AWS_ACCESS_KEY_ID` is used.
    """
    profile: Optional[str] = None
    """
    Profile is the named AWS profile used to authenticate.
    """
    region: Optional[str] = None
    """
    Region is the AWS region. If blank, the region from the default credentials chain used.
    """
    role_arn: Annotated[Optional[str], Field(alias="roleArn")] = None
    """
    RoleArn is the named AWS profile used to authenticate.
    """
    secret_key: Annotated[Optional[SecretKey], Field(alias="secretKey")] = None
    """
    SecretKey is the AWS API secret. If not specified, the environment
    variable `AWS_SECRET_ACCESS_KEY` is used.
    """


class TlsConfigModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsConfigModel2"]:
            return TlsConfigModel2

        def build(self) -> "TlsConfigModel2":
            return TlsConfigModel2(**self._attrs)

        @overload
        def ca(self, value_or_callback: Optional[Ca], /) -> "TlsConfigModel2.Builder": ...

        @overload
        def ca(
            self, value_or_callback: Callable[[Ca.Builder], Ca.Builder | Ca], /
        ) -> "TlsConfigModel2.Builder": ...

        @overload
        def ca(self, value_or_callback: Never = ...) -> "Ca.BuilderContext": ...

        def ca(self, value_or_callback=None, /):
            """
            Certificate authority used when verifying server certificates.
            """
            if self._in_context and value_or_callback is None:
                context = Ca.BuilderContext()
                context._parent_builder = self
                context._field_name = "ca"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ca.builder())
                if isinstance(output, Ca.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ca", value)

        def ca_file(self, value: Optional[str], /) -> Self:
            """
            Path to the CA cert in the Prometheus container to use for the targets.
            """
            return self._set("ca_file", value)

        @overload
        def cert(self, value_or_callback: Optional[Cert], /) -> "TlsConfigModel2.Builder": ...

        @overload
        def cert(
            self, value_or_callback: Callable[[Cert.Builder], Cert.Builder | Cert], /
        ) -> "TlsConfigModel2.Builder": ...

        @overload
        def cert(self, value_or_callback: Never = ...) -> "Cert.BuilderContext": ...

        def cert(self, value_or_callback=None, /):
            """
            Client certificate to present when doing client-authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Cert.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cert.builder())
                if isinstance(output, Cert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert", value)

        def cert_file(self, value: Optional[str], /) -> Self:
            """
            Path to the client cert file in the Prometheus container for the targets.
            """
            return self._set("cert_file", value)

        def insecure_skip_verify(self, value: Optional[bool], /) -> Self:
            """
            Disable target certificate validation.
            """
            return self._set("insecure_skip_verify", value)

        def key_file(self, value: Optional[str], /) -> Self:
            """
            Path to the client key file in the Prometheus container for the targets.
            """
            return self._set("key_file", value)

        @overload
        def key_secret(
            self, value_or_callback: Optional[KeySecret], /
        ) -> "TlsConfigModel2.Builder": ...

        @overload
        def key_secret(
            self,
            value_or_callback: Callable[[KeySecret.Builder], KeySecret.Builder | KeySecret],
            /,
        ) -> "TlsConfigModel2.Builder": ...

        @overload
        def key_secret(self, value_or_callback: Never = ...) -> "KeySecret.BuilderContext": ...

        def key_secret(self, value_or_callback=None, /):
            """
            Secret containing the client key file for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = KeySecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "key_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KeySecret.builder())
                if isinstance(output, KeySecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("key_secret", value)

        def max_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Maximum acceptable TLS version.

            It requires Prometheus >= v2.41.0.
            """
            return self._set("max_version", value)

        def min_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Minimum acceptable TLS version.

            It requires Prometheus >= v2.35.0.
            """
            return self._set("min_version", value)

        def server_name(self, value: Optional[str], /) -> Self:
            """
            Used to verify the hostname for the targets.
            """
            return self._set("server_name", value)

    class BuilderContext(BuilderContextBase["TlsConfigModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsConfigModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsConfigModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsConfigModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsConfigModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca: Optional[Ca] = None
    """
    Certificate authority used when verifying server certificates.
    """
    ca_file: Annotated[Optional[str], Field(alias="caFile")] = None
    """
    Path to the CA cert in the Prometheus container to use for the targets.
    """
    cert: Optional[Cert] = None
    """
    Client certificate to present when doing client-authentication.
    """
    cert_file: Annotated[Optional[str], Field(alias="certFile")] = None
    """
    Path to the client cert file in the Prometheus container for the targets.
    """
    insecure_skip_verify: Annotated[Optional[bool], Field(alias="insecureSkipVerify")] = None
    """
    Disable target certificate validation.
    """
    key_file: Annotated[Optional[str], Field(alias="keyFile")] = None
    """
    Path to the client key file in the Prometheus container for the targets.
    """
    key_secret: Annotated[Optional[KeySecret], Field(alias="keySecret")] = None
    """
    Secret containing the client key file for the targets.
    """
    max_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="maxVersion")
    ] = None
    """
    Maximum acceptable TLS version.

    It requires Prometheus >= v2.41.0.
    """
    min_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="minVersion")
    ] = None
    """
    Minimum acceptable TLS version.

    It requires Prometheus >= v2.35.0.
    """
    server_name: Annotated[Optional[str], Field(alias="serverName")] = None
    """
    Used to verify the hostname for the targets.
    """


class AlertmanagerEndpoint(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AlertmanagerEndpoint"]:
            return AlertmanagerEndpoint

        def build(self) -> "AlertmanagerEndpoint":
            return AlertmanagerEndpoint(**self._attrs)

        @overload
        def alert_relabelings(
            self, value_or_callback: List[AlertRelabeling], /
        ) -> "AlertmanagerEndpoint.Builder": ...

        @overload
        def alert_relabelings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AlertRelabeling, AlertRelabeling.Builder]],
                GenericListBuilder[AlertRelabeling, AlertRelabeling.Builder]
                | List[AlertRelabeling],
            ],
            /,
        ) -> "AlertmanagerEndpoint.Builder": ...

        @overload
        def alert_relabelings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[AlertRelabeling.Builder]: ...

        def alert_relabelings(self, value_or_callback=None, /):
            """
            Relabeling configs applied before sending alerts to a specific Alertmanager.
            It requires Prometheus >= v2.51.0.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AlertRelabeling.Builder]()
                context._parent_builder = self
                context._field_name = "alert_relabelings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AlertRelabeling.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("alert_relabelings", value)

        def api_version(self, value: Optional[Literal["v1", "V1", "v2", "V2"]], /) -> Self:
            """
            Version of the Alertmanager API that Prometheus uses to send alerts.
            It can be "V1" or "V2".
            The field has no effect for Prometheus >= v3.0.0 because only the v2 API is supported.
            """
            return self._set("api_version", value)

        @overload
        def authorization(
            self, value_or_callback: Optional[Authorization], /
        ) -> "AlertmanagerEndpoint.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [Authorization.Builder], Authorization.Builder | Authorization
            ],
            /,
        ) -> "AlertmanagerEndpoint.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "Authorization.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization section for Alertmanager.

            Cannot be set at the same time as `basicAuth`, `bearerTokenFile` or `sigv4`.
            """
            if self._in_context and value_or_callback is None:
                context = Authorization.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Authorization.builder())
                if isinstance(output, Authorization.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def basic_auth(
            self, value_or_callback: Optional[BasicAuth], /
        ) -> "AlertmanagerEndpoint.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "AlertmanagerEndpoint.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            BasicAuth configuration for Alertmanager.

            Cannot be set at the same time as `bearerTokenFile`, `authorization` or `sigv4`.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        def bearer_token_file(self, value: Optional[str], /) -> Self:
            """
            File to read bearer token for Alertmanager.

            Cannot be set at the same time as `basicAuth`, `authorization`, or `sigv4`.

            Deprecated: this will be removed in a future release. Prefer using `authorization`.
            """
            return self._set("bearer_token_file", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            Whether to enable HTTP2.
            """
            return self._set("enable_http2", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the Endpoints object in the namespace.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the Endpoints object.

            If not set, the object will be discovered in the namespace of the
            Prometheus object.
            """
            return self._set("namespace", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        def path_prefix(self, value: Optional[str], /) -> Self:
            """
            Prefix for the HTTP path alerts are pushed to.
            """
            return self._set("path_prefix", value)

        def port(self, value: Union[int, str], /) -> Self:
            """
            Port on which the Alertmanager API is exposed.
            """
            return self._set("port", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        @overload
        def relabelings(
            self, value_or_callback: List[Relabeling], /
        ) -> "AlertmanagerEndpoint.Builder": ...

        @overload
        def relabelings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Relabeling, Relabeling.Builder]],
                GenericListBuilder[Relabeling, Relabeling.Builder] | List[Relabeling],
            ],
            /,
        ) -> "AlertmanagerEndpoint.Builder": ...

        @overload
        def relabelings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Relabeling.Builder]: ...

        def relabelings(self, value_or_callback=None, /):
            """
            Relabel configuration applied to the discovered Alertmanagers.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Relabeling.Builder]()
                context._parent_builder = self
                context._field_name = "relabelings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Relabeling.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("relabelings", value)

        def scheme(self, value: Optional[str], /) -> Self:
            """
            Scheme to use when firing alerts.
            """
            return self._set("scheme", value)

        @overload
        def sigv4(
            self, value_or_callback: Optional[Sigv4], /
        ) -> "AlertmanagerEndpoint.Builder": ...

        @overload
        def sigv4(
            self, value_or_callback: Callable[[Sigv4.Builder], Sigv4.Builder | Sigv4], /
        ) -> "AlertmanagerEndpoint.Builder": ...

        @overload
        def sigv4(self, value_or_callback: Never = ...) -> "Sigv4.BuilderContext": ...

        def sigv4(self, value_or_callback=None, /):
            """
            Sigv4 allows to configures AWS's Signature Verification 4 for the URL.

            It requires Prometheus >= v2.48.0.

            Cannot be set at the same time as `basicAuth`, `bearerTokenFile` or `authorization`.
            """
            if self._in_context and value_or_callback is None:
                context = Sigv4.BuilderContext()
                context._parent_builder = self
                context._field_name = "sigv4"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sigv4.builder())
                if isinstance(output, Sigv4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sigv4", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout is a per-target Alertmanager timeout when pushing alerts.
            """
            return self._set("timeout", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel2], /
        ) -> "AlertmanagerEndpoint.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel2.Builder], TlsConfigModel2.Builder | TlsConfigModel2
            ],
            /,
        ) -> "AlertmanagerEndpoint.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel2.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS Config to use for Alertmanager.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel2.builder())
                if isinstance(output, TlsConfigModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["AlertmanagerEndpoint.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AlertmanagerEndpoint.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AlertmanagerEndpoint."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AlertmanagerEndpoint", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AlertmanagerEndpoint.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    alert_relabelings: Annotated[
        Optional[List[AlertRelabeling]], Field(alias="alertRelabelings")
    ] = None
    """
    Relabeling configs applied before sending alerts to a specific Alertmanager.
    It requires Prometheus >= v2.51.0.
    """
    api_version: Annotated[Optional[Literal["v1", "V1", "v2", "V2"]], Field(alias="apiVersion")] = (
        None
    )
    """
    Version of the Alertmanager API that Prometheus uses to send alerts.
    It can be "V1" or "V2".
    The field has no effect for Prometheus >= v3.0.0 because only the v2 API is supported.
    """
    authorization: Optional[Authorization] = None
    """
    Authorization section for Alertmanager.

    Cannot be set at the same time as `basicAuth`, `bearerTokenFile` or `sigv4`.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    BasicAuth configuration for Alertmanager.

    Cannot be set at the same time as `bearerTokenFile`, `authorization` or `sigv4`.
    """
    bearer_token_file: Annotated[Optional[str], Field(alias="bearerTokenFile")] = None
    """
    File to read bearer token for Alertmanager.

    Cannot be set at the same time as `basicAuth`, `authorization`, or `sigv4`.

    Deprecated: this will be removed in a future release. Prefer using `authorization`.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHttp2")] = None
    """
    Whether to enable HTTP2.
    """
    name: Annotated[str, Field(min_length=1)]
    """
    Name of the Endpoints object in the namespace.
    """
    namespace: Annotated[Optional[str], Field(min_length=1)] = None
    """
    Namespace of the Endpoints object.

    If not set, the object will be discovered in the namespace of the
    Prometheus object.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    path_prefix: Annotated[Optional[str], Field(alias="pathPrefix")] = None
    """
    Prefix for the HTTP path alerts are pushed to.
    """
    port: Union[int, str]
    """
    Port on which the Alertmanager API is exposed.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    relabelings: Optional[List[Relabeling]] = None
    """
    Relabel configuration applied to the discovered Alertmanagers.
    """
    scheme: Optional[str] = None
    """
    Scheme to use when firing alerts.
    """
    sigv4: Optional[Sigv4] = None
    """
    Sigv4 allows to configures AWS's Signature Verification 4 for the URL.

    It requires Prometheus >= v2.48.0.

    Cannot be set at the same time as `basicAuth`, `bearerTokenFile` or `authorization`.
    """
    timeout: Annotated[
        Optional[str],
        Field(
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"
        ),
    ] = None
    """
    Timeout is a per-target Alertmanager timeout when pushing alerts.
    """
    tls_config: Annotated[Optional[TlsConfigModel2], Field(alias="tlsConfig")] = None
    """
    TLS Config to use for Alertmanager.
    """


class Alerting(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Alerting"]:
            return Alerting

        def build(self) -> "Alerting":
            return Alerting(**self._attrs)

        @overload
        def alertmanagers(
            self, value_or_callback: List[AlertmanagerEndpoint], /
        ) -> "Alerting.Builder": ...

        @overload
        def alertmanagers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AlertmanagerEndpoint, AlertmanagerEndpoint.Builder]],
                GenericListBuilder[AlertmanagerEndpoint, AlertmanagerEndpoint.Builder]
                | List[AlertmanagerEndpoint],
            ],
            /,
        ) -> "Alerting.Builder": ...

        @overload
        def alertmanagers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[AlertmanagerEndpoint.Builder]: ...

        def alertmanagers(self, value_or_callback=None, /):
            """
            Alertmanager endpoints where Prometheus should send alerts to.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AlertmanagerEndpoint.Builder]()
                context._parent_builder = self
                context._field_name = "alertmanagers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AlertmanagerEndpoint.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("alertmanagers", value)

    class BuilderContext(BuilderContextBase["Alerting.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Alerting.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Alerting."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Alerting", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Alerting.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    alertmanagers: List[AlertmanagerEndpoint]
    """
    Alertmanager endpoints where Prometheus should send alerts to.
    """


class AuthorizationModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AuthorizationModel"]:
            return AuthorizationModel

        def build(self) -> "AuthorizationModel":
            return AuthorizationModel(**self._attrs)

        @overload
        def credentials(
            self, value_or_callback: Optional[Credentials], /
        ) -> "AuthorizationModel.Builder": ...

        @overload
        def credentials(
            self,
            value_or_callback: Callable[[Credentials.Builder], Credentials.Builder | Credentials],
            /,
        ) -> "AuthorizationModel.Builder": ...

        @overload
        def credentials(self, value_or_callback: Never = ...) -> "Credentials.BuilderContext": ...

        def credentials(self, value_or_callback=None, /):
            """
            Selects a key of a Secret in the namespace that contains the credentials for authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Credentials.BuilderContext()
                context._parent_builder = self
                context._field_name = "credentials"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Credentials.builder())
                if isinstance(output, Credentials.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("credentials", value)

        def credentials_file(self, value: Optional[str], /) -> Self:
            """
            File to read a secret from, mutually exclusive with `credentials`.
            """
            return self._set("credentials_file", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Defines the authentication type. The value is case-insensitive.

            "Basic" is not a supported value.

            Default: "Bearer"
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["AuthorizationModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AuthorizationModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AuthorizationModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AuthorizationModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AuthorizationModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    credentials: Optional[Credentials] = None
    """
    Selects a key of a Secret in the namespace that contains the credentials for authentication.
    """
    credentials_file: Annotated[Optional[str], Field(alias="credentialsFile")] = None
    """
    File to read a secret from, mutually exclusive with `credentials`.
    """
    type: Optional[str] = None
    """
    Defines the authentication type. The value is case-insensitive.

    "Basic" is not a supported value.

    Default: "Bearer"
    """


class ApiserverConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ApiserverConfig"]:
            return ApiserverConfig

        def build(self) -> "ApiserverConfig":
            return ApiserverConfig(**self._attrs)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel], /
        ) -> "ApiserverConfig.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel.Builder],
                AuthorizationModel.Builder | AuthorizationModel,
            ],
            /,
        ) -> "ApiserverConfig.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization section for the API server.

            Cannot be set at the same time as `basicAuth`, `bearerToken`, or
            `bearerTokenFile`.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel.builder())
                if isinstance(output, AuthorizationModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def basic_auth(
            self, value_or_callback: Optional[BasicAuth], /
        ) -> "ApiserverConfig.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "ApiserverConfig.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            BasicAuth configuration for the API server.

            Cannot be set at the same time as `authorization`, `bearerToken`, or
            `bearerTokenFile`.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        def bearer_token(self, value: Optional[str], /) -> Self:
            """
            *Warning: this field shouldn't be used because the token value appears
            in clear-text. Prefer using `authorization`.*

            Deprecated: this will be removed in a future release.
            """
            return self._set("bearer_token", value)

        def bearer_token_file(self, value: Optional[str], /) -> Self:
            """
            File to read bearer token for accessing apiserver.

            Cannot be set at the same time as `basicAuth`, `authorization`, or `bearerToken`.

            Deprecated: this will be removed in a future release. Prefer using `authorization`.
            """
            return self._set("bearer_token_file", value)

        def host(self, value: str, /) -> Self:
            """
            Kubernetes API address consisting of a hostname or IP address followed
            by an optional port number.
            """
            return self._set("host", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel2], /
        ) -> "ApiserverConfig.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel2.Builder], TlsConfigModel2.Builder | TlsConfigModel2
            ],
            /,
        ) -> "ApiserverConfig.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel2.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS Config to use for the API server.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel2.builder())
                if isinstance(output, TlsConfigModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["ApiserverConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ApiserverConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ApiserverConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ApiserverConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ApiserverConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authorization: Optional[AuthorizationModel] = None
    """
    Authorization section for the API server.

    Cannot be set at the same time as `basicAuth`, `bearerToken`, or
    `bearerTokenFile`.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    BasicAuth configuration for the API server.

    Cannot be set at the same time as `authorization`, `bearerToken`, or
    `bearerTokenFile`.
    """
    bearer_token: Annotated[Optional[str], Field(alias="bearerToken")] = None
    """
    *Warning: this field shouldn't be used because the token value appears
    in clear-text. Prefer using `authorization`.*

    Deprecated: this will be removed in a future release.
    """
    bearer_token_file: Annotated[Optional[str], Field(alias="bearerTokenFile")] = None
    """
    File to read bearer token for accessing apiserver.

    Cannot be set at the same time as `basicAuth`, `authorization`, or `bearerToken`.

    Deprecated: this will be removed in a future release. Prefer using `authorization`.
    """
    host: str
    """
    Kubernetes API address consisting of a hostname or IP address followed
    by an optional port number.
    """
    tls_config: Annotated[Optional[TlsConfigModel2], Field(alias="tlsConfig")] = None
    """
    TLS Config to use for the API server.
    """


class ArbitraryFsAccessThroughSMs(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ArbitraryFsAccessThroughSMs"]:
            return ArbitraryFsAccessThroughSMs

        def build(self) -> "ArbitraryFsAccessThroughSMs":
            return ArbitraryFsAccessThroughSMs(**self._attrs)

        def deny(self, value: Optional[bool], /) -> Self:
            return self._set("deny", value)

    class BuilderContext(BuilderContextBase["ArbitraryFsAccessThroughSMs.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ArbitraryFsAccessThroughSMs.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ArbitraryFsAccessThroughSMs."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ArbitraryFsAccessThroughSMs", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ArbitraryFsAccessThroughSMs.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    deny: Optional[bool] = None


class DivisorModel7(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel7":
            value = cast(int, self._value)
            return DivisorModel7(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel7.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel7.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel7."""
        return cls.BuilderContext()


class DivisorModel8(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel8":
            value = cast(str, self._value)
            return DivisorModel8(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel8.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel8.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel8."""
        return cls.BuilderContext()


class SecretRefModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretRefModel1"]:
            return SecretRefModel1

        def build(self) -> "SecretRefModel1":
            return SecretRefModel1(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["SecretRefModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretRefModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretRefModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretRefModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRefModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret must be defined
    """


class LimitsModel11(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel11":
            value = cast(int, self._value)
            return LimitsModel11(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel11.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel11.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel11."""
        return cls.BuilderContext()


class LimitsModel12(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel12":
            value = cast(str, self._value)
            return LimitsModel12(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel12.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel12.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel12."""
        return cls.BuilderContext()


class RequestsModel11(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel11":
            value = cast(int, self._value)
            return RequestsModel11(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel11.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel11.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel11."""
        return cls.BuilderContext()


class RequestsModel12(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel12":
            value = cast(str, self._value)
            return RequestsModel12(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel12.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel12.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel12."""
        return cls.BuilderContext()


class ResourcesModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourcesModel1"]:
            return ResourcesModel1

        def build(self) -> "ResourcesModel1":
            return ResourcesModel1(**self._attrs)

        @overload
        def claims(self, value_or_callback: List[Claim], /) -> "ResourcesModel1.Builder": ...

        @overload
        def claims(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Claim, Claim.Builder]],
                GenericListBuilder[Claim, Claim.Builder] | List[Claim],
            ],
            /,
        ) -> "ResourcesModel1.Builder": ...

        @overload
        def claims(self, value_or_callback: Never = ...) -> ListBuilderContext[Claim.Builder]: ...

        def claims(self, value_or_callback=None, /):
            """
            Claims lists the names of resources, defined in spec.resourceClaims,
            that are used by this container.

            This is an alpha field and requires enabling the
            DynamicResourceAllocation feature gate.

            This field is immutable. It can only be set for containers.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Claim.Builder]()
                context._parent_builder = self
                context._field_name = "claims"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Claim.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("claims", value)

        def limits(
            self, value: Optional[Dict[str, Union[LimitsModel11, LimitsModel12]]], /
        ) -> Self:
            """
            Limits describes the maximum amount of compute resources allowed.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            return self._set("limits", value)

        def requests(
            self, value: Optional[Dict[str, Union[RequestsModel11, RequestsModel12]]], /
        ) -> Self:
            """
            Requests describes the minimum amount of compute resources required.
            If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
            otherwise to an implementation-defined value. Requests cannot exceed Limits.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            return self._set("requests", value)

    class BuilderContext(BuilderContextBase["ResourcesModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourcesModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourcesModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourcesModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourcesModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    claims: Optional[List[Claim]] = None
    """
    Claims lists the names of resources, defined in spec.resourceClaims,
    that are used by this container.

    This is an alpha field and requires enabling the
    DynamicResourceAllocation feature gate.

    This field is immutable. It can only be set for containers.
    """
    limits: Optional[Dict[str, Union[LimitsModel11, LimitsModel12]]] = None
    """
    Limits describes the maximum amount of compute resources allowed.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """
    requests: Optional[Dict[str, Union[RequestsModel11, RequestsModel12]]] = None
    """
    Requests describes the minimum amount of compute resources required.
    If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    otherwise to an implementation-defined value. Requests cannot exceed Limits.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """


class SecurityContextModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecurityContextModel1"]:
            return SecurityContextModel1

        def build(self) -> "SecurityContextModel1":
            return SecurityContextModel1(**self._attrs)

        def allow_privilege_escalation(self, value: Optional[bool], /) -> Self:
            """
            AllowPrivilegeEscalation controls whether a process can gain more
            privileges than its parent process. This bool directly controls if
            the no_new_privs flag will be set on the container process.
            AllowPrivilegeEscalation is true always when the container is:
            1) run as Privileged
            2) has CAP_SYS_ADMIN
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("allow_privilege_escalation", value)

        @overload
        def app_armor_profile(
            self, value_or_callback: Optional[AppArmorProfile], /
        ) -> "SecurityContextModel1.Builder": ...

        @overload
        def app_armor_profile(
            self,
            value_or_callback: Callable[
                [AppArmorProfile.Builder], AppArmorProfile.Builder | AppArmorProfile
            ],
            /,
        ) -> "SecurityContextModel1.Builder": ...

        @overload
        def app_armor_profile(
            self, value_or_callback: Never = ...
        ) -> "AppArmorProfile.BuilderContext": ...

        def app_armor_profile(self, value_or_callback=None, /):
            """
            appArmorProfile is the AppArmor options to use by this container. If set, this profile
            overrides the pod's appArmorProfile.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = AppArmorProfile.BuilderContext()
                context._parent_builder = self
                context._field_name = "app_armor_profile"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AppArmorProfile.builder())
                if isinstance(output, AppArmorProfile.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("app_armor_profile", value)

        @overload
        def capabilities(
            self, value_or_callback: Optional[Capabilities], /
        ) -> "SecurityContextModel1.Builder": ...

        @overload
        def capabilities(
            self,
            value_or_callback: Callable[
                [Capabilities.Builder], Capabilities.Builder | Capabilities
            ],
            /,
        ) -> "SecurityContextModel1.Builder": ...

        @overload
        def capabilities(self, value_or_callback: Never = ...) -> "Capabilities.BuilderContext": ...

        def capabilities(self, value_or_callback=None, /):
            """
            The capabilities to add/drop when running containers.
            Defaults to the default set of capabilities granted by the container runtime.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = Capabilities.BuilderContext()
                context._parent_builder = self
                context._field_name = "capabilities"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Capabilities.builder())
                if isinstance(output, Capabilities.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("capabilities", value)

        def privileged(self, value: Optional[bool], /) -> Self:
            """
            Run container in privileged mode.
            Processes in privileged containers are essentially equivalent to root on the host.
            Defaults to false.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("privileged", value)

        def proc_mount(self, value: Optional[str], /) -> Self:
            """
            procMount denotes the type of proc mount to use for the containers.
            The default value is Default which uses the container runtime defaults for
            readonly paths and masked paths.
            This requires the ProcMountType feature flag to be enabled.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("proc_mount", value)

        def read_only_root_filesystem(self, value: Optional[bool], /) -> Self:
            """
            Whether this container has a read-only root filesystem.
            Default is false.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("read_only_root_filesystem", value)

        def run_as_group(self, value: Optional[int], /) -> Self:
            """
            The GID to run the entrypoint of the container process.
            Uses runtime default if unset.
            May also be set in PodSecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("run_as_group", value)

        def run_as_non_root(self, value: Optional[bool], /) -> Self:
            """
            Indicates that the container must run as a non-root user.
            If true, the Kubelet will validate the image at runtime to ensure that it
            does not run as UID 0 (root) and fail to start the container if it does.
            If unset or false, no such validation will be performed.
            May also be set in PodSecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            """
            return self._set("run_as_non_root", value)

        def run_as_user(self, value: Optional[int], /) -> Self:
            """
            The UID to run the entrypoint of the container process.
            Defaults to user specified in image metadata if unspecified.
            May also be set in PodSecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("run_as_user", value)

        @overload
        def se_linux_options(
            self, value_or_callback: Optional[SeLinuxOptions], /
        ) -> "SecurityContextModel1.Builder": ...

        @overload
        def se_linux_options(
            self,
            value_or_callback: Callable[
                [SeLinuxOptions.Builder], SeLinuxOptions.Builder | SeLinuxOptions
            ],
            /,
        ) -> "SecurityContextModel1.Builder": ...

        @overload
        def se_linux_options(
            self, value_or_callback: Never = ...
        ) -> "SeLinuxOptions.BuilderContext": ...

        def se_linux_options(self, value_or_callback=None, /):
            """
            The SELinux context to be applied to the container.
            If unspecified, the container runtime will allocate a random SELinux context for each
            container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = SeLinuxOptions.BuilderContext()
                context._parent_builder = self
                context._field_name = "se_linux_options"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SeLinuxOptions.builder())
                if isinstance(output, SeLinuxOptions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("se_linux_options", value)

        @overload
        def seccomp_profile(
            self, value_or_callback: Optional[SeccompProfile], /
        ) -> "SecurityContextModel1.Builder": ...

        @overload
        def seccomp_profile(
            self,
            value_or_callback: Callable[
                [SeccompProfile.Builder], SeccompProfile.Builder | SeccompProfile
            ],
            /,
        ) -> "SecurityContextModel1.Builder": ...

        @overload
        def seccomp_profile(
            self, value_or_callback: Never = ...
        ) -> "SeccompProfile.BuilderContext": ...

        def seccomp_profile(self, value_or_callback=None, /):
            """
            The seccomp options to use by this container. If seccomp options are
            provided at both the pod & container level, the container options
            override the pod options.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = SeccompProfile.BuilderContext()
                context._parent_builder = self
                context._field_name = "seccomp_profile"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SeccompProfile.builder())
                if isinstance(output, SeccompProfile.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("seccomp_profile", value)

        @overload
        def windows_options(
            self, value_or_callback: Optional[WindowsOptions], /
        ) -> "SecurityContextModel1.Builder": ...

        @overload
        def windows_options(
            self,
            value_or_callback: Callable[
                [WindowsOptions.Builder], WindowsOptions.Builder | WindowsOptions
            ],
            /,
        ) -> "SecurityContextModel1.Builder": ...

        @overload
        def windows_options(
            self, value_or_callback: Never = ...
        ) -> "WindowsOptions.BuilderContext": ...

        def windows_options(self, value_or_callback=None, /):
            """
            The Windows specific settings applied to all containers.
            If unspecified, the options from the PodSecurityContext will be used.
            If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
            Note that this field cannot be set when spec.os.name is linux.
            """
            if self._in_context and value_or_callback is None:
                context = WindowsOptions.BuilderContext()
                context._parent_builder = self
                context._field_name = "windows_options"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WindowsOptions.builder())
                if isinstance(output, WindowsOptions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("windows_options", value)

    class BuilderContext(BuilderContextBase["SecurityContextModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecurityContextModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecurityContextModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecurityContextModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecurityContextModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    allow_privilege_escalation: Annotated[
        Optional[bool], Field(alias="allowPrivilegeEscalation")
    ] = None
    """
    AllowPrivilegeEscalation controls whether a process can gain more
    privileges than its parent process. This bool directly controls if
    the no_new_privs flag will be set on the container process.
    AllowPrivilegeEscalation is true always when the container is:
    1) run as Privileged
    2) has CAP_SYS_ADMIN
    Note that this field cannot be set when spec.os.name is windows.
    """
    app_armor_profile: Annotated[Optional[AppArmorProfile], Field(alias="appArmorProfile")] = None
    """
    appArmorProfile is the AppArmor options to use by this container. If set, this profile
    overrides the pod's appArmorProfile.
    Note that this field cannot be set when spec.os.name is windows.
    """
    capabilities: Optional[Capabilities] = None
    """
    The capabilities to add/drop when running containers.
    Defaults to the default set of capabilities granted by the container runtime.
    Note that this field cannot be set when spec.os.name is windows.
    """
    privileged: Optional[bool] = None
    """
    Run container in privileged mode.
    Processes in privileged containers are essentially equivalent to root on the host.
    Defaults to false.
    Note that this field cannot be set when spec.os.name is windows.
    """
    proc_mount: Annotated[Optional[str], Field(alias="procMount")] = None
    """
    procMount denotes the type of proc mount to use for the containers.
    The default value is Default which uses the container runtime defaults for
    readonly paths and masked paths.
    This requires the ProcMountType feature flag to be enabled.
    Note that this field cannot be set when spec.os.name is windows.
    """
    read_only_root_filesystem: Annotated[Optional[bool], Field(alias="readOnlyRootFilesystem")] = (
        None
    )
    """
    Whether this container has a read-only root filesystem.
    Default is false.
    Note that this field cannot be set when spec.os.name is windows.
    """
    run_as_group: Annotated[Optional[int], Field(alias="runAsGroup")] = None
    """
    The GID to run the entrypoint of the container process.
    Uses runtime default if unset.
    May also be set in PodSecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    Note that this field cannot be set when spec.os.name is windows.
    """
    run_as_non_root: Annotated[Optional[bool], Field(alias="runAsNonRoot")] = None
    """
    Indicates that the container must run as a non-root user.
    If true, the Kubelet will validate the image at runtime to ensure that it
    does not run as UID 0 (root) and fail to start the container if it does.
    If unset or false, no such validation will be performed.
    May also be set in PodSecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    """
    run_as_user: Annotated[Optional[int], Field(alias="runAsUser")] = None
    """
    The UID to run the entrypoint of the container process.
    Defaults to user specified in image metadata if unspecified.
    May also be set in PodSecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    Note that this field cannot be set when spec.os.name is windows.
    """
    se_linux_options: Annotated[Optional[SeLinuxOptions], Field(alias="seLinuxOptions")] = None
    """
    The SELinux context to be applied to the container.
    If unspecified, the container runtime will allocate a random SELinux context for each
    container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    Note that this field cannot be set when spec.os.name is windows.
    """
    seccomp_profile: Annotated[Optional[SeccompProfile], Field(alias="seccompProfile")] = None
    """
    The seccomp options to use by this container. If seccomp options are
    provided at both the pod & container level, the container options
    override the pod options.
    Note that this field cannot be set when spec.os.name is windows.
    """
    windows_options: Annotated[Optional[WindowsOptions], Field(alias="windowsOptions")] = None
    """
    The Windows specific settings applied to all containers.
    If unspecified, the options from the PodSecurityContext will be used.
    If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
    Note that this field cannot be set when spec.os.name is linux.
    """


class EnableFeature(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "EnableFeature":
            value = cast(str, self._value)
            return EnableFeature(value)

    root: Annotated[str, Field(min_length=1)]

    class BuilderContext(BuilderContextBase["EnableFeature.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = EnableFeature.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for EnableFeature."""
        return cls.BuilderContext()


class ExcludedFromEnforcement(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ExcludedFromEnforcement"]:
            return ExcludedFromEnforcement

        def build(self) -> "ExcludedFromEnforcement":
            return ExcludedFromEnforcement(**self._attrs)

        def group(self, value: Optional[Literal["monitoring.coreos.com"]], /) -> Self:
            """
            Group of the referent. When not specified, it defaults to `monitoring.coreos.com`
            """
            return self._set("group", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent. When not set, all resources in the namespace are matched.
            """
            return self._set("name", value)

        def namespace(self, value: str, /) -> Self:
            """
            Namespace of the referent.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
            """
            return self._set("namespace", value)

        def resource(
            self,
            value: Literal[
                "prometheusrules",
                "servicemonitors",
                "podmonitors",
                "probes",
                "scrapeconfigs",
            ],
            /,
        ) -> Self:
            """
            Resource of the referent.
            """
            return self._set("resource", value)

    class BuilderContext(BuilderContextBase["ExcludedFromEnforcement.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ExcludedFromEnforcement.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ExcludedFromEnforcement."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ExcludedFromEnforcement", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ExcludedFromEnforcement.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    group: Optional[Literal["monitoring.coreos.com"]] = "monitoring.coreos.com"
    """
    Group of the referent. When not specified, it defaults to `monitoring.coreos.com`
    """
    name: Optional[str] = None
    """
    Name of the referent. When not set, all resources in the namespace are matched.
    """
    namespace: Annotated[str, Field(min_length=1)]
    """
    Namespace of the referent.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    """
    resource: Literal[
        "prometheusrules", "servicemonitors", "podmonitors", "probes", "scrapeconfigs"
    ]
    """
    Resource of the referent.
    """


class Exemplars(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Exemplars"]:
            return Exemplars

        def build(self) -> "Exemplars":
            return Exemplars(**self._attrs)

        def max_size(self, value: Optional[int], /) -> Self:
            """
            Maximum number of exemplars stored in memory for all series.

            exemplar-storage itself must be enabled using the `spec.enableFeature`
            option for exemplars to be scraped in the first place.

            If not set, Prometheus uses its default value. A value of zero or less
            than zero disables the storage.
            """
            return self._set("max_size", value)

    class BuilderContext(BuilderContextBase["Exemplars.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Exemplars.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Exemplars."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Exemplars", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Exemplars.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    max_size: Annotated[Optional[int], Field(alias="maxSize")] = None
    """
    Maximum number of exemplars stored in memory for all series.

    exemplar-storage itself must be enabled using the `spec.enableFeature`
    option for exemplars to be scraped in the first place.

    If not set, Prometheus uses its default value. A value of zero or less
    than zero disables the storage.
    """


class DivisorModel9(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel9":
            value = cast(int, self._value)
            return DivisorModel9(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel9.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel9.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel9."""
        return cls.BuilderContext()


class DivisorModel10(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel10":
            value = cast(str, self._value)
            return DivisorModel10(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel10.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel10.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel10."""
        return cls.BuilderContext()


class LimitsModel13(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel13":
            value = cast(int, self._value)
            return LimitsModel13(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel13.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel13.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel13."""
        return cls.BuilderContext()


class LimitsModel14(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel14":
            value = cast(str, self._value)
            return LimitsModel14(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel14.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel14.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel14."""
        return cls.BuilderContext()


class RequestsModel13(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel13":
            value = cast(int, self._value)
            return RequestsModel13(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel13.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel13.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel13."""
        return cls.BuilderContext()


class RequestsModel14(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel14":
            value = cast(str, self._value)
            return RequestsModel14(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel14.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel14.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel14."""
        return cls.BuilderContext()


class PromoteResourceAttribute(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "PromoteResourceAttribute":
            value = cast(str, self._value)
            return PromoteResourceAttribute(value)

    root: Annotated[str, Field(min_length=1)]

    class BuilderContext(BuilderContextBase["PromoteResourceAttribute.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PromoteResourceAttribute.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PromoteResourceAttribute."""
        return cls.BuilderContext()


class Otlp(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Otlp"]:
            return Otlp

        def build(self) -> "Otlp":
            return Otlp(**self._attrs)

        def keep_identifying_resource_attributes(self, value: Optional[bool], /) -> Self:
            """
            Enables adding `service.name`, `service.namespace` and `service.instance.id`
            resource attributes to the `target_info` metric, on top of converting them into the `instance` and `job` labels.

            It requires Prometheus >= v3.1.0.
            """
            return self._set("keep_identifying_resource_attributes", value)

        @overload
        def promote_resource_attributes(
            self, value_or_callback: List[PromoteResourceAttribute], /
        ) -> "Otlp.Builder": ...

        @overload
        def promote_resource_attributes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PromoteResourceAttribute, PromoteResourceAttribute.Builder]],
                GenericListBuilder[PromoteResourceAttribute, PromoteResourceAttribute.Builder]
                | List[PromoteResourceAttribute],
            ],
            /,
        ) -> "Otlp.Builder": ...

        @overload
        def promote_resource_attributes(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PromoteResourceAttribute.Builder]: ...

        def promote_resource_attributes(self, value_or_callback=None, /):
            """
            List of OpenTelemetry Attributes that should be promoted to metric labels, defaults to none.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PromoteResourceAttribute.Builder]()
                context._parent_builder = self
                context._field_name = "promote_resource_attributes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PromoteResourceAttribute.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("promote_resource_attributes", value)

        def translation_strategy(
            self,
            value: Optional[
                Literal["NoUTF8EscapingWithSuffixes", "UnderscoreEscapingWithSuffixes"]
            ],
            /,
        ) -> Self:
            """
            Configures how the OTLP receiver endpoint translates the incoming metrics.

            It requires Prometheus >= v3.0.0.
            """
            return self._set("translation_strategy", value)

    class BuilderContext(BuilderContextBase["Otlp.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Otlp.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Otlp."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Otlp", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Otlp.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    keep_identifying_resource_attributes: Annotated[
        Optional[bool], Field(alias="keepIdentifyingResourceAttributes")
    ] = None
    """
    Enables adding `service.name`, `service.namespace` and `service.instance.id`
    resource attributes to the `target_info` metric, on top of converting them into the `instance` and `job` labels.

    It requires Prometheus >= v3.1.0.
    """
    promote_resource_attributes: Annotated[
        Optional[List[PromoteResourceAttribute]],
        Field(alias="promoteResourceAttributes", min_length=1),
    ] = None
    """
    List of OpenTelemetry Attributes that should be promoted to metric labels, defaults to none.
    """
    translation_strategy: Annotated[
        Optional[Literal["NoUTF8EscapingWithSuffixes", "UnderscoreEscapingWithSuffixes"]],
        Field(alias="translationStrategy"),
    ] = None
    """
    Configures how the OTLP receiver endpoint translates the incoming metrics.

    It requires Prometheus >= v3.0.0.
    """


class PodMonitorNamespaceSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodMonitorNamespaceSelector"]:
            return PodMonitorNamespaceSelector

        def build(self) -> "PodMonitorNamespaceSelector":
            return PodMonitorNamespaceSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel2], /
        ) -> "PodMonitorNamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel2, MatchExpressionModel2.Builder]],
                GenericListBuilder[MatchExpressionModel2, MatchExpressionModel2.Builder]
                | List[MatchExpressionModel2],
            ],
            /,
        ) -> "PodMonitorNamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel2.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel2.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel2.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["PodMonitorNamespaceSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodMonitorNamespaceSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodMonitorNamespaceSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodMonitorNamespaceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodMonitorNamespaceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel2]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class PodMonitorSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodMonitorSelector"]:
            return PodMonitorSelector

        def build(self) -> "PodMonitorSelector":
            return PodMonitorSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel2], /
        ) -> "PodMonitorSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel2, MatchExpressionModel2.Builder]],
                GenericListBuilder[MatchExpressionModel2, MatchExpressionModel2.Builder]
                | List[MatchExpressionModel2],
            ],
            /,
        ) -> "PodMonitorSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel2.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel2.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel2.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["PodMonitorSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodMonitorSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodMonitorSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodMonitorSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodMonitorSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel2]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class ProbeNamespaceSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProbeNamespaceSelector"]:
            return ProbeNamespaceSelector

        def build(self) -> "ProbeNamespaceSelector":
            return ProbeNamespaceSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel2], /
        ) -> "ProbeNamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel2, MatchExpressionModel2.Builder]],
                GenericListBuilder[MatchExpressionModel2, MatchExpressionModel2.Builder]
                | List[MatchExpressionModel2],
            ],
            /,
        ) -> "ProbeNamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel2.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel2.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel2.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["ProbeNamespaceSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProbeNamespaceSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProbeNamespaceSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProbeNamespaceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProbeNamespaceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel2]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class ProbeSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProbeSelector"]:
            return ProbeSelector

        def build(self) -> "ProbeSelector":
            return ProbeSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel2], /
        ) -> "ProbeSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel2, MatchExpressionModel2.Builder]],
                GenericListBuilder[MatchExpressionModel2, MatchExpressionModel2.Builder]
                | List[MatchExpressionModel2],
            ],
            /,
        ) -> "ProbeSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel2.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel2.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel2.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["ProbeSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProbeSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProbeSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProbeSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProbeSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel2]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class PrometheusRulesExcludedFromEnforce(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PrometheusRulesExcludedFromEnforce"]:
            return PrometheusRulesExcludedFromEnforce

        def build(self) -> "PrometheusRulesExcludedFromEnforce":
            return PrometheusRulesExcludedFromEnforce(**self._attrs)

        def rule_name(self, value: str, /) -> Self:
            """
            Name of the excluded PrometheusRule object.
            """
            return self._set("rule_name", value)

        def rule_namespace(self, value: str, /) -> Self:
            """
            Namespace of the excluded PrometheusRule object.
            """
            return self._set("rule_namespace", value)

    class BuilderContext(BuilderContextBase["PrometheusRulesExcludedFromEnforce.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PrometheusRulesExcludedFromEnforce.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PrometheusRulesExcludedFromEnforce."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PrometheusRulesExcludedFromEnforce", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PrometheusRulesExcludedFromEnforce.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    rule_name: Annotated[str, Field(alias="ruleName")]
    """
    Name of the excluded PrometheusRule object.
    """
    rule_namespace: Annotated[str, Field(alias="ruleNamespace")]
    """
    Namespace of the excluded PrometheusRule object.
    """


class Query(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Query"]:
            return Query

        def build(self) -> "Query":
            return Query(**self._attrs)

        def lookback_delta(self, value: Optional[str], /) -> Self:
            """
            The delta difference allowed for retrieving metrics during expression evaluations.
            """
            return self._set("lookback_delta", value)

        def max_concurrency(self, value: Optional[int], /) -> Self:
            """
            Number of concurrent queries that can be run at once.
            """
            return self._set("max_concurrency", value)

        def max_samples(self, value: Optional[int], /) -> Self:
            """
            Maximum number of samples a single query can load into memory. Note that
            queries will fail if they would load more samples than this into memory,
            so this also limits the number of samples a query can return.
            """
            return self._set("max_samples", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            Maximum time a query may take before being aborted.
            """
            return self._set("timeout", value)

    class BuilderContext(BuilderContextBase["Query.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Query.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Query."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Query", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Query.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    lookback_delta: Annotated[Optional[str], Field(alias="lookbackDelta")] = None
    """
    The delta difference allowed for retrieving metrics during expression evaluations.
    """
    max_concurrency: Annotated[Optional[int], Field(alias="maxConcurrency", ge=1)] = None
    """
    Number of concurrent queries that can be run at once.
    """
    max_samples: Annotated[Optional[int], Field(alias="maxSamples")] = None
    """
    Maximum number of samples a single query can load into memory. Note that
    queries will fail if they would load more samples than this into memory,
    so this also limits the number of samples a query can return.
    """
    timeout: Annotated[
        Optional[str],
        Field(
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"
        ),
    ] = None
    """
    Maximum time a query may take before being aborted.
    """


class TlsConfigModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsConfigModel3"]:
            return TlsConfigModel3

        def build(self) -> "TlsConfigModel3":
            return TlsConfigModel3(**self._attrs)

        @overload
        def ca(self, value_or_callback: Optional[Ca], /) -> "TlsConfigModel3.Builder": ...

        @overload
        def ca(
            self, value_or_callback: Callable[[Ca.Builder], Ca.Builder | Ca], /
        ) -> "TlsConfigModel3.Builder": ...

        @overload
        def ca(self, value_or_callback: Never = ...) -> "Ca.BuilderContext": ...

        def ca(self, value_or_callback=None, /):
            """
            Certificate authority used when verifying server certificates.
            """
            if self._in_context and value_or_callback is None:
                context = Ca.BuilderContext()
                context._parent_builder = self
                context._field_name = "ca"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ca.builder())
                if isinstance(output, Ca.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ca", value)

        @overload
        def cert(self, value_or_callback: Optional[Cert], /) -> "TlsConfigModel3.Builder": ...

        @overload
        def cert(
            self, value_or_callback: Callable[[Cert.Builder], Cert.Builder | Cert], /
        ) -> "TlsConfigModel3.Builder": ...

        @overload
        def cert(self, value_or_callback: Never = ...) -> "Cert.BuilderContext": ...

        def cert(self, value_or_callback=None, /):
            """
            Client certificate to present when doing client-authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Cert.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cert.builder())
                if isinstance(output, Cert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert", value)

        def insecure_skip_verify(self, value: Optional[bool], /) -> Self:
            """
            Disable target certificate validation.
            """
            return self._set("insecure_skip_verify", value)

        @overload
        def key_secret(
            self, value_or_callback: Optional[KeySecret], /
        ) -> "TlsConfigModel3.Builder": ...

        @overload
        def key_secret(
            self,
            value_or_callback: Callable[[KeySecret.Builder], KeySecret.Builder | KeySecret],
            /,
        ) -> "TlsConfigModel3.Builder": ...

        @overload
        def key_secret(self, value_or_callback: Never = ...) -> "KeySecret.BuilderContext": ...

        def key_secret(self, value_or_callback=None, /):
            """
            Secret containing the client key file for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = KeySecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "key_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KeySecret.builder())
                if isinstance(output, KeySecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("key_secret", value)

        def max_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Maximum acceptable TLS version.

            It requires Prometheus >= v2.41.0.
            """
            return self._set("max_version", value)

        def min_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Minimum acceptable TLS version.

            It requires Prometheus >= v2.35.0.
            """
            return self._set("min_version", value)

        def server_name(self, value: Optional[str], /) -> Self:
            """
            Used to verify the hostname for the targets.
            """
            return self._set("server_name", value)

    class BuilderContext(BuilderContextBase["TlsConfigModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsConfigModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsConfigModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsConfigModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsConfigModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca: Optional[Ca] = None
    """
    Certificate authority used when verifying server certificates.
    """
    cert: Optional[Cert] = None
    """
    Client certificate to present when doing client-authentication.
    """
    insecure_skip_verify: Annotated[Optional[bool], Field(alias="insecureSkipVerify")] = None
    """
    Disable target certificate validation.
    """
    key_secret: Annotated[Optional[KeySecret], Field(alias="keySecret")] = None
    """
    Secret containing the client key file for the targets.
    """
    max_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="maxVersion")
    ] = None
    """
    Maximum acceptable TLS version.

    It requires Prometheus >= v2.41.0.
    """
    min_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="minVersion")
    ] = None
    """
    Minimum acceptable TLS version.

    It requires Prometheus >= v2.35.0.
    """
    server_name: Annotated[Optional[str], Field(alias="serverName")] = None
    """
    Used to verify the hostname for the targets.
    """


class TlsConfigModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsConfigModel4"]:
            return TlsConfigModel4

        def build(self) -> "TlsConfigModel4":
            return TlsConfigModel4(**self._attrs)

        @overload
        def ca(self, value_or_callback: Optional[Ca], /) -> "TlsConfigModel4.Builder": ...

        @overload
        def ca(
            self, value_or_callback: Callable[[Ca.Builder], Ca.Builder | Ca], /
        ) -> "TlsConfigModel4.Builder": ...

        @overload
        def ca(self, value_or_callback: Never = ...) -> "Ca.BuilderContext": ...

        def ca(self, value_or_callback=None, /):
            """
            Certificate authority used when verifying server certificates.
            """
            if self._in_context and value_or_callback is None:
                context = Ca.BuilderContext()
                context._parent_builder = self
                context._field_name = "ca"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ca.builder())
                if isinstance(output, Ca.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ca", value)

        def ca_file(self, value: Optional[str], /) -> Self:
            """
            Path to the CA cert in the Prometheus container to use for the targets.
            """
            return self._set("ca_file", value)

        @overload
        def cert(self, value_or_callback: Optional[Cert], /) -> "TlsConfigModel4.Builder": ...

        @overload
        def cert(
            self, value_or_callback: Callable[[Cert.Builder], Cert.Builder | Cert], /
        ) -> "TlsConfigModel4.Builder": ...

        @overload
        def cert(self, value_or_callback: Never = ...) -> "Cert.BuilderContext": ...

        def cert(self, value_or_callback=None, /):
            """
            Client certificate to present when doing client-authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Cert.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cert.builder())
                if isinstance(output, Cert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert", value)

        def cert_file(self, value: Optional[str], /) -> Self:
            """
            Path to the client cert file in the Prometheus container for the targets.
            """
            return self._set("cert_file", value)

        def insecure_skip_verify(self, value: Optional[bool], /) -> Self:
            """
            Disable target certificate validation.
            """
            return self._set("insecure_skip_verify", value)

        def key_file(self, value: Optional[str], /) -> Self:
            """
            Path to the client key file in the Prometheus container for the targets.
            """
            return self._set("key_file", value)

        @overload
        def key_secret(
            self, value_or_callback: Optional[KeySecret], /
        ) -> "TlsConfigModel4.Builder": ...

        @overload
        def key_secret(
            self,
            value_or_callback: Callable[[KeySecret.Builder], KeySecret.Builder | KeySecret],
            /,
        ) -> "TlsConfigModel4.Builder": ...

        @overload
        def key_secret(self, value_or_callback: Never = ...) -> "KeySecret.BuilderContext": ...

        def key_secret(self, value_or_callback=None, /):
            """
            Secret containing the client key file for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = KeySecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "key_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KeySecret.builder())
                if isinstance(output, KeySecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("key_secret", value)

        def max_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Maximum acceptable TLS version.

            It requires Prometheus >= v2.41.0.
            """
            return self._set("max_version", value)

        def min_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Minimum acceptable TLS version.

            It requires Prometheus >= v2.35.0.
            """
            return self._set("min_version", value)

        def server_name(self, value: Optional[str], /) -> Self:
            """
            Used to verify the hostname for the targets.
            """
            return self._set("server_name", value)

    class BuilderContext(BuilderContextBase["TlsConfigModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsConfigModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsConfigModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsConfigModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsConfigModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca: Optional[Ca] = None
    """
    Certificate authority used when verifying server certificates.
    """
    ca_file: Annotated[Optional[str], Field(alias="caFile")] = None
    """
    Path to the CA cert in the Prometheus container to use for the targets.
    """
    cert: Optional[Cert] = None
    """
    Client certificate to present when doing client-authentication.
    """
    cert_file: Annotated[Optional[str], Field(alias="certFile")] = None
    """
    Path to the client cert file in the Prometheus container for the targets.
    """
    insecure_skip_verify: Annotated[Optional[bool], Field(alias="insecureSkipVerify")] = None
    """
    Disable target certificate validation.
    """
    key_file: Annotated[Optional[str], Field(alias="keyFile")] = None
    """
    Path to the client key file in the Prometheus container for the targets.
    """
    key_secret: Annotated[Optional[KeySecret], Field(alias="keySecret")] = None
    """
    Secret containing the client key file for the targets.
    """
    max_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="maxVersion")
    ] = None
    """
    Maximum acceptable TLS version.

    It requires Prometheus >= v2.41.0.
    """
    min_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="minVersion")
    ] = None
    """
    Minimum acceptable TLS version.

    It requires Prometheus >= v2.35.0.
    """
    server_name: Annotated[Optional[str], Field(alias="serverName")] = None
    """
    Used to verify the hostname for the targets.
    """


class RemoteRead(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RemoteRead"]:
            return RemoteRead

        def build(self) -> "RemoteRead":
            return RemoteRead(**self._attrs)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel], /
        ) -> "RemoteRead.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel.Builder],
                AuthorizationModel.Builder | AuthorizationModel,
            ],
            /,
        ) -> "RemoteRead.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization section for the URL.

            It requires Prometheus >= v2.26.0.

            Cannot be set at the same time as `basicAuth`, or `oauth2`.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel.builder())
                if isinstance(output, AuthorizationModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def basic_auth(self, value_or_callback: Optional[BasicAuth], /) -> "RemoteRead.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "RemoteRead.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            BasicAuth configuration for the URL.

            Cannot be set at the same time as `authorization`, or `oauth2`.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        def bearer_token(self, value: Optional[str], /) -> Self:
            """
            *Warning: this field shouldn't be used because the token value appears
            in clear-text. Prefer using `authorization`.*

            Deprecated: this will be removed in a future release.
            """
            return self._set("bearer_token", value)

        def bearer_token_file(self, value: Optional[str], /) -> Self:
            """
            File from which to read the bearer token for the URL.

            Deprecated: this will be removed in a future release. Prefer using `authorization`.
            """
            return self._set("bearer_token_file", value)

        def filter_external_labels(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the external labels as selectors for the remote read endpoint.

            It requires Prometheus >= v2.34.0.
            """
            return self._set("filter_external_labels", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            Configure whether HTTP requests follow HTTP 3xx redirects.

            It requires Prometheus >= v2.26.0.
            """
            return self._set("follow_redirects", value)

        def headers(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Custom HTTP headers to be sent along with each remote read request.
            Be aware that headers that are set by Prometheus itself can't be overwritten.
            Only valid in Prometheus versions 2.26.0 and newer.
            """
            return self._set("headers", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the remote read queue, it must be unique if specified. The
            name is used in metrics and logging in order to differentiate read
            configurations.

            It requires Prometheus >= v2.15.0.
            """
            return self._set("name", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        @overload
        def oauth2(self, value_or_callback: Optional[Oauth2], /) -> "RemoteRead.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "RemoteRead.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            OAuth2 configuration for the URL.

            It requires Prometheus >= v2.27.0.

            Cannot be set at the same time as `authorization`, or `basicAuth`.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        def read_recent(self, value: Optional[bool], /) -> Self:
            """
            Whether reads should be made for queries for time ranges that
            the local storage should have complete data for.
            """
            return self._set("read_recent", value)

        def remote_timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout for requests to the remote read endpoint.
            """
            return self._set("remote_timeout", value)

        def required_matchers(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            An optional list of equality matchers which have to be present
            in a selector to query the remote read endpoint.
            """
            return self._set("required_matchers", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel4], /
        ) -> "RemoteRead.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel4.Builder], TlsConfigModel4.Builder | TlsConfigModel4
            ],
            /,
        ) -> "RemoteRead.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel4.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS Config to use for the URL.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel4.builder())
                if isinstance(output, TlsConfigModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

        def url(self, value: str, /) -> Self:
            """
            The URL of the endpoint to query from.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["RemoteRead.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RemoteRead.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RemoteRead."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RemoteRead", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RemoteRead.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authorization: Optional[AuthorizationModel] = None
    """
    Authorization section for the URL.

    It requires Prometheus >= v2.26.0.

    Cannot be set at the same time as `basicAuth`, or `oauth2`.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    BasicAuth configuration for the URL.

    Cannot be set at the same time as `authorization`, or `oauth2`.
    """
    bearer_token: Annotated[Optional[str], Field(alias="bearerToken")] = None
    """
    *Warning: this field shouldn't be used because the token value appears
    in clear-text. Prefer using `authorization`.*

    Deprecated: this will be removed in a future release.
    """
    bearer_token_file: Annotated[Optional[str], Field(alias="bearerTokenFile")] = None
    """
    File from which to read the bearer token for the URL.

    Deprecated: this will be removed in a future release. Prefer using `authorization`.
    """
    filter_external_labels: Annotated[Optional[bool], Field(alias="filterExternalLabels")] = None
    """
    Whether to use the external labels as selectors for the remote read endpoint.

    It requires Prometheus >= v2.34.0.
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    Configure whether HTTP requests follow HTTP 3xx redirects.

    It requires Prometheus >= v2.26.0.
    """
    headers: Optional[Dict[str, str]] = None
    """
    Custom HTTP headers to be sent along with each remote read request.
    Be aware that headers that are set by Prometheus itself can't be overwritten.
    Only valid in Prometheus versions 2.26.0 and newer.
    """
    name: Optional[str] = None
    """
    The name of the remote read queue, it must be unique if specified. The
    name is used in metrics and logging in order to differentiate read
    configurations.

    It requires Prometheus >= v2.15.0.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    oauth2: Optional[Oauth2] = None
    """
    OAuth2 configuration for the URL.

    It requires Prometheus >= v2.27.0.

    Cannot be set at the same time as `authorization`, or `basicAuth`.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    read_recent: Annotated[Optional[bool], Field(alias="readRecent")] = None
    """
    Whether reads should be made for queries for time ranges that
    the local storage should have complete data for.
    """
    remote_timeout: Annotated[
        Optional[str],
        Field(
            alias="remoteTimeout",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Timeout for requests to the remote read endpoint.
    """
    required_matchers: Annotated[Optional[Dict[str, str]], Field(alias="requiredMatchers")] = None
    """
    An optional list of equality matchers which have to be present
    in a selector to query the remote read endpoint.
    """
    tls_config: Annotated[Optional[TlsConfigModel4], Field(alias="tlsConfig")] = None
    """
    TLS Config to use for the URL.
    """
    url: str
    """
    The URL of the endpoint to query from.
    """


class ManagedIdentity(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ManagedIdentity"]:
            return ManagedIdentity

        def build(self) -> "ManagedIdentity":
            return ManagedIdentity(**self._attrs)

        def client_id(self, value: str, /) -> Self:
            """
            The client id
            """
            return self._set("client_id", value)

    class BuilderContext(BuilderContextBase["ManagedIdentity.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ManagedIdentity.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ManagedIdentity."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ManagedIdentity", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ManagedIdentity.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    client_id: Annotated[str, Field(alias="clientId")]
    """
    The client id
    """


class Oauth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Oauth"]:
            return Oauth

        def build(self) -> "Oauth":
            return Oauth(**self._attrs)

        def client_id(self, value: str, /) -> Self:
            """
            `clientID` is the clientId of the Azure Active Directory application that is being used to authenticate.
            """
            return self._set("client_id", value)

        @overload
        def client_secret(self, value_or_callback: ClientSecret, /) -> "Oauth.Builder": ...

        @overload
        def client_secret(
            self,
            value_or_callback: Callable[
                [ClientSecret.Builder], ClientSecret.Builder | ClientSecret
            ],
            /,
        ) -> "Oauth.Builder": ...

        @overload
        def client_secret(
            self, value_or_callback: Never = ...
        ) -> "ClientSecret.BuilderContext": ...

        def client_secret(self, value_or_callback=None, /):
            """
            `clientSecret` specifies a key of a Secret containing the client secret of the Azure Active Directory application that is being used to authenticate.
            """
            if self._in_context and value_or_callback is None:
                context = ClientSecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "client_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClientSecret.builder())
                if isinstance(output, ClientSecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("client_secret", value)

        def tenant_id(self, value: str, /) -> Self:
            """
            `tenantId` is the tenant ID of the Azure Active Directory application that is being used to authenticate.
            """
            return self._set("tenant_id", value)

    class BuilderContext(BuilderContextBase["Oauth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Oauth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Oauth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Oauth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Oauth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    client_id: Annotated[str, Field(alias="clientId", min_length=1)]
    """
    `clientID` is the clientId of the Azure Active Directory application that is being used to authenticate.
    """
    client_secret: Annotated[ClientSecret, Field(alias="clientSecret")]
    """
    `clientSecret` specifies a key of a Secret containing the client secret of the Azure Active Directory application that is being used to authenticate.
    """
    tenant_id: Annotated[str, Field(alias="tenantId", min_length=1, pattern="^[0-9a-zA-Z-.]+$")]
    """
    `tenantId` is the tenant ID of the Azure Active Directory application that is being used to authenticate.
    """


class Sdk(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Sdk"]:
            return Sdk

        def build(self) -> "Sdk":
            return Sdk(**self._attrs)

        def tenant_id(self, value: Optional[str], /) -> Self:
            """
            `tenantId` is the tenant ID of the azure active directory application that is being used to authenticate.
            """
            return self._set("tenant_id", value)

    class BuilderContext(BuilderContextBase["Sdk.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Sdk.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Sdk."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Sdk", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Sdk.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    tenant_id: Annotated[Optional[str], Field(alias="tenantId", pattern="^[0-9a-zA-Z-.]+$")] = None
    """
    `tenantId` is the tenant ID of the azure active directory application that is being used to authenticate.
    """


class AzureAd(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AzureAd"]:
            return AzureAd

        def build(self) -> "AzureAd":
            return AzureAd(**self._attrs)

        def cloud(
            self,
            value: Optional[Literal["AzureChina", "AzureGovernment", "AzurePublic"]],
            /,
        ) -> Self:
            """
            The Azure Cloud. Options are 'AzurePublic', 'AzureChina', or 'AzureGovernment'.
            """
            return self._set("cloud", value)

        @overload
        def managed_identity(
            self, value_or_callback: Optional[ManagedIdentity], /
        ) -> "AzureAd.Builder": ...

        @overload
        def managed_identity(
            self,
            value_or_callback: Callable[
                [ManagedIdentity.Builder], ManagedIdentity.Builder | ManagedIdentity
            ],
            /,
        ) -> "AzureAd.Builder": ...

        @overload
        def managed_identity(
            self, value_or_callback: Never = ...
        ) -> "ManagedIdentity.BuilderContext": ...

        def managed_identity(self, value_or_callback=None, /):
            """
            ManagedIdentity defines the Azure User-assigned Managed identity.
            Cannot be set at the same time as `oauth` or `sdk`.
            """
            if self._in_context and value_or_callback is None:
                context = ManagedIdentity.BuilderContext()
                context._parent_builder = self
                context._field_name = "managed_identity"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ManagedIdentity.builder())
                if isinstance(output, ManagedIdentity.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("managed_identity", value)

        @overload
        def oauth(self, value_or_callback: Optional[Oauth], /) -> "AzureAd.Builder": ...

        @overload
        def oauth(
            self, value_or_callback: Callable[[Oauth.Builder], Oauth.Builder | Oauth], /
        ) -> "AzureAd.Builder": ...

        @overload
        def oauth(self, value_or_callback: Never = ...) -> "Oauth.BuilderContext": ...

        def oauth(self, value_or_callback=None, /):
            """
            OAuth defines the oauth config that is being used to authenticate.
            Cannot be set at the same time as `managedIdentity` or `sdk`.

            It requires Prometheus >= v2.48.0.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth.builder())
                if isinstance(output, Oauth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth", value)

        @overload
        def sdk(self, value_or_callback: Optional[Sdk], /) -> "AzureAd.Builder": ...

        @overload
        def sdk(
            self, value_or_callback: Callable[[Sdk.Builder], Sdk.Builder | Sdk], /
        ) -> "AzureAd.Builder": ...

        @overload
        def sdk(self, value_or_callback: Never = ...) -> "Sdk.BuilderContext": ...

        def sdk(self, value_or_callback=None, /):
            """
            SDK defines the Azure SDK config that is being used to authenticate.
            See https://learn.microsoft.com/en-us/azure/developer/go/azure-sdk-authentication
            Cannot be set at the same time as `oauth` or `managedIdentity`.

            It requires Prometheus >= 2.52.0.
            """
            if self._in_context and value_or_callback is None:
                context = Sdk.BuilderContext()
                context._parent_builder = self
                context._field_name = "sdk"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sdk.builder())
                if isinstance(output, Sdk.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sdk", value)

    class BuilderContext(BuilderContextBase["AzureAd.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AzureAd.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AzureAd."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AzureAd", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AzureAd.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cloud: Optional[Literal["AzureChina", "AzureGovernment", "AzurePublic"]] = None
    """
    The Azure Cloud. Options are 'AzurePublic', 'AzureChina', or 'AzureGovernment'.
    """
    managed_identity: Annotated[Optional[ManagedIdentity], Field(alias="managedIdentity")] = None
    """
    ManagedIdentity defines the Azure User-assigned Managed identity.
    Cannot be set at the same time as `oauth` or `sdk`.
    """
    oauth: Optional[Oauth] = None
    """
    OAuth defines the oauth config that is being used to authenticate.
    Cannot be set at the same time as `managedIdentity` or `sdk`.

    It requires Prometheus >= v2.48.0.
    """
    sdk: Optional[Sdk] = None
    """
    SDK defines the Azure SDK config that is being used to authenticate.
    See https://learn.microsoft.com/en-us/azure/developer/go/azure-sdk-authentication
    Cannot be set at the same time as `oauth` or `managedIdentity`.

    It requires Prometheus >= 2.52.0.
    """


class MetadataConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MetadataConfig"]:
            return MetadataConfig

        def build(self) -> "MetadataConfig":
            return MetadataConfig(**self._attrs)

        def send(self, value: Optional[bool], /) -> Self:
            """
            Defines whether metric metadata is sent to the remote storage or not.
            """
            return self._set("send", value)

        def send_interval(self, value: Optional[str], /) -> Self:
            """
            Defines how frequently metric metadata is sent to the remote storage.
            """
            return self._set("send_interval", value)

    class BuilderContext(BuilderContextBase["MetadataConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MetadataConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MetadataConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MetadataConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MetadataConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    send: Optional[bool] = None
    """
    Defines whether metric metadata is sent to the remote storage or not.
    """
    send_interval: Annotated[
        Optional[str],
        Field(
            alias="sendInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Defines how frequently metric metadata is sent to the remote storage.
    """


class TlsConfigModel5(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsConfigModel5"]:
            return TlsConfigModel5

        def build(self) -> "TlsConfigModel5":
            return TlsConfigModel5(**self._attrs)

        @overload
        def ca(self, value_or_callback: Optional[Ca], /) -> "TlsConfigModel5.Builder": ...

        @overload
        def ca(
            self, value_or_callback: Callable[[Ca.Builder], Ca.Builder | Ca], /
        ) -> "TlsConfigModel5.Builder": ...

        @overload
        def ca(self, value_or_callback: Never = ...) -> "Ca.BuilderContext": ...

        def ca(self, value_or_callback=None, /):
            """
            Certificate authority used when verifying server certificates.
            """
            if self._in_context and value_or_callback is None:
                context = Ca.BuilderContext()
                context._parent_builder = self
                context._field_name = "ca"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ca.builder())
                if isinstance(output, Ca.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ca", value)

        @overload
        def cert(self, value_or_callback: Optional[Cert], /) -> "TlsConfigModel5.Builder": ...

        @overload
        def cert(
            self, value_or_callback: Callable[[Cert.Builder], Cert.Builder | Cert], /
        ) -> "TlsConfigModel5.Builder": ...

        @overload
        def cert(self, value_or_callback: Never = ...) -> "Cert.BuilderContext": ...

        def cert(self, value_or_callback=None, /):
            """
            Client certificate to present when doing client-authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Cert.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cert.builder())
                if isinstance(output, Cert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert", value)

        def insecure_skip_verify(self, value: Optional[bool], /) -> Self:
            """
            Disable target certificate validation.
            """
            return self._set("insecure_skip_verify", value)

        @overload
        def key_secret(
            self, value_or_callback: Optional[KeySecret], /
        ) -> "TlsConfigModel5.Builder": ...

        @overload
        def key_secret(
            self,
            value_or_callback: Callable[[KeySecret.Builder], KeySecret.Builder | KeySecret],
            /,
        ) -> "TlsConfigModel5.Builder": ...

        @overload
        def key_secret(self, value_or_callback: Never = ...) -> "KeySecret.BuilderContext": ...

        def key_secret(self, value_or_callback=None, /):
            """
            Secret containing the client key file for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = KeySecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "key_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KeySecret.builder())
                if isinstance(output, KeySecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("key_secret", value)

        def max_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Maximum acceptable TLS version.

            It requires Prometheus >= v2.41.0.
            """
            return self._set("max_version", value)

        def min_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Minimum acceptable TLS version.

            It requires Prometheus >= v2.35.0.
            """
            return self._set("min_version", value)

        def server_name(self, value: Optional[str], /) -> Self:
            """
            Used to verify the hostname for the targets.
            """
            return self._set("server_name", value)

    class BuilderContext(BuilderContextBase["TlsConfigModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsConfigModel5.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsConfigModel5."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsConfigModel5", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsConfigModel5.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca: Optional[Ca] = None
    """
    Certificate authority used when verifying server certificates.
    """
    cert: Optional[Cert] = None
    """
    Client certificate to present when doing client-authentication.
    """
    insecure_skip_verify: Annotated[Optional[bool], Field(alias="insecureSkipVerify")] = None
    """
    Disable target certificate validation.
    """
    key_secret: Annotated[Optional[KeySecret], Field(alias="keySecret")] = None
    """
    Secret containing the client key file for the targets.
    """
    max_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="maxVersion")
    ] = None
    """
    Maximum acceptable TLS version.

    It requires Prometheus >= v2.41.0.
    """
    min_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="minVersion")
    ] = None
    """
    Minimum acceptable TLS version.

    It requires Prometheus >= v2.35.0.
    """
    server_name: Annotated[Optional[str], Field(alias="serverName")] = None
    """
    Used to verify the hostname for the targets.
    """


class QueueConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["QueueConfig"]:
            return QueueConfig

        def build(self) -> "QueueConfig":
            return QueueConfig(**self._attrs)

        def batch_send_deadline(self, value: Optional[str], /) -> Self:
            """
            BatchSendDeadline is the maximum time a sample will wait in buffer.
            """
            return self._set("batch_send_deadline", value)

        def capacity(self, value: Optional[int], /) -> Self:
            """
            Capacity is the number of samples to buffer per shard before we start
            dropping them.
            """
            return self._set("capacity", value)

        def max_backoff(self, value: Optional[str], /) -> Self:
            """
            MaxBackoff is the maximum retry delay.
            """
            return self._set("max_backoff", value)

        def max_retries(self, value: Optional[int], /) -> Self:
            """
            MaxRetries is the maximum number of times to retry a batch on recoverable errors.
            """
            return self._set("max_retries", value)

        def max_samples_per_send(self, value: Optional[int], /) -> Self:
            """
            MaxSamplesPerSend is the maximum number of samples per send.
            """
            return self._set("max_samples_per_send", value)

        def max_shards(self, value: Optional[int], /) -> Self:
            """
            MaxShards is the maximum number of shards, i.e. amount of concurrency.
            """
            return self._set("max_shards", value)

        def min_backoff(self, value: Optional[str], /) -> Self:
            """
            MinBackoff is the initial retry delay. Gets doubled for every retry.
            """
            return self._set("min_backoff", value)

        def min_shards(self, value: Optional[int], /) -> Self:
            """
            MinShards is the minimum number of shards, i.e. amount of concurrency.
            """
            return self._set("min_shards", value)

        def retry_on_rate_limit(self, value: Optional[bool], /) -> Self:
            """
            Retry upon receiving a 429 status code from the remote-write storage.

            This is an *experimental feature*, it may change in any upcoming release
            in a breaking way.
            """
            return self._set("retry_on_rate_limit", value)

        def sample_age_limit(self, value: Optional[str], /) -> Self:
            """
            SampleAgeLimit drops samples older than the limit.
            It requires Prometheus >= v2.50.0.
            """
            return self._set("sample_age_limit", value)

    class BuilderContext(BuilderContextBase["QueueConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = QueueConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for QueueConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["QueueConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use QueueConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    batch_send_deadline: Annotated[
        Optional[str],
        Field(
            alias="batchSendDeadline",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    BatchSendDeadline is the maximum time a sample will wait in buffer.
    """
    capacity: Optional[int] = None
    """
    Capacity is the number of samples to buffer per shard before we start
    dropping them.
    """
    max_backoff: Annotated[
        Optional[str],
        Field(
            alias="maxBackoff",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    MaxBackoff is the maximum retry delay.
    """
    max_retries: Annotated[Optional[int], Field(alias="maxRetries")] = None
    """
    MaxRetries is the maximum number of times to retry a batch on recoverable errors.
    """
    max_samples_per_send: Annotated[Optional[int], Field(alias="maxSamplesPerSend")] = None
    """
    MaxSamplesPerSend is the maximum number of samples per send.
    """
    max_shards: Annotated[Optional[int], Field(alias="maxShards")] = None
    """
    MaxShards is the maximum number of shards, i.e. amount of concurrency.
    """
    min_backoff: Annotated[
        Optional[str],
        Field(
            alias="minBackoff",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    MinBackoff is the initial retry delay. Gets doubled for every retry.
    """
    min_shards: Annotated[Optional[int], Field(alias="minShards")] = None
    """
    MinShards is the minimum number of shards, i.e. amount of concurrency.
    """
    retry_on_rate_limit: Annotated[Optional[bool], Field(alias="retryOnRateLimit")] = None
    """
    Retry upon receiving a 429 status code from the remote-write storage.

    This is an *experimental feature*, it may change in any upcoming release
    in a breaking way.
    """
    sample_age_limit: Annotated[
        Optional[str],
        Field(
            alias="sampleAgeLimit",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    SampleAgeLimit drops samples older than the limit.
    It requires Prometheus >= v2.50.0.
    """


class TlsConfigModel6(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsConfigModel6"]:
            return TlsConfigModel6

        def build(self) -> "TlsConfigModel6":
            return TlsConfigModel6(**self._attrs)

        @overload
        def ca(self, value_or_callback: Optional[Ca], /) -> "TlsConfigModel6.Builder": ...

        @overload
        def ca(
            self, value_or_callback: Callable[[Ca.Builder], Ca.Builder | Ca], /
        ) -> "TlsConfigModel6.Builder": ...

        @overload
        def ca(self, value_or_callback: Never = ...) -> "Ca.BuilderContext": ...

        def ca(self, value_or_callback=None, /):
            """
            Certificate authority used when verifying server certificates.
            """
            if self._in_context and value_or_callback is None:
                context = Ca.BuilderContext()
                context._parent_builder = self
                context._field_name = "ca"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ca.builder())
                if isinstance(output, Ca.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ca", value)

        def ca_file(self, value: Optional[str], /) -> Self:
            """
            Path to the CA cert in the Prometheus container to use for the targets.
            """
            return self._set("ca_file", value)

        @overload
        def cert(self, value_or_callback: Optional[Cert], /) -> "TlsConfigModel6.Builder": ...

        @overload
        def cert(
            self, value_or_callback: Callable[[Cert.Builder], Cert.Builder | Cert], /
        ) -> "TlsConfigModel6.Builder": ...

        @overload
        def cert(self, value_or_callback: Never = ...) -> "Cert.BuilderContext": ...

        def cert(self, value_or_callback=None, /):
            """
            Client certificate to present when doing client-authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Cert.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cert.builder())
                if isinstance(output, Cert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert", value)

        def cert_file(self, value: Optional[str], /) -> Self:
            """
            Path to the client cert file in the Prometheus container for the targets.
            """
            return self._set("cert_file", value)

        def insecure_skip_verify(self, value: Optional[bool], /) -> Self:
            """
            Disable target certificate validation.
            """
            return self._set("insecure_skip_verify", value)

        def key_file(self, value: Optional[str], /) -> Self:
            """
            Path to the client key file in the Prometheus container for the targets.
            """
            return self._set("key_file", value)

        @overload
        def key_secret(
            self, value_or_callback: Optional[KeySecret], /
        ) -> "TlsConfigModel6.Builder": ...

        @overload
        def key_secret(
            self,
            value_or_callback: Callable[[KeySecret.Builder], KeySecret.Builder | KeySecret],
            /,
        ) -> "TlsConfigModel6.Builder": ...

        @overload
        def key_secret(self, value_or_callback: Never = ...) -> "KeySecret.BuilderContext": ...

        def key_secret(self, value_or_callback=None, /):
            """
            Secret containing the client key file for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = KeySecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "key_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KeySecret.builder())
                if isinstance(output, KeySecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("key_secret", value)

        def max_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Maximum acceptable TLS version.

            It requires Prometheus >= v2.41.0.
            """
            return self._set("max_version", value)

        def min_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Minimum acceptable TLS version.

            It requires Prometheus >= v2.35.0.
            """
            return self._set("min_version", value)

        def server_name(self, value: Optional[str], /) -> Self:
            """
            Used to verify the hostname for the targets.
            """
            return self._set("server_name", value)

    class BuilderContext(BuilderContextBase["TlsConfigModel6.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsConfigModel6.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsConfigModel6."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsConfigModel6", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsConfigModel6.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca: Optional[Ca] = None
    """
    Certificate authority used when verifying server certificates.
    """
    ca_file: Annotated[Optional[str], Field(alias="caFile")] = None
    """
    Path to the CA cert in the Prometheus container to use for the targets.
    """
    cert: Optional[Cert] = None
    """
    Client certificate to present when doing client-authentication.
    """
    cert_file: Annotated[Optional[str], Field(alias="certFile")] = None
    """
    Path to the client cert file in the Prometheus container for the targets.
    """
    insecure_skip_verify: Annotated[Optional[bool], Field(alias="insecureSkipVerify")] = None
    """
    Disable target certificate validation.
    """
    key_file: Annotated[Optional[str], Field(alias="keyFile")] = None
    """
    Path to the client key file in the Prometheus container for the targets.
    """
    key_secret: Annotated[Optional[KeySecret], Field(alias="keySecret")] = None
    """
    Secret containing the client key file for the targets.
    """
    max_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="maxVersion")
    ] = None
    """
    Maximum acceptable TLS version.

    It requires Prometheus >= v2.41.0.
    """
    min_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="minVersion")
    ] = None
    """
    Minimum acceptable TLS version.

    It requires Prometheus >= v2.35.0.
    """
    server_name: Annotated[Optional[str], Field(alias="serverName")] = None
    """
    Used to verify the hostname for the targets.
    """


class WriteRelabelConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WriteRelabelConfig"]:
            return WriteRelabelConfig

        def build(self) -> "WriteRelabelConfig":
            return WriteRelabelConfig(**self._attrs)

        def action(
            self,
            value: Optional[
                Literal[
                    "replace",
                    "Replace",
                    "keep",
                    "Keep",
                    "drop",
                    "Drop",
                    "hashmod",
                    "HashMod",
                    "labelmap",
                    "LabelMap",
                    "labeldrop",
                    "LabelDrop",
                    "labelkeep",
                    "LabelKeep",
                    "lowercase",
                    "Lowercase",
                    "uppercase",
                    "Uppercase",
                    "keepequal",
                    "KeepEqual",
                    "dropequal",
                    "DropEqual",
                ]
            ],
            /,
        ) -> Self:
            """
            Action to perform based on the regex matching.

            `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
            `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.

            Default: "Replace"
            """
            return self._set("action", value)

        def modulus(self, value: Optional[int], /) -> Self:
            """
            Modulus to take of the hash of the source label values.

            Only applicable when the action is `HashMod`.
            """
            return self._set("modulus", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            Regular expression against which the extracted value is matched.
            """
            return self._set("regex", value)

        def replacement(self, value: Optional[str], /) -> Self:
            """
            Replacement value against which a Replace action is performed if the
            regular expression matches.

            Regex capture groups are available.
            """
            return self._set("replacement", value)

        def separator(self, value: Optional[str], /) -> Self:
            """
            Separator is the string between concatenated SourceLabels.
            """
            return self._set("separator", value)

        @overload
        def source_labels(
            self, value_or_callback: List[SourceLabel], /
        ) -> "WriteRelabelConfig.Builder": ...

        @overload
        def source_labels(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[SourceLabel, SourceLabel.Builder]],
                GenericListBuilder[SourceLabel, SourceLabel.Builder] | List[SourceLabel],
            ],
            /,
        ) -> "WriteRelabelConfig.Builder": ...

        @overload
        def source_labels(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[SourceLabel.Builder]: ...

        def source_labels(self, value_or_callback=None, /):
            """
            The source labels select values from existing labels. Their content is
            concatenated using the configured Separator and matched against the
            configured regular expression.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[SourceLabel.Builder]()
                context._parent_builder = self
                context._field_name = "source_labels"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SourceLabel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("source_labels", value)

        def target_label(self, value: Optional[str], /) -> Self:
            """
            Label to which the resulting string is written in a replacement.

            It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
            `KeepEqual` and `DropEqual` actions.

            Regex capture groups are available.
            """
            return self._set("target_label", value)

    class BuilderContext(BuilderContextBase["WriteRelabelConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WriteRelabelConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WriteRelabelConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WriteRelabelConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WriteRelabelConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    action: Optional[
        Literal[
            "replace",
            "Replace",
            "keep",
            "Keep",
            "drop",
            "Drop",
            "hashmod",
            "HashMod",
            "labelmap",
            "LabelMap",
            "labeldrop",
            "LabelDrop",
            "labelkeep",
            "LabelKeep",
            "lowercase",
            "Lowercase",
            "uppercase",
            "Uppercase",
            "keepequal",
            "KeepEqual",
            "dropequal",
            "DropEqual",
        ]
    ] = "replace"
    """
    Action to perform based on the regex matching.

    `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
    `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.

    Default: "Replace"
    """
    modulus: Optional[int] = None
    """
    Modulus to take of the hash of the source label values.

    Only applicable when the action is `HashMod`.
    """
    regex: Optional[str] = None
    """
    Regular expression against which the extracted value is matched.
    """
    replacement: Optional[str] = None
    """
    Replacement value against which a Replace action is performed if the
    regular expression matches.

    Regex capture groups are available.
    """
    separator: Optional[str] = None
    """
    Separator is the string between concatenated SourceLabels.
    """
    source_labels: Annotated[Optional[List[SourceLabel]], Field(alias="sourceLabels")] = None
    """
    The source labels select values from existing labels. Their content is
    concatenated using the configured Separator and matched against the
    configured regular expression.
    """
    target_label: Annotated[Optional[str], Field(alias="targetLabel")] = None
    """
    Label to which the resulting string is written in a replacement.

    It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
    `KeepEqual` and `DropEqual` actions.

    Regex capture groups are available.
    """


class RemoteWrite(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RemoteWrite"]:
            return RemoteWrite

        def build(self) -> "RemoteWrite":
            return RemoteWrite(**self._attrs)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel], /
        ) -> "RemoteWrite.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel.Builder],
                AuthorizationModel.Builder | AuthorizationModel,
            ],
            /,
        ) -> "RemoteWrite.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization section for the URL.

            It requires Prometheus >= v2.26.0.

            Cannot be set at the same time as `sigv4`, `basicAuth`, `oauth2`, or `azureAd`.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel.builder())
                if isinstance(output, AuthorizationModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def azure_ad(self, value_or_callback: Optional[AzureAd], /) -> "RemoteWrite.Builder": ...

        @overload
        def azure_ad(
            self,
            value_or_callback: Callable[[AzureAd.Builder], AzureAd.Builder | AzureAd],
            /,
        ) -> "RemoteWrite.Builder": ...

        @overload
        def azure_ad(self, value_or_callback: Never = ...) -> "AzureAd.BuilderContext": ...

        def azure_ad(self, value_or_callback=None, /):
            """
            AzureAD for the URL.

            It requires Prometheus >= v2.45.0.

            Cannot be set at the same time as `authorization`, `basicAuth`, `oauth2`, or `sigv4`.
            """
            if self._in_context and value_or_callback is None:
                context = AzureAd.BuilderContext()
                context._parent_builder = self
                context._field_name = "azure_ad"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AzureAd.builder())
                if isinstance(output, AzureAd.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("azure_ad", value)

        @overload
        def basic_auth(
            self, value_or_callback: Optional[BasicAuth], /
        ) -> "RemoteWrite.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "RemoteWrite.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            BasicAuth configuration for the URL.

            Cannot be set at the same time as `sigv4`, `authorization`, `oauth2`, or `azureAd`.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        def bearer_token(self, value: Optional[str], /) -> Self:
            """
            *Warning: this field shouldn't be used because the token value appears
            in clear-text. Prefer using `authorization`.*

            Deprecated: this will be removed in a future release.
            """
            return self._set("bearer_token", value)

        def bearer_token_file(self, value: Optional[str], /) -> Self:
            """
            File from which to read bearer token for the URL.

            Deprecated: this will be removed in a future release. Prefer using `authorization`.
            """
            return self._set("bearer_token_file", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            Whether to enable HTTP2.
            """
            return self._set("enable_http2", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            Configure whether HTTP requests follow HTTP 3xx redirects.

            It requires Prometheus >= v2.26.0.
            """
            return self._set("follow_redirects", value)

        def headers(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Custom HTTP headers to be sent along with each remote write request.
            Be aware that headers that are set by Prometheus itself can't be overwritten.

            It requires Prometheus >= v2.25.0.
            """
            return self._set("headers", value)

        def message_version(self, value: Optional[Literal["V1.0", "V2.0"]], /) -> Self:
            """
            The Remote Write message's version to use when writing to the endpoint.

            `Version1.0` corresponds to the `prometheus.WriteRequest` protobuf message introduced in Remote Write 1.0.
            `Version2.0` corresponds to the `io.prometheus.write.v2.Request` protobuf message introduced in Remote Write 2.0.

            When `Version2.0` is selected, Prometheus will automatically be
            configured to append the metadata of scraped metrics to the WAL.

            Before setting this field, consult with your remote storage provider
            what message version it supports.

            It requires Prometheus >= v2.54.0.
            """
            return self._set("message_version", value)

        @overload
        def metadata_config(
            self, value_or_callback: Optional[MetadataConfig], /
        ) -> "RemoteWrite.Builder": ...

        @overload
        def metadata_config(
            self,
            value_or_callback: Callable[
                [MetadataConfig.Builder], MetadataConfig.Builder | MetadataConfig
            ],
            /,
        ) -> "RemoteWrite.Builder": ...

        @overload
        def metadata_config(
            self, value_or_callback: Never = ...
        ) -> "MetadataConfig.BuilderContext": ...

        def metadata_config(self, value_or_callback=None, /):
            """
            MetadataConfig configures the sending of series metadata to the remote storage.
            """
            if self._in_context and value_or_callback is None:
                context = MetadataConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MetadataConfig.builder())
                if isinstance(output, MetadataConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata_config", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the remote write queue, it must be unique if specified. The
            name is used in metrics and logging in order to differentiate queues.

            It requires Prometheus >= v2.15.0.
            """
            return self._set("name", value)

        def no_proxy(self, value: Optional[str], /) -> Self:
            """
            `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
            that should be excluded from proxying. IP and domain names can
            contain port numbers.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("no_proxy", value)

        @overload
        def oauth2(self, value_or_callback: Optional[Oauth2], /) -> "RemoteWrite.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "RemoteWrite.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            OAuth2 configuration for the URL.

            It requires Prometheus >= v2.27.0.

            Cannot be set at the same time as `sigv4`, `authorization`, `basicAuth`, or `azureAd`.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        def proxy_connect_header(
            self, value: Optional[Dict[str, List[ProxyConnectHeader]]], /
        ) -> Self:
            """
            ProxyConnectHeader optionally specifies headers to send to
            proxies during CONNECT requests.

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_connect_header", value)

        def proxy_from_environment(self, value: Optional[bool], /) -> Self:
            """
            Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

            It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
            """
            return self._set("proxy_from_environment", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` defines the HTTP proxy server to use.
            """
            return self._set("proxy_url", value)

        @overload
        def queue_config(
            self, value_or_callback: Optional[QueueConfig], /
        ) -> "RemoteWrite.Builder": ...

        @overload
        def queue_config(
            self,
            value_or_callback: Callable[[QueueConfig.Builder], QueueConfig.Builder | QueueConfig],
            /,
        ) -> "RemoteWrite.Builder": ...

        @overload
        def queue_config(self, value_or_callback: Never = ...) -> "QueueConfig.BuilderContext": ...

        def queue_config(self, value_or_callback=None, /):
            """
            QueueConfig allows tuning of the remote write queue parameters.
            """
            if self._in_context and value_or_callback is None:
                context = QueueConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "queue_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(QueueConfig.builder())
                if isinstance(output, QueueConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("queue_config", value)

        def remote_timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout for requests to the remote write endpoint.
            """
            return self._set("remote_timeout", value)

        def send_exemplars(self, value: Optional[bool], /) -> Self:
            """
            Enables sending of exemplars over remote write. Note that
            exemplar-storage itself must be enabled using the `spec.enableFeatures`
            option for exemplars to be scraped in the first place.

            It requires Prometheus >= v2.27.0.
            """
            return self._set("send_exemplars", value)

        def send_native_histograms(self, value: Optional[bool], /) -> Self:
            """
            Enables sending of native histograms, also known as sparse histograms
            over remote write.

            It requires Prometheus >= v2.40.0.
            """
            return self._set("send_native_histograms", value)

        @overload
        def sigv4(self, value_or_callback: Optional[Sigv4], /) -> "RemoteWrite.Builder": ...

        @overload
        def sigv4(
            self, value_or_callback: Callable[[Sigv4.Builder], Sigv4.Builder | Sigv4], /
        ) -> "RemoteWrite.Builder": ...

        @overload
        def sigv4(self, value_or_callback: Never = ...) -> "Sigv4.BuilderContext": ...

        def sigv4(self, value_or_callback=None, /):
            """
            Sigv4 allows to configures AWS's Signature Verification 4 for the URL.

            It requires Prometheus >= v2.26.0.

            Cannot be set at the same time as `authorization`, `basicAuth`, `oauth2`, or `azureAd`.
            """
            if self._in_context and value_or_callback is None:
                context = Sigv4.BuilderContext()
                context._parent_builder = self
                context._field_name = "sigv4"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sigv4.builder())
                if isinstance(output, Sigv4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sigv4", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel6], /
        ) -> "RemoteWrite.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel6.Builder], TlsConfigModel6.Builder | TlsConfigModel6
            ],
            /,
        ) -> "RemoteWrite.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel6.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS Config to use for the URL.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel6.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel6.builder())
                if isinstance(output, TlsConfigModel6.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

        def url(self, value: str, /) -> Self:
            """
            The URL of the endpoint to send samples to.
            """
            return self._set("url", value)

        @overload
        def write_relabel_configs(
            self, value_or_callback: List[WriteRelabelConfig], /
        ) -> "RemoteWrite.Builder": ...

        @overload
        def write_relabel_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[WriteRelabelConfig, WriteRelabelConfig.Builder]],
                GenericListBuilder[WriteRelabelConfig, WriteRelabelConfig.Builder]
                | List[WriteRelabelConfig],
            ],
            /,
        ) -> "RemoteWrite.Builder": ...

        @overload
        def write_relabel_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[WriteRelabelConfig.Builder]: ...

        def write_relabel_configs(self, value_or_callback=None, /):
            """
            The list of remote write relabel configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[WriteRelabelConfig.Builder]()
                context._parent_builder = self
                context._field_name = "write_relabel_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WriteRelabelConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("write_relabel_configs", value)

    class BuilderContext(BuilderContextBase["RemoteWrite.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RemoteWrite.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RemoteWrite."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RemoteWrite", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RemoteWrite.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authorization: Optional[AuthorizationModel] = None
    """
    Authorization section for the URL.

    It requires Prometheus >= v2.26.0.

    Cannot be set at the same time as `sigv4`, `basicAuth`, `oauth2`, or `azureAd`.
    """
    azure_ad: Annotated[Optional[AzureAd], Field(alias="azureAd")] = None
    """
    AzureAD for the URL.

    It requires Prometheus >= v2.45.0.

    Cannot be set at the same time as `authorization`, `basicAuth`, `oauth2`, or `sigv4`.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    BasicAuth configuration for the URL.

    Cannot be set at the same time as `sigv4`, `authorization`, `oauth2`, or `azureAd`.
    """
    bearer_token: Annotated[Optional[str], Field(alias="bearerToken")] = None
    """
    *Warning: this field shouldn't be used because the token value appears
    in clear-text. Prefer using `authorization`.*

    Deprecated: this will be removed in a future release.
    """
    bearer_token_file: Annotated[Optional[str], Field(alias="bearerTokenFile")] = None
    """
    File from which to read bearer token for the URL.

    Deprecated: this will be removed in a future release. Prefer using `authorization`.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHTTP2")] = None
    """
    Whether to enable HTTP2.
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    Configure whether HTTP requests follow HTTP 3xx redirects.

    It requires Prometheus >= v2.26.0.
    """
    headers: Optional[Dict[str, str]] = None
    """
    Custom HTTP headers to be sent along with each remote write request.
    Be aware that headers that are set by Prometheus itself can't be overwritten.

    It requires Prometheus >= v2.25.0.
    """
    message_version: Annotated[Optional[Literal["V1.0", "V2.0"]], Field(alias="messageVersion")] = (
        None
    )
    """
    The Remote Write message's version to use when writing to the endpoint.

    `Version1.0` corresponds to the `prometheus.WriteRequest` protobuf message introduced in Remote Write 1.0.
    `Version2.0` corresponds to the `io.prometheus.write.v2.Request` protobuf message introduced in Remote Write 2.0.

    When `Version2.0` is selected, Prometheus will automatically be
    configured to append the metadata of scraped metrics to the WAL.

    Before setting this field, consult with your remote storage provider
    what message version it supports.

    It requires Prometheus >= v2.54.0.
    """
    metadata_config: Annotated[Optional[MetadataConfig], Field(alias="metadataConfig")] = None
    """
    MetadataConfig configures the sending of series metadata to the remote storage.
    """
    name: Optional[str] = None
    """
    The name of the remote write queue, it must be unique if specified. The
    name is used in metrics and logging in order to differentiate queues.

    It requires Prometheus >= v2.15.0.
    """
    no_proxy: Annotated[Optional[str], Field(alias="noProxy")] = None
    """
    `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names
    that should be excluded from proxying. IP and domain names can
    contain port numbers.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    oauth2: Optional[Oauth2] = None
    """
    OAuth2 configuration for the URL.

    It requires Prometheus >= v2.27.0.

    Cannot be set at the same time as `sigv4`, `authorization`, `basicAuth`, or `azureAd`.
    """
    proxy_connect_header: Annotated[
        Optional[Dict[str, List[ProxyConnectHeader]]], Field(alias="proxyConnectHeader")
    ] = None
    """
    ProxyConnectHeader optionally specifies headers to send to
    proxies during CONNECT requests.

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_from_environment: Annotated[Optional[bool], Field(alias="proxyFromEnvironment")] = None
    """
    Whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).

    It requires Prometheus >= v2.43.0 or Alertmanager >= 0.25.0.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl", pattern="^http(s)?://.+$")] = None
    """
    `proxyURL` defines the HTTP proxy server to use.
    """
    queue_config: Annotated[Optional[QueueConfig], Field(alias="queueConfig")] = None
    """
    QueueConfig allows tuning of the remote write queue parameters.
    """
    remote_timeout: Annotated[
        Optional[str],
        Field(
            alias="remoteTimeout",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Timeout for requests to the remote write endpoint.
    """
    send_exemplars: Annotated[Optional[bool], Field(alias="sendExemplars")] = None
    """
    Enables sending of exemplars over remote write. Note that
    exemplar-storage itself must be enabled using the `spec.enableFeatures`
    option for exemplars to be scraped in the first place.

    It requires Prometheus >= v2.27.0.
    """
    send_native_histograms: Annotated[Optional[bool], Field(alias="sendNativeHistograms")] = None
    """
    Enables sending of native histograms, also known as sparse histograms
    over remote write.

    It requires Prometheus >= v2.40.0.
    """
    sigv4: Optional[Sigv4] = None
    """
    Sigv4 allows to configures AWS's Signature Verification 4 for the URL.

    It requires Prometheus >= v2.26.0.

    Cannot be set at the same time as `authorization`, `basicAuth`, `oauth2`, or `azureAd`.
    """
    tls_config: Annotated[Optional[TlsConfigModel6], Field(alias="tlsConfig")] = None
    """
    TLS Config to use for the URL.
    """
    url: Annotated[str, Field(min_length=1)]
    """
    The URL of the endpoint to send samples to.
    """
    write_relabel_configs: Annotated[
        Optional[List[WriteRelabelConfig]], Field(alias="writeRelabelConfigs")
    ] = None
    """
    The list of remote write relabel configurations.
    """


class LimitsModel15(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel15":
            value = cast(int, self._value)
            return LimitsModel15(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel15.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel15.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel15."""
        return cls.BuilderContext()


class LimitsModel16(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel16":
            value = cast(str, self._value)
            return LimitsModel16(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel16.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel16.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel16."""
        return cls.BuilderContext()


class RequestsModel15(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel15":
            value = cast(int, self._value)
            return RequestsModel15(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel15.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel15.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel15."""
        return cls.BuilderContext()


class RequestsModel16(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel16":
            value = cast(str, self._value)
            return RequestsModel16(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel16.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel16.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel16."""
        return cls.BuilderContext()


class RuleNamespaceSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RuleNamespaceSelector"]:
            return RuleNamespaceSelector

        def build(self) -> "RuleNamespaceSelector":
            return RuleNamespaceSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel2], /
        ) -> "RuleNamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel2, MatchExpressionModel2.Builder]],
                GenericListBuilder[MatchExpressionModel2, MatchExpressionModel2.Builder]
                | List[MatchExpressionModel2],
            ],
            /,
        ) -> "RuleNamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel2.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel2.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel2.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["RuleNamespaceSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RuleNamespaceSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RuleNamespaceSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RuleNamespaceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RuleNamespaceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel2]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class RuleSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RuleSelector"]:
            return RuleSelector

        def build(self) -> "RuleSelector":
            return RuleSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel2], /
        ) -> "RuleSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel2, MatchExpressionModel2.Builder]],
                GenericListBuilder[MatchExpressionModel2, MatchExpressionModel2.Builder]
                | List[MatchExpressionModel2],
            ],
            /,
        ) -> "RuleSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel2.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel2.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel2.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["RuleSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RuleSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RuleSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RuleSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RuleSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel2]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class Alert(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Alert"]:
            return Alert

        def build(self) -> "Alert":
            return Alert(**self._attrs)

        def for_grace_period(self, value: Optional[str], /) -> Self:
            """
            Minimum duration between alert and restored 'for' state.

            This is maintained only for alerts with a configured 'for' time greater
            than the grace period.
            """
            return self._set("for_grace_period", value)

        def for_outage_tolerance(self, value: Optional[str], /) -> Self:
            """
            Max time to tolerate prometheus outage for restoring 'for' state of
            alert.
            """
            return self._set("for_outage_tolerance", value)

        def resend_delay(self, value: Optional[str], /) -> Self:
            """
            Minimum amount of time to wait before resending an alert to
            Alertmanager.
            """
            return self._set("resend_delay", value)

    class BuilderContext(BuilderContextBase["Alert.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Alert.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Alert."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Alert", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Alert.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    for_grace_period: Annotated[Optional[str], Field(alias="forGracePeriod")] = None
    """
    Minimum duration between alert and restored 'for' state.

    This is maintained only for alerts with a configured 'for' time greater
    than the grace period.
    """
    for_outage_tolerance: Annotated[Optional[str], Field(alias="forOutageTolerance")] = None
    """
    Max time to tolerate prometheus outage for restoring 'for' state of
    alert.
    """
    resend_delay: Annotated[Optional[str], Field(alias="resendDelay")] = None
    """
    Minimum amount of time to wait before resending an alert to
    Alertmanager.
    """


class Rules(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Rules"]:
            return Rules

        def build(self) -> "Rules":
            return Rules(**self._attrs)

        @overload
        def alert(self, value_or_callback: Optional[Alert], /) -> "Rules.Builder": ...

        @overload
        def alert(
            self, value_or_callback: Callable[[Alert.Builder], Alert.Builder | Alert], /
        ) -> "Rules.Builder": ...

        @overload
        def alert(self, value_or_callback: Never = ...) -> "Alert.BuilderContext": ...

        def alert(self, value_or_callback=None, /):
            """
            Defines the parameters of the Prometheus rules' engine.

            Any update to these parameters trigger a restart of the pods.
            """
            if self._in_context and value_or_callback is None:
                context = Alert.BuilderContext()
                context._parent_builder = self
                context._field_name = "alert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Alert.builder())
                if isinstance(output, Alert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("alert", value)

    class BuilderContext(BuilderContextBase["Rules.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Rules.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Rules."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Rules", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Rules.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    alert: Optional[Alert] = None
    """
    Defines the parameters of the Prometheus rules' engine.

    Any update to these parameters trigger a restart of the pods.
    """


class Runtime(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Runtime"]:
            return Runtime

        def build(self) -> "Runtime":
            return Runtime(**self._attrs)

        def go_gc(self, value: Optional[int], /) -> Self:
            """
            The Go garbage collection target percentage. Lowering this number may increase the CPU usage.
            See: https://tip.golang.org/doc/gc-guide#GOGC
            """
            return self._set("go_gc", value)

    class BuilderContext(BuilderContextBase["Runtime.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Runtime.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Runtime."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Runtime", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Runtime.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    go_gc: Annotated[Optional[int], Field(alias="goGC", ge=-1)] = None
    """
    The Go garbage collection target percentage. Lowering this number may increase the CPU usage.
    See: https://tip.golang.org/doc/gc-guide#GOGC
    """


class ScrapeClass(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ScrapeClass"]:
            return ScrapeClass

        def build(self) -> "ScrapeClass":
            return ScrapeClass(**self._attrs)

        @overload
        def attach_metadata(
            self, value_or_callback: Optional[AttachMetadata], /
        ) -> "ScrapeClass.Builder": ...

        @overload
        def attach_metadata(
            self,
            value_or_callback: Callable[
                [AttachMetadata.Builder], AttachMetadata.Builder | AttachMetadata
            ],
            /,
        ) -> "ScrapeClass.Builder": ...

        @overload
        def attach_metadata(
            self, value_or_callback: Never = ...
        ) -> "AttachMetadata.BuilderContext": ...

        def attach_metadata(self, value_or_callback=None, /):
            """
            AttachMetadata configures additional metadata to the discovered targets.
            When the scrape object defines its own configuration, it takes
            precedence over the scrape class configuration.
            """
            if self._in_context and value_or_callback is None:
                context = AttachMetadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "attach_metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AttachMetadata.builder())
                if isinstance(output, AttachMetadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("attach_metadata", value)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel], /
        ) -> "ScrapeClass.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel.Builder],
                AuthorizationModel.Builder | AuthorizationModel,
            ],
            /,
        ) -> "ScrapeClass.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            Authorization section for the ScrapeClass.
            It will only apply if the scrape resource doesn't specify any Authorization.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel.builder())
                if isinstance(output, AuthorizationModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        def default(self, value: Optional[bool], /) -> Self:
            """
            Default indicates that the scrape applies to all scrape objects that
            don't configure an explicit scrape class name.

            Only one scrape class can be set as the default.
            """
            return self._set("default", value)

        def fallback_scrape_protocol(
            self,
            value: Optional[
                Literal[
                    "PrometheusProto",
                    "OpenMetricsText0.0.1",
                    "OpenMetricsText1.0.0",
                    "PrometheusText0.0.4",
                    "PrometheusText1.0.0",
                ]
            ],
            /,
        ) -> Self:
            """
            The protocol to use if a scrape returns blank, unparseable, or otherwise invalid Content-Type.
            It will only apply if the scrape resource doesn't specify any FallbackScrapeProtocol

            It requires Prometheus >= v3.0.0.
            """
            return self._set("fallback_scrape_protocol", value)

        @overload
        def metric_relabelings(
            self, value_or_callback: List[MetricRelabeling], /
        ) -> "ScrapeClass.Builder": ...

        @overload
        def metric_relabelings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MetricRelabeling, MetricRelabeling.Builder]],
                GenericListBuilder[MetricRelabeling, MetricRelabeling.Builder]
                | List[MetricRelabeling],
            ],
            /,
        ) -> "ScrapeClass.Builder": ...

        @overload
        def metric_relabelings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MetricRelabeling.Builder]: ...

        def metric_relabelings(self, value_or_callback=None, /):
            """
            MetricRelabelings configures the relabeling rules to apply to all samples before ingestion.

            The Operator adds the scrape class metric relabelings defined here.
            Then the Operator adds the target-specific metric relabelings defined in ServiceMonitors, PodMonitors, Probes and ScrapeConfigs.
            Then the Operator adds namespace enforcement relabeling rule, specified in '.spec.enforcedNamespaceLabel'.

            More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MetricRelabeling.Builder]()
                context._parent_builder = self
                context._field_name = "metric_relabelings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MetricRelabeling.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("metric_relabelings", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the scrape class.
            """
            return self._set("name", value)

        @overload
        def relabelings(self, value_or_callback: List[Relabeling], /) -> "ScrapeClass.Builder": ...

        @overload
        def relabelings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Relabeling, Relabeling.Builder]],
                GenericListBuilder[Relabeling, Relabeling.Builder] | List[Relabeling],
            ],
            /,
        ) -> "ScrapeClass.Builder": ...

        @overload
        def relabelings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Relabeling.Builder]: ...

        def relabelings(self, value_or_callback=None, /):
            """
            Relabelings configures the relabeling rules to apply to all scrape targets.

            The Operator automatically adds relabelings for a few standard Kubernetes fields
            like `__meta_kubernetes_namespace` and `__meta_kubernetes_service_name`.
            Then the Operator adds the scrape class relabelings defined here.
            Then the Operator adds the target-specific relabelings defined in the scrape object.

            More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Relabeling.Builder]()
                context._parent_builder = self
                context._field_name = "relabelings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Relabeling.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("relabelings", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel6], /
        ) -> "ScrapeClass.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel6.Builder], TlsConfigModel6.Builder | TlsConfigModel6
            ],
            /,
        ) -> "ScrapeClass.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel6.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLSConfig defines the TLS settings to use for the scrape. When the
            scrape objects define their own CA, certificate and/or key, they take
            precedence over the corresponding scrape class fields.

            For now only the `caFile`, `certFile` and `keyFile` fields are supported.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel6.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel6.builder())
                if isinstance(output, TlsConfigModel6.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["ScrapeClass.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ScrapeClass.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ScrapeClass."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ScrapeClass", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ScrapeClass.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    attach_metadata: Annotated[Optional[AttachMetadata], Field(alias="attachMetadata")] = None
    """
    AttachMetadata configures additional metadata to the discovered targets.
    When the scrape object defines its own configuration, it takes
    precedence over the scrape class configuration.
    """
    authorization: Optional[AuthorizationModel] = None
    """
    Authorization section for the ScrapeClass.
    It will only apply if the scrape resource doesn't specify any Authorization.
    """
    default: Optional[bool] = None
    """
    Default indicates that the scrape applies to all scrape objects that
    don't configure an explicit scrape class name.

    Only one scrape class can be set as the default.
    """
    fallback_scrape_protocol: Annotated[
        Optional[
            Literal[
                "PrometheusProto",
                "OpenMetricsText0.0.1",
                "OpenMetricsText1.0.0",
                "PrometheusText0.0.4",
                "PrometheusText1.0.0",
            ]
        ],
        Field(alias="fallbackScrapeProtocol"),
    ] = None
    """
    The protocol to use if a scrape returns blank, unparseable, or otherwise invalid Content-Type.
    It will only apply if the scrape resource doesn't specify any FallbackScrapeProtocol

    It requires Prometheus >= v3.0.0.
    """
    metric_relabelings: Annotated[
        Optional[List[MetricRelabeling]], Field(alias="metricRelabelings")
    ] = None
    """
    MetricRelabelings configures the relabeling rules to apply to all samples before ingestion.

    The Operator adds the scrape class metric relabelings defined here.
    Then the Operator adds the target-specific metric relabelings defined in ServiceMonitors, PodMonitors, Probes and ScrapeConfigs.
    Then the Operator adds namespace enforcement relabeling rule, specified in '.spec.enforcedNamespaceLabel'.

    More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs
    """
    name: Annotated[str, Field(min_length=1)]
    """
    Name of the scrape class.
    """
    relabelings: Optional[List[Relabeling]] = None
    """
    Relabelings configures the relabeling rules to apply to all scrape targets.

    The Operator automatically adds relabelings for a few standard Kubernetes fields
    like `__meta_kubernetes_namespace` and `__meta_kubernetes_service_name`.
    Then the Operator adds the scrape class relabelings defined here.
    Then the Operator adds the target-specific relabelings defined in the scrape object.

    More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
    """
    tls_config: Annotated[Optional[TlsConfigModel6], Field(alias="tlsConfig")] = None
    """
    TLSConfig defines the TLS settings to use for the scrape. When the
    scrape objects define their own CA, certificate and/or key, they take
    precedence over the corresponding scrape class fields.

    For now only the `caFile`, `certFile` and `keyFile` fields are supported.
    """


class ScrapeConfigNamespaceSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ScrapeConfigNamespaceSelector"]:
            return ScrapeConfigNamespaceSelector

        def build(self) -> "ScrapeConfigNamespaceSelector":
            return ScrapeConfigNamespaceSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel2], /
        ) -> "ScrapeConfigNamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel2, MatchExpressionModel2.Builder]],
                GenericListBuilder[MatchExpressionModel2, MatchExpressionModel2.Builder]
                | List[MatchExpressionModel2],
            ],
            /,
        ) -> "ScrapeConfigNamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel2.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel2.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel2.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["ScrapeConfigNamespaceSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ScrapeConfigNamespaceSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ScrapeConfigNamespaceSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ScrapeConfigNamespaceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ScrapeConfigNamespaceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel2]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class ScrapeConfigSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ScrapeConfigSelector"]:
            return ScrapeConfigSelector

        def build(self) -> "ScrapeConfigSelector":
            return ScrapeConfigSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel2], /
        ) -> "ScrapeConfigSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel2, MatchExpressionModel2.Builder]],
                GenericListBuilder[MatchExpressionModel2, MatchExpressionModel2.Builder]
                | List[MatchExpressionModel2],
            ],
            /,
        ) -> "ScrapeConfigSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel2.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel2.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel2.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["ScrapeConfigSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ScrapeConfigSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ScrapeConfigSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ScrapeConfigSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ScrapeConfigSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel2]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class SecurityContextModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecurityContextModel2"]:
            return SecurityContextModel2

        def build(self) -> "SecurityContextModel2":
            return SecurityContextModel2(**self._attrs)

        @overload
        def app_armor_profile(
            self, value_or_callback: Optional[AppArmorProfile], /
        ) -> "SecurityContextModel2.Builder": ...

        @overload
        def app_armor_profile(
            self,
            value_or_callback: Callable[
                [AppArmorProfile.Builder], AppArmorProfile.Builder | AppArmorProfile
            ],
            /,
        ) -> "SecurityContextModel2.Builder": ...

        @overload
        def app_armor_profile(
            self, value_or_callback: Never = ...
        ) -> "AppArmorProfile.BuilderContext": ...

        def app_armor_profile(self, value_or_callback=None, /):
            """
            appArmorProfile is the AppArmor options to use by the containers in this pod.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = AppArmorProfile.BuilderContext()
                context._parent_builder = self
                context._field_name = "app_armor_profile"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AppArmorProfile.builder())
                if isinstance(output, AppArmorProfile.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("app_armor_profile", value)

        def fs_group(self, value: Optional[int], /) -> Self:
            """
            A special supplemental group that applies to all containers in a pod.
            Some volume types allow the Kubelet to change the ownership of that volume
            to be owned by the pod:

            1. The owning GID will be the FSGroup
            2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
            3. The permission bits are OR'd with rw-rw----

            If unset, the Kubelet will not modify the ownership and permissions of any volume.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("fs_group", value)

        def fs_group_change_policy(self, value: Optional[str], /) -> Self:
            """
            fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
            before being exposed inside Pod. This field will only apply to
            volume types which support fsGroup based ownership(and permissions).
            It will have no effect on ephemeral volume types such as: secret, configmaps
            and emptydir.
            Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("fs_group_change_policy", value)

        def run_as_group(self, value: Optional[int], /) -> Self:
            """
            The GID to run the entrypoint of the container process.
            Uses runtime default if unset.
            May also be set in SecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence
            for that container.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("run_as_group", value)

        def run_as_non_root(self, value: Optional[bool], /) -> Self:
            """
            Indicates that the container must run as a non-root user.
            If true, the Kubelet will validate the image at runtime to ensure that it
            does not run as UID 0 (root) and fail to start the container if it does.
            If unset or false, no such validation will be performed.
            May also be set in SecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            """
            return self._set("run_as_non_root", value)

        def run_as_user(self, value: Optional[int], /) -> Self:
            """
            The UID to run the entrypoint of the container process.
            Defaults to user specified in image metadata if unspecified.
            May also be set in SecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence
            for that container.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("run_as_user", value)

        def se_linux_change_policy(self, value: Optional[str], /) -> Self:
            """
            seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
            It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
            Valid values are "MountOption" and "Recursive".

            "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
            This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.

            "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
            This requires all Pods that share the same volume to use the same SELinux label.
            It is not possible to share the same volume among privileged and unprivileged Pods.
            Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
            whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
            CSIDriver instance. Other volumes are always re-labelled recursively.
            "MountOption" value is allowed only when SELinuxMount feature gate is enabled.

            If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
            If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
            and "Recursive" for all other volumes.

            This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.

            All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("se_linux_change_policy", value)

        @overload
        def se_linux_options(
            self, value_or_callback: Optional[SeLinuxOptions], /
        ) -> "SecurityContextModel2.Builder": ...

        @overload
        def se_linux_options(
            self,
            value_or_callback: Callable[
                [SeLinuxOptions.Builder], SeLinuxOptions.Builder | SeLinuxOptions
            ],
            /,
        ) -> "SecurityContextModel2.Builder": ...

        @overload
        def se_linux_options(
            self, value_or_callback: Never = ...
        ) -> "SeLinuxOptions.BuilderContext": ...

        def se_linux_options(self, value_or_callback=None, /):
            """
            The SELinux context to be applied to all containers.
            If unspecified, the container runtime will allocate a random SELinux context for each
            container.  May also be set in SecurityContext.  If set in
            both SecurityContext and PodSecurityContext, the value specified in SecurityContext
            takes precedence for that container.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = SeLinuxOptions.BuilderContext()
                context._parent_builder = self
                context._field_name = "se_linux_options"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SeLinuxOptions.builder())
                if isinstance(output, SeLinuxOptions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("se_linux_options", value)

        @overload
        def seccomp_profile(
            self, value_or_callback: Optional[SeccompProfile], /
        ) -> "SecurityContextModel2.Builder": ...

        @overload
        def seccomp_profile(
            self,
            value_or_callback: Callable[
                [SeccompProfile.Builder], SeccompProfile.Builder | SeccompProfile
            ],
            /,
        ) -> "SecurityContextModel2.Builder": ...

        @overload
        def seccomp_profile(
            self, value_or_callback: Never = ...
        ) -> "SeccompProfile.BuilderContext": ...

        def seccomp_profile(self, value_or_callback=None, /):
            """
            The seccomp options to use by the containers in this pod.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = SeccompProfile.BuilderContext()
                context._parent_builder = self
                context._field_name = "seccomp_profile"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SeccompProfile.builder())
                if isinstance(output, SeccompProfile.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("seccomp_profile", value)

        def supplemental_groups(self, value: Optional[List[int]], /) -> Self:
            """
            A list of groups applied to the first process run in each container, in
            addition to the container's primary GID and fsGroup (if specified).  If
            the SupplementalGroupsPolicy feature is enabled, the
            supplementalGroupsPolicy field determines whether these are in addition
            to or instead of any group memberships defined in the container image.
            If unspecified, no additional groups are added, though group memberships
            defined in the container image may still be used, depending on the
            supplementalGroupsPolicy field.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("supplemental_groups", value)

        def supplemental_groups_policy(self, value: Optional[str], /) -> Self:
            """
            Defines how supplemental groups of the first container processes are calculated.
            Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
            (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
            and the container runtime must implement support for this feature.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("supplemental_groups_policy", value)

        @overload
        def sysctls(
            self, value_or_callback: List[Sysctl], /
        ) -> "SecurityContextModel2.Builder": ...

        @overload
        def sysctls(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Sysctl, Sysctl.Builder]],
                GenericListBuilder[Sysctl, Sysctl.Builder] | List[Sysctl],
            ],
            /,
        ) -> "SecurityContextModel2.Builder": ...

        @overload
        def sysctls(self, value_or_callback: Never = ...) -> ListBuilderContext[Sysctl.Builder]: ...

        def sysctls(self, value_or_callback=None, /):
            """
            Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
            sysctls (by the container runtime) might fail to launch.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Sysctl.Builder]()
                context._parent_builder = self
                context._field_name = "sysctls"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sysctl.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("sysctls", value)

        @overload
        def windows_options(
            self, value_or_callback: Optional[WindowsOptions], /
        ) -> "SecurityContextModel2.Builder": ...

        @overload
        def windows_options(
            self,
            value_or_callback: Callable[
                [WindowsOptions.Builder], WindowsOptions.Builder | WindowsOptions
            ],
            /,
        ) -> "SecurityContextModel2.Builder": ...

        @overload
        def windows_options(
            self, value_or_callback: Never = ...
        ) -> "WindowsOptions.BuilderContext": ...

        def windows_options(self, value_or_callback=None, /):
            """
            The Windows specific settings applied to all containers.
            If unspecified, the options within a container's SecurityContext will be used.
            If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
            Note that this field cannot be set when spec.os.name is linux.
            """
            if self._in_context and value_or_callback is None:
                context = WindowsOptions.BuilderContext()
                context._parent_builder = self
                context._field_name = "windows_options"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WindowsOptions.builder())
                if isinstance(output, WindowsOptions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("windows_options", value)

    class BuilderContext(BuilderContextBase["SecurityContextModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecurityContextModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecurityContextModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecurityContextModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecurityContextModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    app_armor_profile: Annotated[Optional[AppArmorProfile], Field(alias="appArmorProfile")] = None
    """
    appArmorProfile is the AppArmor options to use by the containers in this pod.
    Note that this field cannot be set when spec.os.name is windows.
    """
    fs_group: Annotated[Optional[int], Field(alias="fsGroup")] = None
    """
    A special supplemental group that applies to all containers in a pod.
    Some volume types allow the Kubelet to change the ownership of that volume
    to be owned by the pod:

    1. The owning GID will be the FSGroup
    2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
    3. The permission bits are OR'd with rw-rw----

    If unset, the Kubelet will not modify the ownership and permissions of any volume.
    Note that this field cannot be set when spec.os.name is windows.
    """
    fs_group_change_policy: Annotated[Optional[str], Field(alias="fsGroupChangePolicy")] = None
    """
    fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
    before being exposed inside Pod. This field will only apply to
    volume types which support fsGroup based ownership(and permissions).
    It will have no effect on ephemeral volume types such as: secret, configmaps
    and emptydir.
    Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
    Note that this field cannot be set when spec.os.name is windows.
    """
    run_as_group: Annotated[Optional[int], Field(alias="runAsGroup")] = None
    """
    The GID to run the entrypoint of the container process.
    Uses runtime default if unset.
    May also be set in SecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence
    for that container.
    Note that this field cannot be set when spec.os.name is windows.
    """
    run_as_non_root: Annotated[Optional[bool], Field(alias="runAsNonRoot")] = None
    """
    Indicates that the container must run as a non-root user.
    If true, the Kubelet will validate the image at runtime to ensure that it
    does not run as UID 0 (root) and fail to start the container if it does.
    If unset or false, no such validation will be performed.
    May also be set in SecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    """
    run_as_user: Annotated[Optional[int], Field(alias="runAsUser")] = None
    """
    The UID to run the entrypoint of the container process.
    Defaults to user specified in image metadata if unspecified.
    May also be set in SecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence
    for that container.
    Note that this field cannot be set when spec.os.name is windows.
    """
    se_linux_change_policy: Annotated[Optional[str], Field(alias="seLinuxChangePolicy")] = None
    """
    seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
    It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
    Valid values are "MountOption" and "Recursive".

    "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
    This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.

    "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
    This requires all Pods that share the same volume to use the same SELinux label.
    It is not possible to share the same volume among privileged and unprivileged Pods.
    Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
    whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
    CSIDriver instance. Other volumes are always re-labelled recursively.
    "MountOption" value is allowed only when SELinuxMount feature gate is enabled.

    If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
    If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
    and "Recursive" for all other volumes.

    This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.

    All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
    Note that this field cannot be set when spec.os.name is windows.
    """
    se_linux_options: Annotated[Optional[SeLinuxOptions], Field(alias="seLinuxOptions")] = None
    """
    The SELinux context to be applied to all containers.
    If unspecified, the container runtime will allocate a random SELinux context for each
    container.  May also be set in SecurityContext.  If set in
    both SecurityContext and PodSecurityContext, the value specified in SecurityContext
    takes precedence for that container.
    Note that this field cannot be set when spec.os.name is windows.
    """
    seccomp_profile: Annotated[Optional[SeccompProfile], Field(alias="seccompProfile")] = None
    """
    The seccomp options to use by the containers in this pod.
    Note that this field cannot be set when spec.os.name is windows.
    """
    supplemental_groups: Annotated[Optional[List[int]], Field(alias="supplementalGroups")] = None
    """
    A list of groups applied to the first process run in each container, in
    addition to the container's primary GID and fsGroup (if specified).  If
    the SupplementalGroupsPolicy feature is enabled, the
    supplementalGroupsPolicy field determines whether these are in addition
    to or instead of any group memberships defined in the container image.
    If unspecified, no additional groups are added, though group memberships
    defined in the container image may still be used, depending on the
    supplementalGroupsPolicy field.
    Note that this field cannot be set when spec.os.name is windows.
    """
    supplemental_groups_policy: Annotated[
        Optional[str], Field(alias="supplementalGroupsPolicy")
    ] = None
    """
    Defines how supplemental groups of the first container processes are calculated.
    Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
    (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
    and the container runtime must implement support for this feature.
    Note that this field cannot be set when spec.os.name is windows.
    """
    sysctls: Optional[List[Sysctl]] = None
    """
    Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
    sysctls (by the container runtime) might fail to launch.
    Note that this field cannot be set when spec.os.name is windows.
    """
    windows_options: Annotated[Optional[WindowsOptions], Field(alias="windowsOptions")] = None
    """
    The Windows specific settings applied to all containers.
    If unspecified, the options within a container's SecurityContext will be used.
    If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
    Note that this field cannot be set when spec.os.name is linux.
    """


class ServiceMonitorNamespaceSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceMonitorNamespaceSelector"]:
            return ServiceMonitorNamespaceSelector

        def build(self) -> "ServiceMonitorNamespaceSelector":
            return ServiceMonitorNamespaceSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel2], /
        ) -> "ServiceMonitorNamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel2, MatchExpressionModel2.Builder]],
                GenericListBuilder[MatchExpressionModel2, MatchExpressionModel2.Builder]
                | List[MatchExpressionModel2],
            ],
            /,
        ) -> "ServiceMonitorNamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel2.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel2.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel2.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["ServiceMonitorNamespaceSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceMonitorNamespaceSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceMonitorNamespaceSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceMonitorNamespaceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceMonitorNamespaceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel2]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class ServiceMonitorSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceMonitorSelector"]:
            return ServiceMonitorSelector

        def build(self) -> "ServiceMonitorSelector":
            return ServiceMonitorSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel2], /
        ) -> "ServiceMonitorSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel2, MatchExpressionModel2.Builder]],
                GenericListBuilder[MatchExpressionModel2, MatchExpressionModel2.Builder]
                | List[MatchExpressionModel2],
            ],
            /,
        ) -> "ServiceMonitorSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel2.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel2.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel2.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["ServiceMonitorSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceMonitorSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceMonitorSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceMonitorSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceMonitorSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel2]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class SizeLimitModel3(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def build(self) -> "SizeLimitModel3":
            value = cast(int, self._value)
            return SizeLimitModel3(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    sizeLimit is the total amount of local storage required for this EmptyDir volume.
    The size limit is also applicable for memory medium.
    The maximum usage on memory medium EmptyDir would be the minimum value between
    the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    The default is nil which means that the limit is undefined.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    """

    class BuilderContext(BuilderContextBase["SizeLimitModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SizeLimitModel3.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SizeLimitModel3."""
        return cls.BuilderContext()


class SizeLimitModel4(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def build(self) -> "SizeLimitModel4":
            value = cast(str, self._value)
            return SizeLimitModel4(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    sizeLimit is the total amount of local storage required for this EmptyDir volume.
    The size limit is also applicable for memory medium.
    The maximum usage on memory medium EmptyDir would be the minimum value between
    the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    The default is nil which means that the limit is undefined.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    """

    class BuilderContext(BuilderContextBase["SizeLimitModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SizeLimitModel4.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SizeLimitModel4."""
        return cls.BuilderContext()


class LimitsModel17(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel17":
            value = cast(int, self._value)
            return LimitsModel17(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel17.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel17.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel17."""
        return cls.BuilderContext()


class LimitsModel18(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel18":
            value = cast(str, self._value)
            return LimitsModel18(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel18.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel18.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel18."""
        return cls.BuilderContext()


class RequestsModel17(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel17":
            value = cast(int, self._value)
            return RequestsModel17(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel17.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel17.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel17."""
        return cls.BuilderContext()


class RequestsModel18(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel18":
            value = cast(str, self._value)
            return RequestsModel18(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel18.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel18.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel18."""
        return cls.BuilderContext()


class ResourcesModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourcesModel2"]:
            return ResourcesModel2

        def build(self) -> "ResourcesModel2":
            return ResourcesModel2(**self._attrs)

        def limits(
            self, value: Optional[Dict[str, Union[LimitsModel17, LimitsModel18]]], /
        ) -> Self:
            """
            Limits describes the maximum amount of compute resources allowed.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            return self._set("limits", value)

        def requests(
            self, value: Optional[Dict[str, Union[RequestsModel17, RequestsModel18]]], /
        ) -> Self:
            """
            Requests describes the minimum amount of compute resources required.
            If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
            otherwise to an implementation-defined value. Requests cannot exceed Limits.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            return self._set("requests", value)

    class BuilderContext(BuilderContextBase["ResourcesModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourcesModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourcesModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourcesModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourcesModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    limits: Optional[Dict[str, Union[LimitsModel17, LimitsModel18]]] = None
    """
    Limits describes the maximum amount of compute resources allowed.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """
    requests: Optional[Dict[str, Union[RequestsModel17, RequestsModel18]]] = None
    """
    Requests describes the minimum amount of compute resources required.
    If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    otherwise to an implementation-defined value. Requests cannot exceed Limits.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """


class LimitsModel19(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel19":
            value = cast(int, self._value)
            return LimitsModel19(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel19.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel19.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel19."""
        return cls.BuilderContext()


class LimitsModel20(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel20":
            value = cast(str, self._value)
            return LimitsModel20(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel20.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel20.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel20."""
        return cls.BuilderContext()


class RequestsModel19(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel19":
            value = cast(int, self._value)
            return RequestsModel19(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel19.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel19.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel19."""
        return cls.BuilderContext()


class RequestsModel20(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel20":
            value = cast(str, self._value)
            return RequestsModel20(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel20.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel20.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel20."""
        return cls.BuilderContext()


class AllocatedResourcesModel1(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "AllocatedResourcesModel1":
            value = cast(int, self._value)
            return AllocatedResourcesModel1(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["AllocatedResourcesModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllocatedResourcesModel1.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllocatedResourcesModel1."""
        return cls.BuilderContext()


class AllocatedResourcesModel2(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "AllocatedResourcesModel2":
            value = cast(str, self._value)
            return AllocatedResourcesModel2(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["AllocatedResourcesModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllocatedResourcesModel2.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllocatedResourcesModel2."""
        return cls.BuilderContext()


class CapacityModel1(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "CapacityModel1":
            value = cast(int, self._value)
            return CapacityModel1(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["CapacityModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CapacityModel1.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CapacityModel1."""
        return cls.BuilderContext()


class CapacityModel2(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "CapacityModel2":
            value = cast(str, self._value)
            return CapacityModel2(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["CapacityModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CapacityModel2.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CapacityModel2."""
        return cls.BuilderContext()


class ConditionModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConditionModel1"]:
            return ConditionModel1

        def build(self) -> "ConditionModel1":
            return ConditionModel1(**self._attrs)

        def last_probe_time(self, value: Optional[datetime], /) -> Self:
            """
            lastProbeTime is the time we probed the condition.
            """
            return self._set("last_probe_time", value)

        def last_transition_time(self, value: Optional[datetime], /) -> Self:
            """
            lastTransitionTime is the time the condition transitioned from one status to another.
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            message is the human-readable message indicating details about last transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            reason is a unique, this should be a short, machine understandable string that gives the reason
            for condition's last transition. If it reports "Resizing" that means the underlying
            persistent volume is being resized.
            """
            return self._set("reason", value)

        def status(self, value: str, /) -> Self:
            """
            Status is the status of the condition.
            Can be True, False, Unknown.
            More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type is the type of the condition.
            More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["ConditionModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConditionModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConditionModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConditionModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConditionModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_probe_time: Annotated[Optional[datetime], Field(alias="lastProbeTime")] = None
    """
    lastProbeTime is the time we probed the condition.
    """
    last_transition_time: Annotated[Optional[datetime], Field(alias="lastTransitionTime")] = None
    """
    lastTransitionTime is the time the condition transitioned from one status to another.
    """
    message: Optional[str] = None
    """
    message is the human-readable message indicating details about last transition.
    """
    reason: Optional[str] = None
    """
    reason is a unique, this should be a short, machine understandable string that gives the reason
    for condition's last transition. If it reports "Resizing" that means the underlying
    persistent volume is being resized.
    """
    status: str
    """
    Status is the status of the condition.
    Can be True, False, Unknown.
    More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required
    """
    type: str
    """
    Type is the type of the condition.
    More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about
    """


class VolumeClaimTemplateModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VolumeClaimTemplateModel2"]:
            return VolumeClaimTemplateModel2

        def build(self) -> "VolumeClaimTemplateModel2":
            return VolumeClaimTemplateModel2(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[Metadata], /
        ) -> "VolumeClaimTemplateModel2.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[[Metadata.Builder], Metadata.Builder | Metadata],
            /,
        ) -> "VolumeClaimTemplateModel2.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "Metadata.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            """
            EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
            """
            if self._in_context and value_or_callback is None:
                context = Metadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Metadata.builder())
                if isinstance(output, Metadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[Spec], /
        ) -> "VolumeClaimTemplateModel2.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Callable[[Spec.Builder], Spec.Builder | Spec], /
        ) -> "VolumeClaimTemplateModel2.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "Spec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            """
            Defines the desired characteristics of a volume requested by a pod author.
            More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
            """
            if self._in_context and value_or_callback is None:
                context = Spec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Spec.builder())
                if isinstance(output, Spec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[Status], /
        ) -> "VolumeClaimTemplateModel2.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[[Status.Builder], Status.Builder | Status],
            /,
        ) -> "VolumeClaimTemplateModel2.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "Status.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            """
            Deprecated: this field is never set.
            """
            if self._in_context and value_or_callback is None:
                context = Status.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Status.builder())
                if isinstance(output, Status.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["VolumeClaimTemplateModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VolumeClaimTemplateModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VolumeClaimTemplateModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VolumeClaimTemplateModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VolumeClaimTemplateModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[str] = None
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[Metadata] = None
    """
    EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
    """
    spec: Optional[Spec] = None
    """
    Defines the desired characteristics of a volume requested by a pod author.
    More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
    """
    status: Optional[Status] = None
    """
    Deprecated: this field is never set.
    """


class GrpcServerTlsConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GrpcServerTlsConfig"]:
            return GrpcServerTlsConfig

        def build(self) -> "GrpcServerTlsConfig":
            return GrpcServerTlsConfig(**self._attrs)

        @overload
        def ca(self, value_or_callback: Optional[Ca], /) -> "GrpcServerTlsConfig.Builder": ...

        @overload
        def ca(
            self, value_or_callback: Callable[[Ca.Builder], Ca.Builder | Ca], /
        ) -> "GrpcServerTlsConfig.Builder": ...

        @overload
        def ca(self, value_or_callback: Never = ...) -> "Ca.BuilderContext": ...

        def ca(self, value_or_callback=None, /):
            """
            Certificate authority used when verifying server certificates.
            """
            if self._in_context and value_or_callback is None:
                context = Ca.BuilderContext()
                context._parent_builder = self
                context._field_name = "ca"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ca.builder())
                if isinstance(output, Ca.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ca", value)

        def ca_file(self, value: Optional[str], /) -> Self:
            """
            Path to the CA cert in the Prometheus container to use for the targets.
            """
            return self._set("ca_file", value)

        @overload
        def cert(self, value_or_callback: Optional[Cert], /) -> "GrpcServerTlsConfig.Builder": ...

        @overload
        def cert(
            self, value_or_callback: Callable[[Cert.Builder], Cert.Builder | Cert], /
        ) -> "GrpcServerTlsConfig.Builder": ...

        @overload
        def cert(self, value_or_callback: Never = ...) -> "Cert.BuilderContext": ...

        def cert(self, value_or_callback=None, /):
            """
            Client certificate to present when doing client-authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Cert.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cert.builder())
                if isinstance(output, Cert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert", value)

        def cert_file(self, value: Optional[str], /) -> Self:
            """
            Path to the client cert file in the Prometheus container for the targets.
            """
            return self._set("cert_file", value)

        def insecure_skip_verify(self, value: Optional[bool], /) -> Self:
            """
            Disable target certificate validation.
            """
            return self._set("insecure_skip_verify", value)

        def key_file(self, value: Optional[str], /) -> Self:
            """
            Path to the client key file in the Prometheus container for the targets.
            """
            return self._set("key_file", value)

        @overload
        def key_secret(
            self, value_or_callback: Optional[KeySecret], /
        ) -> "GrpcServerTlsConfig.Builder": ...

        @overload
        def key_secret(
            self,
            value_or_callback: Callable[[KeySecret.Builder], KeySecret.Builder | KeySecret],
            /,
        ) -> "GrpcServerTlsConfig.Builder": ...

        @overload
        def key_secret(self, value_or_callback: Never = ...) -> "KeySecret.BuilderContext": ...

        def key_secret(self, value_or_callback=None, /):
            """
            Secret containing the client key file for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = KeySecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "key_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KeySecret.builder())
                if isinstance(output, KeySecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("key_secret", value)

        def max_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Maximum acceptable TLS version.

            It requires Prometheus >= v2.41.0.
            """
            return self._set("max_version", value)

        def min_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Minimum acceptable TLS version.

            It requires Prometheus >= v2.35.0.
            """
            return self._set("min_version", value)

        def server_name(self, value: Optional[str], /) -> Self:
            """
            Used to verify the hostname for the targets.
            """
            return self._set("server_name", value)

    class BuilderContext(BuilderContextBase["GrpcServerTlsConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GrpcServerTlsConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GrpcServerTlsConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GrpcServerTlsConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GrpcServerTlsConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca: Optional[Ca] = None
    """
    Certificate authority used when verifying server certificates.
    """
    ca_file: Annotated[Optional[str], Field(alias="caFile")] = None
    """
    Path to the CA cert in the Prometheus container to use for the targets.
    """
    cert: Optional[Cert] = None
    """
    Client certificate to present when doing client-authentication.
    """
    cert_file: Annotated[Optional[str], Field(alias="certFile")] = None
    """
    Path to the client cert file in the Prometheus container for the targets.
    """
    insecure_skip_verify: Annotated[Optional[bool], Field(alias="insecureSkipVerify")] = None
    """
    Disable target certificate validation.
    """
    key_file: Annotated[Optional[str], Field(alias="keyFile")] = None
    """
    Path to the client key file in the Prometheus container for the targets.
    """
    key_secret: Annotated[Optional[KeySecret], Field(alias="keySecret")] = None
    """
    Secret containing the client key file for the targets.
    """
    max_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="maxVersion")
    ] = None
    """
    Maximum acceptable TLS version.

    It requires Prometheus >= v2.41.0.
    """
    min_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="minVersion")
    ] = None
    """
    Minimum acceptable TLS version.

    It requires Prometheus >= v2.35.0.
    """
    server_name: Annotated[Optional[str], Field(alias="serverName")] = None
    """
    Used to verify the hostname for the targets.
    """


class ObjectStorageConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ObjectStorageConfig"]:
            return ObjectStorageConfig

        def build(self) -> "ObjectStorageConfig":
            return ObjectStorageConfig(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ObjectStorageConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ObjectStorageConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ObjectStorageConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ObjectStorageConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ObjectStorageConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class LimitsModel21(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel21":
            value = cast(int, self._value)
            return LimitsModel21(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel21.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel21.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel21."""
        return cls.BuilderContext()


class LimitsModel22(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel22":
            value = cast(str, self._value)
            return LimitsModel22(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel22.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel22.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel22."""
        return cls.BuilderContext()


class RequestsModel21(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel21":
            value = cast(int, self._value)
            return RequestsModel21(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel21.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel21.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel21."""
        return cls.BuilderContext()


class RequestsModel22(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel22":
            value = cast(str, self._value)
            return RequestsModel22(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel22.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel22.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel22."""
        return cls.BuilderContext()


class ResourcesModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourcesModel3"]:
            return ResourcesModel3

        def build(self) -> "ResourcesModel3":
            return ResourcesModel3(**self._attrs)

        @overload
        def claims(self, value_or_callback: List[Claim], /) -> "ResourcesModel3.Builder": ...

        @overload
        def claims(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Claim, Claim.Builder]],
                GenericListBuilder[Claim, Claim.Builder] | List[Claim],
            ],
            /,
        ) -> "ResourcesModel3.Builder": ...

        @overload
        def claims(self, value_or_callback: Never = ...) -> ListBuilderContext[Claim.Builder]: ...

        def claims(self, value_or_callback=None, /):
            """
            Claims lists the names of resources, defined in spec.resourceClaims,
            that are used by this container.

            This is an alpha field and requires enabling the
            DynamicResourceAllocation feature gate.

            This field is immutable. It can only be set for containers.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Claim.Builder]()
                context._parent_builder = self
                context._field_name = "claims"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Claim.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("claims", value)

        def limits(
            self, value: Optional[Dict[str, Union[LimitsModel21, LimitsModel22]]], /
        ) -> Self:
            """
            Limits describes the maximum amount of compute resources allowed.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            return self._set("limits", value)

        def requests(
            self, value: Optional[Dict[str, Union[RequestsModel21, RequestsModel22]]], /
        ) -> Self:
            """
            Requests describes the minimum amount of compute resources required.
            If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
            otherwise to an implementation-defined value. Requests cannot exceed Limits.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            return self._set("requests", value)

    class BuilderContext(BuilderContextBase["ResourcesModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourcesModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourcesModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourcesModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourcesModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    claims: Optional[List[Claim]] = None
    """
    Claims lists the names of resources, defined in spec.resourceClaims,
    that are used by this container.

    This is an alpha field and requires enabling the
    DynamicResourceAllocation feature gate.

    This field is immutable. It can only be set for containers.
    """
    limits: Optional[Dict[str, Union[LimitsModel21, LimitsModel22]]] = None
    """
    Limits describes the maximum amount of compute resources allowed.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """
    requests: Optional[Dict[str, Union[RequestsModel21, RequestsModel22]]] = None
    """
    Requests describes the minimum amount of compute resources required.
    If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    otherwise to an implementation-defined value. Requests cannot exceed Limits.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """


class TracingConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TracingConfig"]:
            return TracingConfig

        def build(self) -> "TracingConfig":
            return TracingConfig(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["TracingConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TracingConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TracingConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TracingConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TracingConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class Thanos(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Thanos"]:
            return Thanos

        def build(self) -> "Thanos":
            return Thanos(**self._attrs)

        @overload
        def additional_args(
            self, value_or_callback: List[AdditionalArg], /
        ) -> "Thanos.Builder": ...

        @overload
        def additional_args(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AdditionalArg, AdditionalArg.Builder]],
                GenericListBuilder[AdditionalArg, AdditionalArg.Builder] | List[AdditionalArg],
            ],
            /,
        ) -> "Thanos.Builder": ...

        @overload
        def additional_args(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[AdditionalArg.Builder]: ...

        def additional_args(self, value_or_callback=None, /):
            """
            AdditionalArgs allows setting additional arguments for the Thanos container.
            The arguments are passed as-is to the Thanos container which may cause issues
            if they are invalid or not supported the given Thanos version.
            In case of an argument conflict (e.g. an argument which is already set by the
            operator itself) or when providing an invalid argument, the reconciliation will
            fail and an error will be logged.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AdditionalArg.Builder]()
                context._parent_builder = self
                context._field_name = "additional_args"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AdditionalArg.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("additional_args", value)

        def base_image(self, value: Optional[str], /) -> Self:
            """
            Deprecated: use 'image' instead.
            """
            return self._set("base_image", value)

        def block_size(self, value: Optional[str], /) -> Self:
            """
            BlockDuration controls the size of TSDB blocks produced by Prometheus.
            The default value is 2h to match the upstream Prometheus defaults.

            WARNING: Changing the block duration can impact the performance and
            efficiency of the entire Prometheus/Thanos stack due to how it interacts
            with memory and Thanos compactors. It is recommended to keep this value
            set to a multiple of 120 times your longest scrape or rule interval. For
            example, 30s * 120 = 1h.
            """
            return self._set("block_size", value)

        def get_config_interval(self, value: Optional[str], /) -> Self:
            """
            How often to retrieve the Prometheus configuration.
            """
            return self._set("get_config_interval", value)

        def get_config_timeout(self, value: Optional[str], /) -> Self:
            """
            Maximum time to wait when retrieving the Prometheus configuration.
            """
            return self._set("get_config_timeout", value)

        def grpc_listen_local(self, value: Optional[bool], /) -> Self:
            """
            When true, the Thanos sidecar listens on the loopback interface instead
            of the Pod IP's address for the gRPC endpoints.

            It has no effect if `listenLocal` is true.
            """
            return self._set("grpc_listen_local", value)

        @overload
        def grpc_server_tls_config(
            self, value_or_callback: Optional[GrpcServerTlsConfig], /
        ) -> "Thanos.Builder": ...

        @overload
        def grpc_server_tls_config(
            self,
            value_or_callback: Callable[
                [GrpcServerTlsConfig.Builder],
                GrpcServerTlsConfig.Builder | GrpcServerTlsConfig,
            ],
            /,
        ) -> "Thanos.Builder": ...

        @overload
        def grpc_server_tls_config(
            self, value_or_callback: Never = ...
        ) -> "GrpcServerTlsConfig.BuilderContext": ...

        def grpc_server_tls_config(self, value_or_callback=None, /):
            """
            Configures the TLS parameters for the gRPC server providing the StoreAPI.

            Note: Currently only the `caFile`, `certFile`, and `keyFile` fields are supported.
            """
            if self._in_context and value_or_callback is None:
                context = GrpcServerTlsConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "grpc_server_tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GrpcServerTlsConfig.builder())
                if isinstance(output, GrpcServerTlsConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("grpc_server_tls_config", value)

        def http_listen_local(self, value: Optional[bool], /) -> Self:
            """
            When true, the Thanos sidecar listens on the loopback interface instead
            of the Pod IP's address for the HTTP endpoints.

            It has no effect if `listenLocal` is true.
            """
            return self._set("http_listen_local", value)

        def image(self, value: Optional[str], /) -> Self:
            """
            Container image name for Thanos. If specified, it takes precedence over
            the `spec.thanos.baseImage`, `spec.thanos.tag` and `spec.thanos.sha`
            fields.

            Specifying `spec.thanos.version` is still necessary to ensure the
            Prometheus Operator knows which version of Thanos is being configured.

            If neither `spec.thanos.image` nor `spec.thanos.baseImage` are defined,
            the operator will use the latest upstream version of Thanos available at
            the time when the operator was released.
            """
            return self._set("image", value)

        def listen_local(self, value: Optional[bool], /) -> Self:
            """
            Deprecated: use `grpcListenLocal` and `httpListenLocal` instead.
            """
            return self._set("listen_local", value)

        def log_format(self, value: Optional[Literal["", "logfmt", "json"]], /) -> Self:
            """
            Log format for the Thanos sidecar.
            """
            return self._set("log_format", value)

        def log_level(
            self, value: Optional[Literal["", "debug", "info", "warn", "error"]], /
        ) -> Self:
            """
            Log level for the Thanos sidecar.
            """
            return self._set("log_level", value)

        def min_time(self, value: Optional[str], /) -> Self:
            """
            Defines the start of time range limit served by the Thanos sidecar's StoreAPI.
            The field's value should be a constant time in RFC3339 format or a time
            duration relative to current time, such as -1d or 2h45m. Valid duration
            units are ms, s, m, h, d, w, y.
            """
            return self._set("min_time", value)

        @overload
        def object_storage_config(
            self, value_or_callback: Optional[ObjectStorageConfig], /
        ) -> "Thanos.Builder": ...

        @overload
        def object_storage_config(
            self,
            value_or_callback: Callable[
                [ObjectStorageConfig.Builder],
                ObjectStorageConfig.Builder | ObjectStorageConfig,
            ],
            /,
        ) -> "Thanos.Builder": ...

        @overload
        def object_storage_config(
            self, value_or_callback: Never = ...
        ) -> "ObjectStorageConfig.BuilderContext": ...

        def object_storage_config(self, value_or_callback=None, /):
            """
            Defines the Thanos sidecar's configuration to upload TSDB blocks to object storage.

            More info: https://thanos.io/tip/thanos/storage.md/

            objectStorageConfigFile takes precedence over this field.
            """
            if self._in_context and value_or_callback is None:
                context = ObjectStorageConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "object_storage_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ObjectStorageConfig.builder())
                if isinstance(output, ObjectStorageConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("object_storage_config", value)

        def object_storage_config_file(self, value: Optional[str], /) -> Self:
            """
            Defines the Thanos sidecar's configuration file to upload TSDB blocks to object storage.

            More info: https://thanos.io/tip/thanos/storage.md/

            This field takes precedence over objectStorageConfig.
            """
            return self._set("object_storage_config_file", value)

        def ready_timeout(self, value: Optional[str], /) -> Self:
            """
            ReadyTimeout is the maximum time that the Thanos sidecar will wait for
            Prometheus to start.
            """
            return self._set("ready_timeout", value)

        @overload
        def resources(
            self, value_or_callback: Optional[ResourcesModel3], /
        ) -> "Thanos.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[
                [ResourcesModel3.Builder], ResourcesModel3.Builder | ResourcesModel3
            ],
            /,
        ) -> "Thanos.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "ResourcesModel3.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            Defines the resources requests and limits of the Thanos sidecar.
            """
            if self._in_context and value_or_callback is None:
                context = ResourcesModel3.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourcesModel3.builder())
                if isinstance(output, ResourcesModel3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def sha(self, value: Optional[str], /) -> Self:
            """
            Deprecated: use 'image' instead.  The image digest can be specified as part of the image name.
            """
            return self._set("sha", value)

        def tag(self, value: Optional[str], /) -> Self:
            """
            Deprecated: use 'image' instead. The image's tag can be specified as as part of the image name.
            """
            return self._set("tag", value)

        @overload
        def tracing_config(
            self, value_or_callback: Optional[TracingConfig], /
        ) -> "Thanos.Builder": ...

        @overload
        def tracing_config(
            self,
            value_or_callback: Callable[
                [TracingConfig.Builder], TracingConfig.Builder | TracingConfig
            ],
            /,
        ) -> "Thanos.Builder": ...

        @overload
        def tracing_config(
            self, value_or_callback: Never = ...
        ) -> "TracingConfig.BuilderContext": ...

        def tracing_config(self, value_or_callback=None, /):
            """
            Defines the tracing configuration for the Thanos sidecar.

            `tracingConfigFile` takes precedence over this field.

            More info: https://thanos.io/tip/thanos/tracing.md/

            This is an *experimental feature*, it may change in any upcoming release
            in a breaking way.
            """
            if self._in_context and value_or_callback is None:
                context = TracingConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "tracing_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TracingConfig.builder())
                if isinstance(output, TracingConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tracing_config", value)

        def tracing_config_file(self, value: Optional[str], /) -> Self:
            """
            Defines the tracing configuration file for the Thanos sidecar.

            This field takes precedence over `tracingConfig`.

            More info: https://thanos.io/tip/thanos/tracing.md/

            This is an *experimental feature*, it may change in any upcoming release
            in a breaking way.
            """
            return self._set("tracing_config_file", value)

        def version(self, value: Optional[str], /) -> Self:
            """
            Version of Thanos being deployed. The operator uses this information
            to generate the Prometheus StatefulSet + configuration files.

            If not specified, the operator assumes the latest upstream release of
            Thanos available at the time when the version of the operator was
            released.
            """
            return self._set("version", value)

        @overload
        def volume_mounts(self, value_or_callback: List[VolumeMount], /) -> "Thanos.Builder": ...

        @overload
        def volume_mounts(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[VolumeMount, VolumeMount.Builder]],
                GenericListBuilder[VolumeMount, VolumeMount.Builder] | List[VolumeMount],
            ],
            /,
        ) -> "Thanos.Builder": ...

        @overload
        def volume_mounts(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[VolumeMount.Builder]: ...

        def volume_mounts(self, value_or_callback=None, /):
            """
            VolumeMounts allows configuration of additional VolumeMounts for Thanos.
            VolumeMounts specified will be appended to other VolumeMounts in the
            'thanos-sidecar' container.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[VolumeMount.Builder]()
                context._parent_builder = self
                context._field_name = "volume_mounts"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VolumeMount.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("volume_mounts", value)

    class BuilderContext(BuilderContextBase["Thanos.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Thanos.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Thanos."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Thanos", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Thanos.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    additional_args: Annotated[Optional[List[AdditionalArg]], Field(alias="additionalArgs")] = None
    """
    AdditionalArgs allows setting additional arguments for the Thanos container.
    The arguments are passed as-is to the Thanos container which may cause issues
    if they are invalid or not supported the given Thanos version.
    In case of an argument conflict (e.g. an argument which is already set by the
    operator itself) or when providing an invalid argument, the reconciliation will
    fail and an error will be logged.
    """
    base_image: Annotated[Optional[str], Field(alias="baseImage")] = None
    """
    Deprecated: use 'image' instead.
    """
    block_size: Annotated[
        Optional[str],
        Field(
            alias="blockSize",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = "2h"
    """
    BlockDuration controls the size of TSDB blocks produced by Prometheus.
    The default value is 2h to match the upstream Prometheus defaults.

    WARNING: Changing the block duration can impact the performance and
    efficiency of the entire Prometheus/Thanos stack due to how it interacts
    with memory and Thanos compactors. It is recommended to keep this value
    set to a multiple of 120 times your longest scrape or rule interval. For
    example, 30s * 120 = 1h.
    """
    get_config_interval: Annotated[
        Optional[str],
        Field(
            alias="getConfigInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    How often to retrieve the Prometheus configuration.
    """
    get_config_timeout: Annotated[
        Optional[str],
        Field(
            alias="getConfigTimeout",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Maximum time to wait when retrieving the Prometheus configuration.
    """
    grpc_listen_local: Annotated[Optional[bool], Field(alias="grpcListenLocal")] = None
    """
    When true, the Thanos sidecar listens on the loopback interface instead
    of the Pod IP's address for the gRPC endpoints.

    It has no effect if `listenLocal` is true.
    """
    grpc_server_tls_config: Annotated[
        Optional[GrpcServerTlsConfig], Field(alias="grpcServerTlsConfig")
    ] = None
    """
    Configures the TLS parameters for the gRPC server providing the StoreAPI.

    Note: Currently only the `caFile`, `certFile`, and `keyFile` fields are supported.
    """
    http_listen_local: Annotated[Optional[bool], Field(alias="httpListenLocal")] = None
    """
    When true, the Thanos sidecar listens on the loopback interface instead
    of the Pod IP's address for the HTTP endpoints.

    It has no effect if `listenLocal` is true.
    """
    image: Optional[str] = None
    """
    Container image name for Thanos. If specified, it takes precedence over
    the `spec.thanos.baseImage`, `spec.thanos.tag` and `spec.thanos.sha`
    fields.

    Specifying `spec.thanos.version` is still necessary to ensure the
    Prometheus Operator knows which version of Thanos is being configured.

    If neither `spec.thanos.image` nor `spec.thanos.baseImage` are defined,
    the operator will use the latest upstream version of Thanos available at
    the time when the operator was released.
    """
    listen_local: Annotated[Optional[bool], Field(alias="listenLocal")] = None
    """
    Deprecated: use `grpcListenLocal` and `httpListenLocal` instead.
    """
    log_format: Annotated[Optional[Literal["", "logfmt", "json"]], Field(alias="logFormat")] = None
    """
    Log format for the Thanos sidecar.
    """
    log_level: Annotated[
        Optional[Literal["", "debug", "info", "warn", "error"]], Field(alias="logLevel")
    ] = None
    """
    Log level for the Thanos sidecar.
    """
    min_time: Annotated[Optional[str], Field(alias="minTime")] = None
    """
    Defines the start of time range limit served by the Thanos sidecar's StoreAPI.
    The field's value should be a constant time in RFC3339 format or a time
    duration relative to current time, such as -1d or 2h45m. Valid duration
    units are ms, s, m, h, d, w, y.
    """
    object_storage_config: Annotated[
        Optional[ObjectStorageConfig], Field(alias="objectStorageConfig")
    ] = None
    """
    Defines the Thanos sidecar's configuration to upload TSDB blocks to object storage.

    More info: https://thanos.io/tip/thanos/storage.md/

    objectStorageConfigFile takes precedence over this field.
    """
    object_storage_config_file: Annotated[Optional[str], Field(alias="objectStorageConfigFile")] = (
        None
    )
    """
    Defines the Thanos sidecar's configuration file to upload TSDB blocks to object storage.

    More info: https://thanos.io/tip/thanos/storage.md/

    This field takes precedence over objectStorageConfig.
    """
    ready_timeout: Annotated[
        Optional[str],
        Field(
            alias="readyTimeout",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    ReadyTimeout is the maximum time that the Thanos sidecar will wait for
    Prometheus to start.
    """
    resources: Optional[ResourcesModel3] = None
    """
    Defines the resources requests and limits of the Thanos sidecar.
    """
    sha: Optional[str] = None
    """
    Deprecated: use 'image' instead.  The image digest can be specified as part of the image name.
    """
    tag: Optional[str] = None
    """
    Deprecated: use 'image' instead. The image's tag can be specified as as part of the image name.
    """
    tracing_config: Annotated[Optional[TracingConfig], Field(alias="tracingConfig")] = None
    """
    Defines the tracing configuration for the Thanos sidecar.

    `tracingConfigFile` takes precedence over this field.

    More info: https://thanos.io/tip/thanos/tracing.md/

    This is an *experimental feature*, it may change in any upcoming release
    in a breaking way.
    """
    tracing_config_file: Annotated[Optional[str], Field(alias="tracingConfigFile")] = None
    """
    Defines the tracing configuration file for the Thanos sidecar.

    This field takes precedence over `tracingConfig`.

    More info: https://thanos.io/tip/thanos/tracing.md/

    This is an *experimental feature*, it may change in any upcoming release
    in a breaking way.
    """
    version: Optional[str] = None
    """
    Version of Thanos being deployed. The operator uses this information
    to generate the Prometheus StatefulSet + configuration files.

    If not specified, the operator assumes the latest upstream release of
    Thanos available at the time when the version of the operator was
    released.
    """
    volume_mounts: Annotated[Optional[List[VolumeMount]], Field(alias="volumeMounts")] = None
    """
    VolumeMounts allows configuration of additional VolumeMounts for Thanos.
    VolumeMounts specified will be appended to other VolumeMounts in the
    'thanos-sidecar' container.
    """


class TopologySpreadConstraintModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TopologySpreadConstraintModel"]:
            return TopologySpreadConstraintModel

        def build(self) -> "TopologySpreadConstraintModel":
            return TopologySpreadConstraintModel(**self._attrs)

        def additional_label_selectors(
            self, value: Optional[Literal["OnResource", "OnShard"]], /
        ) -> Self:
            """
            Defines what Prometheus Operator managed labels should be added to labelSelector on the topologySpreadConstraint.
            """
            return self._set("additional_label_selectors", value)

        @overload
        def label_selector(
            self, value_or_callback: Optional[LabelSelector], /
        ) -> "TopologySpreadConstraintModel.Builder": ...

        @overload
        def label_selector(
            self,
            value_or_callback: Callable[
                [LabelSelector.Builder], LabelSelector.Builder | LabelSelector
            ],
            /,
        ) -> "TopologySpreadConstraintModel.Builder": ...

        @overload
        def label_selector(
            self, value_or_callback: Never = ...
        ) -> "LabelSelector.BuilderContext": ...

        def label_selector(self, value_or_callback=None, /):
            """
            LabelSelector is used to find matching pods.
            Pods that match this label selector are counted to determine the number of pods
            in their corresponding topology domain.
            """
            if self._in_context and value_or_callback is None:
                context = LabelSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "label_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LabelSelector.builder())
                if isinstance(output, LabelSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("label_selector", value)

        def match_label_keys(self, value: Optional[List[str]], /) -> Self:
            """
            MatchLabelKeys is a set of pod label keys to select the pods over which
            spreading will be calculated. The keys are used to lookup values from the
            incoming pod labels, those key-value labels are ANDed with labelSelector
            to select the group of existing pods over which spreading will be calculated
            for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
            MatchLabelKeys cannot be set when LabelSelector isn't set.
            Keys that don't exist in the incoming pod labels will
            be ignored. A null or empty list means only match against labelSelector.

            This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
            """
            return self._set("match_label_keys", value)

        def max_skew(self, value: int, /) -> Self:
            """
            MaxSkew describes the degree to which pods may be unevenly distributed.
            When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
            between the number of matching pods in the target topology and the global minimum.
            The global minimum is the minimum number of matching pods in an eligible domain
            or zero if the number of eligible domains is less than MinDomains.
            For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
            labelSelector spread as 2/2/1:
            In this case, the global minimum is 1.
            | zone1 | zone2 | zone3 |
            |  P P  |  P P  |   P   |
            - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
            scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
            violate MaxSkew(1).
            - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
            When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
            to topologies that satisfy it.
            It's a required field. Default value is 1 and 0 is not allowed.
            """
            return self._set("max_skew", value)

        def min_domains(self, value: Optional[int], /) -> Self:
            """
            MinDomains indicates a minimum number of eligible domains.
            When the number of eligible domains with matching topology keys is less than minDomains,
            Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
            And when the number of eligible domains with matching topology keys equals or greater than minDomains,
            this value has no effect on scheduling.
            As a result, when the number of eligible domains is less than minDomains,
            scheduler won't schedule more than maxSkew Pods to those domains.
            If value is nil, the constraint behaves as if MinDomains is equal to 1.
            Valid values are integers greater than 0.
            When value is not nil, WhenUnsatisfiable must be DoNotSchedule.

            For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
            labelSelector spread as 2/2/2:
            | zone1 | zone2 | zone3 |
            |  P P  |  P P  |  P P  |
            The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
            In this situation, new pod with the same labelSelector cannot be scheduled,
            because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
            it will violate MaxSkew.
            """
            return self._set("min_domains", value)

        def node_affinity_policy(self, value: Optional[str], /) -> Self:
            """
            NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
            when calculating pod topology spread skew. Options are:
            - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
            - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.

            If this value is nil, the behavior is equivalent to the Honor policy.
            This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
            """
            return self._set("node_affinity_policy", value)

        def node_taints_policy(self, value: Optional[str], /) -> Self:
            """
            NodeTaintsPolicy indicates how we will treat node taints when calculating
            pod topology spread skew. Options are:
            - Honor: nodes without taints, along with tainted nodes for which the incoming pod
            has a toleration, are included.
            - Ignore: node taints are ignored. All nodes are included.

            If this value is nil, the behavior is equivalent to the Ignore policy.
            This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
            """
            return self._set("node_taints_policy", value)

        def topology_key(self, value: str, /) -> Self:
            """
            TopologyKey is the key of node labels. Nodes that have a label with this key
            and identical values are considered to be in the same topology.
            We consider each <key, value> as a "bucket", and try to put balanced number
            of pods into each bucket.
            We define a domain as a particular instance of a topology.
            Also, we define an eligible domain as a domain whose nodes meet the requirements of
            nodeAffinityPolicy and nodeTaintsPolicy.
            e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
            And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
            It's a required field.
            """
            return self._set("topology_key", value)

        def when_unsatisfiable(self, value: str, /) -> Self:
            """
            WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
            the spread constraint.
            - DoNotSchedule (default) tells the scheduler not to schedule it.
            - ScheduleAnyway tells the scheduler to schedule the pod in any location,
              but giving higher precedence to topologies that would help reduce the
              skew.
            A constraint is considered "Unsatisfiable" for an incoming pod
            if and only if every possible node assignment for that pod would violate
            "MaxSkew" on some topology.
            For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
            labelSelector spread as 3/1/1:
            | zone1 | zone2 | zone3 |
            | P P P |   P   |   P   |
            If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
            to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
            MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
            won't make it *more* imbalanced.
            It's a required field.
            """
            return self._set("when_unsatisfiable", value)

    class BuilderContext(BuilderContextBase["TopologySpreadConstraintModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TopologySpreadConstraintModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TopologySpreadConstraintModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TopologySpreadConstraintModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TopologySpreadConstraintModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    additional_label_selectors: Annotated[
        Optional[Literal["OnResource", "OnShard"]],
        Field(alias="additionalLabelSelectors"),
    ] = None
    """
    Defines what Prometheus Operator managed labels should be added to labelSelector on the topologySpreadConstraint.
    """
    label_selector: Annotated[Optional[LabelSelector], Field(alias="labelSelector")] = None
    """
    LabelSelector is used to find matching pods.
    Pods that match this label selector are counted to determine the number of pods
    in their corresponding topology domain.
    """
    match_label_keys: Annotated[Optional[List[str]], Field(alias="matchLabelKeys")] = None
    """
    MatchLabelKeys is a set of pod label keys to select the pods over which
    spreading will be calculated. The keys are used to lookup values from the
    incoming pod labels, those key-value labels are ANDed with labelSelector
    to select the group of existing pods over which spreading will be calculated
    for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
    MatchLabelKeys cannot be set when LabelSelector isn't set.
    Keys that don't exist in the incoming pod labels will
    be ignored. A null or empty list means only match against labelSelector.

    This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
    """
    max_skew: Annotated[int, Field(alias="maxSkew")]
    """
    MaxSkew describes the degree to which pods may be unevenly distributed.
    When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
    between the number of matching pods in the target topology and the global minimum.
    The global minimum is the minimum number of matching pods in an eligible domain
    or zero if the number of eligible domains is less than MinDomains.
    For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
    labelSelector spread as 2/2/1:
    In this case, the global minimum is 1.
    | zone1 | zone2 | zone3 |
    |  P P  |  P P  |   P   |
    - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
    scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
    violate MaxSkew(1).
    - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
    When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
    to topologies that satisfy it.
    It's a required field. Default value is 1 and 0 is not allowed.
    """
    min_domains: Annotated[Optional[int], Field(alias="minDomains")] = None
    """
    MinDomains indicates a minimum number of eligible domains.
    When the number of eligible domains with matching topology keys is less than minDomains,
    Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
    And when the number of eligible domains with matching topology keys equals or greater than minDomains,
    this value has no effect on scheduling.
    As a result, when the number of eligible domains is less than minDomains,
    scheduler won't schedule more than maxSkew Pods to those domains.
    If value is nil, the constraint behaves as if MinDomains is equal to 1.
    Valid values are integers greater than 0.
    When value is not nil, WhenUnsatisfiable must be DoNotSchedule.

    For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
    labelSelector spread as 2/2/2:
    | zone1 | zone2 | zone3 |
    |  P P  |  P P  |  P P  |
    The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
    In this situation, new pod with the same labelSelector cannot be scheduled,
    because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
    it will violate MaxSkew.
    """
    node_affinity_policy: Annotated[Optional[str], Field(alias="nodeAffinityPolicy")] = None
    """
    NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
    when calculating pod topology spread skew. Options are:
    - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
    - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.

    If this value is nil, the behavior is equivalent to the Honor policy.
    This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
    """
    node_taints_policy: Annotated[Optional[str], Field(alias="nodeTaintsPolicy")] = None
    """
    NodeTaintsPolicy indicates how we will treat node taints when calculating
    pod topology spread skew. Options are:
    - Honor: nodes without taints, along with tainted nodes for which the incoming pod
    has a toleration, are included.
    - Ignore: node taints are ignored. All nodes are included.

    If this value is nil, the behavior is equivalent to the Ignore policy.
    This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
    """
    topology_key: Annotated[str, Field(alias="topologyKey")]
    """
    TopologyKey is the key of node labels. Nodes that have a label with this key
    and identical values are considered to be in the same topology.
    We consider each <key, value> as a "bucket", and try to put balanced number
    of pods into each bucket.
    We define a domain as a particular instance of a topology.
    Also, we define an eligible domain as a domain whose nodes meet the requirements of
    nodeAffinityPolicy and nodeTaintsPolicy.
    e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
    And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
    It's a required field.
    """
    when_unsatisfiable: Annotated[str, Field(alias="whenUnsatisfiable")]
    """
    WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
    the spread constraint.
    - DoNotSchedule (default) tells the scheduler not to schedule it.
    - ScheduleAnyway tells the scheduler to schedule the pod in any location,
      but giving higher precedence to topologies that would help reduce the
      skew.
    A constraint is considered "Unsatisfiable" for an incoming pod
    if and only if every possible node assignment for that pod would violate
    "MaxSkew" on some topology.
    For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
    labelSelector spread as 3/1/1:
    | zone1 | zone2 | zone3 |
    | P P P |   P   |   P   |
    If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
    to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
    MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
    won't make it *more* imbalanced.
    It's a required field.
    """


class SamplingFraction(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
            """
            self._value = value
            return self

        def build(self) -> "SamplingFraction":
            value = cast(int, self._value)
            return SamplingFraction(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
    """

    class BuilderContext(BuilderContextBase["SamplingFraction.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SamplingFraction.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SamplingFraction."""
        return cls.BuilderContext()


class SamplingFractionModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
            """
            self._value = value
            return self

        def build(self) -> "SamplingFractionModel":
            value = cast(str, self._value)
            return SamplingFractionModel(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
    """

    class BuilderContext(BuilderContextBase["SamplingFractionModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SamplingFractionModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SamplingFractionModel."""
        return cls.BuilderContext()


class TracingConfigModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TracingConfigModel"]:
            return TracingConfigModel

        def build(self) -> "TracingConfigModel":
            return TracingConfigModel(**self._attrs)

        def client_type(self, value: Optional[Literal["http", "grpc"]], /) -> Self:
            """
            Client used to export the traces. Supported values are `http` or `grpc`.
            """
            return self._set("client_type", value)

        def compression(self, value: Optional[Literal["gzip"]], /) -> Self:
            """
            Compression key for supported compression types. The only supported value is `gzip`.
            """
            return self._set("compression", value)

        def endpoint(self, value: str, /) -> Self:
            """
            Endpoint to send the traces to. Should be provided in format <host>:<port>.
            """
            return self._set("endpoint", value)

        def headers(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Key-value pairs to be used as headers associated with gRPC or HTTP requests.
            """
            return self._set("headers", value)

        def insecure(self, value: Optional[bool], /) -> Self:
            """
            If disabled, the client will use a secure connection.
            """
            return self._set("insecure", value)

        def sampling_fraction(
            self, value: Optional[Union[SamplingFraction, SamplingFractionModel]], /
        ) -> Self:
            """
            Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
            """
            return self._set("sampling_fraction", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            Maximum time the exporter will wait for each batch export.
            """
            return self._set("timeout", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel6], /
        ) -> "TracingConfigModel.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel6.Builder], TlsConfigModel6.Builder | TlsConfigModel6
            ],
            /,
        ) -> "TracingConfigModel.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel6.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS Config to use when sending traces.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel6.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel6.builder())
                if isinstance(output, TlsConfigModel6.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["TracingConfigModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TracingConfigModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TracingConfigModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TracingConfigModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TracingConfigModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    client_type: Annotated[Optional[Literal["http", "grpc"]], Field(alias="clientType")] = None
    """
    Client used to export the traces. Supported values are `http` or `grpc`.
    """
    compression: Optional[Literal["gzip"]] = None
    """
    Compression key for supported compression types. The only supported value is `gzip`.
    """
    endpoint: Annotated[str, Field(min_length=1)]
    """
    Endpoint to send the traces to. Should be provided in format <host>:<port>.
    """
    headers: Optional[Dict[str, str]] = None
    """
    Key-value pairs to be used as headers associated with gRPC or HTTP requests.
    """
    insecure: Optional[bool] = None
    """
    If disabled, the client will use a secure connection.
    """
    sampling_fraction: Annotated[
        Optional[Union[SamplingFraction, SamplingFractionModel]],
        Field(alias="samplingFraction"),
    ] = None
    """
    Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
    """
    timeout: Annotated[
        Optional[str],
        Field(
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"
        ),
    ] = None
    """
    Maximum time the exporter will wait for each batch export.
    """
    tls_config: Annotated[Optional[TlsConfigModel6], Field(alias="tlsConfig")] = None
    """
    TLS Config to use when sending traces.
    """


class Tsdb(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Tsdb"]:
            return Tsdb

        def build(self) -> "Tsdb":
            return Tsdb(**self._attrs)

        def out_of_order_time_window(self, value: Optional[str], /) -> Self:
            """
            Configures how old an out-of-order/out-of-bounds sample can be with
            respect to the TSDB max time.

            An out-of-order/out-of-bounds sample is ingested into the TSDB as long as
            the timestamp of the sample is >= (TSDB.MaxTime - outOfOrderTimeWindow).

            This is an *experimental feature*, it may change in any upcoming release
            in a breaking way.

            It requires Prometheus >= v2.39.0 or PrometheusAgent >= v2.54.0.
            """
            return self._set("out_of_order_time_window", value)

    class BuilderContext(BuilderContextBase["Tsdb.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Tsdb.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Tsdb."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Tsdb", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Tsdb.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    out_of_order_time_window: Annotated[
        Optional[str],
        Field(
            alias="outOfOrderTimeWindow",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Configures how old an out-of-order/out-of-bounds sample can be with
    respect to the TSDB max time.

    An out-of-order/out-of-bounds sample is ingested into the TSDB as long as
    the timestamp of the sample is >= (TSDB.MaxTime - outOfOrderTimeWindow).

    This is an *experimental feature*, it may change in any upcoming release
    in a breaking way.

    It requires Prometheus >= v2.39.0 or PrometheusAgent >= v2.54.0.
    """


class SecretRefModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretRefModel2"]:
            return SecretRefModel2

        def build(self) -> "SecretRefModel2":
            return SecretRefModel2(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["SecretRefModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretRefModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretRefModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretRefModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRefModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """


class ConfigMapModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapModel3"]:
            return ConfigMapModel3

        def build(self) -> "ConfigMapModel3":
            return ConfigMapModel3(**self._attrs)

        def default_mode(self, value: Optional[int], /) -> Self:
            """
            defaultMode is optional: mode bits used to set permissions on created files by default.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            Defaults to 0644.
            Directories within the path are not affected by this setting.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("default_mode", value)

        @overload
        def items(self, value_or_callback: List[ItemModel3], /) -> "ConfigMapModel3.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel3, ItemModel3.Builder]],
                GenericListBuilder[ItemModel3, ItemModel3.Builder] | List[ItemModel3],
            ],
            /,
        ) -> "ConfigMapModel3.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel3.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items if unspecified, each key-value pair in the Data field of the referenced
            ConfigMap will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the ConfigMap,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel3.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel3.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional specify whether the ConfigMap or its keys must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_mode: Annotated[Optional[int], Field(alias="defaultMode")] = None
    """
    defaultMode is optional: mode bits used to set permissions on created files by default.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    Defaults to 0644.
    Directories within the path are not affected by this setting.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    items: Optional[List[ItemModel3]] = None
    """
    items if unspecified, each key-value pair in the Data field of the referenced
    ConfigMap will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the ConfigMap,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    optional specify whether the ConfigMap or its keys must be defined
    """


class DivisorModel11(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel11":
            value = cast(int, self._value)
            return DivisorModel11(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel11.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel11.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel11."""
        return cls.BuilderContext()


class DivisorModel12(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel12":
            value = cast(str, self._value)
            return DivisorModel12(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel12.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel12.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel12."""
        return cls.BuilderContext()


class ItemModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ItemModel4"]:
            return ItemModel4

        def build(self) -> "ItemModel4":
            return ItemModel4(**self._attrs)

        @overload
        def field_ref(self, value_or_callback: Optional[FieldRef], /) -> "ItemModel4.Builder": ...

        @overload
        def field_ref(
            self,
            value_or_callback: Callable[[FieldRef.Builder], FieldRef.Builder | FieldRef],
            /,
        ) -> "ItemModel4.Builder": ...

        @overload
        def field_ref(self, value_or_callback: Never = ...) -> "FieldRef.BuilderContext": ...

        def field_ref(self, value_or_callback=None, /):
            """
            Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
            """
            if self._in_context and value_or_callback is None:
                context = FieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FieldRef.builder())
                if isinstance(output, FieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("field_ref", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            Optional: mode bits used to set permissions on this file, must be an octal value
            between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
            """
            return self._set("path", value)

        @overload
        def resource_field_ref(
            self, value_or_callback: Optional[ResourceFieldRef], /
        ) -> "ItemModel4.Builder": ...

        @overload
        def resource_field_ref(
            self,
            value_or_callback: Callable[
                [ResourceFieldRef.Builder], ResourceFieldRef.Builder | ResourceFieldRef
            ],
            /,
        ) -> "ItemModel4.Builder": ...

        @overload
        def resource_field_ref(
            self, value_or_callback: Never = ...
        ) -> "ResourceFieldRef.BuilderContext": ...

        def resource_field_ref(self, value_or_callback=None, /):
            """
            Selects a resource of the container: only resources limits and requests
            (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceFieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource_field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceFieldRef.builder())
                if isinstance(output, ResourceFieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_field_ref", value)

    class BuilderContext(BuilderContextBase["ItemModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ItemModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ItemModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ItemModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ItemModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    field_ref: Annotated[Optional[FieldRef], Field(alias="fieldRef")] = None
    """
    Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
    """
    mode: Optional[int] = None
    """
    Optional: mode bits used to set permissions on this file, must be an octal value
    between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    """
    resource_field_ref: Annotated[Optional[ResourceFieldRef], Field(alias="resourceFieldRef")] = (
        None
    )
    """
    Selects a resource of the container: only resources limits and requests
    (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    """


class DownwardApiModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DownwardApiModel1"]:
            return DownwardApiModel1

        def build(self) -> "DownwardApiModel1":
            return DownwardApiModel1(**self._attrs)

        def default_mode(self, value: Optional[int], /) -> Self:
            """
            Optional: mode bits to use on created files by default. Must be a
            Optional: mode bits used to set permissions on created files by default.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            Defaults to 0644.
            Directories within the path are not affected by this setting.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("default_mode", value)

        @overload
        def items(self, value_or_callback: List[ItemModel4], /) -> "DownwardApiModel1.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel4, ItemModel4.Builder]],
                GenericListBuilder[ItemModel4, ItemModel4.Builder] | List[ItemModel4],
            ],
            /,
        ) -> "DownwardApiModel1.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel4.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            Items is a list of downward API volume file
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel4.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel4.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

    class BuilderContext(BuilderContextBase["DownwardApiModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DownwardApiModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DownwardApiModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DownwardApiModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DownwardApiModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_mode: Annotated[Optional[int], Field(alias="defaultMode")] = None
    """
    Optional: mode bits to use on created files by default. Must be a
    Optional: mode bits used to set permissions on created files by default.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    Defaults to 0644.
    Directories within the path are not affected by this setting.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    items: Optional[List[ItemModel4]] = None
    """
    Items is a list of downward API volume file
    """


class SizeLimitModel5(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def build(self) -> "SizeLimitModel5":
            value = cast(int, self._value)
            return SizeLimitModel5(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    sizeLimit is the total amount of local storage required for this EmptyDir volume.
    The size limit is also applicable for memory medium.
    The maximum usage on memory medium EmptyDir would be the minimum value between
    the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    The default is nil which means that the limit is undefined.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    """

    class BuilderContext(BuilderContextBase["SizeLimitModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SizeLimitModel5.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SizeLimitModel5."""
        return cls.BuilderContext()


class SizeLimitModel6(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def build(self) -> "SizeLimitModel6":
            value = cast(str, self._value)
            return SizeLimitModel6(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    sizeLimit is the total amount of local storage required for this EmptyDir volume.
    The size limit is also applicable for memory medium.
    The maximum usage on memory medium EmptyDir would be the minimum value between
    the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    The default is nil which means that the limit is undefined.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    """

    class BuilderContext(BuilderContextBase["SizeLimitModel6.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SizeLimitModel6.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SizeLimitModel6."""
        return cls.BuilderContext()


class LimitsModel23(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel23":
            value = cast(int, self._value)
            return LimitsModel23(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel23.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel23.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel23."""
        return cls.BuilderContext()


class LimitsModel24(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel24":
            value = cast(str, self._value)
            return LimitsModel24(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel24.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel24.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel24."""
        return cls.BuilderContext()


class RequestsModel23(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel23":
            value = cast(int, self._value)
            return RequestsModel23(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel23.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel23.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel23."""
        return cls.BuilderContext()


class RequestsModel24(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel24":
            value = cast(str, self._value)
            return RequestsModel24(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel24.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel24.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel24."""
        return cls.BuilderContext()


class ResourcesModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourcesModel4"]:
            return ResourcesModel4

        def build(self) -> "ResourcesModel4":
            return ResourcesModel4(**self._attrs)

        def limits(
            self, value: Optional[Dict[str, Union[LimitsModel23, LimitsModel24]]], /
        ) -> Self:
            """
            Limits describes the maximum amount of compute resources allowed.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            return self._set("limits", value)

        def requests(
            self, value: Optional[Dict[str, Union[RequestsModel23, RequestsModel24]]], /
        ) -> Self:
            """
            Requests describes the minimum amount of compute resources required.
            If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
            otherwise to an implementation-defined value. Requests cannot exceed Limits.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            return self._set("requests", value)

    class BuilderContext(BuilderContextBase["ResourcesModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourcesModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourcesModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourcesModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourcesModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    limits: Optional[Dict[str, Union[LimitsModel23, LimitsModel24]]] = None
    """
    Limits describes the maximum amount of compute resources allowed.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """
    requests: Optional[Dict[str, Union[RequestsModel23, RequestsModel24]]] = None
    """
    Requests describes the minimum amount of compute resources required.
    If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    otherwise to an implementation-defined value. Requests cannot exceed Limits.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """


class VolumeClaimTemplateModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VolumeClaimTemplateModel3"]:
            return VolumeClaimTemplateModel3

        def build(self) -> "VolumeClaimTemplateModel3":
            return VolumeClaimTemplateModel3(**self._attrs)

        def metadata(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            May contain labels and annotations that will be copied into the PVC
            when creating it. No other fields are allowed and will be rejected during
            validation.
            """
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Spec, /) -> "VolumeClaimTemplateModel3.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Callable[[Spec.Builder], Spec.Builder | Spec], /
        ) -> "VolumeClaimTemplateModel3.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "Spec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            """
            The specification for the PersistentVolumeClaim. The entire content is
            copied unchanged into the PVC that gets created from this
            template. The same fields as in a PersistentVolumeClaim
            are also valid here.
            """
            if self._in_context and value_or_callback is None:
                context = Spec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Spec.builder())
                if isinstance(output, Spec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["VolumeClaimTemplateModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VolumeClaimTemplateModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VolumeClaimTemplateModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VolumeClaimTemplateModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VolumeClaimTemplateModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    metadata: Optional[Dict[str, Any]] = None
    """
    May contain labels and annotations that will be copied into the PVC
    when creating it. No other fields are allowed and will be rejected during
    validation.
    """
    spec: Spec
    """
    The specification for the PersistentVolumeClaim. The entire content is
    copied unchanged into the PVC that gets created from this
    template. The same fields as in a PersistentVolumeClaim
    are also valid here.
    """


class ItemModel5(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ItemModel5"]:
            return ItemModel5

        def build(self) -> "ItemModel5":
            return ItemModel5(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key is the key to project.
            """
            return self._set("key", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            mode is Optional: mode bits used to set permissions on this file.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            path is the relative path of the file to map the key to.
            May not be an absolute path.
            May not contain the path element '..'.
            May not start with the string '..'.
            """
            return self._set("path", value)

    class BuilderContext(BuilderContextBase["ItemModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ItemModel5.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ItemModel5."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ItemModel5", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ItemModel5.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key is the key to project.
    """
    mode: Optional[int] = None
    """
    mode is Optional: mode bits used to set permissions on this file.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    path is the relative path of the file to map the key to.
    May not be an absolute path.
    May not contain the path element '..'.
    May not start with the string '..'.
    """


class ConfigMapModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapModel4"]:
            return ConfigMapModel4

        def build(self) -> "ConfigMapModel4":
            return ConfigMapModel4(**self._attrs)

        @overload
        def items(self, value_or_callback: List[ItemModel5], /) -> "ConfigMapModel4.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel5, ItemModel5.Builder]],
                GenericListBuilder[ItemModel5, ItemModel5.Builder] | List[ItemModel5],
            ],
            /,
        ) -> "ConfigMapModel4.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel5.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items if unspecified, each key-value pair in the Data field of the referenced
            ConfigMap will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the ConfigMap,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel5.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel5.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional specify whether the ConfigMap or its keys must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    items: Optional[List[ItemModel5]] = None
    """
    items if unspecified, each key-value pair in the Data field of the referenced
    ConfigMap will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the ConfigMap,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    optional specify whether the ConfigMap or its keys must be defined
    """


class DivisorModel13(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel13":
            value = cast(int, self._value)
            return DivisorModel13(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel13.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel13.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel13."""
        return cls.BuilderContext()


class DivisorModel14(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel14":
            value = cast(str, self._value)
            return DivisorModel14(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel14.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel14.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel14."""
        return cls.BuilderContext()


class ItemModel6(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ItemModel6"]:
            return ItemModel6

        def build(self) -> "ItemModel6":
            return ItemModel6(**self._attrs)

        @overload
        def field_ref(self, value_or_callback: Optional[FieldRef], /) -> "ItemModel6.Builder": ...

        @overload
        def field_ref(
            self,
            value_or_callback: Callable[[FieldRef.Builder], FieldRef.Builder | FieldRef],
            /,
        ) -> "ItemModel6.Builder": ...

        @overload
        def field_ref(self, value_or_callback: Never = ...) -> "FieldRef.BuilderContext": ...

        def field_ref(self, value_or_callback=None, /):
            """
            Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
            """
            if self._in_context and value_or_callback is None:
                context = FieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FieldRef.builder())
                if isinstance(output, FieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("field_ref", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            Optional: mode bits used to set permissions on this file, must be an octal value
            between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
            """
            return self._set("path", value)

        @overload
        def resource_field_ref(
            self, value_or_callback: Optional[ResourceFieldRef], /
        ) -> "ItemModel6.Builder": ...

        @overload
        def resource_field_ref(
            self,
            value_or_callback: Callable[
                [ResourceFieldRef.Builder], ResourceFieldRef.Builder | ResourceFieldRef
            ],
            /,
        ) -> "ItemModel6.Builder": ...

        @overload
        def resource_field_ref(
            self, value_or_callback: Never = ...
        ) -> "ResourceFieldRef.BuilderContext": ...

        def resource_field_ref(self, value_or_callback=None, /):
            """
            Selects a resource of the container: only resources limits and requests
            (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceFieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource_field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceFieldRef.builder())
                if isinstance(output, ResourceFieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_field_ref", value)

    class BuilderContext(BuilderContextBase["ItemModel6.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ItemModel6.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ItemModel6."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ItemModel6", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ItemModel6.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    field_ref: Annotated[Optional[FieldRef], Field(alias="fieldRef")] = None
    """
    Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
    """
    mode: Optional[int] = None
    """
    Optional: mode bits used to set permissions on this file, must be an octal value
    between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    """
    resource_field_ref: Annotated[Optional[ResourceFieldRef], Field(alias="resourceFieldRef")] = (
        None
    )
    """
    Selects a resource of the container: only resources limits and requests
    (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    """


class DownwardApiModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DownwardApiModel2"]:
            return DownwardApiModel2

        def build(self) -> "DownwardApiModel2":
            return DownwardApiModel2(**self._attrs)

        @overload
        def items(self, value_or_callback: List[ItemModel6], /) -> "DownwardApiModel2.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel6, ItemModel6.Builder]],
                GenericListBuilder[ItemModel6, ItemModel6.Builder] | List[ItemModel6],
            ],
            /,
        ) -> "DownwardApiModel2.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel6.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            Items is a list of DownwardAPIVolume file
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel6.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel6.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

    class BuilderContext(BuilderContextBase["DownwardApiModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DownwardApiModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DownwardApiModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DownwardApiModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DownwardApiModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    items: Optional[List[ItemModel6]] = None
    """
    Items is a list of DownwardAPIVolume file
    """


class ItemModel7(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ItemModel7"]:
            return ItemModel7

        def build(self) -> "ItemModel7":
            return ItemModel7(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key is the key to project.
            """
            return self._set("key", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            mode is Optional: mode bits used to set permissions on this file.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            path is the relative path of the file to map the key to.
            May not be an absolute path.
            May not contain the path element '..'.
            May not start with the string '..'.
            """
            return self._set("path", value)

    class BuilderContext(BuilderContextBase["ItemModel7.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ItemModel7.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ItemModel7."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ItemModel7", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ItemModel7.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key is the key to project.
    """
    mode: Optional[int] = None
    """
    mode is Optional: mode bits used to set permissions on this file.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    path is the relative path of the file to map the key to.
    May not be an absolute path.
    May not contain the path element '..'.
    May not start with the string '..'.
    """


class SecretModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretModel3"]:
            return SecretModel3

        def build(self) -> "SecretModel3":
            return SecretModel3(**self._attrs)

        @overload
        def items(self, value_or_callback: List[ItemModel7], /) -> "SecretModel3.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel7, ItemModel7.Builder]],
                GenericListBuilder[ItemModel7, ItemModel7.Builder] | List[ItemModel7],
            ],
            /,
        ) -> "SecretModel3.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel7.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items if unspecified, each key-value pair in the Data field of the referenced
            Secret will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the Secret,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel7.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel7.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional field specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["SecretModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    items: Optional[List[ItemModel7]] = None
    """
    items if unspecified, each key-value pair in the Data field of the referenced
    Secret will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the Secret,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    optional field specify whether the Secret or its key must be defined
    """


class SecretModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretModel4"]:
            return SecretModel4

        def build(self) -> "SecretModel4":
            return SecretModel4(**self._attrs)

        def default_mode(self, value: Optional[int], /) -> Self:
            """
            defaultMode is Optional: mode bits used to set permissions on created files by default.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values
            for mode bits. Defaults to 0644.
            Directories within the path are not affected by this setting.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("default_mode", value)

        @overload
        def items(self, value_or_callback: List[ItemModel7], /) -> "SecretModel4.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel7, ItemModel7.Builder]],
                GenericListBuilder[ItemModel7, ItemModel7.Builder] | List[ItemModel7],
            ],
            /,
        ) -> "SecretModel4.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel7.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items If unspecified, each key-value pair in the Data field of the referenced
            Secret will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the Secret,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel7.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel7.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional field specify whether the Secret or its keys must be defined
            """
            return self._set("optional", value)

        def secret_name(self, value: Optional[str], /) -> Self:
            """
            secretName is the name of the secret in the pod's namespace to use.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
            """
            return self._set("secret_name", value)

    class BuilderContext(BuilderContextBase["SecretModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_mode: Annotated[Optional[int], Field(alias="defaultMode")] = None
    """
    defaultMode is Optional: mode bits used to set permissions on created files by default.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values
    for mode bits. Defaults to 0644.
    Directories within the path are not affected by this setting.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    items: Optional[List[ItemModel7]] = None
    """
    items If unspecified, each key-value pair in the Data field of the referenced
    Secret will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the Secret,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    optional: Optional[bool] = None
    """
    optional field specify whether the Secret or its keys must be defined
    """
    secret_name: Annotated[Optional[str], Field(alias="secretName")] = None
    """
    secretName is the name of the secret in the pod's namespace to use.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
    """


class ConfigMapModel5(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapModel5"]:
            return ConfigMapModel5

        def build(self) -> "ConfigMapModel5":
            return ConfigMapModel5(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key to select.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the ConfigMap or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapModel5.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapModel5."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapModel5", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapModel5.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key to select.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the ConfigMap or its key must be defined
    """


class SecretModel5(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretModel5"]:
            return SecretModel5

        def build(self) -> "SecretModel5":
            return SecretModel5(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["SecretModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretModel5.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretModel5."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretModel5", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretModel5.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class TlsConfigModel7(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsConfigModel7"]:
            return TlsConfigModel7

        def build(self) -> "TlsConfigModel7":
            return TlsConfigModel7(**self._attrs)

        @overload
        def cert(self, value_or_callback: Optional[Cert], /) -> "TlsConfigModel7.Builder": ...

        @overload
        def cert(
            self, value_or_callback: Callable[[Cert.Builder], Cert.Builder | Cert], /
        ) -> "TlsConfigModel7.Builder": ...

        @overload
        def cert(self, value_or_callback: Never = ...) -> "Cert.BuilderContext": ...

        def cert(self, value_or_callback=None, /):
            """
            Secret or ConfigMap containing the TLS certificate for the web server.

            Either `keySecret` or `keyFile` must be defined.

            It is mutually exclusive with `certFile`.
            """
            if self._in_context and value_or_callback is None:
                context = Cert.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cert.builder())
                if isinstance(output, Cert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert", value)

        def cert_file(self, value: Optional[str], /) -> Self:
            """
            Path to the TLS certificate file in the container for the web server.

            Either `keySecret` or `keyFile` must be defined.

            It is mutually exclusive with `cert`.
            """
            return self._set("cert_file", value)

        def cipher_suites(self, value: Optional[List[str]], /) -> Self:
            """
            List of supported cipher suites for TLS versions up to TLS 1.2.

            If not defined, the Go default cipher suites are used.
            Available cipher suites are documented in the Go documentation:
            https://golang.org/pkg/crypto/tls/#pkg-constants
            """
            return self._set("cipher_suites", value)

        @overload
        def client_ca(
            self, value_or_callback: Optional[ClientCa], /
        ) -> "TlsConfigModel7.Builder": ...

        @overload
        def client_ca(
            self,
            value_or_callback: Callable[[ClientCa.Builder], ClientCa.Builder | ClientCa],
            /,
        ) -> "TlsConfigModel7.Builder": ...

        @overload
        def client_ca(self, value_or_callback: Never = ...) -> "ClientCa.BuilderContext": ...

        def client_ca(self, value_or_callback=None, /):
            """
            Secret or ConfigMap containing the CA certificate for client certificate
            authentication to the server.

            It is mutually exclusive with `clientCAFile`.
            """
            if self._in_context and value_or_callback is None:
                context = ClientCa.BuilderContext()
                context._parent_builder = self
                context._field_name = "client_ca"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClientCa.builder())
                if isinstance(output, ClientCa.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("client_ca", value)

        def client_auth_type(self, value: Optional[str], /) -> Self:
            """
            The server policy for client TLS authentication.

            For more detail on clientAuth options:
            https://golang.org/pkg/crypto/tls/#ClientAuthType
            """
            return self._set("client_auth_type", value)

        def client_ca_file(self, value: Optional[str], /) -> Self:
            """
            Path to the CA certificate file for client certificate authentication to
            the server.

            It is mutually exclusive with `client_ca`.
            """
            return self._set("client_ca_file", value)

        def curve_preferences(self, value: Optional[List[str]], /) -> Self:
            """
            Elliptic curves that will be used in an ECDHE handshake, in preference
            order.

            Available curves are documented in the Go documentation:
            https://golang.org/pkg/crypto/tls/#CurveID
            """
            return self._set("curve_preferences", value)

        def key_file(self, value: Optional[str], /) -> Self:
            """
            Path to the TLS private key file in the container for the web server.

            If defined, either `cert` or `certFile` must be defined.

            It is mutually exclusive with `keySecret`.
            """
            return self._set("key_file", value)

        @overload
        def key_secret(
            self, value_or_callback: Optional[KeySecret], /
        ) -> "TlsConfigModel7.Builder": ...

        @overload
        def key_secret(
            self,
            value_or_callback: Callable[[KeySecret.Builder], KeySecret.Builder | KeySecret],
            /,
        ) -> "TlsConfigModel7.Builder": ...

        @overload
        def key_secret(self, value_or_callback: Never = ...) -> "KeySecret.BuilderContext": ...

        def key_secret(self, value_or_callback=None, /):
            """
            Secret containing the TLS private key for the web server.

            Either `cert` or `certFile` must be defined.

            It is mutually exclusive with `keyFile`.
            """
            if self._in_context and value_or_callback is None:
                context = KeySecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "key_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KeySecret.builder())
                if isinstance(output, KeySecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("key_secret", value)

        def max_version(self, value: Optional[str], /) -> Self:
            """
            Maximum TLS version that is acceptable.
            """
            return self._set("max_version", value)

        def min_version(self, value: Optional[str], /) -> Self:
            """
            Minimum TLS version that is acceptable.
            """
            return self._set("min_version", value)

        def prefer_server_cipher_suites(self, value: Optional[bool], /) -> Self:
            """
            Controls whether the server selects the client's most preferred cipher
            suite, or the server's most preferred cipher suite.

            If true then the server's preference, as expressed in
            the order of elements in cipherSuites, is used.
            """
            return self._set("prefer_server_cipher_suites", value)

    class BuilderContext(BuilderContextBase["TlsConfigModel7.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsConfigModel7.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsConfigModel7."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsConfigModel7", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsConfigModel7.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cert: Optional[Cert] = None
    """
    Secret or ConfigMap containing the TLS certificate for the web server.

    Either `keySecret` or `keyFile` must be defined.

    It is mutually exclusive with `certFile`.
    """
    cert_file: Annotated[Optional[str], Field(alias="certFile")] = None
    """
    Path to the TLS certificate file in the container for the web server.

    Either `keySecret` or `keyFile` must be defined.

    It is mutually exclusive with `cert`.
    """
    cipher_suites: Annotated[Optional[List[str]], Field(alias="cipherSuites")] = None
    """
    List of supported cipher suites for TLS versions up to TLS 1.2.

    If not defined, the Go default cipher suites are used.
    Available cipher suites are documented in the Go documentation:
    https://golang.org/pkg/crypto/tls/#pkg-constants
    """
    client_ca: Optional[ClientCa] = None
    """
    Secret or ConfigMap containing the CA certificate for client certificate
    authentication to the server.

    It is mutually exclusive with `clientCAFile`.
    """
    client_auth_type: Annotated[Optional[str], Field(alias="clientAuthType")] = None
    """
    The server policy for client TLS authentication.

    For more detail on clientAuth options:
    https://golang.org/pkg/crypto/tls/#ClientAuthType
    """
    client_ca_file: Annotated[Optional[str], Field(alias="clientCAFile")] = None
    """
    Path to the CA certificate file for client certificate authentication to
    the server.

    It is mutually exclusive with `client_ca`.
    """
    curve_preferences: Annotated[Optional[List[str]], Field(alias="curvePreferences")] = None
    """
    Elliptic curves that will be used in an ECDHE handshake, in preference
    order.

    Available curves are documented in the Go documentation:
    https://golang.org/pkg/crypto/tls/#CurveID
    """
    key_file: Annotated[Optional[str], Field(alias="keyFile")] = None
    """
    Path to the TLS private key file in the container for the web server.

    If defined, either `cert` or `certFile` must be defined.

    It is mutually exclusive with `keySecret`.
    """
    key_secret: Annotated[Optional[KeySecret], Field(alias="keySecret")] = None
    """
    Secret containing the TLS private key for the web server.

    Either `cert` or `certFile` must be defined.

    It is mutually exclusive with `keyFile`.
    """
    max_version: Annotated[Optional[str], Field(alias="maxVersion")] = None
    """
    Maximum TLS version that is acceptable.
    """
    min_version: Annotated[Optional[str], Field(alias="minVersion")] = None
    """
    Minimum TLS version that is acceptable.
    """
    prefer_server_cipher_suites: Annotated[
        Optional[bool], Field(alias="preferServerCipherSuites")
    ] = None
    """
    Controls whether the server selects the client's most preferred cipher
    suite, or the server's most preferred cipher suite.

    If true then the server's preference, as expressed in
    the order of elements in cipherSuites, is used.
    """


class WebModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WebModel"]:
            return WebModel

        def build(self) -> "WebModel":
            return WebModel(**self._attrs)

        @overload
        def http_config(
            self, value_or_callback: Optional[HttpConfigModel], /
        ) -> "WebModel.Builder": ...

        @overload
        def http_config(
            self,
            value_or_callback: Callable[
                [HttpConfigModel.Builder], HttpConfigModel.Builder | HttpConfigModel
            ],
            /,
        ) -> "WebModel.Builder": ...

        @overload
        def http_config(
            self, value_or_callback: Never = ...
        ) -> "HttpConfigModel.BuilderContext": ...

        def http_config(self, value_or_callback=None, /):
            """
            Defines HTTP parameters for web server.
            """
            if self._in_context and value_or_callback is None:
                context = HttpConfigModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpConfigModel.builder())
                if isinstance(output, HttpConfigModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_config", value)

        def max_connections(self, value: Optional[int], /) -> Self:
            """
            Defines the maximum number of simultaneous connections
            A zero value means that Prometheus doesn't accept any incoming connection.
            """
            return self._set("max_connections", value)

        def page_title(self, value: Optional[str], /) -> Self:
            """
            The prometheus web page title.
            """
            return self._set("page_title", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel7], /
        ) -> "WebModel.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel7.Builder], TlsConfigModel7.Builder | TlsConfigModel7
            ],
            /,
        ) -> "WebModel.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel7.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            Defines the TLS parameters for HTTPS.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel7.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel7.builder())
                if isinstance(output, TlsConfigModel7.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["WebModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WebModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WebModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WebModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WebModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    http_config: Annotated[Optional[HttpConfigModel], Field(alias="httpConfig")] = None
    """
    Defines HTTP parameters for web server.
    """
    max_connections: Annotated[Optional[int], Field(alias="maxConnections", ge=0)] = None
    """
    Defines the maximum number of simultaneous connections
    A zero value means that Prometheus doesn't accept any incoming connection.
    """
    page_title: Annotated[Optional[str], Field(alias="pageTitle")] = None
    """
    The prometheus web page title.
    """
    tls_config: Annotated[Optional[TlsConfigModel7], Field(alias="tlsConfig")] = None
    """
    Defines the TLS parameters for HTTPS.
    """


class PrometheusSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PrometheusSpec"]:
            return PrometheusSpec

        def build(self) -> "PrometheusSpec":
            return PrometheusSpec(**self._attrs)

        @overload
        def additional_alert_manager_configs(
            self, value_or_callback: Optional[AdditionalAlertManagerConfigs], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def additional_alert_manager_configs(
            self,
            value_or_callback: Callable[
                [AdditionalAlertManagerConfigs.Builder],
                AdditionalAlertManagerConfigs.Builder | AdditionalAlertManagerConfigs,
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def additional_alert_manager_configs(
            self, value_or_callback: Never = ...
        ) -> "AdditionalAlertManagerConfigs.BuilderContext": ...

        def additional_alert_manager_configs(self, value_or_callback=None, /):
            """
            AdditionalAlertManagerConfigs specifies a key of a Secret containing
            additional Prometheus Alertmanager configurations. The Alertmanager
            configurations are appended to the configuration generated by the
            Prometheus Operator. They must be formatted according to the official
            Prometheus documentation:

            https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alertmanager_config

            The user is responsible for making sure that the configurations are valid

            Note that using this feature may expose the possibility to break
            upgrades of Prometheus. It is advised to review Prometheus release notes
            to ensure that no incompatible AlertManager configs are going to break
            Prometheus after the upgrade.
            """
            if self._in_context and value_or_callback is None:
                context = AdditionalAlertManagerConfigs.BuilderContext()
                context._parent_builder = self
                context._field_name = "additional_alert_manager_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AdditionalAlertManagerConfigs.builder())
                if isinstance(output, AdditionalAlertManagerConfigs.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("additional_alert_manager_configs", value)

        @overload
        def additional_alert_relabel_configs(
            self, value_or_callback: Optional[AdditionalAlertRelabelConfigs], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def additional_alert_relabel_configs(
            self,
            value_or_callback: Callable[
                [AdditionalAlertRelabelConfigs.Builder],
                AdditionalAlertRelabelConfigs.Builder | AdditionalAlertRelabelConfigs,
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def additional_alert_relabel_configs(
            self, value_or_callback: Never = ...
        ) -> "AdditionalAlertRelabelConfigs.BuilderContext": ...

        def additional_alert_relabel_configs(self, value_or_callback=None, /):
            """
            AdditionalAlertRelabelConfigs specifies a key of a Secret containing
            additional Prometheus alert relabel configurations. The alert relabel
            configurations are appended to the configuration generated by the
            Prometheus Operator. They must be formatted according to the official
            Prometheus documentation:

            https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs

            The user is responsible for making sure that the configurations are valid

            Note that using this feature may expose the possibility to break
            upgrades of Prometheus. It is advised to review Prometheus release notes
            to ensure that no incompatible alert relabel configs are going to break
            Prometheus after the upgrade.
            """
            if self._in_context and value_or_callback is None:
                context = AdditionalAlertRelabelConfigs.BuilderContext()
                context._parent_builder = self
                context._field_name = "additional_alert_relabel_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AdditionalAlertRelabelConfigs.builder())
                if isinstance(output, AdditionalAlertRelabelConfigs.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("additional_alert_relabel_configs", value)

        @overload
        def additional_args(
            self, value_or_callback: List[AdditionalArg], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def additional_args(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AdditionalArg, AdditionalArg.Builder]],
                GenericListBuilder[AdditionalArg, AdditionalArg.Builder] | List[AdditionalArg],
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def additional_args(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[AdditionalArg.Builder]: ...

        def additional_args(self, value_or_callback=None, /):
            """
            AdditionalArgs allows setting additional arguments for the 'prometheus' container.

            It is intended for e.g. activating hidden flags which are not supported by
            the dedicated configuration options yet. The arguments are passed as-is to the
            Prometheus container which may cause issues if they are invalid or not supported
            by the given Prometheus version.

            In case of an argument conflict (e.g. an argument which is already set by the
            operator itself) or when providing an invalid argument, the reconciliation will
            fail and an error will be logged.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AdditionalArg.Builder]()
                context._parent_builder = self
                context._field_name = "additional_args"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AdditionalArg.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("additional_args", value)

        @overload
        def additional_scrape_configs(
            self, value_or_callback: Optional[AdditionalScrapeConfigs], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def additional_scrape_configs(
            self,
            value_or_callback: Callable[
                [AdditionalScrapeConfigs.Builder],
                AdditionalScrapeConfigs.Builder | AdditionalScrapeConfigs,
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def additional_scrape_configs(
            self, value_or_callback: Never = ...
        ) -> "AdditionalScrapeConfigs.BuilderContext": ...

        def additional_scrape_configs(self, value_or_callback=None, /):
            """
            AdditionalScrapeConfigs allows specifying a key of a Secret containing
            additional Prometheus scrape configurations. Scrape configurations
            specified are appended to the configurations generated by the Prometheus
            Operator. Job configurations specified must have the form as specified
            in the official Prometheus documentation:
            https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config.
            As scrape configs are appended, the user is responsible to make sure it
            is valid. Note that using this feature may expose the possibility to
            break upgrades of Prometheus. It is advised to review Prometheus release
            notes to ensure that no incompatible scrape configs are going to break
            Prometheus after the upgrade.
            """
            if self._in_context and value_or_callback is None:
                context = AdditionalScrapeConfigs.BuilderContext()
                context._parent_builder = self
                context._field_name = "additional_scrape_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AdditionalScrapeConfigs.builder())
                if isinstance(output, AdditionalScrapeConfigs.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("additional_scrape_configs", value)

        @overload
        def affinity(
            self, value_or_callback: Optional[Affinity], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def affinity(
            self,
            value_or_callback: Callable[[Affinity.Builder], Affinity.Builder | Affinity],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def affinity(self, value_or_callback: Never = ...) -> "Affinity.BuilderContext": ...

        def affinity(self, value_or_callback=None, /):
            """
            Defines the Pods' affinity scheduling rules if specified.
            """
            if self._in_context and value_or_callback is None:
                context = Affinity.BuilderContext()
                context._parent_builder = self
                context._field_name = "affinity"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Affinity.builder())
                if isinstance(output, Affinity.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("affinity", value)

        @overload
        def alerting(
            self, value_or_callback: Optional[Alerting], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def alerting(
            self,
            value_or_callback: Callable[[Alerting.Builder], Alerting.Builder | Alerting],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def alerting(self, value_or_callback: Never = ...) -> "Alerting.BuilderContext": ...

        def alerting(self, value_or_callback=None, /):
            """
            Defines the settings related to Alertmanager.
            """
            if self._in_context and value_or_callback is None:
                context = Alerting.BuilderContext()
                context._parent_builder = self
                context._field_name = "alerting"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Alerting.builder())
                if isinstance(output, Alerting.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("alerting", value)

        def allow_overlapping_blocks(self, value: Optional[bool], /) -> Self:
            """
            AllowOverlappingBlocks enables vertical compaction and vertical query
            merge in Prometheus.

            Deprecated: this flag has no effect for Prometheus >= 2.39.0 where overlapping blocks are enabled by default.
            """
            return self._set("allow_overlapping_blocks", value)

        @overload
        def apiserver_config(
            self, value_or_callback: Optional[ApiserverConfig], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def apiserver_config(
            self,
            value_or_callback: Callable[
                [ApiserverConfig.Builder], ApiserverConfig.Builder | ApiserverConfig
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def apiserver_config(
            self, value_or_callback: Never = ...
        ) -> "ApiserverConfig.BuilderContext": ...

        def apiserver_config(self, value_or_callback=None, /):
            """
            APIServerConfig allows specifying a host and auth methods to access the
            Kuberntees API server.
            If null, Prometheus is assumed to run inside of the cluster: it will
            discover the API servers automatically and use the Pod's CA certificate
            and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
            """
            if self._in_context and value_or_callback is None:
                context = ApiserverConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "apiserver_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ApiserverConfig.builder())
                if isinstance(output, ApiserverConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("apiserver_config", value)

        @overload
        def arbitrary_fs_access_through_s_ms(
            self, value_or_callback: Optional[ArbitraryFsAccessThroughSMs], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def arbitrary_fs_access_through_s_ms(
            self,
            value_or_callback: Callable[
                [ArbitraryFsAccessThroughSMs.Builder],
                ArbitraryFsAccessThroughSMs.Builder | ArbitraryFsAccessThroughSMs,
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def arbitrary_fs_access_through_s_ms(
            self, value_or_callback: Never = ...
        ) -> "ArbitraryFsAccessThroughSMs.BuilderContext": ...

        def arbitrary_fs_access_through_s_ms(self, value_or_callback=None, /):
            """
            When true, ServiceMonitor, PodMonitor and Probe object are forbidden to
            reference arbitrary files on the file system of the 'prometheus'
            container.
            When a ServiceMonitor's endpoint specifies a `bearerTokenFile` value
            (e.g.  '/var/run/secrets/kubernetes.io/serviceaccount/token'), a
            malicious target can get access to the Prometheus service account's
            token in the Prometheus' scrape request. Setting
            `spec.arbitraryFSAccessThroughSM` to 'true' would prevent the attack.
            Users should instead provide the credentials using the
            `spec.bearerTokenSecret` field.
            """
            if self._in_context and value_or_callback is None:
                context = ArbitraryFsAccessThroughSMs.BuilderContext()
                context._parent_builder = self
                context._field_name = "arbitrary_fs_access_through_s_ms"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ArbitraryFsAccessThroughSMs.builder())
                if isinstance(output, ArbitraryFsAccessThroughSMs.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("arbitrary_fs_access_through_s_ms", value)

        def automount_service_account_token(self, value: Optional[bool], /) -> Self:
            """
            AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in the pod.
            If the field isn't set, the operator mounts the service account token by default.

            **Warning:** be aware that by default, Prometheus requires the service account token for Kubernetes service discovery.
            It is possible to use strategic merge patch to project the service account token into the 'prometheus' container.
            """
            return self._set("automount_service_account_token", value)

        def base_image(self, value: Optional[str], /) -> Self:
            """
            Deprecated: use 'spec.image' instead.
            """
            return self._set("base_image", value)

        def body_size_limit(self, value: Optional[str], /) -> Self:
            """
            BodySizeLimit defines per-scrape on response body size.
            Only valid in Prometheus versions 2.45.0 and newer.

            Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
            If you want to enforce a maximum limit for all scrape objects, refer to enforcedBodySizeLimit.
            """
            return self._set("body_size_limit", value)

        def config_maps(self, value: Optional[List[str]], /) -> Self:
            """
            ConfigMaps is a list of ConfigMaps in the same namespace as the Prometheus
            object, which shall be mounted into the Prometheus Pods.
            Each ConfigMap is added to the StatefulSet definition as a volume named `configmap-<configmap-name>`.
            The ConfigMaps are mounted into /etc/prometheus/configmaps/<configmap-name> in the 'prometheus' container.
            """
            return self._set("config_maps", value)

        @overload
        def containers(self, value_or_callback: List[Container], /) -> "PrometheusSpec.Builder": ...

        @overload
        def containers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Container, Container.Builder]],
                GenericListBuilder[Container, Container.Builder] | List[Container],
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def containers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Container.Builder]: ...

        def containers(self, value_or_callback=None, /):
            """
            Containers allows injecting additional containers or modifying operator
            generated containers. This can be used to allow adding an authentication
            proxy to the Pods or to change the behavior of an operator generated
            container. Containers described here modify an operator generated
            container if they share the same name and modifications are done via a
            strategic merge patch.

            The names of containers managed by the operator are:
            * `prometheus`
            * `config-reloader`
            * `thanos-sidecar`

            Overriding containers is entirely outside the scope of what the
            maintainers will support and by doing so, you accept that this behaviour
            may break at any time without notice.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Container.Builder]()
                context._parent_builder = self
                context._field_name = "containers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Container.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("containers", value)

        def disable_compaction(self, value: Optional[bool], /) -> Self:
            """
            When true, the Prometheus compaction is disabled.
            When `spec.thanos.objectStorageConfig` or `spec.objectStorageConfigFile` are defined, the operator automatically
            disables block compaction to avoid race conditions during block uploads (as the Thanos documentation recommends).
            """
            return self._set("disable_compaction", value)

        @overload
        def dns_config(
            self, value_or_callback: Optional[DnsConfig], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def dns_config(
            self,
            value_or_callback: Callable[[DnsConfig.Builder], DnsConfig.Builder | DnsConfig],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def dns_config(self, value_or_callback: Never = ...) -> "DnsConfig.BuilderContext": ...

        def dns_config(self, value_or_callback=None, /):
            """
            Defines the DNS configuration for the pods.
            """
            if self._in_context and value_or_callback is None:
                context = DnsConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "dns_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DnsConfig.builder())
                if isinstance(output, DnsConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("dns_config", value)

        def dns_policy(
            self,
            value: Optional[Literal["ClusterFirstWithHostNet", "ClusterFirst", "Default", "None"]],
            /,
        ) -> Self:
            """
            Defines the DNS policy for the pods.
            """
            return self._set("dns_policy", value)

        def enable_admin_api(self, value: Optional[bool], /) -> Self:
            """
            Enables access to the Prometheus web admin API.

            WARNING: Enabling the admin APIs enables mutating endpoints, to delete data,
            shutdown Prometheus, and more. Enabling this should be done with care and the
            user is advised to add additional authentication authorization via a proxy to
            ensure only clients authorized to perform these actions can do so.

            For more information:
            https://prometheus.io/docs/prometheus/latest/querying/api/#tsdb-admin-apis
            """
            return self._set("enable_admin_api", value)

        @overload
        def enable_features(
            self, value_or_callback: List[EnableFeature], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def enable_features(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[EnableFeature, EnableFeature.Builder]],
                GenericListBuilder[EnableFeature, EnableFeature.Builder] | List[EnableFeature],
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def enable_features(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[EnableFeature.Builder]: ...

        def enable_features(self, value_or_callback=None, /):
            """
            Enable access to Prometheus feature flags. By default, no features are enabled.

            Enabling features which are disabled by default is entirely outside the
            scope of what the maintainers will support and by doing so, you accept
            that this behaviour may break at any time without notice.

            For more information see https://prometheus.io/docs/prometheus/latest/feature_flags/
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[EnableFeature.Builder]()
                context._parent_builder = self
                context._field_name = "enable_features"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(EnableFeature.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("enable_features", value)

        def enable_otlp_receiver(self, value: Optional[bool], /) -> Self:
            """
            Enable Prometheus to be used as a receiver for the OTLP Metrics protocol.

            Note that the OTLP receiver endpoint is automatically enabled if `.spec.otlpConfig` is defined.

            It requires Prometheus >= v2.47.0.
            """
            return self._set("enable_otlp_receiver", value)

        def enable_remote_write_receiver(self, value: Optional[bool], /) -> Self:
            """
            Enable Prometheus to be used as a receiver for the Prometheus remote
            write protocol.

            WARNING: This is not considered an efficient way of ingesting samples.
            Use it with caution for specific low-volume use cases.
            It is not suitable for replacing the ingestion via scraping and turning
            Prometheus into a push-based metrics collection system.
            For more information see https://prometheus.io/docs/prometheus/latest/querying/api/#remote-write-receiver

            It requires Prometheus >= v2.33.0.
            """
            return self._set("enable_remote_write_receiver", value)

        def enforced_body_size_limit(self, value: Optional[str], /) -> Self:
            """
            When defined, enforcedBodySizeLimit specifies a global limit on the size
            of uncompressed response body that will be accepted by Prometheus.
            Targets responding with a body larger than this many bytes will cause
            the scrape to fail.

            It requires Prometheus >= v2.28.0.

            When both `enforcedBodySizeLimit` and `bodySizeLimit` are defined and greater than zero, the following rules apply:
            * Scrape objects without a defined bodySizeLimit value will inherit the global bodySizeLimit value (Prometheus >= 2.45.0) or the enforcedBodySizeLimit value (Prometheus < v2.45.0).
              If Prometheus version is >= 2.45.0 and the `enforcedBodySizeLimit` is greater than the `bodySizeLimit`, the `bodySizeLimit` will be set to `enforcedBodySizeLimit`.
            * Scrape objects with a bodySizeLimit value less than or equal to enforcedBodySizeLimit keep their specific value.
            * Scrape objects with a bodySizeLimit value greater than enforcedBodySizeLimit are set to enforcedBodySizeLimit.
            """
            return self._set("enforced_body_size_limit", value)

        def enforced_keep_dropped_targets(self, value: Optional[int], /) -> Self:
            """
            When defined, enforcedKeepDroppedTargets specifies a global limit on the number of targets
            dropped by relabeling that will be kept in memory. The value overrides
            any `spec.keepDroppedTargets` set by
            ServiceMonitor, PodMonitor, Probe objects unless `spec.keepDroppedTargets` is
            greater than zero and less than `spec.enforcedKeepDroppedTargets`.

            It requires Prometheus >= v2.47.0.

            When both `enforcedKeepDroppedTargets` and `keepDroppedTargets` are defined and greater than zero, the following rules apply:
            * Scrape objects without a defined keepDroppedTargets value will inherit the global keepDroppedTargets value (Prometheus >= 2.45.0) or the enforcedKeepDroppedTargets value (Prometheus < v2.45.0).
              If Prometheus version is >= 2.45.0 and the `enforcedKeepDroppedTargets` is greater than the `keepDroppedTargets`, the `keepDroppedTargets` will be set to `enforcedKeepDroppedTargets`.
            * Scrape objects with a keepDroppedTargets value less than or equal to enforcedKeepDroppedTargets keep their specific value.
            * Scrape objects with a keepDroppedTargets value greater than enforcedKeepDroppedTargets are set to enforcedKeepDroppedTargets.
            """
            return self._set("enforced_keep_dropped_targets", value)

        def enforced_label_limit(self, value: Optional[int], /) -> Self:
            """
            When defined, enforcedLabelLimit specifies a global limit on the number
            of labels per sample. The value overrides any `spec.labelLimit` set by
            ServiceMonitor, PodMonitor, Probe objects unless `spec.labelLimit` is
            greater than zero and less than `spec.enforcedLabelLimit`.

            It requires Prometheus >= v2.27.0.

            When both `enforcedLabelLimit` and `labelLimit` are defined and greater than zero, the following rules apply:
            * Scrape objects without a defined labelLimit value will inherit the global labelLimit value (Prometheus >= 2.45.0) or the enforcedLabelLimit value (Prometheus < v2.45.0).
              If Prometheus version is >= 2.45.0 and the `enforcedLabelLimit` is greater than the `labelLimit`, the `labelLimit` will be set to `enforcedLabelLimit`.
            * Scrape objects with a labelLimit value less than or equal to enforcedLabelLimit keep their specific value.
            * Scrape objects with a labelLimit value greater than enforcedLabelLimit are set to enforcedLabelLimit.
            """
            return self._set("enforced_label_limit", value)

        def enforced_label_name_length_limit(self, value: Optional[int], /) -> Self:
            """
            When defined, enforcedLabelNameLengthLimit specifies a global limit on the length
            of labels name per sample. The value overrides any `spec.labelNameLengthLimit` set by
            ServiceMonitor, PodMonitor, Probe objects unless `spec.labelNameLengthLimit` is
            greater than zero and less than `spec.enforcedLabelNameLengthLimit`.

            It requires Prometheus >= v2.27.0.

            When both `enforcedLabelNameLengthLimit` and `labelNameLengthLimit` are defined and greater than zero, the following rules apply:
            * Scrape objects without a defined labelNameLengthLimit value will inherit the global labelNameLengthLimit value (Prometheus >= 2.45.0) or the enforcedLabelNameLengthLimit value (Prometheus < v2.45.0).
              If Prometheus version is >= 2.45.0 and the `enforcedLabelNameLengthLimit` is greater than the `labelNameLengthLimit`, the `labelNameLengthLimit` will be set to `enforcedLabelNameLengthLimit`.
            * Scrape objects with a labelNameLengthLimit value less than or equal to enforcedLabelNameLengthLimit keep their specific value.
            * Scrape objects with a labelNameLengthLimit value greater than enforcedLabelNameLengthLimit are set to enforcedLabelNameLengthLimit.
            """
            return self._set("enforced_label_name_length_limit", value)

        def enforced_label_value_length_limit(self, value: Optional[int], /) -> Self:
            """
            When not null, enforcedLabelValueLengthLimit defines a global limit on the length
            of labels value per sample. The value overrides any `spec.labelValueLengthLimit` set by
            ServiceMonitor, PodMonitor, Probe objects unless `spec.labelValueLengthLimit` is
            greater than zero and less than `spec.enforcedLabelValueLengthLimit`.

            It requires Prometheus >= v2.27.0.

            When both `enforcedLabelValueLengthLimit` and `labelValueLengthLimit` are defined and greater than zero, the following rules apply:
            * Scrape objects without a defined labelValueLengthLimit value will inherit the global labelValueLengthLimit value (Prometheus >= 2.45.0) or the enforcedLabelValueLengthLimit value (Prometheus < v2.45.0).
              If Prometheus version is >= 2.45.0 and the `enforcedLabelValueLengthLimit` is greater than the `labelValueLengthLimit`, the `labelValueLengthLimit` will be set to `enforcedLabelValueLengthLimit`.
            * Scrape objects with a labelValueLengthLimit value less than or equal to enforcedLabelValueLengthLimit keep their specific value.
            * Scrape objects with a labelValueLengthLimit value greater than enforcedLabelValueLengthLimit are set to enforcedLabelValueLengthLimit.
            """
            return self._set("enforced_label_value_length_limit", value)

        def enforced_namespace_label(self, value: Optional[str], /) -> Self:
            """
            When not empty, a label will be added to:

            1. All metrics scraped from `ServiceMonitor`, `PodMonitor`, `Probe` and `ScrapeConfig` objects.
            2. All metrics generated from recording rules defined in `PrometheusRule` objects.
            3. All alerts generated from alerting rules defined in `PrometheusRule` objects.
            4. All vector selectors of PromQL expressions defined in `PrometheusRule` objects.

            The label will not added for objects referenced in `spec.excludedFromEnforcement`.

            The label's name is this field's value.
            The label's value is the namespace of the `ServiceMonitor`,
            `PodMonitor`, `Probe`, `PrometheusRule` or `ScrapeConfig` object.
            """
            return self._set("enforced_namespace_label", value)

        def enforced_sample_limit(self, value: Optional[int], /) -> Self:
            """
            When defined, enforcedSampleLimit specifies a global limit on the number
            of scraped samples that will be accepted. This overrides any
            `spec.sampleLimit` set by ServiceMonitor, PodMonitor, Probe objects
            unless `spec.sampleLimit` is greater than zero and less than
            `spec.enforcedSampleLimit`.

            It is meant to be used by admins to keep the overall number of
            samples/series under a desired limit.

            When both `enforcedSampleLimit` and `sampleLimit` are defined and greater than zero, the following rules apply:
            * Scrape objects without a defined sampleLimit value will inherit the global sampleLimit value (Prometheus >= 2.45.0) or the enforcedSampleLimit value (Prometheus < v2.45.0).
              If Prometheus version is >= 2.45.0 and the `enforcedSampleLimit` is greater than the `sampleLimit`, the `sampleLimit` will be set to `enforcedSampleLimit`.
            * Scrape objects with a sampleLimit value less than or equal to enforcedSampleLimit keep their specific value.
            * Scrape objects with a sampleLimit value greater than enforcedSampleLimit are set to enforcedSampleLimit.
            """
            return self._set("enforced_sample_limit", value)

        def enforced_target_limit(self, value: Optional[int], /) -> Self:
            """
            When defined, enforcedTargetLimit specifies a global limit on the number
            of scraped targets. The value overrides any `spec.targetLimit` set by
            ServiceMonitor, PodMonitor, Probe objects unless `spec.targetLimit` is
            greater than zero and less than `spec.enforcedTargetLimit`.

            It is meant to be used by admins to to keep the overall number of
            targets under a desired limit.

            When both `enforcedTargetLimit` and `targetLimit` are defined and greater than zero, the following rules apply:
            * Scrape objects without a defined targetLimit value will inherit the global targetLimit value (Prometheus >= 2.45.0) or the enforcedTargetLimit value (Prometheus < v2.45.0).
              If Prometheus version is >= 2.45.0 and the `enforcedTargetLimit` is greater than the `targetLimit`, the `targetLimit` will be set to `enforcedTargetLimit`.
            * Scrape objects with a targetLimit value less than or equal to enforcedTargetLimit keep their specific value.
            * Scrape objects with a targetLimit value greater than enforcedTargetLimit are set to enforcedTargetLimit.
            """
            return self._set("enforced_target_limit", value)

        def evaluation_interval(self, value: Optional[str], /) -> Self:
            """
            Interval between rule evaluations.
            Default: "30s"
            """
            return self._set("evaluation_interval", value)

        @overload
        def excluded_from_enforcement(
            self, value_or_callback: List[ExcludedFromEnforcement], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def excluded_from_enforcement(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ExcludedFromEnforcement, ExcludedFromEnforcement.Builder]],
                GenericListBuilder[ExcludedFromEnforcement, ExcludedFromEnforcement.Builder]
                | List[ExcludedFromEnforcement],
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def excluded_from_enforcement(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ExcludedFromEnforcement.Builder]: ...

        def excluded_from_enforcement(self, value_or_callback=None, /):
            """
            List of references to PodMonitor, ServiceMonitor, Probe and PrometheusRule objects
            to be excluded from enforcing a namespace label of origin.

            It is only applicable if `spec.enforcedNamespaceLabel` set to true.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ExcludedFromEnforcement.Builder]()
                context._parent_builder = self
                context._field_name = "excluded_from_enforcement"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ExcludedFromEnforcement.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("excluded_from_enforcement", value)

        @overload
        def exemplars(
            self, value_or_callback: Optional[Exemplars], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def exemplars(
            self,
            value_or_callback: Callable[[Exemplars.Builder], Exemplars.Builder | Exemplars],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def exemplars(self, value_or_callback: Never = ...) -> "Exemplars.BuilderContext": ...

        def exemplars(self, value_or_callback=None, /):
            """
            Exemplars related settings that are runtime reloadable.
            It requires to enable the `exemplar-storage` feature flag to be effective.
            """
            if self._in_context and value_or_callback is None:
                context = Exemplars.BuilderContext()
                context._parent_builder = self
                context._field_name = "exemplars"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exemplars.builder())
                if isinstance(output, Exemplars.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exemplars", value)

        def external_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            The labels to add to any time series or alerts when communicating with
            external systems (federation, remote storage, Alertmanager).
            Labels defined by `spec.replicaExternalLabelName` and
            `spec.prometheusExternalLabelName` take precedence over this list.
            """
            return self._set("external_labels", value)

        def external_url(self, value: Optional[str], /) -> Self:
            """
            The external URL under which the Prometheus service is externally
            available. This is necessary to generate correct URLs (for instance if
            Prometheus is accessible behind an Ingress resource).
            """
            return self._set("external_url", value)

        @overload
        def host_aliases(
            self, value_or_callback: List[HostAliase], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def host_aliases(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[HostAliase, HostAliase.Builder]],
                GenericListBuilder[HostAliase, HostAliase.Builder] | List[HostAliase],
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def host_aliases(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[HostAliase.Builder]: ...

        def host_aliases(self, value_or_callback=None, /):
            """
            Optional list of hosts and IPs that will be injected into the Pod's
            hosts file if specified.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[HostAliase.Builder]()
                context._parent_builder = self
                context._field_name = "host_aliases"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HostAliase.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("host_aliases", value)

        def host_network(self, value: Optional[bool], /) -> Self:
            """
            Use the host's network namespace if true.

            Make sure to understand the security implications if you want to enable
            it (https://kubernetes.io/docs/concepts/configuration/overview/).

            When hostNetwork is enabled, this will set the DNS policy to
            `ClusterFirstWithHostNet` automatically (unless `.spec.DNSPolicy` is set
            to a different value).
            """
            return self._set("host_network", value)

        def ignore_namespace_selectors(self, value: Optional[bool], /) -> Self:
            """
            When true, `spec.namespaceSelector` from all PodMonitor, ServiceMonitor
            and Probe objects will be ignored. They will only discover targets
            within the namespace of the PodMonitor, ServiceMonitor and Probe
            object.
            """
            return self._set("ignore_namespace_selectors", value)

        def image(self, value: Optional[str], /) -> Self:
            """
            Container image name for Prometheus. If specified, it takes precedence
            over the `spec.baseImage`, `spec.tag` and `spec.sha` fields.

            Specifying `spec.version` is still necessary to ensure the Prometheus
            Operator knows which version of Prometheus is being configured.

            If neither `spec.image` nor `spec.baseImage` are defined, the operator
            will use the latest upstream version of Prometheus available at the time
            when the operator was released.
            """
            return self._set("image", value)

        def image_pull_policy(
            self, value: Optional[Literal["", "Always", "Never", "IfNotPresent"]], /
        ) -> Self:
            """
            Image pull policy for the 'prometheus', 'init-config-reloader' and 'config-reloader' containers.
            See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
            """
            return self._set("image_pull_policy", value)

        @overload
        def image_pull_secrets(
            self, value_or_callback: List[ImagePullSecret], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def image_pull_secrets(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ImagePullSecret, ImagePullSecret.Builder]],
                GenericListBuilder[ImagePullSecret, ImagePullSecret.Builder]
                | List[ImagePullSecret],
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def image_pull_secrets(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ImagePullSecret.Builder]: ...

        def image_pull_secrets(self, value_or_callback=None, /):
            """
            An optional list of references to Secrets in the same namespace
            to use for pulling images from registries.
            See http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ImagePullSecret.Builder]()
                context._parent_builder = self
                context._field_name = "image_pull_secrets"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImagePullSecret.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("image_pull_secrets", value)

        @overload
        def init_containers(
            self, value_or_callback: List[InitContainer], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def init_containers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[InitContainer, InitContainer.Builder]],
                GenericListBuilder[InitContainer, InitContainer.Builder] | List[InitContainer],
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def init_containers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[InitContainer.Builder]: ...

        def init_containers(self, value_or_callback=None, /):
            """
            InitContainers allows injecting initContainers to the Pod definition. Those
            can be used to e.g.  fetch secrets for injection into the Prometheus
            configuration from external sources. Any errors during the execution of
            an initContainer will lead to a restart of the Pod. More info:
            https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
            InitContainers described here modify an operator generated init
            containers if they share the same name and modifications are done via a
            strategic merge patch.

            The names of init container name managed by the operator are:
            * `init-config-reloader`.

            Overriding init containers is entirely outside the scope of what the
            maintainers will support and by doing so, you accept that this behaviour
            may break at any time without notice.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[InitContainer.Builder]()
                context._parent_builder = self
                context._field_name = "init_containers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitContainer.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_containers", value)

        def keep_dropped_targets(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on the number of targets dropped by relabeling
            that will be kept in memory. 0 means no limit.

            It requires Prometheus >= v2.47.0.

            Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
            If you want to enforce a maximum limit for all scrape objects, refer to enforcedKeepDroppedTargets.
            """
            return self._set("keep_dropped_targets", value)

        def label_limit(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on number of labels that will be accepted for a sample.
            Only valid in Prometheus versions 2.45.0 and newer.

            Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
            If you want to enforce a maximum limit for all scrape objects, refer to enforcedLabelLimit.
            """
            return self._set("label_limit", value)

        def label_name_length_limit(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on length of labels name that will be accepted for a sample.
            Only valid in Prometheus versions 2.45.0 and newer.

            Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
            If you want to enforce a maximum limit for all scrape objects, refer to enforcedLabelNameLengthLimit.
            """
            return self._set("label_name_length_limit", value)

        def label_value_length_limit(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on length of labels value that will be accepted for a sample.
            Only valid in Prometheus versions 2.45.0 and newer.

            Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
            If you want to enforce a maximum limit for all scrape objects, refer to enforcedLabelValueLengthLimit.
            """
            return self._set("label_value_length_limit", value)

        def listen_local(self, value: Optional[bool], /) -> Self:
            """
            When true, the Prometheus server listens on the loopback address
            instead of the Pod IP's address.
            """
            return self._set("listen_local", value)

        def log_format(self, value: Optional[Literal["", "logfmt", "json"]], /) -> Self:
            """
            Log format for Log level for Prometheus and the config-reloader sidecar.
            """
            return self._set("log_format", value)

        def log_level(
            self, value: Optional[Literal["", "debug", "info", "warn", "error"]], /
        ) -> Self:
            """
            Log level for Prometheus and the config-reloader sidecar.
            """
            return self._set("log_level", value)

        def maximum_startup_duration_seconds(self, value: Optional[int], /) -> Self:
            """
            Defines the maximum time that the `prometheus` container's startup probe will wait before being considered failed. The startup probe will return success after the WAL replay is complete.
            If set, the value should be greater than 60 (seconds). Otherwise it will be equal to 600 seconds (15 minutes).
            """
            return self._set("maximum_startup_duration_seconds", value)

        def min_ready_seconds(self, value: Optional[int], /) -> Self:
            """
            Minimum number of seconds for which a newly created Pod should be ready
            without any of its container crashing for it to be considered available.
            Defaults to 0 (pod will be considered available as soon as it is ready)

            This is an alpha field from kubernetes 1.22 until 1.24 which requires
            enabling the StatefulSetMinReadySeconds feature gate.
            """
            return self._set("min_ready_seconds", value)

        def name_validation_scheme(self, value: Optional[Literal["UTF8", "Legacy"]], /) -> Self:
            """
            Specifies the validation scheme for metric and label names.
            """
            return self._set("name_validation_scheme", value)

        def node_selector(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Defines on which Nodes the Pods are scheduled.
            """
            return self._set("node_selector", value)

        @overload
        def otlp(self, value_or_callback: Optional[Otlp], /) -> "PrometheusSpec.Builder": ...

        @overload
        def otlp(
            self, value_or_callback: Callable[[Otlp.Builder], Otlp.Builder | Otlp], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def otlp(self, value_or_callback: Never = ...) -> "Otlp.BuilderContext": ...

        def otlp(self, value_or_callback=None, /):
            """
            Settings related to the OTLP receiver feature.
            It requires Prometheus >= v2.55.0.
            """
            if self._in_context and value_or_callback is None:
                context = Otlp.BuilderContext()
                context._parent_builder = self
                context._field_name = "otlp"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Otlp.builder())
                if isinstance(output, Otlp.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("otlp", value)

        def override_honor_labels(self, value: Optional[bool], /) -> Self:
            """
            When true, Prometheus resolves label conflicts by renaming the labels in the scraped data
             to exported_ for all targets created from ServiceMonitor, PodMonitor and
            ScrapeConfig objects. Otherwise the HonorLabels field of the service or pod monitor applies.
            In practice,`overrideHonorLaels:true` enforces `honorLabels:false`
            for all ServiceMonitor, PodMonitor and ScrapeConfig objects.
            """
            return self._set("override_honor_labels", value)

        def override_honor_timestamps(self, value: Optional[bool], /) -> Self:
            """
            When true, Prometheus ignores the timestamps for all the targets created
            from service and pod monitors.
            Otherwise the HonorTimestamps field of the service or pod monitor applies.
            """
            return self._set("override_honor_timestamps", value)

        def paused(self, value: Optional[bool], /) -> Self:
            """
            When a Prometheus deployment is paused, no actions except for deletion
            will be performed on the underlying objects.
            """
            return self._set("paused", value)

        @overload
        def persistent_volume_claim_retention_policy(
            self, value_or_callback: Optional[PersistentVolumeClaimRetentionPolicy], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def persistent_volume_claim_retention_policy(
            self,
            value_or_callback: Callable[
                [PersistentVolumeClaimRetentionPolicy.Builder],
                PersistentVolumeClaimRetentionPolicy.Builder | PersistentVolumeClaimRetentionPolicy,
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def persistent_volume_claim_retention_policy(
            self, value_or_callback: Never = ...
        ) -> "PersistentVolumeClaimRetentionPolicy.BuilderContext": ...

        def persistent_volume_claim_retention_policy(self, value_or_callback=None, /):
            """
            The field controls if and how PVCs are deleted during the lifecycle of a StatefulSet.
            The default behavior is all PVCs are retained.
            This is an alpha field from kubernetes 1.23 until 1.26 and a beta field from 1.26.
            It requires enabling the StatefulSetAutoDeletePVC feature gate.
            """
            if self._in_context and value_or_callback is None:
                context = PersistentVolumeClaimRetentionPolicy.BuilderContext()
                context._parent_builder = self
                context._field_name = "persistent_volume_claim_retention_policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PersistentVolumeClaimRetentionPolicy.builder())
                if isinstance(output, PersistentVolumeClaimRetentionPolicy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("persistent_volume_claim_retention_policy", value)

        @overload
        def pod_metadata(
            self, value_or_callback: Optional[PodMetadata], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def pod_metadata(
            self,
            value_or_callback: Callable[[PodMetadata.Builder], PodMetadata.Builder | PodMetadata],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def pod_metadata(self, value_or_callback: Never = ...) -> "PodMetadata.BuilderContext": ...

        def pod_metadata(self, value_or_callback=None, /):
            """
            PodMetadata configures labels and annotations which are propagated to the Prometheus pods.

            The following items are reserved and cannot be overridden:
            * "prometheus" label, set to the name of the Prometheus object.
            * "app.kubernetes.io/instance" label, set to the name of the Prometheus object.
            * "app.kubernetes.io/managed-by" label, set to "prometheus-operator".
            * "app.kubernetes.io/name" label, set to "prometheus".
            * "app.kubernetes.io/version" label, set to the Prometheus version.
            * "operator.prometheus.io/name" label, set to the name of the Prometheus object.
            * "operator.prometheus.io/shard" label, set to the shard number of the Prometheus object.
            * "kubectl.kubernetes.io/default-container" annotation, set to "prometheus".
            """
            if self._in_context and value_or_callback is None:
                context = PodMetadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "pod_metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodMetadata.builder())
                if isinstance(output, PodMetadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("pod_metadata", value)

        @overload
        def pod_monitor_namespace_selector(
            self, value_or_callback: Optional[PodMonitorNamespaceSelector], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def pod_monitor_namespace_selector(
            self,
            value_or_callback: Callable[
                [PodMonitorNamespaceSelector.Builder],
                PodMonitorNamespaceSelector.Builder | PodMonitorNamespaceSelector,
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def pod_monitor_namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "PodMonitorNamespaceSelector.BuilderContext": ...

        def pod_monitor_namespace_selector(self, value_or_callback=None, /):
            """
            Namespaces to match for PodMonitors discovery. An empty label selector
            matches all namespaces. A null label selector (default value) matches the current
            namespace only.
            """
            if self._in_context and value_or_callback is None:
                context = PodMonitorNamespaceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "pod_monitor_namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodMonitorNamespaceSelector.builder())
                if isinstance(output, PodMonitorNamespaceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("pod_monitor_namespace_selector", value)

        @overload
        def pod_monitor_selector(
            self, value_or_callback: Optional[PodMonitorSelector], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def pod_monitor_selector(
            self,
            value_or_callback: Callable[
                [PodMonitorSelector.Builder],
                PodMonitorSelector.Builder | PodMonitorSelector,
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def pod_monitor_selector(
            self, value_or_callback: Never = ...
        ) -> "PodMonitorSelector.BuilderContext": ...

        def pod_monitor_selector(self, value_or_callback=None, /):
            """
            PodMonitors to be selected for target discovery. An empty label selector
            matches all objects. A null label selector matches no objects.

            If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
            and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
            The Prometheus operator will ensure that the Prometheus configuration's
            Secret exists, but it is the responsibility of the user to provide the raw
            gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
            This behavior is *deprecated* and will be removed in the next major version
            of the custom resource definition. It is recommended to use
            `spec.additionalScrapeConfigs` instead.
            """
            if self._in_context and value_or_callback is None:
                context = PodMonitorSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "pod_monitor_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodMonitorSelector.builder())
                if isinstance(output, PodMonitorSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("pod_monitor_selector", value)

        def pod_target_labels(self, value: Optional[List[str]], /) -> Self:
            """
            PodTargetLabels are appended to the `spec.podTargetLabels` field of all
            PodMonitor and ServiceMonitor objects.
            """
            return self._set("pod_target_labels", value)

        def port_name(self, value: Optional[str], /) -> Self:
            """
            Port name used for the pods and governing service.
            Default: "web"
            """
            return self._set("port_name", value)

        def priority_class_name(self, value: Optional[str], /) -> Self:
            """
            Priority class assigned to the Pods.
            """
            return self._set("priority_class_name", value)

        @overload
        def probe_namespace_selector(
            self, value_or_callback: Optional[ProbeNamespaceSelector], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def probe_namespace_selector(
            self,
            value_or_callback: Callable[
                [ProbeNamespaceSelector.Builder],
                ProbeNamespaceSelector.Builder | ProbeNamespaceSelector,
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def probe_namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "ProbeNamespaceSelector.BuilderContext": ...

        def probe_namespace_selector(self, value_or_callback=None, /):
            """
            Namespaces to match for Probe discovery. An empty label
            selector matches all namespaces. A null label selector matches the
            current namespace only.
            """
            if self._in_context and value_or_callback is None:
                context = ProbeNamespaceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "probe_namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProbeNamespaceSelector.builder())
                if isinstance(output, ProbeNamespaceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("probe_namespace_selector", value)

        @overload
        def probe_selector(
            self, value_or_callback: Optional[ProbeSelector], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def probe_selector(
            self,
            value_or_callback: Callable[
                [ProbeSelector.Builder], ProbeSelector.Builder | ProbeSelector
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def probe_selector(
            self, value_or_callback: Never = ...
        ) -> "ProbeSelector.BuilderContext": ...

        def probe_selector(self, value_or_callback=None, /):
            """
            Probes to be selected for target discovery. An empty label selector
            matches all objects. A null label selector matches no objects.

            If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
            and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
            The Prometheus operator will ensure that the Prometheus configuration's
            Secret exists, but it is the responsibility of the user to provide the raw
            gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
            This behavior is *deprecated* and will be removed in the next major version
            of the custom resource definition. It is recommended to use
            `spec.additionalScrapeConfigs` instead.
            """
            if self._in_context and value_or_callback is None:
                context = ProbeSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "probe_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProbeSelector.builder())
                if isinstance(output, ProbeSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("probe_selector", value)

        def prometheus_external_label_name(self, value: Optional[str], /) -> Self:
            """
            Name of Prometheus external label used to denote the Prometheus instance
            name. The external label will _not_ be added when the field is set to
            the empty string (`""`).

            Default: "prometheus"
            """
            return self._set("prometheus_external_label_name", value)

        @overload
        def prometheus_rules_excluded_from_enforce(
            self, value_or_callback: List[PrometheusRulesExcludedFromEnforce], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def prometheus_rules_excluded_from_enforce(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        PrometheusRulesExcludedFromEnforce,
                        PrometheusRulesExcludedFromEnforce.Builder,
                    ]
                ],
                GenericListBuilder[
                    PrometheusRulesExcludedFromEnforce,
                    PrometheusRulesExcludedFromEnforce.Builder,
                ]
                | List[PrometheusRulesExcludedFromEnforce],
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def prometheus_rules_excluded_from_enforce(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PrometheusRulesExcludedFromEnforce.Builder]: ...

        def prometheus_rules_excluded_from_enforce(self, value_or_callback=None, /):
            """
            Defines the list of PrometheusRule objects to which the namespace label
            enforcement doesn't apply.
            This is only relevant when `spec.enforcedNamespaceLabel` is set to true.
            Deprecated: use `spec.excludedFromEnforcement` instead.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PrometheusRulesExcludedFromEnforce.Builder]()
                context._parent_builder = self
                context._field_name = "prometheus_rules_excluded_from_enforce"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PrometheusRulesExcludedFromEnforce.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("prometheus_rules_excluded_from_enforce", value)

        @overload
        def query(self, value_or_callback: Optional[Query], /) -> "PrometheusSpec.Builder": ...

        @overload
        def query(
            self, value_or_callback: Callable[[Query.Builder], Query.Builder | Query], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def query(self, value_or_callback: Never = ...) -> "Query.BuilderContext": ...

        def query(self, value_or_callback=None, /):
            """
            QuerySpec defines the configuration of the Promethus query service.
            """
            if self._in_context and value_or_callback is None:
                context = Query.BuilderContext()
                context._parent_builder = self
                context._field_name = "query"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Query.builder())
                if isinstance(output, Query.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("query", value)

        def query_log_file(self, value: Optional[str], /) -> Self:
            """
            queryLogFile specifies where the file to which PromQL queries are logged.

            If the filename has an empty path, e.g. 'query.log', The Prometheus Pods
            will mount the file into an emptyDir volume at `/var/log/prometheus`.
            If a full path is provided, e.g. '/var/log/prometheus/query.log', you
            must mount a volume in the specified directory and it must be writable.
            This is because the prometheus container runs with a read-only root
            filesystem for security reasons.
            Alternatively, the location can be set to a standard I/O stream, e.g.
            `/dev/stdout`, to log query information to the default Prometheus log
            stream.
            """
            return self._set("query_log_file", value)

        def reload_strategy(self, value: Optional[Literal["HTTP", "ProcessSignal"]], /) -> Self:
            """
            Defines the strategy used to reload the Prometheus configuration.
            If not specified, the configuration is reloaded using the /-/reload HTTP endpoint.
            """
            return self._set("reload_strategy", value)

        @overload
        def remote_read(
            self, value_or_callback: List[RemoteRead], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def remote_read(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[RemoteRead, RemoteRead.Builder]],
                GenericListBuilder[RemoteRead, RemoteRead.Builder] | List[RemoteRead],
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def remote_read(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[RemoteRead.Builder]: ...

        def remote_read(self, value_or_callback=None, /):
            """
            Defines the list of remote read configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[RemoteRead.Builder]()
                context._parent_builder = self
                context._field_name = "remote_read"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RemoteRead.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("remote_read", value)

        @overload
        def remote_write(
            self, value_or_callback: List[RemoteWrite], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def remote_write(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[RemoteWrite, RemoteWrite.Builder]],
                GenericListBuilder[RemoteWrite, RemoteWrite.Builder] | List[RemoteWrite],
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def remote_write(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[RemoteWrite.Builder]: ...

        def remote_write(self, value_or_callback=None, /):
            """
            Defines the list of remote write configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[RemoteWrite.Builder]()
                context._parent_builder = self
                context._field_name = "remote_write"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RemoteWrite.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("remote_write", value)

        def remote_write_receiver_message_versions(
            self, value: Optional[List[Literal["V1.0", "V2.0"]]], /
        ) -> Self:
            """
            List of the protobuf message versions to accept when receiving the
            remote writes.

            It requires Prometheus >= v2.54.0.
            """
            return self._set("remote_write_receiver_message_versions", value)

        def replica_external_label_name(self, value: Optional[str], /) -> Self:
            """
            Name of Prometheus external label used to denote the replica name.
            The external label will _not_ be added when the field is set to the
            empty string (`""`).

            Default: "prometheus_replica"
            """
            return self._set("replica_external_label_name", value)

        def replicas(self, value: Optional[int], /) -> Self:
            """
            Number of replicas of each shard to deploy for a Prometheus deployment.
            `spec.replicas` multiplied by `spec.shards` is the total number of Pods
            created.

            Default: 1
            """
            return self._set("replicas", value)

        @overload
        def resources(
            self, value_or_callback: Optional[ResourcesModel1], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[
                [ResourcesModel1.Builder], ResourcesModel1.Builder | ResourcesModel1
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "ResourcesModel1.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            Defines the resources requests and limits of the 'prometheus' container.
            """
            if self._in_context and value_or_callback is None:
                context = ResourcesModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourcesModel1.builder())
                if isinstance(output, ResourcesModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def retention(self, value: Optional[str], /) -> Self:
            """
            How long to retain the Prometheus data.

            Default: "24h" if `spec.retention` and `spec.retentionSize` are empty.
            """
            return self._set("retention", value)

        def retention_size(self, value: Optional[str], /) -> Self:
            """
            Maximum number of bytes used by the Prometheus data.
            """
            return self._set("retention_size", value)

        def route_prefix(self, value: Optional[str], /) -> Self:
            """
            The route prefix Prometheus registers HTTP handlers for.

            This is useful when using `spec.externalURL`, and a proxy is rewriting
            HTTP routes of a request, and the actual ExternalURL is still true, but
            the server serves requests under a different route prefix. For example
            for use with `kubectl proxy`.
            """
            return self._set("route_prefix", value)

        @overload
        def rule_namespace_selector(
            self, value_or_callback: Optional[RuleNamespaceSelector], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def rule_namespace_selector(
            self,
            value_or_callback: Callable[
                [RuleNamespaceSelector.Builder],
                RuleNamespaceSelector.Builder | RuleNamespaceSelector,
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def rule_namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "RuleNamespaceSelector.BuilderContext": ...

        def rule_namespace_selector(self, value_or_callback=None, /):
            """
            Namespaces to match for PrometheusRule discovery. An empty label selector
            matches all namespaces. A null label selector matches the current
            namespace only.
            """
            if self._in_context and value_or_callback is None:
                context = RuleNamespaceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "rule_namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RuleNamespaceSelector.builder())
                if isinstance(output, RuleNamespaceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("rule_namespace_selector", value)

        def rule_query_offset(self, value: Optional[str], /) -> Self:
            """
            Defines the offset the rule evaluation timestamp of this particular group by the specified duration into the past.
            It requires Prometheus >= v2.53.0.
            """
            return self._set("rule_query_offset", value)

        @overload
        def rule_selector(
            self, value_or_callback: Optional[RuleSelector], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def rule_selector(
            self,
            value_or_callback: Callable[
                [RuleSelector.Builder], RuleSelector.Builder | RuleSelector
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def rule_selector(
            self, value_or_callback: Never = ...
        ) -> "RuleSelector.BuilderContext": ...

        def rule_selector(self, value_or_callback=None, /):
            """
            PrometheusRule objects to be selected for rule evaluation. An empty
            label selector matches all objects. A null label selector matches no
            objects.
            """
            if self._in_context and value_or_callback is None:
                context = RuleSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "rule_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RuleSelector.builder())
                if isinstance(output, RuleSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("rule_selector", value)

        @overload
        def rules(self, value_or_callback: Optional[Rules], /) -> "PrometheusSpec.Builder": ...

        @overload
        def rules(
            self, value_or_callback: Callable[[Rules.Builder], Rules.Builder | Rules], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def rules(self, value_or_callback: Never = ...) -> "Rules.BuilderContext": ...

        def rules(self, value_or_callback=None, /):
            """
            Defines the configuration of the Prometheus rules' engine.
            """
            if self._in_context and value_or_callback is None:
                context = Rules.BuilderContext()
                context._parent_builder = self
                context._field_name = "rules"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Rules.builder())
                if isinstance(output, Rules.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("rules", value)

        @overload
        def runtime(self, value_or_callback: Optional[Runtime], /) -> "PrometheusSpec.Builder": ...

        @overload
        def runtime(
            self,
            value_or_callback: Callable[[Runtime.Builder], Runtime.Builder | Runtime],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def runtime(self, value_or_callback: Never = ...) -> "Runtime.BuilderContext": ...

        def runtime(self, value_or_callback=None, /):
            """
            RuntimeConfig configures the values for the Prometheus process behavior
            """
            if self._in_context and value_or_callback is None:
                context = Runtime.BuilderContext()
                context._parent_builder = self
                context._field_name = "runtime"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Runtime.builder())
                if isinstance(output, Runtime.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("runtime", value)

        def sample_limit(self, value: Optional[int], /) -> Self:
            """
            SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
            Only valid in Prometheus versions 2.45.0 and newer.

            Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
            If you want to enforce a maximum limit for all scrape objects, refer to enforcedSampleLimit.
            """
            return self._set("sample_limit", value)

        @overload
        def scrape_classes(
            self, value_or_callback: List[ScrapeClass], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def scrape_classes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ScrapeClass, ScrapeClass.Builder]],
                GenericListBuilder[ScrapeClass, ScrapeClass.Builder] | List[ScrapeClass],
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def scrape_classes(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ScrapeClass.Builder]: ...

        def scrape_classes(self, value_or_callback=None, /):
            """
            List of scrape classes to expose to scraping objects such as
            PodMonitors, ServiceMonitors, Probes and ScrapeConfigs.

            This is an *experimental feature*, it may change in any upcoming release
            in a breaking way.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ScrapeClass.Builder]()
                context._parent_builder = self
                context._field_name = "scrape_classes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ScrapeClass.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("scrape_classes", value)

        @overload
        def scrape_config_namespace_selector(
            self, value_or_callback: Optional[ScrapeConfigNamespaceSelector], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def scrape_config_namespace_selector(
            self,
            value_or_callback: Callable[
                [ScrapeConfigNamespaceSelector.Builder],
                ScrapeConfigNamespaceSelector.Builder | ScrapeConfigNamespaceSelector,
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def scrape_config_namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "ScrapeConfigNamespaceSelector.BuilderContext": ...

        def scrape_config_namespace_selector(self, value_or_callback=None, /):
            """
            Namespaces to match for ScrapeConfig discovery. An empty label selector
            matches all namespaces. A null label selector matches the current
            namespace only.

            Note that the ScrapeConfig custom resource definition is currently at Alpha level.
            """
            if self._in_context and value_or_callback is None:
                context = ScrapeConfigNamespaceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "scrape_config_namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ScrapeConfigNamespaceSelector.builder())
                if isinstance(output, ScrapeConfigNamespaceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("scrape_config_namespace_selector", value)

        @overload
        def scrape_config_selector(
            self, value_or_callback: Optional[ScrapeConfigSelector], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def scrape_config_selector(
            self,
            value_or_callback: Callable[
                [ScrapeConfigSelector.Builder],
                ScrapeConfigSelector.Builder | ScrapeConfigSelector,
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def scrape_config_selector(
            self, value_or_callback: Never = ...
        ) -> "ScrapeConfigSelector.BuilderContext": ...

        def scrape_config_selector(self, value_or_callback=None, /):
            """
            ScrapeConfigs to be selected for target discovery. An empty label
            selector matches all objects. A null label selector matches no objects.

            If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
            and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
            The Prometheus operator will ensure that the Prometheus configuration's
            Secret exists, but it is the responsibility of the user to provide the raw
            gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
            This behavior is *deprecated* and will be removed in the next major version
            of the custom resource definition. It is recommended to use
            `spec.additionalScrapeConfigs` instead.

            Note that the ScrapeConfig custom resource definition is currently at Alpha level.
            """
            if self._in_context and value_or_callback is None:
                context = ScrapeConfigSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "scrape_config_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ScrapeConfigSelector.builder())
                if isinstance(output, ScrapeConfigSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("scrape_config_selector", value)

        def scrape_failure_log_file(self, value: Optional[str], /) -> Self:
            """
            File to which scrape failures are logged.
            Reloading the configuration will reopen the file.

            If the filename has an empty path, e.g. 'file.log', The Prometheus Pods
            will mount the file into an emptyDir volume at `/var/log/prometheus`.
            If a full path is provided, e.g. '/var/log/prometheus/file.log', you
            must mount a volume in the specified directory and it must be writable.
            It requires Prometheus >= v2.55.0.
            """
            return self._set("scrape_failure_log_file", value)

        def scrape_interval(self, value: Optional[str], /) -> Self:
            """
            Interval between consecutive scrapes.

            Default: "30s"
            """
            return self._set("scrape_interval", value)

        def scrape_protocols(
            self,
            value: Optional[
                List[
                    Literal[
                        "PrometheusProto",
                        "OpenMetricsText0.0.1",
                        "OpenMetricsText1.0.0",
                        "PrometheusText0.0.4",
                        "PrometheusText1.0.0",
                    ]
                ]
            ],
            /,
        ) -> Self:
            """
            The protocols to negotiate during a scrape. It tells clients the
            protocols supported by Prometheus in order of preference (from most to least preferred).

            If unset, Prometheus uses its default value.

            It requires Prometheus >= v2.49.0.

            `PrometheusText1.0.0` requires Prometheus >= v3.0.0.
            """
            return self._set("scrape_protocols", value)

        def scrape_timeout(self, value: Optional[str], /) -> Self:
            """
            Number of seconds to wait until a scrape request times out.
            The value cannot be greater than the scrape interval otherwise the operator will reject the resource.
            """
            return self._set("scrape_timeout", value)

        def secrets(self, value: Optional[List[str]], /) -> Self:
            """
            Secrets is a list of Secrets in the same namespace as the Prometheus
            object, which shall be mounted into the Prometheus Pods.
            Each Secret is added to the StatefulSet definition as a volume named `secret-<secret-name>`.
            The Secrets are mounted into /etc/prometheus/secrets/<secret-name> in the 'prometheus' container.
            """
            return self._set("secrets", value)

        @overload
        def security_context(
            self, value_or_callback: Optional[SecurityContextModel2], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def security_context(
            self,
            value_or_callback: Callable[
                [SecurityContextModel2.Builder],
                SecurityContextModel2.Builder | SecurityContextModel2,
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def security_context(
            self, value_or_callback: Never = ...
        ) -> "SecurityContextModel2.BuilderContext": ...

        def security_context(self, value_or_callback=None, /):
            """
            SecurityContext holds pod-level security attributes and common container settings.
            This defaults to the default PodSecurityContext.
            """
            if self._in_context and value_or_callback is None:
                context = SecurityContextModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "security_context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecurityContextModel2.builder())
                if isinstance(output, SecurityContextModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("security_context", value)

        def service_account_name(self, value: Optional[str], /) -> Self:
            """
            ServiceAccountName is the name of the ServiceAccount to use to run the
            Prometheus Pods.
            """
            return self._set("service_account_name", value)

        def service_discovery_role(
            self, value: Optional[Literal["Endpoints", "EndpointSlice"]], /
        ) -> Self:
            """
            Defines the service discovery role used to discover targets from
            `ServiceMonitor` objects and Alertmanager endpoints.

            If set, the value should be either "Endpoints" or "EndpointSlice".
            If unset, the operator assumes the "Endpoints" role.
            """
            return self._set("service_discovery_role", value)

        @overload
        def service_monitor_namespace_selector(
            self, value_or_callback: Optional[ServiceMonitorNamespaceSelector], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def service_monitor_namespace_selector(
            self,
            value_or_callback: Callable[
                [ServiceMonitorNamespaceSelector.Builder],
                ServiceMonitorNamespaceSelector.Builder | ServiceMonitorNamespaceSelector,
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def service_monitor_namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "ServiceMonitorNamespaceSelector.BuilderContext": ...

        def service_monitor_namespace_selector(self, value_or_callback=None, /):
            """
            Namespaces to match for ServicedMonitors discovery. An empty label selector
            matches all namespaces. A null label selector (default value) matches the current
            namespace only.
            """
            if self._in_context and value_or_callback is None:
                context = ServiceMonitorNamespaceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_monitor_namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceMonitorNamespaceSelector.builder())
                if isinstance(output, ServiceMonitorNamespaceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_monitor_namespace_selector", value)

        @overload
        def service_monitor_selector(
            self, value_or_callback: Optional[ServiceMonitorSelector], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def service_monitor_selector(
            self,
            value_or_callback: Callable[
                [ServiceMonitorSelector.Builder],
                ServiceMonitorSelector.Builder | ServiceMonitorSelector,
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def service_monitor_selector(
            self, value_or_callback: Never = ...
        ) -> "ServiceMonitorSelector.BuilderContext": ...

        def service_monitor_selector(self, value_or_callback=None, /):
            """
            ServiceMonitors to be selected for target discovery. An empty label
            selector matches all objects. A null label selector matches no objects.

            If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
            and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
            The Prometheus operator will ensure that the Prometheus configuration's
            Secret exists, but it is the responsibility of the user to provide the raw
            gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
            This behavior is *deprecated* and will be removed in the next major version
            of the custom resource definition. It is recommended to use
            `spec.additionalScrapeConfigs` instead.
            """
            if self._in_context and value_or_callback is None:
                context = ServiceMonitorSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_monitor_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceMonitorSelector.builder())
                if isinstance(output, ServiceMonitorSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_monitor_selector", value)

        def service_name(self, value: Optional[str], /) -> Self:
            """
            The name of the service name used by the underlying StatefulSet(s) as the governing service.
            If defined, the Service  must be created before the Prometheus/PrometheusAgent resource in the same namespace and it must define a selector that matches the pod labels.
            If empty, the operator will create and manage a headless service named `prometheus-operated` for Prometheus resources,
            or `prometheus-agent-operated` for PrometheusAgent resources.
            When deploying multiple Prometheus/PrometheusAgent resources in the same namespace, it is recommended to specify a different value for each.
            See https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#stable-network-id for more details.
            """
            return self._set("service_name", value)

        def sha(self, value: Optional[str], /) -> Self:
            """
            Deprecated: use 'spec.image' instead. The image's digest can be specified as part of the image name.
            """
            return self._set("sha", value)

        def shards(self, value: Optional[int], /) -> Self:
            """
            Number of shards to distribute scraped targets onto.

            `spec.replicas` multiplied by `spec.shards` is the total number of Pods
            being created.

            When not defined, the operator assumes only one shard.

            Note that scaling down shards will not reshard data onto the remaining
            instances, it must be manually moved. Increasing shards will not reshard
            data either but it will continue to be available from the same
            instances. To query globally, use Thanos sidecar and Thanos querier or
            remote write data to a central location.
            Alerting and recording rules

            By default, the sharding is performed on:
            * The `__address__` target's metadata label for PodMonitor,
            ServiceMonitor and ScrapeConfig resources.
            * The `__param_target__` label for Probe resources.

            Users can define their own sharding implementation by setting the
            `__tmp_hash` label during the target discovery with relabeling
            configuration (either in the monitoring resources or via scrape class).
            """
            return self._set("shards", value)

        @overload
        def storage(self, value_or_callback: Optional[Storage], /) -> "PrometheusSpec.Builder": ...

        @overload
        def storage(
            self,
            value_or_callback: Callable[[Storage.Builder], Storage.Builder | Storage],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def storage(self, value_or_callback: Never = ...) -> "Storage.BuilderContext": ...

        def storage(self, value_or_callback=None, /):
            """
            Storage defines the storage used by Prometheus.
            """
            if self._in_context and value_or_callback is None:
                context = Storage.BuilderContext()
                context._parent_builder = self
                context._field_name = "storage"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Storage.builder())
                if isinstance(output, Storage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("storage", value)

        def tag(self, value: Optional[str], /) -> Self:
            """
            Deprecated: use 'spec.image' instead. The image's tag can be specified as part of the image name.
            """
            return self._set("tag", value)

        def target_limit(self, value: Optional[int], /) -> Self:
            """
            TargetLimit defines a limit on the number of scraped targets that will be accepted.
            Only valid in Prometheus versions 2.45.0 and newer.

            Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
            If you want to enforce a maximum limit for all scrape objects, refer to enforcedTargetLimit.
            """
            return self._set("target_limit", value)

        @overload
        def thanos(self, value_or_callback: Optional[Thanos], /) -> "PrometheusSpec.Builder": ...

        @overload
        def thanos(
            self,
            value_or_callback: Callable[[Thanos.Builder], Thanos.Builder | Thanos],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def thanos(self, value_or_callback: Never = ...) -> "Thanos.BuilderContext": ...

        def thanos(self, value_or_callback=None, /):
            """
            Defines the configuration of the optional Thanos sidecar.
            """
            if self._in_context and value_or_callback is None:
                context = Thanos.BuilderContext()
                context._parent_builder = self
                context._field_name = "thanos"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Thanos.builder())
                if isinstance(output, Thanos.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("thanos", value)

        @overload
        def tolerations(
            self, value_or_callback: List[Toleration], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def tolerations(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Toleration, Toleration.Builder]],
                GenericListBuilder[Toleration, Toleration.Builder] | List[Toleration],
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def tolerations(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Toleration.Builder]: ...

        def tolerations(self, value_or_callback=None, /):
            """
            Defines the Pods' tolerations if specified.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Toleration.Builder]()
                context._parent_builder = self
                context._field_name = "tolerations"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Toleration.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("tolerations", value)

        @overload
        def topology_spread_constraints(
            self, value_or_callback: List[TopologySpreadConstraintModel], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def topology_spread_constraints(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        TopologySpreadConstraintModel,
                        TopologySpreadConstraintModel.Builder,
                    ]
                ],
                GenericListBuilder[
                    TopologySpreadConstraintModel, TopologySpreadConstraintModel.Builder
                ]
                | List[TopologySpreadConstraintModel],
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def topology_spread_constraints(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[TopologySpreadConstraintModel.Builder]: ...

        def topology_spread_constraints(self, value_or_callback=None, /):
            """
            Defines the pod's topology spread constraints if specified.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[TopologySpreadConstraintModel.Builder]()
                context._parent_builder = self
                context._field_name = "topology_spread_constraints"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TopologySpreadConstraintModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("topology_spread_constraints", value)

        @overload
        def tracing_config(
            self, value_or_callback: Optional[TracingConfigModel], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def tracing_config(
            self,
            value_or_callback: Callable[
                [TracingConfigModel.Builder],
                TracingConfigModel.Builder | TracingConfigModel,
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def tracing_config(
            self, value_or_callback: Never = ...
        ) -> "TracingConfigModel.BuilderContext": ...

        def tracing_config(self, value_or_callback=None, /):
            """
            TracingConfig configures tracing in Prometheus.

            This is an *experimental feature*, it may change in any upcoming release
            in a breaking way.
            """
            if self._in_context and value_or_callback is None:
                context = TracingConfigModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "tracing_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TracingConfigModel.builder())
                if isinstance(output, TracingConfigModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tracing_config", value)

        @overload
        def tsdb(self, value_or_callback: Optional[Tsdb], /) -> "PrometheusSpec.Builder": ...

        @overload
        def tsdb(
            self, value_or_callback: Callable[[Tsdb.Builder], Tsdb.Builder | Tsdb], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def tsdb(self, value_or_callback: Never = ...) -> "Tsdb.BuilderContext": ...

        def tsdb(self, value_or_callback=None, /):
            """
            Defines the runtime reloadable configuration of the timeseries database(TSDB).
            It requires Prometheus >= v2.39.0 or PrometheusAgent >= v2.54.0.
            """
            if self._in_context and value_or_callback is None:
                context = Tsdb.BuilderContext()
                context._parent_builder = self
                context._field_name = "tsdb"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Tsdb.builder())
                if isinstance(output, Tsdb.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tsdb", value)

        def version(self, value: Optional[str], /) -> Self:
            """
            Version of Prometheus being deployed. The operator uses this information
            to generate the Prometheus StatefulSet + configuration files.

            If not specified, the operator assumes the latest upstream version of
            Prometheus available at the time when the version of the operator was
            released.
            """
            return self._set("version", value)

        @overload
        def volume_mounts(
            self, value_or_callback: List[VolumeMount], /
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def volume_mounts(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[VolumeMount, VolumeMount.Builder]],
                GenericListBuilder[VolumeMount, VolumeMount.Builder] | List[VolumeMount],
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def volume_mounts(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[VolumeMount.Builder]: ...

        def volume_mounts(self, value_or_callback=None, /):
            """
            VolumeMounts allows the configuration of additional VolumeMounts.

            VolumeMounts will be appended to other VolumeMounts in the 'prometheus'
            container, that are generated as a result of StorageSpec objects.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[VolumeMount.Builder]()
                context._parent_builder = self
                context._field_name = "volume_mounts"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VolumeMount.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("volume_mounts", value)

        @overload
        def volumes(self, value_or_callback: List[Volume], /) -> "PrometheusSpec.Builder": ...

        @overload
        def volumes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Volume, Volume.Builder]],
                GenericListBuilder[Volume, Volume.Builder] | List[Volume],
            ],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def volumes(self, value_or_callback: Never = ...) -> ListBuilderContext[Volume.Builder]: ...

        def volumes(self, value_or_callback=None, /):
            """
            Volumes allows the configuration of additional volumes on the output
            StatefulSet definition. Volumes specified will be appended to other
            volumes that are generated as a result of StorageSpec objects.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Volume.Builder]()
                context._parent_builder = self
                context._field_name = "volumes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Volume.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("volumes", value)

        def wal_compression(self, value: Optional[bool], /) -> Self:
            """
            Configures compression of the write-ahead log (WAL) using Snappy.

            WAL compression is enabled by default for Prometheus >= 2.20.0

            Requires Prometheus v2.11.0 and above.
            """
            return self._set("wal_compression", value)

        @overload
        def web(self, value_or_callback: Optional[WebModel], /) -> "PrometheusSpec.Builder": ...

        @overload
        def web(
            self,
            value_or_callback: Callable[[WebModel.Builder], WebModel.Builder | WebModel],
            /,
        ) -> "PrometheusSpec.Builder": ...

        @overload
        def web(self, value_or_callback: Never = ...) -> "WebModel.BuilderContext": ...

        def web(self, value_or_callback=None, /):
            """
            Defines the configuration of the Prometheus web server.
            """
            if self._in_context and value_or_callback is None:
                context = WebModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "web"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WebModel.builder())
                if isinstance(output, WebModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("web", value)

    class BuilderContext(BuilderContextBase["PrometheusSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PrometheusSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PrometheusSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PrometheusSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PrometheusSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    additional_alert_manager_configs: Annotated[
        Optional[AdditionalAlertManagerConfigs],
        Field(alias="additionalAlertManagerConfigs"),
    ] = None
    """
    AdditionalAlertManagerConfigs specifies a key of a Secret containing
    additional Prometheus Alertmanager configurations. The Alertmanager
    configurations are appended to the configuration generated by the
    Prometheus Operator. They must be formatted according to the official
    Prometheus documentation:

    https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alertmanager_config

    The user is responsible for making sure that the configurations are valid

    Note that using this feature may expose the possibility to break
    upgrades of Prometheus. It is advised to review Prometheus release notes
    to ensure that no incompatible AlertManager configs are going to break
    Prometheus after the upgrade.
    """
    additional_alert_relabel_configs: Annotated[
        Optional[AdditionalAlertRelabelConfigs],
        Field(alias="additionalAlertRelabelConfigs"),
    ] = None
    """
    AdditionalAlertRelabelConfigs specifies a key of a Secret containing
    additional Prometheus alert relabel configurations. The alert relabel
    configurations are appended to the configuration generated by the
    Prometheus Operator. They must be formatted according to the official
    Prometheus documentation:

    https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs

    The user is responsible for making sure that the configurations are valid

    Note that using this feature may expose the possibility to break
    upgrades of Prometheus. It is advised to review Prometheus release notes
    to ensure that no incompatible alert relabel configs are going to break
    Prometheus after the upgrade.
    """
    additional_args: Annotated[Optional[List[AdditionalArg]], Field(alias="additionalArgs")] = None
    """
    AdditionalArgs allows setting additional arguments for the 'prometheus' container.

    It is intended for e.g. activating hidden flags which are not supported by
    the dedicated configuration options yet. The arguments are passed as-is to the
    Prometheus container which may cause issues if they are invalid or not supported
    by the given Prometheus version.

    In case of an argument conflict (e.g. an argument which is already set by the
    operator itself) or when providing an invalid argument, the reconciliation will
    fail and an error will be logged.
    """
    additional_scrape_configs: Annotated[
        Optional[AdditionalScrapeConfigs], Field(alias="additionalScrapeConfigs")
    ] = None
    """
    AdditionalScrapeConfigs allows specifying a key of a Secret containing
    additional Prometheus scrape configurations. Scrape configurations
    specified are appended to the configurations generated by the Prometheus
    Operator. Job configurations specified must have the form as specified
    in the official Prometheus documentation:
    https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config.
    As scrape configs are appended, the user is responsible to make sure it
    is valid. Note that using this feature may expose the possibility to
    break upgrades of Prometheus. It is advised to review Prometheus release
    notes to ensure that no incompatible scrape configs are going to break
    Prometheus after the upgrade.
    """
    affinity: Optional[Affinity] = None
    """
    Defines the Pods' affinity scheduling rules if specified.
    """
    alerting: Optional[Alerting] = None
    """
    Defines the settings related to Alertmanager.
    """
    allow_overlapping_blocks: Annotated[Optional[bool], Field(alias="allowOverlappingBlocks")] = (
        None
    )
    """
    AllowOverlappingBlocks enables vertical compaction and vertical query
    merge in Prometheus.

    Deprecated: this flag has no effect for Prometheus >= 2.39.0 where overlapping blocks are enabled by default.
    """
    apiserver_config: Annotated[Optional[ApiserverConfig], Field(alias="apiserverConfig")] = None
    """
    APIServerConfig allows specifying a host and auth methods to access the
    Kuberntees API server.
    If null, Prometheus is assumed to run inside of the cluster: it will
    discover the API servers automatically and use the Pod's CA certificate
    and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
    """
    arbitrary_fs_access_through_s_ms: Annotated[
        Optional[ArbitraryFsAccessThroughSMs],
        Field(alias="arbitraryFSAccessThroughSMs"),
    ] = None
    """
    When true, ServiceMonitor, PodMonitor and Probe object are forbidden to
    reference arbitrary files on the file system of the 'prometheus'
    container.
    When a ServiceMonitor's endpoint specifies a `bearerTokenFile` value
    (e.g.  '/var/run/secrets/kubernetes.io/serviceaccount/token'), a
    malicious target can get access to the Prometheus service account's
    token in the Prometheus' scrape request. Setting
    `spec.arbitraryFSAccessThroughSM` to 'true' would prevent the attack.
    Users should instead provide the credentials using the
    `spec.bearerTokenSecret` field.
    """
    automount_service_account_token: Annotated[
        Optional[bool], Field(alias="automountServiceAccountToken")
    ] = None
    """
    AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in the pod.
    If the field isn't set, the operator mounts the service account token by default.

    **Warning:** be aware that by default, Prometheus requires the service account token for Kubernetes service discovery.
    It is possible to use strategic merge patch to project the service account token into the 'prometheus' container.
    """
    base_image: Annotated[Optional[str], Field(alias="baseImage")] = None
    """
    Deprecated: use 'spec.image' instead.
    """
    body_size_limit: Annotated[
        Optional[str],
        Field(alias="bodySizeLimit", pattern="(^0|([0-9]*[.])?[0-9]+((K|M|G|T|E|P)i?)?B)$"),
    ] = None
    """
    BodySizeLimit defines per-scrape on response body size.
    Only valid in Prometheus versions 2.45.0 and newer.

    Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
    If you want to enforce a maximum limit for all scrape objects, refer to enforcedBodySizeLimit.
    """
    config_maps: Annotated[Optional[List[str]], Field(alias="configMaps")] = None
    """
    ConfigMaps is a list of ConfigMaps in the same namespace as the Prometheus
    object, which shall be mounted into the Prometheus Pods.
    Each ConfigMap is added to the StatefulSet definition as a volume named `configmap-<configmap-name>`.
    The ConfigMaps are mounted into /etc/prometheus/configmaps/<configmap-name> in the 'prometheus' container.
    """
    containers: Optional[List[Container]] = None
    """
    Containers allows injecting additional containers or modifying operator
    generated containers. This can be used to allow adding an authentication
    proxy to the Pods or to change the behavior of an operator generated
    container. Containers described here modify an operator generated
    container if they share the same name and modifications are done via a
    strategic merge patch.

    The names of containers managed by the operator are:
    * `prometheus`
    * `config-reloader`
    * `thanos-sidecar`

    Overriding containers is entirely outside the scope of what the
    maintainers will support and by doing so, you accept that this behaviour
    may break at any time without notice.
    """
    disable_compaction: Annotated[Optional[bool], Field(alias="disableCompaction")] = None
    """
    When true, the Prometheus compaction is disabled.
    When `spec.thanos.objectStorageConfig` or `spec.objectStorageConfigFile` are defined, the operator automatically
    disables block compaction to avoid race conditions during block uploads (as the Thanos documentation recommends).
    """
    dns_config: Annotated[Optional[DnsConfig], Field(alias="dnsConfig")] = None
    """
    Defines the DNS configuration for the pods.
    """
    dns_policy: Annotated[
        Optional[Literal["ClusterFirstWithHostNet", "ClusterFirst", "Default", "None"]],
        Field(alias="dnsPolicy"),
    ] = None
    """
    Defines the DNS policy for the pods.
    """
    enable_admin_api: Annotated[Optional[bool], Field(alias="enableAdminAPI")] = None
    """
    Enables access to the Prometheus web admin API.

    WARNING: Enabling the admin APIs enables mutating endpoints, to delete data,
    shutdown Prometheus, and more. Enabling this should be done with care and the
    user is advised to add additional authentication authorization via a proxy to
    ensure only clients authorized to perform these actions can do so.

    For more information:
    https://prometheus.io/docs/prometheus/latest/querying/api/#tsdb-admin-apis
    """
    enable_features: Annotated[Optional[List[EnableFeature]], Field(alias="enableFeatures")] = None
    """
    Enable access to Prometheus feature flags. By default, no features are enabled.

    Enabling features which are disabled by default is entirely outside the
    scope of what the maintainers will support and by doing so, you accept
    that this behaviour may break at any time without notice.

    For more information see https://prometheus.io/docs/prometheus/latest/feature_flags/
    """
    enable_otlp_receiver: Annotated[Optional[bool], Field(alias="enableOTLPReceiver")] = None
    """
    Enable Prometheus to be used as a receiver for the OTLP Metrics protocol.

    Note that the OTLP receiver endpoint is automatically enabled if `.spec.otlpConfig` is defined.

    It requires Prometheus >= v2.47.0.
    """
    enable_remote_write_receiver: Annotated[
        Optional[bool], Field(alias="enableRemoteWriteReceiver")
    ] = None
    """
    Enable Prometheus to be used as a receiver for the Prometheus remote
    write protocol.

    WARNING: This is not considered an efficient way of ingesting samples.
    Use it with caution for specific low-volume use cases.
    It is not suitable for replacing the ingestion via scraping and turning
    Prometheus into a push-based metrics collection system.
    For more information see https://prometheus.io/docs/prometheus/latest/querying/api/#remote-write-receiver

    It requires Prometheus >= v2.33.0.
    """
    enforced_body_size_limit: Annotated[
        Optional[str],
        Field(
            alias="enforcedBodySizeLimit",
            pattern="(^0|([0-9]*[.])?[0-9]+((K|M|G|T|E|P)i?)?B)$",
        ),
    ] = None
    """
    When defined, enforcedBodySizeLimit specifies a global limit on the size
    of uncompressed response body that will be accepted by Prometheus.
    Targets responding with a body larger than this many bytes will cause
    the scrape to fail.

    It requires Prometheus >= v2.28.0.

    When both `enforcedBodySizeLimit` and `bodySizeLimit` are defined and greater than zero, the following rules apply:
    * Scrape objects without a defined bodySizeLimit value will inherit the global bodySizeLimit value (Prometheus >= 2.45.0) or the enforcedBodySizeLimit value (Prometheus < v2.45.0).
      If Prometheus version is >= 2.45.0 and the `enforcedBodySizeLimit` is greater than the `bodySizeLimit`, the `bodySizeLimit` will be set to `enforcedBodySizeLimit`.
    * Scrape objects with a bodySizeLimit value less than or equal to enforcedBodySizeLimit keep their specific value.
    * Scrape objects with a bodySizeLimit value greater than enforcedBodySizeLimit are set to enforcedBodySizeLimit.
    """
    enforced_keep_dropped_targets: Annotated[
        Optional[int], Field(alias="enforcedKeepDroppedTargets")
    ] = None
    """
    When defined, enforcedKeepDroppedTargets specifies a global limit on the number of targets
    dropped by relabeling that will be kept in memory. The value overrides
    any `spec.keepDroppedTargets` set by
    ServiceMonitor, PodMonitor, Probe objects unless `spec.keepDroppedTargets` is
    greater than zero and less than `spec.enforcedKeepDroppedTargets`.

    It requires Prometheus >= v2.47.0.

    When both `enforcedKeepDroppedTargets` and `keepDroppedTargets` are defined and greater than zero, the following rules apply:
    * Scrape objects without a defined keepDroppedTargets value will inherit the global keepDroppedTargets value (Prometheus >= 2.45.0) or the enforcedKeepDroppedTargets value (Prometheus < v2.45.0).
      If Prometheus version is >= 2.45.0 and the `enforcedKeepDroppedTargets` is greater than the `keepDroppedTargets`, the `keepDroppedTargets` will be set to `enforcedKeepDroppedTargets`.
    * Scrape objects with a keepDroppedTargets value less than or equal to enforcedKeepDroppedTargets keep their specific value.
    * Scrape objects with a keepDroppedTargets value greater than enforcedKeepDroppedTargets are set to enforcedKeepDroppedTargets.
    """
    enforced_label_limit: Annotated[Optional[int], Field(alias="enforcedLabelLimit")] = None
    """
    When defined, enforcedLabelLimit specifies a global limit on the number
    of labels per sample. The value overrides any `spec.labelLimit` set by
    ServiceMonitor, PodMonitor, Probe objects unless `spec.labelLimit` is
    greater than zero and less than `spec.enforcedLabelLimit`.

    It requires Prometheus >= v2.27.0.

    When both `enforcedLabelLimit` and `labelLimit` are defined and greater than zero, the following rules apply:
    * Scrape objects without a defined labelLimit value will inherit the global labelLimit value (Prometheus >= 2.45.0) or the enforcedLabelLimit value (Prometheus < v2.45.0).
      If Prometheus version is >= 2.45.0 and the `enforcedLabelLimit` is greater than the `labelLimit`, the `labelLimit` will be set to `enforcedLabelLimit`.
    * Scrape objects with a labelLimit value less than or equal to enforcedLabelLimit keep their specific value.
    * Scrape objects with a labelLimit value greater than enforcedLabelLimit are set to enforcedLabelLimit.
    """
    enforced_label_name_length_limit: Annotated[
        Optional[int], Field(alias="enforcedLabelNameLengthLimit")
    ] = None
    """
    When defined, enforcedLabelNameLengthLimit specifies a global limit on the length
    of labels name per sample. The value overrides any `spec.labelNameLengthLimit` set by
    ServiceMonitor, PodMonitor, Probe objects unless `spec.labelNameLengthLimit` is
    greater than zero and less than `spec.enforcedLabelNameLengthLimit`.

    It requires Prometheus >= v2.27.0.

    When both `enforcedLabelNameLengthLimit` and `labelNameLengthLimit` are defined and greater than zero, the following rules apply:
    * Scrape objects without a defined labelNameLengthLimit value will inherit the global labelNameLengthLimit value (Prometheus >= 2.45.0) or the enforcedLabelNameLengthLimit value (Prometheus < v2.45.0).
      If Prometheus version is >= 2.45.0 and the `enforcedLabelNameLengthLimit` is greater than the `labelNameLengthLimit`, the `labelNameLengthLimit` will be set to `enforcedLabelNameLengthLimit`.
    * Scrape objects with a labelNameLengthLimit value less than or equal to enforcedLabelNameLengthLimit keep their specific value.
    * Scrape objects with a labelNameLengthLimit value greater than enforcedLabelNameLengthLimit are set to enforcedLabelNameLengthLimit.
    """
    enforced_label_value_length_limit: Annotated[
        Optional[int], Field(alias="enforcedLabelValueLengthLimit")
    ] = None
    """
    When not null, enforcedLabelValueLengthLimit defines a global limit on the length
    of labels value per sample. The value overrides any `spec.labelValueLengthLimit` set by
    ServiceMonitor, PodMonitor, Probe objects unless `spec.labelValueLengthLimit` is
    greater than zero and less than `spec.enforcedLabelValueLengthLimit`.

    It requires Prometheus >= v2.27.0.

    When both `enforcedLabelValueLengthLimit` and `labelValueLengthLimit` are defined and greater than zero, the following rules apply:
    * Scrape objects without a defined labelValueLengthLimit value will inherit the global labelValueLengthLimit value (Prometheus >= 2.45.0) or the enforcedLabelValueLengthLimit value (Prometheus < v2.45.0).
      If Prometheus version is >= 2.45.0 and the `enforcedLabelValueLengthLimit` is greater than the `labelValueLengthLimit`, the `labelValueLengthLimit` will be set to `enforcedLabelValueLengthLimit`.
    * Scrape objects with a labelValueLengthLimit value less than or equal to enforcedLabelValueLengthLimit keep their specific value.
    * Scrape objects with a labelValueLengthLimit value greater than enforcedLabelValueLengthLimit are set to enforcedLabelValueLengthLimit.
    """
    enforced_namespace_label: Annotated[Optional[str], Field(alias="enforcedNamespaceLabel")] = None
    """
    When not empty, a label will be added to:

    1. All metrics scraped from `ServiceMonitor`, `PodMonitor`, `Probe` and `ScrapeConfig` objects.
    2. All metrics generated from recording rules defined in `PrometheusRule` objects.
    3. All alerts generated from alerting rules defined in `PrometheusRule` objects.
    4. All vector selectors of PromQL expressions defined in `PrometheusRule` objects.

    The label will not added for objects referenced in `spec.excludedFromEnforcement`.

    The label's name is this field's value.
    The label's value is the namespace of the `ServiceMonitor`,
    `PodMonitor`, `Probe`, `PrometheusRule` or `ScrapeConfig` object.
    """
    enforced_sample_limit: Annotated[Optional[int], Field(alias="enforcedSampleLimit")] = None
    """
    When defined, enforcedSampleLimit specifies a global limit on the number
    of scraped samples that will be accepted. This overrides any
    `spec.sampleLimit` set by ServiceMonitor, PodMonitor, Probe objects
    unless `spec.sampleLimit` is greater than zero and less than
    `spec.enforcedSampleLimit`.

    It is meant to be used by admins to keep the overall number of
    samples/series under a desired limit.

    When both `enforcedSampleLimit` and `sampleLimit` are defined and greater than zero, the following rules apply:
    * Scrape objects without a defined sampleLimit value will inherit the global sampleLimit value (Prometheus >= 2.45.0) or the enforcedSampleLimit value (Prometheus < v2.45.0).
      If Prometheus version is >= 2.45.0 and the `enforcedSampleLimit` is greater than the `sampleLimit`, the `sampleLimit` will be set to `enforcedSampleLimit`.
    * Scrape objects with a sampleLimit value less than or equal to enforcedSampleLimit keep their specific value.
    * Scrape objects with a sampleLimit value greater than enforcedSampleLimit are set to enforcedSampleLimit.
    """
    enforced_target_limit: Annotated[Optional[int], Field(alias="enforcedTargetLimit")] = None
    """
    When defined, enforcedTargetLimit specifies a global limit on the number
    of scraped targets. The value overrides any `spec.targetLimit` set by
    ServiceMonitor, PodMonitor, Probe objects unless `spec.targetLimit` is
    greater than zero and less than `spec.enforcedTargetLimit`.

    It is meant to be used by admins to to keep the overall number of
    targets under a desired limit.

    When both `enforcedTargetLimit` and `targetLimit` are defined and greater than zero, the following rules apply:
    * Scrape objects without a defined targetLimit value will inherit the global targetLimit value (Prometheus >= 2.45.0) or the enforcedTargetLimit value (Prometheus < v2.45.0).
      If Prometheus version is >= 2.45.0 and the `enforcedTargetLimit` is greater than the `targetLimit`, the `targetLimit` will be set to `enforcedTargetLimit`.
    * Scrape objects with a targetLimit value less than or equal to enforcedTargetLimit keep their specific value.
    * Scrape objects with a targetLimit value greater than enforcedTargetLimit are set to enforcedTargetLimit.
    """
    evaluation_interval: Annotated[
        Optional[str],
        Field(
            alias="evaluationInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = "30s"
    """
    Interval between rule evaluations.
    Default: "30s"
    """
    excluded_from_enforcement: Annotated[
        Optional[List[ExcludedFromEnforcement]], Field(alias="excludedFromEnforcement")
    ] = None
    """
    List of references to PodMonitor, ServiceMonitor, Probe and PrometheusRule objects
    to be excluded from enforcing a namespace label of origin.

    It is only applicable if `spec.enforcedNamespaceLabel` set to true.
    """
    exemplars: Optional[Exemplars] = None
    """
    Exemplars related settings that are runtime reloadable.
    It requires to enable the `exemplar-storage` feature flag to be effective.
    """
    external_labels: Annotated[Optional[Dict[str, str]], Field(alias="externalLabels")] = None
    """
    The labels to add to any time series or alerts when communicating with
    external systems (federation, remote storage, Alertmanager).
    Labels defined by `spec.replicaExternalLabelName` and
    `spec.prometheusExternalLabelName` take precedence over this list.
    """
    external_url: Annotated[Optional[str], Field(alias="externalUrl")] = None
    """
    The external URL under which the Prometheus service is externally
    available. This is necessary to generate correct URLs (for instance if
    Prometheus is accessible behind an Ingress resource).
    """
    host_aliases: Annotated[Optional[List[HostAliase]], Field(alias="hostAliases")] = None
    """
    Optional list of hosts and IPs that will be injected into the Pod's
    hosts file if specified.
    """
    host_network: Annotated[Optional[bool], Field(alias="hostNetwork")] = None
    """
    Use the host's network namespace if true.

    Make sure to understand the security implications if you want to enable
    it (https://kubernetes.io/docs/concepts/configuration/overview/).

    When hostNetwork is enabled, this will set the DNS policy to
    `ClusterFirstWithHostNet` automatically (unless `.spec.DNSPolicy` is set
    to a different value).
    """
    ignore_namespace_selectors: Annotated[
        Optional[bool], Field(alias="ignoreNamespaceSelectors")
    ] = None
    """
    When true, `spec.namespaceSelector` from all PodMonitor, ServiceMonitor
    and Probe objects will be ignored. They will only discover targets
    within the namespace of the PodMonitor, ServiceMonitor and Probe
    object.
    """
    image: Optional[str] = None
    """
    Container image name for Prometheus. If specified, it takes precedence
    over the `spec.baseImage`, `spec.tag` and `spec.sha` fields.

    Specifying `spec.version` is still necessary to ensure the Prometheus
    Operator knows which version of Prometheus is being configured.

    If neither `spec.image` nor `spec.baseImage` are defined, the operator
    will use the latest upstream version of Prometheus available at the time
    when the operator was released.
    """
    image_pull_policy: Annotated[
        Optional[Literal["", "Always", "Never", "IfNotPresent"]],
        Field(alias="imagePullPolicy"),
    ] = None
    """
    Image pull policy for the 'prometheus', 'init-config-reloader' and 'config-reloader' containers.
    See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
    """
    image_pull_secrets: Annotated[
        Optional[List[ImagePullSecret]], Field(alias="imagePullSecrets")
    ] = None
    """
    An optional list of references to Secrets in the same namespace
    to use for pulling images from registries.
    See http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
    """
    init_containers: Annotated[Optional[List[InitContainer]], Field(alias="initContainers")] = None
    """
    InitContainers allows injecting initContainers to the Pod definition. Those
    can be used to e.g.  fetch secrets for injection into the Prometheus
    configuration from external sources. Any errors during the execution of
    an initContainer will lead to a restart of the Pod. More info:
    https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
    InitContainers described here modify an operator generated init
    containers if they share the same name and modifications are done via a
    strategic merge patch.

    The names of init container name managed by the operator are:
    * `init-config-reloader`.

    Overriding init containers is entirely outside the scope of what the
    maintainers will support and by doing so, you accept that this behaviour
    may break at any time without notice.
    """
    keep_dropped_targets: Annotated[Optional[int], Field(alias="keepDroppedTargets")] = None
    """
    Per-scrape limit on the number of targets dropped by relabeling
    that will be kept in memory. 0 means no limit.

    It requires Prometheus >= v2.47.0.

    Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
    If you want to enforce a maximum limit for all scrape objects, refer to enforcedKeepDroppedTargets.
    """
    label_limit: Annotated[Optional[int], Field(alias="labelLimit")] = None
    """
    Per-scrape limit on number of labels that will be accepted for a sample.
    Only valid in Prometheus versions 2.45.0 and newer.

    Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
    If you want to enforce a maximum limit for all scrape objects, refer to enforcedLabelLimit.
    """
    label_name_length_limit: Annotated[Optional[int], Field(alias="labelNameLengthLimit")] = None
    """
    Per-scrape limit on length of labels name that will be accepted for a sample.
    Only valid in Prometheus versions 2.45.0 and newer.

    Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
    If you want to enforce a maximum limit for all scrape objects, refer to enforcedLabelNameLengthLimit.
    """
    label_value_length_limit: Annotated[Optional[int], Field(alias="labelValueLengthLimit")] = None
    """
    Per-scrape limit on length of labels value that will be accepted for a sample.
    Only valid in Prometheus versions 2.45.0 and newer.

    Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
    If you want to enforce a maximum limit for all scrape objects, refer to enforcedLabelValueLengthLimit.
    """
    listen_local: Annotated[Optional[bool], Field(alias="listenLocal")] = None
    """
    When true, the Prometheus server listens on the loopback address
    instead of the Pod IP's address.
    """
    log_format: Annotated[Optional[Literal["", "logfmt", "json"]], Field(alias="logFormat")] = None
    """
    Log format for Log level for Prometheus and the config-reloader sidecar.
    """
    log_level: Annotated[
        Optional[Literal["", "debug", "info", "warn", "error"]], Field(alias="logLevel")
    ] = None
    """
    Log level for Prometheus and the config-reloader sidecar.
    """
    maximum_startup_duration_seconds: Annotated[
        Optional[int], Field(alias="maximumStartupDurationSeconds", ge=60)
    ] = None
    """
    Defines the maximum time that the `prometheus` container's startup probe will wait before being considered failed. The startup probe will return success after the WAL replay is complete.
    If set, the value should be greater than 60 (seconds). Otherwise it will be equal to 600 seconds (15 minutes).
    """
    min_ready_seconds: Annotated[Optional[int], Field(alias="minReadySeconds")] = None
    """
    Minimum number of seconds for which a newly created Pod should be ready
    without any of its container crashing for it to be considered available.
    Defaults to 0 (pod will be considered available as soon as it is ready)

    This is an alpha field from kubernetes 1.22 until 1.24 which requires
    enabling the StatefulSetMinReadySeconds feature gate.
    """
    name_validation_scheme: Annotated[
        Optional[Literal["UTF8", "Legacy"]], Field(alias="nameValidationScheme")
    ] = None
    """
    Specifies the validation scheme for metric and label names.
    """
    node_selector: Annotated[Optional[Dict[str, str]], Field(alias="nodeSelector")] = None
    """
    Defines on which Nodes the Pods are scheduled.
    """
    otlp: Optional[Otlp] = None
    """
    Settings related to the OTLP receiver feature.
    It requires Prometheus >= v2.55.0.
    """
    override_honor_labels: Annotated[Optional[bool], Field(alias="overrideHonorLabels")] = None
    """
    When true, Prometheus resolves label conflicts by renaming the labels in the scraped data
     to exported_ for all targets created from ServiceMonitor, PodMonitor and
    ScrapeConfig objects. Otherwise the HonorLabels field of the service or pod monitor applies.
    In practice,`overrideHonorLaels:true` enforces `honorLabels:false`
    for all ServiceMonitor, PodMonitor and ScrapeConfig objects.
    """
    override_honor_timestamps: Annotated[Optional[bool], Field(alias="overrideHonorTimestamps")] = (
        None
    )
    """
    When true, Prometheus ignores the timestamps for all the targets created
    from service and pod monitors.
    Otherwise the HonorTimestamps field of the service or pod monitor applies.
    """
    paused: Optional[bool] = None
    """
    When a Prometheus deployment is paused, no actions except for deletion
    will be performed on the underlying objects.
    """
    persistent_volume_claim_retention_policy: Annotated[
        Optional[PersistentVolumeClaimRetentionPolicy],
        Field(alias="persistentVolumeClaimRetentionPolicy"),
    ] = None
    """
    The field controls if and how PVCs are deleted during the lifecycle of a StatefulSet.
    The default behavior is all PVCs are retained.
    This is an alpha field from kubernetes 1.23 until 1.26 and a beta field from 1.26.
    It requires enabling the StatefulSetAutoDeletePVC feature gate.
    """
    pod_metadata: Annotated[Optional[PodMetadata], Field(alias="podMetadata")] = None
    """
    PodMetadata configures labels and annotations which are propagated to the Prometheus pods.

    The following items are reserved and cannot be overridden:
    * "prometheus" label, set to the name of the Prometheus object.
    * "app.kubernetes.io/instance" label, set to the name of the Prometheus object.
    * "app.kubernetes.io/managed-by" label, set to "prometheus-operator".
    * "app.kubernetes.io/name" label, set to "prometheus".
    * "app.kubernetes.io/version" label, set to the Prometheus version.
    * "operator.prometheus.io/name" label, set to the name of the Prometheus object.
    * "operator.prometheus.io/shard" label, set to the shard number of the Prometheus object.
    * "kubectl.kubernetes.io/default-container" annotation, set to "prometheus".
    """
    pod_monitor_namespace_selector: Annotated[
        Optional[PodMonitorNamespaceSelector],
        Field(alias="podMonitorNamespaceSelector"),
    ] = None
    """
    Namespaces to match for PodMonitors discovery. An empty label selector
    matches all namespaces. A null label selector (default value) matches the current
    namespace only.
    """
    pod_monitor_selector: Annotated[
        Optional[PodMonitorSelector], Field(alias="podMonitorSelector")
    ] = None
    """
    PodMonitors to be selected for target discovery. An empty label selector
    matches all objects. A null label selector matches no objects.

    If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
    and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
    The Prometheus operator will ensure that the Prometheus configuration's
    Secret exists, but it is the responsibility of the user to provide the raw
    gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
    This behavior is *deprecated* and will be removed in the next major version
    of the custom resource definition. It is recommended to use
    `spec.additionalScrapeConfigs` instead.
    """
    pod_target_labels: Annotated[Optional[List[str]], Field(alias="podTargetLabels")] = None
    """
    PodTargetLabels are appended to the `spec.podTargetLabels` field of all
    PodMonitor and ServiceMonitor objects.
    """
    port_name: Annotated[Optional[str], Field(alias="portName")] = "web"
    """
    Port name used for the pods and governing service.
    Default: "web"
    """
    priority_class_name: Annotated[Optional[str], Field(alias="priorityClassName")] = None
    """
    Priority class assigned to the Pods.
    """
    probe_namespace_selector: Annotated[
        Optional[ProbeNamespaceSelector], Field(alias="probeNamespaceSelector")
    ] = None
    """
    Namespaces to match for Probe discovery. An empty label
    selector matches all namespaces. A null label selector matches the
    current namespace only.
    """
    probe_selector: Annotated[Optional[ProbeSelector], Field(alias="probeSelector")] = None
    """
    Probes to be selected for target discovery. An empty label selector
    matches all objects. A null label selector matches no objects.

    If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
    and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
    The Prometheus operator will ensure that the Prometheus configuration's
    Secret exists, but it is the responsibility of the user to provide the raw
    gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
    This behavior is *deprecated* and will be removed in the next major version
    of the custom resource definition. It is recommended to use
    `spec.additionalScrapeConfigs` instead.
    """
    prometheus_external_label_name: Annotated[
        Optional[str], Field(alias="prometheusExternalLabelName")
    ] = None
    """
    Name of Prometheus external label used to denote the Prometheus instance
    name. The external label will _not_ be added when the field is set to
    the empty string (`""`).

    Default: "prometheus"
    """
    prometheus_rules_excluded_from_enforce: Annotated[
        Optional[List[PrometheusRulesExcludedFromEnforce]],
        Field(alias="prometheusRulesExcludedFromEnforce"),
    ] = None
    """
    Defines the list of PrometheusRule objects to which the namespace label
    enforcement doesn't apply.
    This is only relevant when `spec.enforcedNamespaceLabel` is set to true.
    Deprecated: use `spec.excludedFromEnforcement` instead.
    """
    query: Optional[Query] = None
    """
    QuerySpec defines the configuration of the Promethus query service.
    """
    query_log_file: Annotated[Optional[str], Field(alias="queryLogFile")] = None
    """
    queryLogFile specifies where the file to which PromQL queries are logged.

    If the filename has an empty path, e.g. 'query.log', The Prometheus Pods
    will mount the file into an emptyDir volume at `/var/log/prometheus`.
    If a full path is provided, e.g. '/var/log/prometheus/query.log', you
    must mount a volume in the specified directory and it must be writable.
    This is because the prometheus container runs with a read-only root
    filesystem for security reasons.
    Alternatively, the location can be set to a standard I/O stream, e.g.
    `/dev/stdout`, to log query information to the default Prometheus log
    stream.
    """
    reload_strategy: Annotated[
        Optional[Literal["HTTP", "ProcessSignal"]], Field(alias="reloadStrategy")
    ] = None
    """
    Defines the strategy used to reload the Prometheus configuration.
    If not specified, the configuration is reloaded using the /-/reload HTTP endpoint.
    """
    remote_read: Annotated[Optional[List[RemoteRead]], Field(alias="remoteRead")] = None
    """
    Defines the list of remote read configurations.
    """
    remote_write: Annotated[Optional[List[RemoteWrite]], Field(alias="remoteWrite")] = None
    """
    Defines the list of remote write configurations.
    """
    remote_write_receiver_message_versions: Annotated[
        Optional[List[Literal["V1.0", "V2.0"]]],
        Field(alias="remoteWriteReceiverMessageVersions", min_length=1),
    ] = None
    """
    List of the protobuf message versions to accept when receiving the
    remote writes.

    It requires Prometheus >= v2.54.0.
    """
    replica_external_label_name: Annotated[
        Optional[str], Field(alias="replicaExternalLabelName")
    ] = None
    """
    Name of Prometheus external label used to denote the replica name.
    The external label will _not_ be added when the field is set to the
    empty string (`""`).

    Default: "prometheus_replica"
    """
    replicas: Optional[int] = None
    """
    Number of replicas of each shard to deploy for a Prometheus deployment.
    `spec.replicas` multiplied by `spec.shards` is the total number of Pods
    created.

    Default: 1
    """
    resources: Optional[ResourcesModel1] = None
    """
    Defines the resources requests and limits of the 'prometheus' container.
    """
    retention: Annotated[
        Optional[str],
        Field(
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"
        ),
    ] = None
    """
    How long to retain the Prometheus data.

    Default: "24h" if `spec.retention` and `spec.retentionSize` are empty.
    """
    retention_size: Annotated[
        Optional[str],
        Field(alias="retentionSize", pattern="(^0|([0-9]*[.])?[0-9]+((K|M|G|T|E|P)i?)?B)$"),
    ] = None
    """
    Maximum number of bytes used by the Prometheus data.
    """
    route_prefix: Annotated[Optional[str], Field(alias="routePrefix")] = None
    """
    The route prefix Prometheus registers HTTP handlers for.

    This is useful when using `spec.externalURL`, and a proxy is rewriting
    HTTP routes of a request, and the actual ExternalURL is still true, but
    the server serves requests under a different route prefix. For example
    for use with `kubectl proxy`.
    """
    rule_namespace_selector: Annotated[
        Optional[RuleNamespaceSelector], Field(alias="ruleNamespaceSelector")
    ] = None
    """
    Namespaces to match for PrometheusRule discovery. An empty label selector
    matches all namespaces. A null label selector matches the current
    namespace only.
    """
    rule_query_offset: Annotated[
        Optional[str],
        Field(
            alias="ruleQueryOffset",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Defines the offset the rule evaluation timestamp of this particular group by the specified duration into the past.
    It requires Prometheus >= v2.53.0.
    """
    rule_selector: Annotated[Optional[RuleSelector], Field(alias="ruleSelector")] = None
    """
    PrometheusRule objects to be selected for rule evaluation. An empty
    label selector matches all objects. A null label selector matches no
    objects.
    """
    rules: Optional[Rules] = None
    """
    Defines the configuration of the Prometheus rules' engine.
    """
    runtime: Optional[Runtime] = None
    """
    RuntimeConfig configures the values for the Prometheus process behavior
    """
    sample_limit: Annotated[Optional[int], Field(alias="sampleLimit")] = None
    """
    SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
    Only valid in Prometheus versions 2.45.0 and newer.

    Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
    If you want to enforce a maximum limit for all scrape objects, refer to enforcedSampleLimit.
    """
    scrape_classes: Annotated[Optional[List[ScrapeClass]], Field(alias="scrapeClasses")] = None
    """
    List of scrape classes to expose to scraping objects such as
    PodMonitors, ServiceMonitors, Probes and ScrapeConfigs.

    This is an *experimental feature*, it may change in any upcoming release
    in a breaking way.
    """
    scrape_config_namespace_selector: Annotated[
        Optional[ScrapeConfigNamespaceSelector],
        Field(alias="scrapeConfigNamespaceSelector"),
    ] = None
    """
    Namespaces to match for ScrapeConfig discovery. An empty label selector
    matches all namespaces. A null label selector matches the current
    namespace only.

    Note that the ScrapeConfig custom resource definition is currently at Alpha level.
    """
    scrape_config_selector: Annotated[
        Optional[ScrapeConfigSelector], Field(alias="scrapeConfigSelector")
    ] = None
    """
    ScrapeConfigs to be selected for target discovery. An empty label
    selector matches all objects. A null label selector matches no objects.

    If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
    and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
    The Prometheus operator will ensure that the Prometheus configuration's
    Secret exists, but it is the responsibility of the user to provide the raw
    gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
    This behavior is *deprecated* and will be removed in the next major version
    of the custom resource definition. It is recommended to use
    `spec.additionalScrapeConfigs` instead.

    Note that the ScrapeConfig custom resource definition is currently at Alpha level.
    """
    scrape_failure_log_file: Annotated[
        Optional[str], Field(alias="scrapeFailureLogFile", min_length=1)
    ] = None
    """
    File to which scrape failures are logged.
    Reloading the configuration will reopen the file.

    If the filename has an empty path, e.g. 'file.log', The Prometheus Pods
    will mount the file into an emptyDir volume at `/var/log/prometheus`.
    If a full path is provided, e.g. '/var/log/prometheus/file.log', you
    must mount a volume in the specified directory and it must be writable.
    It requires Prometheus >= v2.55.0.
    """
    scrape_interval: Annotated[
        Optional[str],
        Field(
            alias="scrapeInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = "30s"
    """
    Interval between consecutive scrapes.

    Default: "30s"
    """
    scrape_protocols: Annotated[
        Optional[
            List[
                Literal[
                    "PrometheusProto",
                    "OpenMetricsText0.0.1",
                    "OpenMetricsText1.0.0",
                    "PrometheusText0.0.4",
                    "PrometheusText1.0.0",
                ]
            ]
        ],
        Field(alias="scrapeProtocols"),
    ] = None
    """
    The protocols to negotiate during a scrape. It tells clients the
    protocols supported by Prometheus in order of preference (from most to least preferred).

    If unset, Prometheus uses its default value.

    It requires Prometheus >= v2.49.0.

    `PrometheusText1.0.0` requires Prometheus >= v3.0.0.
    """
    scrape_timeout: Annotated[
        Optional[str],
        Field(
            alias="scrapeTimeout",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Number of seconds to wait until a scrape request times out.
    The value cannot be greater than the scrape interval otherwise the operator will reject the resource.
    """
    secrets: Optional[List[str]] = None
    """
    Secrets is a list of Secrets in the same namespace as the Prometheus
    object, which shall be mounted into the Prometheus Pods.
    Each Secret is added to the StatefulSet definition as a volume named `secret-<secret-name>`.
    The Secrets are mounted into /etc/prometheus/secrets/<secret-name> in the 'prometheus' container.
    """
    security_context: Annotated[Optional[SecurityContextModel2], Field(alias="securityContext")] = (
        None
    )
    """
    SecurityContext holds pod-level security attributes and common container settings.
    This defaults to the default PodSecurityContext.
    """
    service_account_name: Annotated[Optional[str], Field(alias="serviceAccountName")] = None
    """
    ServiceAccountName is the name of the ServiceAccount to use to run the
    Prometheus Pods.
    """
    service_discovery_role: Annotated[
        Optional[Literal["Endpoints", "EndpointSlice"]],
        Field(alias="serviceDiscoveryRole"),
    ] = None
    """
    Defines the service discovery role used to discover targets from
    `ServiceMonitor` objects and Alertmanager endpoints.

    If set, the value should be either "Endpoints" or "EndpointSlice".
    If unset, the operator assumes the "Endpoints" role.
    """
    service_monitor_namespace_selector: Annotated[
        Optional[ServiceMonitorNamespaceSelector],
        Field(alias="serviceMonitorNamespaceSelector"),
    ] = None
    """
    Namespaces to match for ServicedMonitors discovery. An empty label selector
    matches all namespaces. A null label selector (default value) matches the current
    namespace only.
    """
    service_monitor_selector: Annotated[
        Optional[ServiceMonitorSelector], Field(alias="serviceMonitorSelector")
    ] = None
    """
    ServiceMonitors to be selected for target discovery. An empty label
    selector matches all objects. A null label selector matches no objects.

    If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
    and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
    The Prometheus operator will ensure that the Prometheus configuration's
    Secret exists, but it is the responsibility of the user to provide the raw
    gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
    This behavior is *deprecated* and will be removed in the next major version
    of the custom resource definition. It is recommended to use
    `spec.additionalScrapeConfigs` instead.
    """
    service_name: Annotated[Optional[str], Field(alias="serviceName", min_length=1)] = None
    """
    The name of the service name used by the underlying StatefulSet(s) as the governing service.
    If defined, the Service  must be created before the Prometheus/PrometheusAgent resource in the same namespace and it must define a selector that matches the pod labels.
    If empty, the operator will create and manage a headless service named `prometheus-operated` for Prometheus resources,
    or `prometheus-agent-operated` for PrometheusAgent resources.
    When deploying multiple Prometheus/PrometheusAgent resources in the same namespace, it is recommended to specify a different value for each.
    See https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#stable-network-id for more details.
    """
    sha: Optional[str] = None
    """
    Deprecated: use 'spec.image' instead. The image's digest can be specified as part of the image name.
    """
    shards: Optional[int] = None
    """
    Number of shards to distribute scraped targets onto.

    `spec.replicas` multiplied by `spec.shards` is the total number of Pods
    being created.

    When not defined, the operator assumes only one shard.

    Note that scaling down shards will not reshard data onto the remaining
    instances, it must be manually moved. Increasing shards will not reshard
    data either but it will continue to be available from the same
    instances. To query globally, use Thanos sidecar and Thanos querier or
    remote write data to a central location.
    Alerting and recording rules

    By default, the sharding is performed on:
    * The `__address__` target's metadata label for PodMonitor,
    ServiceMonitor and ScrapeConfig resources.
    * The `__param_target__` label for Probe resources.

    Users can define their own sharding implementation by setting the
    `__tmp_hash` label during the target discovery with relabeling
    configuration (either in the monitoring resources or via scrape class).
    """
    storage: Optional[Storage] = None
    """
    Storage defines the storage used by Prometheus.
    """
    tag: Optional[str] = None
    """
    Deprecated: use 'spec.image' instead. The image's tag can be specified as part of the image name.
    """
    target_limit: Annotated[Optional[int], Field(alias="targetLimit")] = None
    """
    TargetLimit defines a limit on the number of scraped targets that will be accepted.
    Only valid in Prometheus versions 2.45.0 and newer.

    Note that the global limit only applies to scrape objects that don't specify an explicit limit value.
    If you want to enforce a maximum limit for all scrape objects, refer to enforcedTargetLimit.
    """
    thanos: Optional[Thanos] = None
    """
    Defines the configuration of the optional Thanos sidecar.
    """
    tolerations: Optional[List[Toleration]] = None
    """
    Defines the Pods' tolerations if specified.
    """
    topology_spread_constraints: Annotated[
        Optional[List[TopologySpreadConstraintModel]],
        Field(alias="topologySpreadConstraints"),
    ] = None
    """
    Defines the pod's topology spread constraints if specified.
    """
    tracing_config: Annotated[Optional[TracingConfigModel], Field(alias="tracingConfig")] = None
    """
    TracingConfig configures tracing in Prometheus.

    This is an *experimental feature*, it may change in any upcoming release
    in a breaking way.
    """
    tsdb: Optional[Tsdb] = None
    """
    Defines the runtime reloadable configuration of the timeseries database(TSDB).
    It requires Prometheus >= v2.39.0 or PrometheusAgent >= v2.54.0.
    """
    version: Optional[str] = None
    """
    Version of Prometheus being deployed. The operator uses this information
    to generate the Prometheus StatefulSet + configuration files.

    If not specified, the operator assumes the latest upstream version of
    Prometheus available at the time when the version of the operator was
    released.
    """
    volume_mounts: Annotated[Optional[List[VolumeMount]], Field(alias="volumeMounts")] = None
    """
    VolumeMounts allows the configuration of additional VolumeMounts.

    VolumeMounts will be appended to other VolumeMounts in the 'prometheus'
    container, that are generated as a result of StorageSpec objects.
    """
    volumes: Optional[List[Volume]] = None
    """
    Volumes allows the configuration of additional volumes on the output
    StatefulSet definition. Volumes specified will be appended to other
    volumes that are generated as a result of StorageSpec objects.
    """
    wal_compression: Annotated[Optional[bool], Field(alias="walCompression")] = None
    """
    Configures compression of the write-ahead log (WAL) using Snappy.

    WAL compression is enabled by default for Prometheus >= 2.20.0

    Requires Prometheus v2.11.0 and above.
    """
    web: Optional[WebModel] = None
    """
    Defines the configuration of the Prometheus web server.
    """


class ConditionModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConditionModel2"]:
            return ConditionModel2

        def build(self) -> "ConditionModel2":
            return ConditionModel2(**self._attrs)

        def last_transition_time(self, value: datetime, /) -> Self:
            """
            lastTransitionTime is the time of the last update to the current status property.
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Human-readable message indicating details for the condition's last transition.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration represents the .metadata.generation that the
            condition was set based upon. For instance, if `.metadata.generation` is
            currently 12, but the `.status.conditions[].observedGeneration` is 9, the
            condition is out of date with respect to the current state of the
            instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            Reason for the condition's last transition.
            """
            return self._set("reason", value)

        def status(self, value: str, /) -> Self:
            """
            Status of the condition.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of the condition being reported.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["ConditionModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConditionModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConditionModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConditionModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConditionModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[datetime, Field(alias="lastTransitionTime")]
    """
    lastTransitionTime is the time of the last update to the current status property.
    """
    message: Optional[str] = None
    """
    Human-readable message indicating details for the condition's last transition.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration represents the .metadata.generation that the
    condition was set based upon. For instance, if `.metadata.generation` is
    currently 12, but the `.status.conditions[].observedGeneration` is 9, the
    condition is out of date with respect to the current state of the
    instance.
    """
    reason: Optional[str] = None
    """
    Reason for the condition's last transition.
    """
    status: Annotated[str, Field(min_length=1)]
    """
    Status of the condition.
    """
    type: Annotated[str, Field(min_length=1)]
    """
    Type of the condition being reported.
    """


class ShardStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ShardStatus"]:
            return ShardStatus

        def build(self) -> "ShardStatus":
            return ShardStatus(**self._attrs)

        def available_replicas(self, value: int, /) -> Self:
            """
            Total number of available pods (ready for at least minReadySeconds)
            targeted by this shard.
            """
            return self._set("available_replicas", value)

        def replicas(self, value: int, /) -> Self:
            """
            Total number of pods targeted by this shard.
            """
            return self._set("replicas", value)

        def shard_id(self, value: str, /) -> Self:
            """
            Identifier of the shard.
            """
            return self._set("shard_id", value)

        def unavailable_replicas(self, value: int, /) -> Self:
            """
            Total number of unavailable pods targeted by this shard.
            """
            return self._set("unavailable_replicas", value)

        def updated_replicas(self, value: int, /) -> Self:
            """
            Total number of non-terminated pods targeted by this shard
            that have the desired spec.
            """
            return self._set("updated_replicas", value)

    class BuilderContext(BuilderContextBase["ShardStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ShardStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ShardStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ShardStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ShardStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    available_replicas: Annotated[int, Field(alias="availableReplicas")]
    """
    Total number of available pods (ready for at least minReadySeconds)
    targeted by this shard.
    """
    replicas: int
    """
    Total number of pods targeted by this shard.
    """
    shard_id: Annotated[str, Field(alias="shardID")]
    """
    Identifier of the shard.
    """
    unavailable_replicas: Annotated[int, Field(alias="unavailableReplicas")]
    """
    Total number of unavailable pods targeted by this shard.
    """
    updated_replicas: Annotated[int, Field(alias="updatedReplicas")]
    """
    Total number of non-terminated pods targeted by this shard
    that have the desired spec.
    """


class PrometheusStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PrometheusStatus"]:
            return PrometheusStatus

        def build(self) -> "PrometheusStatus":
            return PrometheusStatus(**self._attrs)

        def available_replicas(self, value: int, /) -> Self:
            """
            Total number of available pods (ready for at least minReadySeconds)
            targeted by this Prometheus deployment.
            """
            return self._set("available_replicas", value)

        @overload
        def conditions(
            self, value_or_callback: List[ConditionModel2], /
        ) -> "PrometheusStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ConditionModel2, ConditionModel2.Builder]],
                GenericListBuilder[ConditionModel2, ConditionModel2.Builder]
                | List[ConditionModel2],
            ],
            /,
        ) -> "PrometheusStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ConditionModel2.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            The current state of the Prometheus deployment.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ConditionModel2.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConditionModel2.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def paused(self, value: bool, /) -> Self:
            """
            Represents whether any actions on the underlying managed objects are
            being performed. Only delete actions will be performed.
            """
            return self._set("paused", value)

        def replicas(self, value: int, /) -> Self:
            """
            Total number of non-terminated pods targeted by this Prometheus deployment
            (their labels match the selector).
            """
            return self._set("replicas", value)

        def selector(self, value: Optional[str], /) -> Self:
            """
            The selector used to match the pods targeted by this Prometheus resource.
            """
            return self._set("selector", value)

        @overload
        def shard_statuses(
            self, value_or_callback: List[ShardStatus], /
        ) -> "PrometheusStatus.Builder": ...

        @overload
        def shard_statuses(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ShardStatus, ShardStatus.Builder]],
                GenericListBuilder[ShardStatus, ShardStatus.Builder] | List[ShardStatus],
            ],
            /,
        ) -> "PrometheusStatus.Builder": ...

        @overload
        def shard_statuses(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ShardStatus.Builder]: ...

        def shard_statuses(self, value_or_callback=None, /):
            """
            The list has one entry per shard. Each entry provides a summary of the shard status.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ShardStatus.Builder]()
                context._parent_builder = self
                context._field_name = "shard_statuses"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ShardStatus.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("shard_statuses", value)

        def shards(self, value: Optional[int], /) -> Self:
            """
            Shards is the most recently observed number of shards.
            """
            return self._set("shards", value)

        def unavailable_replicas(self, value: int, /) -> Self:
            """
            Total number of unavailable pods targeted by this Prometheus deployment.
            """
            return self._set("unavailable_replicas", value)

        def updated_replicas(self, value: int, /) -> Self:
            """
            Total number of non-terminated pods targeted by this Prometheus deployment
            that have the desired version spec.
            """
            return self._set("updated_replicas", value)

    class BuilderContext(BuilderContextBase["PrometheusStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PrometheusStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PrometheusStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PrometheusStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PrometheusStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    available_replicas: Annotated[int, Field(alias="availableReplicas")]
    """
    Total number of available pods (ready for at least minReadySeconds)
    targeted by this Prometheus deployment.
    """
    conditions: Optional[List[ConditionModel2]] = None
    """
    The current state of the Prometheus deployment.
    """
    paused: bool
    """
    Represents whether any actions on the underlying managed objects are
    being performed. Only delete actions will be performed.
    """
    replicas: int
    """
    Total number of non-terminated pods targeted by this Prometheus deployment
    (their labels match the selector).
    """
    selector: Optional[str] = None
    """
    The selector used to match the pods targeted by this Prometheus resource.
    """
    shard_statuses: Annotated[Optional[List[ShardStatus]], Field(alias="shardStatuses")] = None
    """
    The list has one entry per shard. Each entry provides a summary of the shard status.
    """
    shards: Optional[int] = None
    """
    Shards is the most recently observed number of shards.
    """
    unavailable_replicas: Annotated[int, Field(alias="unavailableReplicas")]
    """
    Total number of unavailable pods targeted by this Prometheus deployment.
    """
    updated_replicas: Annotated[int, Field(alias="updatedReplicas")]
    """
    Total number of non-terminated pods targeted by this Prometheus deployment
    that have the desired version spec.
    """


class Rule(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Rule"]:
            return Rule

        def build(self) -> "Rule":
            return Rule(**self._attrs)

        def alert(self, value: Optional[str], /) -> Self:
            """
            Name of the alert. Must be a valid label value.
            Only one of `record` and `alert` must be set.
            """
            return self._set("alert", value)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations to add to each alert.
            Only valid for alerting rules.
            """
            return self._set("annotations", value)

        def expr(self, value: Union[int, str], /) -> Self:
            """
            PromQL expression to evaluate.
            """
            return self._set("expr", value)

        def for_(self, value: Optional[str], /) -> Self:
            """
            Alerts are considered firing once they have been returned for this long.
            """
            return self._set("for_", value)

        def keep_firing_for(self, value: Optional[str], /) -> Self:
            """
            KeepFiringFor defines how long an alert will continue firing after the condition that triggered it has cleared.
            """
            return self._set("keep_firing_for", value)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Labels to add or overwrite.
            """
            return self._set("labels", value)

        def record(self, value: Optional[str], /) -> Self:
            """
            Name of the time series to output to. Must be a valid metric name.
            Only one of `record` and `alert` must be set.
            """
            return self._set("record", value)

    class BuilderContext(BuilderContextBase["Rule.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Rule.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Rule."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Rule", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Rule.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    alert: Optional[str] = None
    """
    Name of the alert. Must be a valid label value.
    Only one of `record` and `alert` must be set.
    """
    annotations: Optional[Dict[str, str]] = None
    """
    Annotations to add to each alert.
    Only valid for alerting rules.
    """
    expr: Union[int, str]
    """
    PromQL expression to evaluate.
    """
    for_: Annotated[
        Optional[str],
        Field(
            alias="for",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Alerts are considered firing once they have been returned for this long.
    """
    keep_firing_for: Annotated[
        Optional[str],
        Field(
            min_length=1,
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    KeepFiringFor defines how long an alert will continue firing after the condition that triggered it has cleared.
    """
    labels: Optional[Dict[str, str]] = None
    """
    Labels to add or overwrite.
    """
    record: Optional[str] = None
    """
    Name of the time series to output to. Must be a valid metric name.
    Only one of `record` and `alert` must be set.
    """


class Group(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Group"]:
            return Group

        def build(self) -> "Group":
            return Group(**self._attrs)

        def interval(self, value: Optional[str], /) -> Self:
            """
            Interval determines how often rules in the group are evaluated.
            """
            return self._set("interval", value)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Labels to add or overwrite before storing the result for its rules.
            The labels defined at the rule level take precedence.

            It requires Prometheus >= 3.0.0.
            The field is ignored for Thanos Ruler.
            """
            return self._set("labels", value)

        def limit(self, value: Optional[int], /) -> Self:
            """
            Limit the number of alerts an alerting rule and series a recording
            rule can produce.
            Limit is supported starting with Prometheus >= 2.31 and Thanos Ruler >= 0.24.
            """
            return self._set("limit", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the rule group.
            """
            return self._set("name", value)

        def partial_response_strategy(self, value: Optional[str], /) -> Self:
            """
            PartialResponseStrategy is only used by ThanosRuler and will
            be ignored by Prometheus instances.
            More info: https://github.com/thanos-io/thanos/blob/main/docs/components/rule.md#partial-response
            """
            return self._set("partial_response_strategy", value)

        def query_offset(self, value: Optional[str], /) -> Self:
            """
            Defines the offset the rule evaluation timestamp of this particular group by the specified duration into the past.

            It requires Prometheus >= v2.53.0.
            It is not supported for ThanosRuler.
            """
            return self._set("query_offset", value)

        @overload
        def rules(self, value_or_callback: List[Rule], /) -> "Group.Builder": ...

        @overload
        def rules(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Rule, Rule.Builder]],
                GenericListBuilder[Rule, Rule.Builder] | List[Rule],
            ],
            /,
        ) -> "Group.Builder": ...

        @overload
        def rules(self, value_or_callback: Never = ...) -> ListBuilderContext[Rule.Builder]: ...

        def rules(self, value_or_callback=None, /):
            """
            List of alerting and recording rules.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Rule.Builder]()
                context._parent_builder = self
                context._field_name = "rules"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Rule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("rules", value)

    class BuilderContext(BuilderContextBase["Group.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Group.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Group."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Group", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Group.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    interval: Annotated[
        Optional[str],
        Field(
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"
        ),
    ] = None
    """
    Interval determines how often rules in the group are evaluated.
    """
    labels: Optional[Dict[str, str]] = None
    """
    Labels to add or overwrite before storing the result for its rules.
    The labels defined at the rule level take precedence.

    It requires Prometheus >= 3.0.0.
    The field is ignored for Thanos Ruler.
    """
    limit: Optional[int] = None
    """
    Limit the number of alerts an alerting rule and series a recording
    rule can produce.
    Limit is supported starting with Prometheus >= 2.31 and Thanos Ruler >= 0.24.
    """
    name: Annotated[str, Field(min_length=1)]
    """
    Name of the rule group.
    """
    partial_response_strategy: Annotated[Optional[str], Field(pattern="^(?i)(abort|warn)?$")] = None
    """
    PartialResponseStrategy is only used by ThanosRuler and will
    be ignored by Prometheus instances.
    More info: https://github.com/thanos-io/thanos/blob/main/docs/components/rule.md#partial-response
    """
    query_offset: Annotated[
        Optional[str],
        Field(
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"
        ),
    ] = None
    """
    Defines the offset the rule evaluation timestamp of this particular group by the specified duration into the past.

    It requires Prometheus >= v2.53.0.
    It is not supported for ThanosRuler.
    """
    rules: Optional[List[Rule]] = None
    """
    List of alerting and recording rules.
    """


class PrometheusRuleSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PrometheusRuleSpec"]:
            return PrometheusRuleSpec

        def build(self) -> "PrometheusRuleSpec":
            return PrometheusRuleSpec(**self._attrs)

        @overload
        def groups(self, value_or_callback: List[Group], /) -> "PrometheusRuleSpec.Builder": ...

        @overload
        def groups(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Group, Group.Builder]],
                GenericListBuilder[Group, Group.Builder] | List[Group],
            ],
            /,
        ) -> "PrometheusRuleSpec.Builder": ...

        @overload
        def groups(self, value_or_callback: Never = ...) -> ListBuilderContext[Group.Builder]: ...

        def groups(self, value_or_callback=None, /):
            """
            Content of Prometheus rule file
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Group.Builder]()
                context._parent_builder = self
                context._field_name = "groups"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Group.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("groups", value)

    class BuilderContext(BuilderContextBase["PrometheusRuleSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PrometheusRuleSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PrometheusRuleSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PrometheusRuleSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PrometheusRuleSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    groups: Optional[List[Group]] = None
    """
    Content of Prometheus rule file
    """


class AuthorizationModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AuthorizationModel1"]:
            return AuthorizationModel1

        def build(self) -> "AuthorizationModel1":
            return AuthorizationModel1(**self._attrs)

        @overload
        def credentials(
            self, value_or_callback: Optional[Credentials], /
        ) -> "AuthorizationModel1.Builder": ...

        @overload
        def credentials(
            self,
            value_or_callback: Callable[[Credentials.Builder], Credentials.Builder | Credentials],
            /,
        ) -> "AuthorizationModel1.Builder": ...

        @overload
        def credentials(self, value_or_callback: Never = ...) -> "Credentials.BuilderContext": ...

        def credentials(self, value_or_callback=None, /):
            """
            Selects a key of a Secret in the namespace that contains the credentials for authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Credentials.BuilderContext()
                context._parent_builder = self
                context._field_name = "credentials"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Credentials.builder())
                if isinstance(output, Credentials.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("credentials", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Defines the authentication type. The value is case-insensitive.

            "Basic" is not a supported value.

            Default: "Bearer"
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["AuthorizationModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AuthorizationModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AuthorizationModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AuthorizationModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AuthorizationModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    credentials: Optional[Credentials] = None
    """
    Selects a key of a Secret in the namespace that contains the credentials for authentication.
    """
    type: Optional[str] = None
    """
    Defines the authentication type. The value is case-insensitive.

    "Basic" is not a supported value.

    Default: "Bearer"
    """


class TlsConfigModel8(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsConfigModel8"]:
            return TlsConfigModel8

        def build(self) -> "TlsConfigModel8":
            return TlsConfigModel8(**self._attrs)

        @overload
        def ca(self, value_or_callback: Optional[Ca], /) -> "TlsConfigModel8.Builder": ...

        @overload
        def ca(
            self, value_or_callback: Callable[[Ca.Builder], Ca.Builder | Ca], /
        ) -> "TlsConfigModel8.Builder": ...

        @overload
        def ca(self, value_or_callback: Never = ...) -> "Ca.BuilderContext": ...

        def ca(self, value_or_callback=None, /):
            """
            Certificate authority used when verifying server certificates.
            """
            if self._in_context and value_or_callback is None:
                context = Ca.BuilderContext()
                context._parent_builder = self
                context._field_name = "ca"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ca.builder())
                if isinstance(output, Ca.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ca", value)

        @overload
        def cert(self, value_or_callback: Optional[Cert], /) -> "TlsConfigModel8.Builder": ...

        @overload
        def cert(
            self, value_or_callback: Callable[[Cert.Builder], Cert.Builder | Cert], /
        ) -> "TlsConfigModel8.Builder": ...

        @overload
        def cert(self, value_or_callback: Never = ...) -> "Cert.BuilderContext": ...

        def cert(self, value_or_callback=None, /):
            """
            Client certificate to present when doing client-authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Cert.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cert.builder())
                if isinstance(output, Cert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert", value)

        def insecure_skip_verify(self, value: Optional[bool], /) -> Self:
            """
            Disable target certificate validation.
            """
            return self._set("insecure_skip_verify", value)

        @overload
        def key_secret(
            self, value_or_callback: Optional[KeySecret], /
        ) -> "TlsConfigModel8.Builder": ...

        @overload
        def key_secret(
            self,
            value_or_callback: Callable[[KeySecret.Builder], KeySecret.Builder | KeySecret],
            /,
        ) -> "TlsConfigModel8.Builder": ...

        @overload
        def key_secret(self, value_or_callback: Never = ...) -> "KeySecret.BuilderContext": ...

        def key_secret(self, value_or_callback=None, /):
            """
            Secret containing the client key file for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = KeySecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "key_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KeySecret.builder())
                if isinstance(output, KeySecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("key_secret", value)

        def max_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Maximum acceptable TLS version.

            It requires Prometheus >= v2.41.0.
            """
            return self._set("max_version", value)

        def min_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Minimum acceptable TLS version.

            It requires Prometheus >= v2.35.0.
            """
            return self._set("min_version", value)

        def server_name(self, value: Optional[str], /) -> Self:
            """
            Used to verify the hostname for the targets.
            """
            return self._set("server_name", value)

    class BuilderContext(BuilderContextBase["TlsConfigModel8.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsConfigModel8.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsConfigModel8."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsConfigModel8", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsConfigModel8.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca: Optional[Ca] = None
    """
    Certificate authority used when verifying server certificates.
    """
    cert: Optional[Cert] = None
    """
    Client certificate to present when doing client-authentication.
    """
    insecure_skip_verify: Annotated[Optional[bool], Field(alias="insecureSkipVerify")] = None
    """
    Disable target certificate validation.
    """
    key_secret: Annotated[Optional[KeySecret], Field(alias="keySecret")] = None
    """
    Secret containing the client key file for the targets.
    """
    max_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="maxVersion")
    ] = None
    """
    Maximum acceptable TLS version.

    It requires Prometheus >= v2.41.0.
    """
    min_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="minVersion")
    ] = None
    """
    Minimum acceptable TLS version.

    It requires Prometheus >= v2.35.0.
    """
    server_name: Annotated[Optional[str], Field(alias="serverName")] = None
    """
    Used to verify the hostname for the targets.
    """


class TlsConfigModel9(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsConfigModel9"]:
            return TlsConfigModel9

        def build(self) -> "TlsConfigModel9":
            return TlsConfigModel9(**self._attrs)

        @overload
        def ca(self, value_or_callback: Optional[Ca], /) -> "TlsConfigModel9.Builder": ...

        @overload
        def ca(
            self, value_or_callback: Callable[[Ca.Builder], Ca.Builder | Ca], /
        ) -> "TlsConfigModel9.Builder": ...

        @overload
        def ca(self, value_or_callback: Never = ...) -> "Ca.BuilderContext": ...

        def ca(self, value_or_callback=None, /):
            """
            Certificate authority used when verifying server certificates.
            """
            if self._in_context and value_or_callback is None:
                context = Ca.BuilderContext()
                context._parent_builder = self
                context._field_name = "ca"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ca.builder())
                if isinstance(output, Ca.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ca", value)

        def ca_file(self, value: Optional[str], /) -> Self:
            """
            Path to the CA cert in the Prometheus container to use for the targets.
            """
            return self._set("ca_file", value)

        @overload
        def cert(self, value_or_callback: Optional[Cert], /) -> "TlsConfigModel9.Builder": ...

        @overload
        def cert(
            self, value_or_callback: Callable[[Cert.Builder], Cert.Builder | Cert], /
        ) -> "TlsConfigModel9.Builder": ...

        @overload
        def cert(self, value_or_callback: Never = ...) -> "Cert.BuilderContext": ...

        def cert(self, value_or_callback=None, /):
            """
            Client certificate to present when doing client-authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Cert.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cert.builder())
                if isinstance(output, Cert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert", value)

        def cert_file(self, value: Optional[str], /) -> Self:
            """
            Path to the client cert file in the Prometheus container for the targets.
            """
            return self._set("cert_file", value)

        def insecure_skip_verify(self, value: Optional[bool], /) -> Self:
            """
            Disable target certificate validation.
            """
            return self._set("insecure_skip_verify", value)

        def key_file(self, value: Optional[str], /) -> Self:
            """
            Path to the client key file in the Prometheus container for the targets.
            """
            return self._set("key_file", value)

        @overload
        def key_secret(
            self, value_or_callback: Optional[KeySecret], /
        ) -> "TlsConfigModel9.Builder": ...

        @overload
        def key_secret(
            self,
            value_or_callback: Callable[[KeySecret.Builder], KeySecret.Builder | KeySecret],
            /,
        ) -> "TlsConfigModel9.Builder": ...

        @overload
        def key_secret(self, value_or_callback: Never = ...) -> "KeySecret.BuilderContext": ...

        def key_secret(self, value_or_callback=None, /):
            """
            Secret containing the client key file for the targets.
            """
            if self._in_context and value_or_callback is None:
                context = KeySecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "key_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KeySecret.builder())
                if isinstance(output, KeySecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("key_secret", value)

        def max_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Maximum acceptable TLS version.

            It requires Prometheus >= v2.41.0.
            """
            return self._set("max_version", value)

        def min_version(
            self, value: Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], /
        ) -> Self:
            """
            Minimum acceptable TLS version.

            It requires Prometheus >= v2.35.0.
            """
            return self._set("min_version", value)

        def server_name(self, value: Optional[str], /) -> Self:
            """
            Used to verify the hostname for the targets.
            """
            return self._set("server_name", value)

    class BuilderContext(BuilderContextBase["TlsConfigModel9.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsConfigModel9.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsConfigModel9."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsConfigModel9", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsConfigModel9.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca: Optional[Ca] = None
    """
    Certificate authority used when verifying server certificates.
    """
    ca_file: Annotated[Optional[str], Field(alias="caFile")] = None
    """
    Path to the CA cert in the Prometheus container to use for the targets.
    """
    cert: Optional[Cert] = None
    """
    Client certificate to present when doing client-authentication.
    """
    cert_file: Annotated[Optional[str], Field(alias="certFile")] = None
    """
    Path to the client cert file in the Prometheus container for the targets.
    """
    insecure_skip_verify: Annotated[Optional[bool], Field(alias="insecureSkipVerify")] = None
    """
    Disable target certificate validation.
    """
    key_file: Annotated[Optional[str], Field(alias="keyFile")] = None
    """
    Path to the client key file in the Prometheus container for the targets.
    """
    key_secret: Annotated[Optional[KeySecret], Field(alias="keySecret")] = None
    """
    Secret containing the client key file for the targets.
    """
    max_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="maxVersion")
    ] = None
    """
    Maximum acceptable TLS version.

    It requires Prometheus >= v2.41.0.
    """
    min_version: Annotated[
        Optional[Literal["TLS10", "TLS11", "TLS12", "TLS13"]], Field(alias="minVersion")
    ] = None
    """
    Minimum acceptable TLS version.

    It requires Prometheus >= v2.35.0.
    """
    server_name: Annotated[Optional[str], Field(alias="serverName")] = None
    """
    Used to verify the hostname for the targets.
    """


class Endpoint(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Endpoint"]:
            return Endpoint

        def build(self) -> "Endpoint":
            return Endpoint(**self._attrs)

        @overload
        def authorization(
            self, value_or_callback: Optional[AuthorizationModel1], /
        ) -> "Endpoint.Builder": ...

        @overload
        def authorization(
            self,
            value_or_callback: Callable[
                [AuthorizationModel1.Builder],
                AuthorizationModel1.Builder | AuthorizationModel1,
            ],
            /,
        ) -> "Endpoint.Builder": ...

        @overload
        def authorization(
            self, value_or_callback: Never = ...
        ) -> "AuthorizationModel1.BuilderContext": ...

        def authorization(self, value_or_callback=None, /):
            """
            `authorization` configures the Authorization header credentials to use when
            scraping the target.

            Cannot be set at the same time as `basicAuth`, or `oauth2`.
            """
            if self._in_context and value_or_callback is None:
                context = AuthorizationModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "authorization"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthorizationModel1.builder())
                if isinstance(output, AuthorizationModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authorization", value)

        @overload
        def basic_auth(self, value_or_callback: Optional[BasicAuth], /) -> "Endpoint.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "Endpoint.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            `basicAuth` configures the Basic Authentication credentials to use when
            scraping the target.

            Cannot be set at the same time as `authorization`, or `oauth2`.
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        def bearer_token_file(self, value: Optional[str], /) -> Self:
            """
            File to read bearer token for scraping the target.

            Deprecated: use `authorization` instead.
            """
            return self._set("bearer_token_file", value)

        @overload
        def bearer_token_secret(
            self, value_or_callback: Optional[BearerTokenSecret], /
        ) -> "Endpoint.Builder": ...

        @overload
        def bearer_token_secret(
            self,
            value_or_callback: Callable[
                [BearerTokenSecret.Builder],
                BearerTokenSecret.Builder | BearerTokenSecret,
            ],
            /,
        ) -> "Endpoint.Builder": ...

        @overload
        def bearer_token_secret(
            self, value_or_callback: Never = ...
        ) -> "BearerTokenSecret.BuilderContext": ...

        def bearer_token_secret(self, value_or_callback=None, /):
            """
            `bearerTokenSecret` specifies a key of a Secret containing the bearer
            token for scraping targets. The secret needs to be in the same namespace
            as the ServiceMonitor object and readable by the Prometheus Operator.

            Deprecated: use `authorization` instead.
            """
            if self._in_context and value_or_callback is None:
                context = BearerTokenSecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "bearer_token_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BearerTokenSecret.builder())
                if isinstance(output, BearerTokenSecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("bearer_token_secret", value)

        def enable_http2(self, value: Optional[bool], /) -> Self:
            """
            `enableHttp2` can be used to disable HTTP2 when scraping the target.
            """
            return self._set("enable_http2", value)

        def filter_running(self, value: Optional[bool], /) -> Self:
            """
            When true, the pods which are not running (e.g. either in Failed or
            Succeeded state) are dropped during the target discovery.

            If unset, the filtering is enabled.

            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase
            """
            return self._set("filter_running", value)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            `followRedirects` defines whether the scrape requests should follow HTTP
            3xx redirects.
            """
            return self._set("follow_redirects", value)

        def honor_labels(self, value: Optional[bool], /) -> Self:
            """
            When true, `honorLabels` preserves the metric's labels when they collide
            with the target's labels.
            """
            return self._set("honor_labels", value)

        def honor_timestamps(self, value: Optional[bool], /) -> Self:
            """
            `honorTimestamps` controls whether Prometheus preserves the timestamps
            when exposed by the target.
            """
            return self._set("honor_timestamps", value)

        def interval(self, value: Optional[str], /) -> Self:
            """
            Interval at which Prometheus scrapes the metrics from the target.

            If empty, Prometheus uses the global scrape interval.
            """
            return self._set("interval", value)

        @overload
        def metric_relabelings(
            self, value_or_callback: List[MetricRelabeling], /
        ) -> "Endpoint.Builder": ...

        @overload
        def metric_relabelings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MetricRelabeling, MetricRelabeling.Builder]],
                GenericListBuilder[MetricRelabeling, MetricRelabeling.Builder]
                | List[MetricRelabeling],
            ],
            /,
        ) -> "Endpoint.Builder": ...

        @overload
        def metric_relabelings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MetricRelabeling.Builder]: ...

        def metric_relabelings(self, value_or_callback=None, /):
            """
            `metricRelabelings` configures the relabeling rules to apply to the
            samples before ingestion.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MetricRelabeling.Builder]()
                context._parent_builder = self
                context._field_name = "metric_relabelings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MetricRelabeling.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("metric_relabelings", value)

        @overload
        def oauth2(self, value_or_callback: Optional[Oauth2], /) -> "Endpoint.Builder": ...

        @overload
        def oauth2(
            self,
            value_or_callback: Callable[[Oauth2.Builder], Oauth2.Builder | Oauth2],
            /,
        ) -> "Endpoint.Builder": ...

        @overload
        def oauth2(self, value_or_callback: Never = ...) -> "Oauth2.BuilderContext": ...

        def oauth2(self, value_or_callback=None, /):
            """
            `oauth2` configures the OAuth2 settings to use when scraping the target.

            It requires Prometheus >= 2.27.0.

            Cannot be set at the same time as `authorization`, or `basicAuth`.
            """
            if self._in_context and value_or_callback is None:
                context = Oauth2.BuilderContext()
                context._parent_builder = self
                context._field_name = "oauth2"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Oauth2.builder())
                if isinstance(output, Oauth2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("oauth2", value)

        def params(self, value: Optional[Dict[str, List[str]]], /) -> Self:
            """
            params define optional HTTP URL parameters.
            """
            return self._set("params", value)

        def path(self, value: Optional[str], /) -> Self:
            """
            HTTP path from which to scrape for metrics.

            If empty, Prometheus uses the default value (e.g. `/metrics`).
            """
            return self._set("path", value)

        def port(self, value: Optional[str], /) -> Self:
            """
            Name of the Service port which this endpoint refers to.

            It takes precedence over `targetPort`.
            """
            return self._set("port", value)

        def proxy_url(self, value: Optional[str], /) -> Self:
            """
            `proxyURL` configures the HTTP Proxy URL (e.g.
            "http://proxyserver:2195") to go through when scraping the target.
            """
            return self._set("proxy_url", value)

        @overload
        def relabelings(self, value_or_callback: List[Relabeling], /) -> "Endpoint.Builder": ...

        @overload
        def relabelings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Relabeling, Relabeling.Builder]],
                GenericListBuilder[Relabeling, Relabeling.Builder] | List[Relabeling],
            ],
            /,
        ) -> "Endpoint.Builder": ...

        @overload
        def relabelings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Relabeling.Builder]: ...

        def relabelings(self, value_or_callback=None, /):
            """
            `relabelings` configures the relabeling rules to apply the target's
            metadata labels.

            The Operator automatically adds relabelings for a few standard Kubernetes fields.

            The original scrape job's name is available via the `__tmp_prometheus_job_name` label.

            More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Relabeling.Builder]()
                context._parent_builder = self
                context._field_name = "relabelings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Relabeling.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("relabelings", value)

        def scheme(self, value: Optional[Literal["http", "https"]], /) -> Self:
            """
            HTTP scheme to use for scraping.

            `http` and `https` are the expected values unless you rewrite the
            `__scheme__` label via relabeling.

            If empty, Prometheus uses the default value `http`.
            """
            return self._set("scheme", value)

        def scrape_timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout after which Prometheus considers the scrape to be failed.

            If empty, Prometheus uses the global scrape timeout unless it is less
            than the target's scrape interval value in which the latter is used.
            The value cannot be greater than the scrape interval otherwise the operator will reject the resource.
            """
            return self._set("scrape_timeout", value)

        def target_port(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Name or number of the target port of the `Pod` object behind the
            Service. The port must be specified with the container's port property.
            """
            return self._set("target_port", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel9], /
        ) -> "Endpoint.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel9.Builder], TlsConfigModel9.Builder | TlsConfigModel9
            ],
            /,
        ) -> "Endpoint.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel9.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            TLS configuration to use when scraping the target.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel9.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel9.builder())
                if isinstance(output, TlsConfigModel9.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

        def track_timestamps_staleness(self, value: Optional[bool], /) -> Self:
            """
            `trackTimestampsStaleness` defines whether Prometheus tracks staleness of
            the metrics that have an explicit timestamp present in scraped data.
            Has no effect if `honorTimestamps` is false.

            It requires Prometheus >= v2.48.0.
            """
            return self._set("track_timestamps_staleness", value)

    class BuilderContext(BuilderContextBase["Endpoint.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Endpoint.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Endpoint."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Endpoint", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Endpoint.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authorization: Optional[AuthorizationModel1] = None
    """
    `authorization` configures the Authorization header credentials to use when
    scraping the target.

    Cannot be set at the same time as `basicAuth`, or `oauth2`.
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    `basicAuth` configures the Basic Authentication credentials to use when
    scraping the target.

    Cannot be set at the same time as `authorization`, or `oauth2`.
    """
    bearer_token_file: Annotated[Optional[str], Field(alias="bearerTokenFile")] = None
    """
    File to read bearer token for scraping the target.

    Deprecated: use `authorization` instead.
    """
    bearer_token_secret: Annotated[
        Optional[BearerTokenSecret], Field(alias="bearerTokenSecret")
    ] = None
    """
    `bearerTokenSecret` specifies a key of a Secret containing the bearer
    token for scraping targets. The secret needs to be in the same namespace
    as the ServiceMonitor object and readable by the Prometheus Operator.

    Deprecated: use `authorization` instead.
    """
    enable_http2: Annotated[Optional[bool], Field(alias="enableHttp2")] = None
    """
    `enableHttp2` can be used to disable HTTP2 when scraping the target.
    """
    filter_running: Annotated[Optional[bool], Field(alias="filterRunning")] = None
    """
    When true, the pods which are not running (e.g. either in Failed or
    Succeeded state) are dropped during the target discovery.

    If unset, the filtering is enabled.

    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase
    """
    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    `followRedirects` defines whether the scrape requests should follow HTTP
    3xx redirects.
    """
    honor_labels: Annotated[Optional[bool], Field(alias="honorLabels")] = None
    """
    When true, `honorLabels` preserves the metric's labels when they collide
    with the target's labels.
    """
    honor_timestamps: Annotated[Optional[bool], Field(alias="honorTimestamps")] = None
    """
    `honorTimestamps` controls whether Prometheus preserves the timestamps
    when exposed by the target.
    """
    interval: Annotated[
        Optional[str],
        Field(
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"
        ),
    ] = None
    """
    Interval at which Prometheus scrapes the metrics from the target.

    If empty, Prometheus uses the global scrape interval.
    """
    metric_relabelings: Annotated[
        Optional[List[MetricRelabeling]], Field(alias="metricRelabelings")
    ] = None
    """
    `metricRelabelings` configures the relabeling rules to apply to the
    samples before ingestion.
    """
    oauth2: Optional[Oauth2] = None
    """
    `oauth2` configures the OAuth2 settings to use when scraping the target.

    It requires Prometheus >= 2.27.0.

    Cannot be set at the same time as `authorization`, or `basicAuth`.
    """
    params: Optional[Dict[str, List[str]]] = None
    """
    params define optional HTTP URL parameters.
    """
    path: Optional[str] = None
    """
    HTTP path from which to scrape for metrics.

    If empty, Prometheus uses the default value (e.g. `/metrics`).
    """
    port: Optional[str] = None
    """
    Name of the Service port which this endpoint refers to.

    It takes precedence over `targetPort`.
    """
    proxy_url: Annotated[Optional[str], Field(alias="proxyUrl")] = None
    """
    `proxyURL` configures the HTTP Proxy URL (e.g.
    "http://proxyserver:2195") to go through when scraping the target.
    """
    relabelings: Optional[List[Relabeling]] = None
    """
    `relabelings` configures the relabeling rules to apply the target's
    metadata labels.

    The Operator automatically adds relabelings for a few standard Kubernetes fields.

    The original scrape job's name is available via the `__tmp_prometheus_job_name` label.

    More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
    """
    scheme: Optional[Literal["http", "https"]] = None
    """
    HTTP scheme to use for scraping.

    `http` and `https` are the expected values unless you rewrite the
    `__scheme__` label via relabeling.

    If empty, Prometheus uses the default value `http`.
    """
    scrape_timeout: Annotated[
        Optional[str],
        Field(
            alias="scrapeTimeout",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = None
    """
    Timeout after which Prometheus considers the scrape to be failed.

    If empty, Prometheus uses the global scrape timeout unless it is less
    than the target's scrape interval value in which the latter is used.
    The value cannot be greater than the scrape interval otherwise the operator will reject the resource.
    """
    target_port: Annotated[Optional[Union[int, str]], Field(alias="targetPort")] = None
    """
    Name or number of the target port of the `Pod` object behind the
    Service. The port must be specified with the container's port property.
    """
    tls_config: Annotated[Optional[TlsConfigModel9], Field(alias="tlsConfig")] = None
    """
    TLS configuration to use when scraping the target.
    """
    track_timestamps_staleness: Annotated[
        Optional[bool], Field(alias="trackTimestampsStaleness")
    ] = None
    """
    `trackTimestampsStaleness` defines whether Prometheus tracks staleness of
    the metrics that have an explicit timestamp present in scraped data.
    Has no effect if `honorTimestamps` is false.

    It requires Prometheus >= v2.48.0.
    """


class NamespaceSelectorModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NamespaceSelectorModel2"]:
            return NamespaceSelectorModel2

        def build(self) -> "NamespaceSelectorModel2":
            return NamespaceSelectorModel2(**self._attrs)

        def any(self, value: Optional[bool], /) -> Self:
            """
            Boolean describing whether all namespaces are selected in contrast to a
            list restricting them.
            """
            return self._set("any", value)

        def match_names(self, value: Optional[List[str]], /) -> Self:
            """
            List of namespace names to select from.
            """
            return self._set("match_names", value)

    class BuilderContext(BuilderContextBase["NamespaceSelectorModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NamespaceSelectorModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NamespaceSelectorModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NamespaceSelectorModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamespaceSelectorModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    any: Optional[bool] = None
    """
    Boolean describing whether all namespaces are selected in contrast to a
    list restricting them.
    """
    match_names: Annotated[Optional[List[str]], Field(alias="matchNames")] = None
    """
    List of namespace names to select from.
    """


class NativeHistogramMinBucketFactorModel3(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            If the growth factor of one bucket to the next is smaller than this,
            buckets will be merged to increase the factor sufficiently.
            It requires Prometheus >= v2.50.0.
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            If the growth factor of one bucket to the next is smaller than this,
            buckets will be merged to increase the factor sufficiently.
            It requires Prometheus >= v2.50.0.
            """
            self._value = value
            return self

        def build(self) -> "NativeHistogramMinBucketFactorModel3":
            value = cast(int, self._value)
            return NativeHistogramMinBucketFactorModel3(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    If the growth factor of one bucket to the next is smaller than this,
    buckets will be merged to increase the factor sufficiently.
    It requires Prometheus >= v2.50.0.
    """

    class BuilderContext(BuilderContextBase["NativeHistogramMinBucketFactorModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NativeHistogramMinBucketFactorModel3.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NativeHistogramMinBucketFactorModel3."""
        return cls.BuilderContext()


class NativeHistogramMinBucketFactorModel4(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            If the growth factor of one bucket to the next is smaller than this,
            buckets will be merged to increase the factor sufficiently.
            It requires Prometheus >= v2.50.0.
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            If the growth factor of one bucket to the next is smaller than this,
            buckets will be merged to increase the factor sufficiently.
            It requires Prometheus >= v2.50.0.
            """
            self._value = value
            return self

        def build(self) -> "NativeHistogramMinBucketFactorModel4":
            value = cast(str, self._value)
            return NativeHistogramMinBucketFactorModel4(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    If the growth factor of one bucket to the next is smaller than this,
    buckets will be merged to increase the factor sufficiently.
    It requires Prometheus >= v2.50.0.
    """

    class BuilderContext(BuilderContextBase["NativeHistogramMinBucketFactorModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NativeHistogramMinBucketFactorModel4.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NativeHistogramMinBucketFactorModel4."""
        return cls.BuilderContext()


class ServiceMonitorSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceMonitorSpec"]:
            return ServiceMonitorSpec

        def build(self) -> "ServiceMonitorSpec":
            return ServiceMonitorSpec(**self._attrs)

        @overload
        def attach_metadata(
            self, value_or_callback: Optional[AttachMetadata], /
        ) -> "ServiceMonitorSpec.Builder": ...

        @overload
        def attach_metadata(
            self,
            value_or_callback: Callable[
                [AttachMetadata.Builder], AttachMetadata.Builder | AttachMetadata
            ],
            /,
        ) -> "ServiceMonitorSpec.Builder": ...

        @overload
        def attach_metadata(
            self, value_or_callback: Never = ...
        ) -> "AttachMetadata.BuilderContext": ...

        def attach_metadata(self, value_or_callback=None, /):
            """
            `attachMetadata` defines additional metadata which is added to the
            discovered targets.

            It requires Prometheus >= v2.37.0.
            """
            if self._in_context and value_or_callback is None:
                context = AttachMetadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "attach_metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AttachMetadata.builder())
                if isinstance(output, AttachMetadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("attach_metadata", value)

        def body_size_limit(self, value: Optional[str], /) -> Self:
            """
            When defined, bodySizeLimit specifies a job level limit on the size
            of uncompressed response body that will be accepted by Prometheus.

            It requires Prometheus >= v2.28.0.
            """
            return self._set("body_size_limit", value)

        @overload
        def endpoints(
            self, value_or_callback: List[Endpoint], /
        ) -> "ServiceMonitorSpec.Builder": ...

        @overload
        def endpoints(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Endpoint, Endpoint.Builder]],
                GenericListBuilder[Endpoint, Endpoint.Builder] | List[Endpoint],
            ],
            /,
        ) -> "ServiceMonitorSpec.Builder": ...

        @overload
        def endpoints(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Endpoint.Builder]: ...

        def endpoints(self, value_or_callback=None, /):
            """
            List of endpoints part of this ServiceMonitor.
            Defines how to scrape metrics from Kubernetes [Endpoints](https://kubernetes.io/docs/concepts/services-networking/service/#endpoints) objects.
            In most cases, an Endpoints object is backed by a Kubernetes [Service](https://kubernetes.io/docs/concepts/services-networking/service/) object with the same name and labels.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Endpoint.Builder]()
                context._parent_builder = self
                context._field_name = "endpoints"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Endpoint.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("endpoints", value)

        def fallback_scrape_protocol(
            self,
            value: Optional[
                Literal[
                    "PrometheusProto",
                    "OpenMetricsText0.0.1",
                    "OpenMetricsText1.0.0",
                    "PrometheusText0.0.4",
                    "PrometheusText1.0.0",
                ]
            ],
            /,
        ) -> Self:
            """
            The protocol to use if a scrape returns blank, unparseable, or otherwise invalid Content-Type.

            It requires Prometheus >= v3.0.0.
            """
            return self._set("fallback_scrape_protocol", value)

        def job_label(self, value: Optional[str], /) -> Self:
            """
            `jobLabel` selects the label from the associated Kubernetes `Service`
            object which will be used as the `job` label for all metrics.

            For example if `jobLabel` is set to `foo` and the Kubernetes `Service`
            object is labeled with `foo: bar`, then Prometheus adds the `job="bar"`
            label to all ingested metrics.

            If the value of this field is empty or if the label doesn't exist for
            the given Service, the `job` label of the metrics defaults to the name
            of the associated Kubernetes `Service`.
            """
            return self._set("job_label", value)

        def keep_dropped_targets(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on the number of targets dropped by relabeling
            that will be kept in memory. 0 means no limit.

            It requires Prometheus >= v2.47.0.
            """
            return self._set("keep_dropped_targets", value)

        def label_limit(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on number of labels that will be accepted for a sample.

            It requires Prometheus >= v2.27.0.
            """
            return self._set("label_limit", value)

        def label_name_length_limit(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on length of labels name that will be accepted for a sample.

            It requires Prometheus >= v2.27.0.
            """
            return self._set("label_name_length_limit", value)

        def label_value_length_limit(self, value: Optional[int], /) -> Self:
            """
            Per-scrape limit on length of labels value that will be accepted for a sample.

            It requires Prometheus >= v2.27.0.
            """
            return self._set("label_value_length_limit", value)

        @overload
        def namespace_selector(
            self, value_or_callback: Optional[NamespaceSelectorModel2], /
        ) -> "ServiceMonitorSpec.Builder": ...

        @overload
        def namespace_selector(
            self,
            value_or_callback: Callable[
                [NamespaceSelectorModel2.Builder],
                NamespaceSelectorModel2.Builder | NamespaceSelectorModel2,
            ],
            /,
        ) -> "ServiceMonitorSpec.Builder": ...

        @overload
        def namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "NamespaceSelectorModel2.BuilderContext": ...

        def namespace_selector(self, value_or_callback=None, /):
            """
            `namespaceSelector` defines in which namespace(s) Prometheus should discover the services.
            By default, the services are discovered in the same namespace as the `ServiceMonitor` object but it is possible to select pods across different/all namespaces.
            """
            if self._in_context and value_or_callback is None:
                context = NamespaceSelectorModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamespaceSelectorModel2.builder())
                if isinstance(output, NamespaceSelectorModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("namespace_selector", value)

        def native_histogram_bucket_limit(self, value: Optional[int], /) -> Self:
            """
            If there are more than this many buckets in a native histogram,
            buckets will be merged to stay within the limit.
            It requires Prometheus >= v2.45.0.
            """
            return self._set("native_histogram_bucket_limit", value)

        def native_histogram_min_bucket_factor(
            self,
            value: Optional[
                Union[
                    NativeHistogramMinBucketFactorModel3,
                    NativeHistogramMinBucketFactorModel4,
                ]
            ],
            /,
        ) -> Self:
            """
            If the growth factor of one bucket to the next is smaller than this,
            buckets will be merged to increase the factor sufficiently.
            It requires Prometheus >= v2.50.0.
            """
            return self._set("native_histogram_min_bucket_factor", value)

        def pod_target_labels(self, value: Optional[List[str]], /) -> Self:
            """
            `podTargetLabels` defines the labels which are transferred from the
            associated Kubernetes `Pod` object onto the ingested metrics.
            """
            return self._set("pod_target_labels", value)

        def sample_limit(self, value: Optional[int], /) -> Self:
            """
            `sampleLimit` defines a per-scrape limit on the number of scraped samples
            that will be accepted.
            """
            return self._set("sample_limit", value)

        def scrape_class(self, value: Optional[str], /) -> Self:
            """
            The scrape class to apply.
            """
            return self._set("scrape_class", value)

        def scrape_classic_histograms(self, value: Optional[bool], /) -> Self:
            """
            Whether to scrape a classic histogram that is also exposed as a native histogram.
            It requires Prometheus >= v2.45.0.
            """
            return self._set("scrape_classic_histograms", value)

        def scrape_protocols(
            self,
            value: Optional[
                List[
                    Literal[
                        "PrometheusProto",
                        "OpenMetricsText0.0.1",
                        "OpenMetricsText1.0.0",
                        "PrometheusText0.0.4",
                        "PrometheusText1.0.0",
                    ]
                ]
            ],
            /,
        ) -> Self:
            """
            `scrapeProtocols` defines the protocols to negotiate during a scrape. It tells clients the
            protocols supported by Prometheus in order of preference (from most to least preferred).

            If unset, Prometheus uses its default value.

            It requires Prometheus >= v2.49.0.
            """
            return self._set("scrape_protocols", value)

        @overload
        def selector(self, value_or_callback: Selector, /) -> "ServiceMonitorSpec.Builder": ...

        @overload
        def selector(
            self,
            value_or_callback: Callable[[Selector.Builder], Selector.Builder | Selector],
            /,
        ) -> "ServiceMonitorSpec.Builder": ...

        @overload
        def selector(self, value_or_callback: Never = ...) -> "Selector.BuilderContext": ...

        def selector(self, value_or_callback=None, /):
            """
            Label selector to select the Kubernetes `Endpoints` objects to scrape metrics from.
            """
            if self._in_context and value_or_callback is None:
                context = Selector.BuilderContext()
                context._parent_builder = self
                context._field_name = "selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Selector.builder())
                if isinstance(output, Selector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("selector", value)

        def selector_mechanism(
            self, value: Optional[Literal["RelabelConfig", "RoleSelector"]], /
        ) -> Self:
            """
            Mechanism used to select the endpoints to scrape.
            By default, the selection process relies on relabel configurations to filter the discovered targets.
            Alternatively, you can opt in for role selectors, which may offer better efficiency in large clusters.
            Which strategy is best for your use case needs to be carefully evaluated.

            It requires Prometheus >= v2.17.0.
            """
            return self._set("selector_mechanism", value)

        def target_labels(self, value: Optional[List[str]], /) -> Self:
            """
            `targetLabels` defines the labels which are transferred from the
            associated Kubernetes `Service` object onto the ingested metrics.
            """
            return self._set("target_labels", value)

        def target_limit(self, value: Optional[int], /) -> Self:
            """
            `targetLimit` defines a limit on the number of scraped targets that will
            be accepted.
            """
            return self._set("target_limit", value)

    class BuilderContext(BuilderContextBase["ServiceMonitorSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceMonitorSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceMonitorSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceMonitorSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceMonitorSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    attach_metadata: Annotated[Optional[AttachMetadata], Field(alias="attachMetadata")] = None
    """
    `attachMetadata` defines additional metadata which is added to the
    discovered targets.

    It requires Prometheus >= v2.37.0.
    """
    body_size_limit: Annotated[
        Optional[str],
        Field(alias="bodySizeLimit", pattern="(^0|([0-9]*[.])?[0-9]+((K|M|G|T|E|P)i?)?B)$"),
    ] = None
    """
    When defined, bodySizeLimit specifies a job level limit on the size
    of uncompressed response body that will be accepted by Prometheus.

    It requires Prometheus >= v2.28.0.
    """
    endpoints: List[Endpoint]
    """
    List of endpoints part of this ServiceMonitor.
    Defines how to scrape metrics from Kubernetes [Endpoints](https://kubernetes.io/docs/concepts/services-networking/service/#endpoints) objects.
    In most cases, an Endpoints object is backed by a Kubernetes [Service](https://kubernetes.io/docs/concepts/services-networking/service/) object with the same name and labels.
    """
    fallback_scrape_protocol: Annotated[
        Optional[
            Literal[
                "PrometheusProto",
                "OpenMetricsText0.0.1",
                "OpenMetricsText1.0.0",
                "PrometheusText0.0.4",
                "PrometheusText1.0.0",
            ]
        ],
        Field(alias="fallbackScrapeProtocol"),
    ] = None
    """
    The protocol to use if a scrape returns blank, unparseable, or otherwise invalid Content-Type.

    It requires Prometheus >= v3.0.0.
    """
    job_label: Annotated[Optional[str], Field(alias="jobLabel")] = None
    """
    `jobLabel` selects the label from the associated Kubernetes `Service`
    object which will be used as the `job` label for all metrics.

    For example if `jobLabel` is set to `foo` and the Kubernetes `Service`
    object is labeled with `foo: bar`, then Prometheus adds the `job="bar"`
    label to all ingested metrics.

    If the value of this field is empty or if the label doesn't exist for
    the given Service, the `job` label of the metrics defaults to the name
    of the associated Kubernetes `Service`.
    """
    keep_dropped_targets: Annotated[Optional[int], Field(alias="keepDroppedTargets")] = None
    """
    Per-scrape limit on the number of targets dropped by relabeling
    that will be kept in memory. 0 means no limit.

    It requires Prometheus >= v2.47.0.
    """
    label_limit: Annotated[Optional[int], Field(alias="labelLimit")] = None
    """
    Per-scrape limit on number of labels that will be accepted for a sample.

    It requires Prometheus >= v2.27.0.
    """
    label_name_length_limit: Annotated[Optional[int], Field(alias="labelNameLengthLimit")] = None
    """
    Per-scrape limit on length of labels name that will be accepted for a sample.

    It requires Prometheus >= v2.27.0.
    """
    label_value_length_limit: Annotated[Optional[int], Field(alias="labelValueLengthLimit")] = None
    """
    Per-scrape limit on length of labels value that will be accepted for a sample.

    It requires Prometheus >= v2.27.0.
    """
    namespace_selector: Annotated[
        Optional[NamespaceSelectorModel2], Field(alias="namespaceSelector")
    ] = None
    """
    `namespaceSelector` defines in which namespace(s) Prometheus should discover the services.
    By default, the services are discovered in the same namespace as the `ServiceMonitor` object but it is possible to select pods across different/all namespaces.
    """
    native_histogram_bucket_limit: Annotated[
        Optional[int], Field(alias="nativeHistogramBucketLimit")
    ] = None
    """
    If there are more than this many buckets in a native histogram,
    buckets will be merged to stay within the limit.
    It requires Prometheus >= v2.45.0.
    """
    native_histogram_min_bucket_factor: Annotated[
        Optional[
            Union[
                NativeHistogramMinBucketFactorModel3,
                NativeHistogramMinBucketFactorModel4,
            ]
        ],
        Field(alias="nativeHistogramMinBucketFactor"),
    ] = None
    """
    If the growth factor of one bucket to the next is smaller than this,
    buckets will be merged to increase the factor sufficiently.
    It requires Prometheus >= v2.50.0.
    """
    pod_target_labels: Annotated[Optional[List[str]], Field(alias="podTargetLabels")] = None
    """
    `podTargetLabels` defines the labels which are transferred from the
    associated Kubernetes `Pod` object onto the ingested metrics.
    """
    sample_limit: Annotated[Optional[int], Field(alias="sampleLimit")] = None
    """
    `sampleLimit` defines a per-scrape limit on the number of scraped samples
    that will be accepted.
    """
    scrape_class: Annotated[Optional[str], Field(alias="scrapeClass", min_length=1)] = None
    """
    The scrape class to apply.
    """
    scrape_classic_histograms: Annotated[Optional[bool], Field(alias="scrapeClassicHistograms")] = (
        None
    )
    """
    Whether to scrape a classic histogram that is also exposed as a native histogram.
    It requires Prometheus >= v2.45.0.
    """
    scrape_protocols: Annotated[
        Optional[
            List[
                Literal[
                    "PrometheusProto",
                    "OpenMetricsText0.0.1",
                    "OpenMetricsText1.0.0",
                    "PrometheusText0.0.4",
                    "PrometheusText1.0.0",
                ]
            ]
        ],
        Field(alias="scrapeProtocols"),
    ] = None
    """
    `scrapeProtocols` defines the protocols to negotiate during a scrape. It tells clients the
    protocols supported by Prometheus in order of preference (from most to least preferred).

    If unset, Prometheus uses its default value.

    It requires Prometheus >= v2.49.0.
    """
    selector: Selector
    """
    Label selector to select the Kubernetes `Endpoints` objects to scrape metrics from.
    """
    selector_mechanism: Annotated[
        Optional[Literal["RelabelConfig", "RoleSelector"]],
        Field(alias="selectorMechanism"),
    ] = None
    """
    Mechanism used to select the endpoints to scrape.
    By default, the selection process relies on relabel configurations to filter the discovered targets.
    Alternatively, you can opt in for role selectors, which may offer better efficiency in large clusters.
    Which strategy is best for your use case needs to be carefully evaluated.

    It requires Prometheus >= v2.17.0.
    """
    target_labels: Annotated[Optional[List[str]], Field(alias="targetLabels")] = None
    """
    `targetLabels` defines the labels which are transferred from the
    associated Kubernetes `Service` object onto the ingested metrics.
    """
    target_limit: Annotated[Optional[int], Field(alias="targetLimit")] = None
    """
    `targetLimit` defines a limit on the number of scraped targets that will
    be accepted.
    """


class MatchExpressionModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchExpressionModel3"]:
            return MatchExpressionModel3

        def build(self) -> "MatchExpressionModel3":
            return MatchExpressionModel3(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The label key that the selector applies to.
            """
            return self._set("key", value)

        def operator(self, value: str, /) -> Self:
            """
            Represents a key's relationship to a set of values.
            Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
            """
            return self._set("operator", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            An array of string values. If the operator is In or NotIn,
            the values array must be non-empty. If the operator is Exists or DoesNotExist,
            the values array must be empty. If the operator is Gt or Lt, the values
            array must have a single element, which will be interpreted as an integer.
            This array is replaced during a strategic merge patch.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["MatchExpressionModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchExpressionModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchExpressionModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchExpressionModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchExpressionModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The label key that the selector applies to.
    """
    operator: str
    """
    Represents a key's relationship to a set of values.
    Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    """
    values: Optional[List[str]] = None
    """
    An array of string values. If the operator is In or NotIn,
    the values array must be non-empty. If the operator is Exists or DoesNotExist,
    the values array must be empty. If the operator is Gt or Lt, the values
    array must have a single element, which will be interpreted as an integer.
    This array is replaced during a strategic merge patch.
    """


class PreferredDuringSchedulingIgnoredDuringExecutionModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PreferredDuringSchedulingIgnoredDuringExecutionModel3"]:
            return PreferredDuringSchedulingIgnoredDuringExecutionModel3

        def build(self) -> "PreferredDuringSchedulingIgnoredDuringExecutionModel3":
            return PreferredDuringSchedulingIgnoredDuringExecutionModel3(**self._attrs)

        @overload
        def preference(
            self, value_or_callback: Preference, /
        ) -> "PreferredDuringSchedulingIgnoredDuringExecutionModel3.Builder": ...

        @overload
        def preference(
            self,
            value_or_callback: Callable[[Preference.Builder], Preference.Builder | Preference],
            /,
        ) -> "PreferredDuringSchedulingIgnoredDuringExecutionModel3.Builder": ...

        @overload
        def preference(self, value_or_callback: Never = ...) -> "Preference.BuilderContext": ...

        def preference(self, value_or_callback=None, /):
            """
            A node selector term, associated with the corresponding weight.
            """
            if self._in_context and value_or_callback is None:
                context = Preference.BuilderContext()
                context._parent_builder = self
                context._field_name = "preference"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Preference.builder())
                if isinstance(output, Preference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("preference", value)

        def weight(self, value: int, /) -> Self:
            """
            Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
            """
            return self._set("weight", value)

    class BuilderContext(
        BuilderContextBase["PreferredDuringSchedulingIgnoredDuringExecutionModel3.Builder"]
    ):
        def model_post_init(self, __context) -> None:
            self._builder = PreferredDuringSchedulingIgnoredDuringExecutionModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PreferredDuringSchedulingIgnoredDuringExecutionModel3."""
        return cls.BuilderContext()

    class ListBuilder(
        GenericListBuilder["PreferredDuringSchedulingIgnoredDuringExecutionModel3", Builder]
    ):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PreferredDuringSchedulingIgnoredDuringExecutionModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    preference: Preference
    """
    A node selector term, associated with the corresponding weight.
    """
    weight: int
    """
    Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
    """


class RequiredDuringSchedulingIgnoredDuringExecutionModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RequiredDuringSchedulingIgnoredDuringExecutionModel3"]:
            return RequiredDuringSchedulingIgnoredDuringExecutionModel3

        def build(self) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel3":
            return RequiredDuringSchedulingIgnoredDuringExecutionModel3(**self._attrs)

        @overload
        def node_selector_terms(
            self, value_or_callback: List[NodeSelectorTerm], /
        ) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel3.Builder": ...

        @overload
        def node_selector_terms(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[NodeSelectorTerm, NodeSelectorTerm.Builder]],
                GenericListBuilder[NodeSelectorTerm, NodeSelectorTerm.Builder]
                | List[NodeSelectorTerm],
            ],
            /,
        ) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel3.Builder": ...

        @overload
        def node_selector_terms(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[NodeSelectorTerm.Builder]: ...

        def node_selector_terms(self, value_or_callback=None, /):
            """
            Required. A list of node selector terms. The terms are ORed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[NodeSelectorTerm.Builder]()
                context._parent_builder = self
                context._field_name = "node_selector_terms"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NodeSelectorTerm.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("node_selector_terms", value)

    class BuilderContext(
        BuilderContextBase["RequiredDuringSchedulingIgnoredDuringExecutionModel3.Builder"]
    ):
        def model_post_init(self, __context) -> None:
            self._builder = RequiredDuringSchedulingIgnoredDuringExecutionModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequiredDuringSchedulingIgnoredDuringExecutionModel3."""
        return cls.BuilderContext()

    class ListBuilder(
        GenericListBuilder["RequiredDuringSchedulingIgnoredDuringExecutionModel3", Builder]
    ):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RequiredDuringSchedulingIgnoredDuringExecutionModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    node_selector_terms: Annotated[List[NodeSelectorTerm], Field(alias="nodeSelectorTerms")]
    """
    Required. A list of node selector terms. The terms are ORed.
    """


class MatchExpressionModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchExpressionModel4"]:
            return MatchExpressionModel4

        def build(self) -> "MatchExpressionModel4":
            return MatchExpressionModel4(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key is the label key that the selector applies to.
            """
            return self._set("key", value)

        def operator(self, value: str, /) -> Self:
            """
            operator represents a key's relationship to a set of values.
            Valid operators are In, NotIn, Exists and DoesNotExist.
            """
            return self._set("operator", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            values is an array of string values. If the operator is In or NotIn,
            the values array must be non-empty. If the operator is Exists or DoesNotExist,
            the values array must be empty. This array is replaced during a strategic
            merge patch.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["MatchExpressionModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchExpressionModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchExpressionModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchExpressionModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchExpressionModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key is the label key that the selector applies to.
    """
    operator: str
    """
    operator represents a key's relationship to a set of values.
    Valid operators are In, NotIn, Exists and DoesNotExist.
    """
    values: Optional[List[str]] = None
    """
    values is an array of string values. If the operator is In or NotIn,
    the values array must be non-empty. If the operator is Exists or DoesNotExist,
    the values array must be empty. This array is replaced during a strategic
    merge patch.
    """


class NamespaceSelectorModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NamespaceSelectorModel3"]:
            return NamespaceSelectorModel3

        def build(self) -> "NamespaceSelectorModel3":
            return NamespaceSelectorModel3(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpressionModel4], /
        ) -> "NamespaceSelectorModel3.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpressionModel4, MatchExpressionModel4.Builder]],
                GenericListBuilder[MatchExpressionModel4, MatchExpressionModel4.Builder]
                | List[MatchExpressionModel4],
            ],
            /,
        ) -> "NamespaceSelectorModel3.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpressionModel4.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpressionModel4.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpressionModel4.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["NamespaceSelectorModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NamespaceSelectorModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NamespaceSelectorModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NamespaceSelectorModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamespaceSelectorModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpressionModel4]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class PreferredDuringSchedulingIgnoredDuringExecutionModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PreferredDuringSchedulingIgnoredDuringExecutionModel4"]:
            return PreferredDuringSchedulingIgnoredDuringExecutionModel4

        def build(self) -> "PreferredDuringSchedulingIgnoredDuringExecutionModel4":
            return PreferredDuringSchedulingIgnoredDuringExecutionModel4(**self._attrs)

        @overload
        def pod_affinity_term(
            self, value_or_callback: PodAffinityTerm, /
        ) -> "PreferredDuringSchedulingIgnoredDuringExecutionModel4.Builder": ...

        @overload
        def pod_affinity_term(
            self,
            value_or_callback: Callable[
                [PodAffinityTerm.Builder], PodAffinityTerm.Builder | PodAffinityTerm
            ],
            /,
        ) -> "PreferredDuringSchedulingIgnoredDuringExecutionModel4.Builder": ...

        @overload
        def pod_affinity_term(
            self, value_or_callback: Never = ...
        ) -> "PodAffinityTerm.BuilderContext": ...

        def pod_affinity_term(self, value_or_callback=None, /):
            """
            Required. A pod affinity term, associated with the corresponding weight.
            """
            if self._in_context and value_or_callback is None:
                context = PodAffinityTerm.BuilderContext()
                context._parent_builder = self
                context._field_name = "pod_affinity_term"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodAffinityTerm.builder())
                if isinstance(output, PodAffinityTerm.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("pod_affinity_term", value)

        def weight(self, value: int, /) -> Self:
            """
            weight associated with matching the corresponding podAffinityTerm,
            in the range 1-100.
            """
            return self._set("weight", value)

    class BuilderContext(
        BuilderContextBase["PreferredDuringSchedulingIgnoredDuringExecutionModel4.Builder"]
    ):
        def model_post_init(self, __context) -> None:
            self._builder = PreferredDuringSchedulingIgnoredDuringExecutionModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PreferredDuringSchedulingIgnoredDuringExecutionModel4."""
        return cls.BuilderContext()

    class ListBuilder(
        GenericListBuilder["PreferredDuringSchedulingIgnoredDuringExecutionModel4", Builder]
    ):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PreferredDuringSchedulingIgnoredDuringExecutionModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    pod_affinity_term: Annotated[PodAffinityTerm, Field(alias="podAffinityTerm")]
    """
    Required. A pod affinity term, associated with the corresponding weight.
    """
    weight: int
    """
    weight associated with matching the corresponding podAffinityTerm,
    in the range 1-100.
    """


class RequiredDuringSchedulingIgnoredDuringExecutionModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RequiredDuringSchedulingIgnoredDuringExecutionModel4"]:
            return RequiredDuringSchedulingIgnoredDuringExecutionModel4

        def build(self) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel4":
            return RequiredDuringSchedulingIgnoredDuringExecutionModel4(**self._attrs)

        @overload
        def label_selector(
            self, value_or_callback: Optional[LabelSelector], /
        ) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel4.Builder": ...

        @overload
        def label_selector(
            self,
            value_or_callback: Callable[
                [LabelSelector.Builder], LabelSelector.Builder | LabelSelector
            ],
            /,
        ) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel4.Builder": ...

        @overload
        def label_selector(
            self, value_or_callback: Never = ...
        ) -> "LabelSelector.BuilderContext": ...

        def label_selector(self, value_or_callback=None, /):
            """
            A label query over a set of resources, in this case pods.
            If it's null, this PodAffinityTerm matches with no Pods.
            """
            if self._in_context and value_or_callback is None:
                context = LabelSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "label_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LabelSelector.builder())
                if isinstance(output, LabelSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("label_selector", value)

        def match_label_keys(self, value: Optional[List[str]], /) -> Self:
            """
            MatchLabelKeys is a set of pod label keys to select which pods will
            be taken into consideration. The keys are used to lookup values from the
            incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
            to select the group of existing pods which pods will be taken into consideration
            for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
            pod labels will be ignored. The default value is empty.
            The same key is forbidden to exist in both matchLabelKeys and labelSelector.
            Also, matchLabelKeys cannot be set when labelSelector isn't set.
            This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
            """
            return self._set("match_label_keys", value)

        def mismatch_label_keys(self, value: Optional[List[str]], /) -> Self:
            """
            MismatchLabelKeys is a set of pod label keys to select which pods will
            be taken into consideration. The keys are used to lookup values from the
            incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
            to select the group of existing pods which pods will be taken into consideration
            for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
            pod labels will be ignored. The default value is empty.
            The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
            Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
            This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
            """
            return self._set("mismatch_label_keys", value)

        @overload
        def namespace_selector(
            self, value_or_callback: Optional[NamespaceSelectorModel3], /
        ) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel4.Builder": ...

        @overload
        def namespace_selector(
            self,
            value_or_callback: Callable[
                [NamespaceSelectorModel3.Builder],
                NamespaceSelectorModel3.Builder | NamespaceSelectorModel3,
            ],
            /,
        ) -> "RequiredDuringSchedulingIgnoredDuringExecutionModel4.Builder": ...

        @overload
        def namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "NamespaceSelectorModel3.BuilderContext": ...

        def namespace_selector(self, value_or_callback=None, /):
            """
            A label query over the set of namespaces that the term applies to.
            The term is applied to the union of the namespaces selected by this field
            and the ones listed in the namespaces field.
            null selector and null or empty namespaces list means "this pod's namespace".
            An empty selector ({}) matches all namespaces.
            """
            if self._in_context and value_or_callback is None:
                context = NamespaceSelectorModel3.BuilderContext()
                context._parent_builder = self
                context._field_name = "namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamespaceSelectorModel3.builder())
                if isinstance(output, NamespaceSelectorModel3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("namespace_selector", value)

        def namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            namespaces specifies a static list of namespace names that the term applies to.
            The term is applied to the union of the namespaces listed in this field
            and the ones selected by namespaceSelector.
            null or empty namespaces list and null namespaceSelector means "this pod's namespace".
            """
            return self._set("namespaces", value)

        def topology_key(self, value: str, /) -> Self:
            """
            This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
            the labelSelector in the specified namespaces, where co-located is defined as running on a node
            whose value of the label with key topologyKey matches that of any node on which any of the
            selected pods is running.
            Empty topologyKey is not allowed.
            """
            return self._set("topology_key", value)

    class BuilderContext(
        BuilderContextBase["RequiredDuringSchedulingIgnoredDuringExecutionModel4.Builder"]
    ):
        def model_post_init(self, __context) -> None:
            self._builder = RequiredDuringSchedulingIgnoredDuringExecutionModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequiredDuringSchedulingIgnoredDuringExecutionModel4."""
        return cls.BuilderContext()

    class ListBuilder(
        GenericListBuilder["RequiredDuringSchedulingIgnoredDuringExecutionModel4", Builder]
    ):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RequiredDuringSchedulingIgnoredDuringExecutionModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    label_selector: Annotated[Optional[LabelSelector], Field(alias="labelSelector")] = None
    """
    A label query over a set of resources, in this case pods.
    If it's null, this PodAffinityTerm matches with no Pods.
    """
    match_label_keys: Annotated[Optional[List[str]], Field(alias="matchLabelKeys")] = None
    """
    MatchLabelKeys is a set of pod label keys to select which pods will
    be taken into consideration. The keys are used to lookup values from the
    incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
    to select the group of existing pods which pods will be taken into consideration
    for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    pod labels will be ignored. The default value is empty.
    The same key is forbidden to exist in both matchLabelKeys and labelSelector.
    Also, matchLabelKeys cannot be set when labelSelector isn't set.
    This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
    """
    mismatch_label_keys: Annotated[Optional[List[str]], Field(alias="mismatchLabelKeys")] = None
    """
    MismatchLabelKeys is a set of pod label keys to select which pods will
    be taken into consideration. The keys are used to lookup values from the
    incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
    to select the group of existing pods which pods will be taken into consideration
    for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
    pod labels will be ignored. The default value is empty.
    The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
    Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
    This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
    """
    namespace_selector: Annotated[
        Optional[NamespaceSelectorModel3], Field(alias="namespaceSelector")
    ] = None
    """
    A label query over the set of namespaces that the term applies to.
    The term is applied to the union of the namespaces selected by this field
    and the ones listed in the namespaces field.
    null selector and null or empty namespaces list means "this pod's namespace".
    An empty selector ({}) matches all namespaces.
    """
    namespaces: Optional[List[str]] = None
    """
    namespaces specifies a static list of namespace names that the term applies to.
    The term is applied to the union of the namespaces listed in this field
    and the ones selected by namespaceSelector.
    null or empty namespaces list and null namespaceSelector means "this pod's namespace".
    """
    topology_key: Annotated[str, Field(alias="topologyKey")]
    """
    This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
    the labelSelector in the specified namespaces, where co-located is defined as running on a node
    whose value of the label with key topologyKey matches that of any node on which any of the
    selected pods is running.
    Empty topologyKey is not allowed.
    """


class AlertRelabelConfigs(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AlertRelabelConfigs"]:
            return AlertRelabelConfigs

        def build(self) -> "AlertRelabelConfigs":
            return AlertRelabelConfigs(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["AlertRelabelConfigs.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AlertRelabelConfigs.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AlertRelabelConfigs."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AlertRelabelConfigs", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AlertRelabelConfigs.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class AlertmanagersConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AlertmanagersConfig"]:
            return AlertmanagersConfig

        def build(self) -> "AlertmanagersConfig":
            return AlertmanagersConfig(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["AlertmanagersConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AlertmanagersConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AlertmanagersConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AlertmanagersConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AlertmanagersConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class DivisorModel15(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel15":
            value = cast(int, self._value)
            return DivisorModel15(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel15.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel15.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel15."""
        return cls.BuilderContext()


class DivisorModel16(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel16":
            value = cast(str, self._value)
            return DivisorModel16(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel16.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel16.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel16."""
        return cls.BuilderContext()


class SecretRefModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretRefModel3"]:
            return SecretRefModel3

        def build(self) -> "SecretRefModel3":
            return SecretRefModel3(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["SecretRefModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretRefModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretRefModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretRefModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRefModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret must be defined
    """


class LimitsModel25(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel25":
            value = cast(int, self._value)
            return LimitsModel25(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel25.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel25.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel25."""
        return cls.BuilderContext()


class LimitsModel26(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel26":
            value = cast(str, self._value)
            return LimitsModel26(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel26.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel26.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel26."""
        return cls.BuilderContext()


class RequestsModel25(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel25":
            value = cast(int, self._value)
            return RequestsModel25(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel25.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel25.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel25."""
        return cls.BuilderContext()


class RequestsModel26(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel26":
            value = cast(str, self._value)
            return RequestsModel26(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel26.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel26.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel26."""
        return cls.BuilderContext()


class ResourcesModel5(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourcesModel5"]:
            return ResourcesModel5

        def build(self) -> "ResourcesModel5":
            return ResourcesModel5(**self._attrs)

        @overload
        def claims(self, value_or_callback: List[Claim], /) -> "ResourcesModel5.Builder": ...

        @overload
        def claims(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Claim, Claim.Builder]],
                GenericListBuilder[Claim, Claim.Builder] | List[Claim],
            ],
            /,
        ) -> "ResourcesModel5.Builder": ...

        @overload
        def claims(self, value_or_callback: Never = ...) -> ListBuilderContext[Claim.Builder]: ...

        def claims(self, value_or_callback=None, /):
            """
            Claims lists the names of resources, defined in spec.resourceClaims,
            that are used by this container.

            This is an alpha field and requires enabling the
            DynamicResourceAllocation feature gate.

            This field is immutable. It can only be set for containers.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Claim.Builder]()
                context._parent_builder = self
                context._field_name = "claims"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Claim.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("claims", value)

        def limits(
            self, value: Optional[Dict[str, Union[LimitsModel25, LimitsModel26]]], /
        ) -> Self:
            """
            Limits describes the maximum amount of compute resources allowed.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            return self._set("limits", value)

        def requests(
            self, value: Optional[Dict[str, Union[RequestsModel25, RequestsModel26]]], /
        ) -> Self:
            """
            Requests describes the minimum amount of compute resources required.
            If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
            otherwise to an implementation-defined value. Requests cannot exceed Limits.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            return self._set("requests", value)

    class BuilderContext(BuilderContextBase["ResourcesModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourcesModel5.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourcesModel5."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourcesModel5", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourcesModel5.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    claims: Optional[List[Claim]] = None
    """
    Claims lists the names of resources, defined in spec.resourceClaims,
    that are used by this container.

    This is an alpha field and requires enabling the
    DynamicResourceAllocation feature gate.

    This field is immutable. It can only be set for containers.
    """
    limits: Optional[Dict[str, Union[LimitsModel25, LimitsModel26]]] = None
    """
    Limits describes the maximum amount of compute resources allowed.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """
    requests: Optional[Dict[str, Union[RequestsModel25, RequestsModel26]]] = None
    """
    Requests describes the minimum amount of compute resources required.
    If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    otherwise to an implementation-defined value. Requests cannot exceed Limits.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """


class SecurityContextModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecurityContextModel3"]:
            return SecurityContextModel3

        def build(self) -> "SecurityContextModel3":
            return SecurityContextModel3(**self._attrs)

        def allow_privilege_escalation(self, value: Optional[bool], /) -> Self:
            """
            AllowPrivilegeEscalation controls whether a process can gain more
            privileges than its parent process. This bool directly controls if
            the no_new_privs flag will be set on the container process.
            AllowPrivilegeEscalation is true always when the container is:
            1) run as Privileged
            2) has CAP_SYS_ADMIN
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("allow_privilege_escalation", value)

        @overload
        def app_armor_profile(
            self, value_or_callback: Optional[AppArmorProfile], /
        ) -> "SecurityContextModel3.Builder": ...

        @overload
        def app_armor_profile(
            self,
            value_or_callback: Callable[
                [AppArmorProfile.Builder], AppArmorProfile.Builder | AppArmorProfile
            ],
            /,
        ) -> "SecurityContextModel3.Builder": ...

        @overload
        def app_armor_profile(
            self, value_or_callback: Never = ...
        ) -> "AppArmorProfile.BuilderContext": ...

        def app_armor_profile(self, value_or_callback=None, /):
            """
            appArmorProfile is the AppArmor options to use by this container. If set, this profile
            overrides the pod's appArmorProfile.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = AppArmorProfile.BuilderContext()
                context._parent_builder = self
                context._field_name = "app_armor_profile"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AppArmorProfile.builder())
                if isinstance(output, AppArmorProfile.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("app_armor_profile", value)

        @overload
        def capabilities(
            self, value_or_callback: Optional[Capabilities], /
        ) -> "SecurityContextModel3.Builder": ...

        @overload
        def capabilities(
            self,
            value_or_callback: Callable[
                [Capabilities.Builder], Capabilities.Builder | Capabilities
            ],
            /,
        ) -> "SecurityContextModel3.Builder": ...

        @overload
        def capabilities(self, value_or_callback: Never = ...) -> "Capabilities.BuilderContext": ...

        def capabilities(self, value_or_callback=None, /):
            """
            The capabilities to add/drop when running containers.
            Defaults to the default set of capabilities granted by the container runtime.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = Capabilities.BuilderContext()
                context._parent_builder = self
                context._field_name = "capabilities"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Capabilities.builder())
                if isinstance(output, Capabilities.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("capabilities", value)

        def privileged(self, value: Optional[bool], /) -> Self:
            """
            Run container in privileged mode.
            Processes in privileged containers are essentially equivalent to root on the host.
            Defaults to false.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("privileged", value)

        def proc_mount(self, value: Optional[str], /) -> Self:
            """
            procMount denotes the type of proc mount to use for the containers.
            The default value is Default which uses the container runtime defaults for
            readonly paths and masked paths.
            This requires the ProcMountType feature flag to be enabled.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("proc_mount", value)

        def read_only_root_filesystem(self, value: Optional[bool], /) -> Self:
            """
            Whether this container has a read-only root filesystem.
            Default is false.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("read_only_root_filesystem", value)

        def run_as_group(self, value: Optional[int], /) -> Self:
            """
            The GID to run the entrypoint of the container process.
            Uses runtime default if unset.
            May also be set in PodSecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("run_as_group", value)

        def run_as_non_root(self, value: Optional[bool], /) -> Self:
            """
            Indicates that the container must run as a non-root user.
            If true, the Kubelet will validate the image at runtime to ensure that it
            does not run as UID 0 (root) and fail to start the container if it does.
            If unset or false, no such validation will be performed.
            May also be set in PodSecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            """
            return self._set("run_as_non_root", value)

        def run_as_user(self, value: Optional[int], /) -> Self:
            """
            The UID to run the entrypoint of the container process.
            Defaults to user specified in image metadata if unspecified.
            May also be set in PodSecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("run_as_user", value)

        @overload
        def se_linux_options(
            self, value_or_callback: Optional[SeLinuxOptions], /
        ) -> "SecurityContextModel3.Builder": ...

        @overload
        def se_linux_options(
            self,
            value_or_callback: Callable[
                [SeLinuxOptions.Builder], SeLinuxOptions.Builder | SeLinuxOptions
            ],
            /,
        ) -> "SecurityContextModel3.Builder": ...

        @overload
        def se_linux_options(
            self, value_or_callback: Never = ...
        ) -> "SeLinuxOptions.BuilderContext": ...

        def se_linux_options(self, value_or_callback=None, /):
            """
            The SELinux context to be applied to the container.
            If unspecified, the container runtime will allocate a random SELinux context for each
            container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = SeLinuxOptions.BuilderContext()
                context._parent_builder = self
                context._field_name = "se_linux_options"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SeLinuxOptions.builder())
                if isinstance(output, SeLinuxOptions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("se_linux_options", value)

        @overload
        def seccomp_profile(
            self, value_or_callback: Optional[SeccompProfile], /
        ) -> "SecurityContextModel3.Builder": ...

        @overload
        def seccomp_profile(
            self,
            value_or_callback: Callable[
                [SeccompProfile.Builder], SeccompProfile.Builder | SeccompProfile
            ],
            /,
        ) -> "SecurityContextModel3.Builder": ...

        @overload
        def seccomp_profile(
            self, value_or_callback: Never = ...
        ) -> "SeccompProfile.BuilderContext": ...

        def seccomp_profile(self, value_or_callback=None, /):
            """
            The seccomp options to use by this container. If seccomp options are
            provided at both the pod & container level, the container options
            override the pod options.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = SeccompProfile.BuilderContext()
                context._parent_builder = self
                context._field_name = "seccomp_profile"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SeccompProfile.builder())
                if isinstance(output, SeccompProfile.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("seccomp_profile", value)

        @overload
        def windows_options(
            self, value_or_callback: Optional[WindowsOptions], /
        ) -> "SecurityContextModel3.Builder": ...

        @overload
        def windows_options(
            self,
            value_or_callback: Callable[
                [WindowsOptions.Builder], WindowsOptions.Builder | WindowsOptions
            ],
            /,
        ) -> "SecurityContextModel3.Builder": ...

        @overload
        def windows_options(
            self, value_or_callback: Never = ...
        ) -> "WindowsOptions.BuilderContext": ...

        def windows_options(self, value_or_callback=None, /):
            """
            The Windows specific settings applied to all containers.
            If unspecified, the options from the PodSecurityContext will be used.
            If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
            Note that this field cannot be set when spec.os.name is linux.
            """
            if self._in_context and value_or_callback is None:
                context = WindowsOptions.BuilderContext()
                context._parent_builder = self
                context._field_name = "windows_options"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WindowsOptions.builder())
                if isinstance(output, WindowsOptions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("windows_options", value)

    class BuilderContext(BuilderContextBase["SecurityContextModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecurityContextModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecurityContextModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecurityContextModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecurityContextModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    allow_privilege_escalation: Annotated[
        Optional[bool], Field(alias="allowPrivilegeEscalation")
    ] = None
    """
    AllowPrivilegeEscalation controls whether a process can gain more
    privileges than its parent process. This bool directly controls if
    the no_new_privs flag will be set on the container process.
    AllowPrivilegeEscalation is true always when the container is:
    1) run as Privileged
    2) has CAP_SYS_ADMIN
    Note that this field cannot be set when spec.os.name is windows.
    """
    app_armor_profile: Annotated[Optional[AppArmorProfile], Field(alias="appArmorProfile")] = None
    """
    appArmorProfile is the AppArmor options to use by this container. If set, this profile
    overrides the pod's appArmorProfile.
    Note that this field cannot be set when spec.os.name is windows.
    """
    capabilities: Optional[Capabilities] = None
    """
    The capabilities to add/drop when running containers.
    Defaults to the default set of capabilities granted by the container runtime.
    Note that this field cannot be set when spec.os.name is windows.
    """
    privileged: Optional[bool] = None
    """
    Run container in privileged mode.
    Processes in privileged containers are essentially equivalent to root on the host.
    Defaults to false.
    Note that this field cannot be set when spec.os.name is windows.
    """
    proc_mount: Annotated[Optional[str], Field(alias="procMount")] = None
    """
    procMount denotes the type of proc mount to use for the containers.
    The default value is Default which uses the container runtime defaults for
    readonly paths and masked paths.
    This requires the ProcMountType feature flag to be enabled.
    Note that this field cannot be set when spec.os.name is windows.
    """
    read_only_root_filesystem: Annotated[Optional[bool], Field(alias="readOnlyRootFilesystem")] = (
        None
    )
    """
    Whether this container has a read-only root filesystem.
    Default is false.
    Note that this field cannot be set when spec.os.name is windows.
    """
    run_as_group: Annotated[Optional[int], Field(alias="runAsGroup")] = None
    """
    The GID to run the entrypoint of the container process.
    Uses runtime default if unset.
    May also be set in PodSecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    Note that this field cannot be set when spec.os.name is windows.
    """
    run_as_non_root: Annotated[Optional[bool], Field(alias="runAsNonRoot")] = None
    """
    Indicates that the container must run as a non-root user.
    If true, the Kubelet will validate the image at runtime to ensure that it
    does not run as UID 0 (root) and fail to start the container if it does.
    If unset or false, no such validation will be performed.
    May also be set in PodSecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    """
    run_as_user: Annotated[Optional[int], Field(alias="runAsUser")] = None
    """
    The UID to run the entrypoint of the container process.
    Defaults to user specified in image metadata if unspecified.
    May also be set in PodSecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    Note that this field cannot be set when spec.os.name is windows.
    """
    se_linux_options: Annotated[Optional[SeLinuxOptions], Field(alias="seLinuxOptions")] = None
    """
    The SELinux context to be applied to the container.
    If unspecified, the container runtime will allocate a random SELinux context for each
    container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    Note that this field cannot be set when spec.os.name is windows.
    """
    seccomp_profile: Annotated[Optional[SeccompProfile], Field(alias="seccompProfile")] = None
    """
    The seccomp options to use by this container. If seccomp options are
    provided at both the pod & container level, the container options
    override the pod options.
    Note that this field cannot be set when spec.os.name is windows.
    """
    windows_options: Annotated[Optional[WindowsOptions], Field(alias="windowsOptions")] = None
    """
    The Windows specific settings applied to all containers.
    If unspecified, the options from the PodSecurityContext will be used.
    If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
    Note that this field cannot be set when spec.os.name is linux.
    """


class DivisorModel17(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel17":
            value = cast(int, self._value)
            return DivisorModel17(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel17.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel17.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel17."""
        return cls.BuilderContext()


class DivisorModel18(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel18":
            value = cast(str, self._value)
            return DivisorModel18(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel18.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel18.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel18."""
        return cls.BuilderContext()


class LimitsModel27(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel27":
            value = cast(int, self._value)
            return LimitsModel27(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel27.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel27.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel27."""
        return cls.BuilderContext()


class LimitsModel28(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel28":
            value = cast(str, self._value)
            return LimitsModel28(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel28.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel28.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel28."""
        return cls.BuilderContext()


class RequestsModel27(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel27":
            value = cast(int, self._value)
            return RequestsModel27(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel27.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel27.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel27."""
        return cls.BuilderContext()


class RequestsModel28(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel28":
            value = cast(str, self._value)
            return RequestsModel28(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel28.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel28.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel28."""
        return cls.BuilderContext()


class QueryConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["QueryConfig"]:
            return QueryConfig

        def build(self) -> "QueryConfig":
            return QueryConfig(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["QueryConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = QueryConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for QueryConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["QueryConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use QueryConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class LimitsModel29(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel29":
            value = cast(int, self._value)
            return LimitsModel29(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel29.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel29.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel29."""
        return cls.BuilderContext()


class LimitsModel30(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel30":
            value = cast(str, self._value)
            return LimitsModel30(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel30.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel30.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel30."""
        return cls.BuilderContext()


class RequestsModel29(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel29":
            value = cast(int, self._value)
            return RequestsModel29(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel29.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel29.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel29."""
        return cls.BuilderContext()


class RequestsModel30(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel30":
            value = cast(str, self._value)
            return RequestsModel30(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel30.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel30.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel30."""
        return cls.BuilderContext()


class SecurityContextModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecurityContextModel4"]:
            return SecurityContextModel4

        def build(self) -> "SecurityContextModel4":
            return SecurityContextModel4(**self._attrs)

        @overload
        def app_armor_profile(
            self, value_or_callback: Optional[AppArmorProfile], /
        ) -> "SecurityContextModel4.Builder": ...

        @overload
        def app_armor_profile(
            self,
            value_or_callback: Callable[
                [AppArmorProfile.Builder], AppArmorProfile.Builder | AppArmorProfile
            ],
            /,
        ) -> "SecurityContextModel4.Builder": ...

        @overload
        def app_armor_profile(
            self, value_or_callback: Never = ...
        ) -> "AppArmorProfile.BuilderContext": ...

        def app_armor_profile(self, value_or_callback=None, /):
            """
            appArmorProfile is the AppArmor options to use by the containers in this pod.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = AppArmorProfile.BuilderContext()
                context._parent_builder = self
                context._field_name = "app_armor_profile"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AppArmorProfile.builder())
                if isinstance(output, AppArmorProfile.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("app_armor_profile", value)

        def fs_group(self, value: Optional[int], /) -> Self:
            """
            A special supplemental group that applies to all containers in a pod.
            Some volume types allow the Kubelet to change the ownership of that volume
            to be owned by the pod:

            1. The owning GID will be the FSGroup
            2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
            3. The permission bits are OR'd with rw-rw----

            If unset, the Kubelet will not modify the ownership and permissions of any volume.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("fs_group", value)

        def fs_group_change_policy(self, value: Optional[str], /) -> Self:
            """
            fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
            before being exposed inside Pod. This field will only apply to
            volume types which support fsGroup based ownership(and permissions).
            It will have no effect on ephemeral volume types such as: secret, configmaps
            and emptydir.
            Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("fs_group_change_policy", value)

        def run_as_group(self, value: Optional[int], /) -> Self:
            """
            The GID to run the entrypoint of the container process.
            Uses runtime default if unset.
            May also be set in SecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence
            for that container.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("run_as_group", value)

        def run_as_non_root(self, value: Optional[bool], /) -> Self:
            """
            Indicates that the container must run as a non-root user.
            If true, the Kubelet will validate the image at runtime to ensure that it
            does not run as UID 0 (root) and fail to start the container if it does.
            If unset or false, no such validation will be performed.
            May also be set in SecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            """
            return self._set("run_as_non_root", value)

        def run_as_user(self, value: Optional[int], /) -> Self:
            """
            The UID to run the entrypoint of the container process.
            Defaults to user specified in image metadata if unspecified.
            May also be set in SecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence
            for that container.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("run_as_user", value)

        def se_linux_change_policy(self, value: Optional[str], /) -> Self:
            """
            seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
            It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
            Valid values are "MountOption" and "Recursive".

            "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
            This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.

            "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
            This requires all Pods that share the same volume to use the same SELinux label.
            It is not possible to share the same volume among privileged and unprivileged Pods.
            Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
            whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
            CSIDriver instance. Other volumes are always re-labelled recursively.
            "MountOption" value is allowed only when SELinuxMount feature gate is enabled.

            If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
            If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
            and "Recursive" for all other volumes.

            This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.

            All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("se_linux_change_policy", value)

        @overload
        def se_linux_options(
            self, value_or_callback: Optional[SeLinuxOptions], /
        ) -> "SecurityContextModel4.Builder": ...

        @overload
        def se_linux_options(
            self,
            value_or_callback: Callable[
                [SeLinuxOptions.Builder], SeLinuxOptions.Builder | SeLinuxOptions
            ],
            /,
        ) -> "SecurityContextModel4.Builder": ...

        @overload
        def se_linux_options(
            self, value_or_callback: Never = ...
        ) -> "SeLinuxOptions.BuilderContext": ...

        def se_linux_options(self, value_or_callback=None, /):
            """
            The SELinux context to be applied to all containers.
            If unspecified, the container runtime will allocate a random SELinux context for each
            container.  May also be set in SecurityContext.  If set in
            both SecurityContext and PodSecurityContext, the value specified in SecurityContext
            takes precedence for that container.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = SeLinuxOptions.BuilderContext()
                context._parent_builder = self
                context._field_name = "se_linux_options"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SeLinuxOptions.builder())
                if isinstance(output, SeLinuxOptions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("se_linux_options", value)

        @overload
        def seccomp_profile(
            self, value_or_callback: Optional[SeccompProfile], /
        ) -> "SecurityContextModel4.Builder": ...

        @overload
        def seccomp_profile(
            self,
            value_or_callback: Callable[
                [SeccompProfile.Builder], SeccompProfile.Builder | SeccompProfile
            ],
            /,
        ) -> "SecurityContextModel4.Builder": ...

        @overload
        def seccomp_profile(
            self, value_or_callback: Never = ...
        ) -> "SeccompProfile.BuilderContext": ...

        def seccomp_profile(self, value_or_callback=None, /):
            """
            The seccomp options to use by the containers in this pod.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = SeccompProfile.BuilderContext()
                context._parent_builder = self
                context._field_name = "seccomp_profile"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SeccompProfile.builder())
                if isinstance(output, SeccompProfile.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("seccomp_profile", value)

        def supplemental_groups(self, value: Optional[List[int]], /) -> Self:
            """
            A list of groups applied to the first process run in each container, in
            addition to the container's primary GID and fsGroup (if specified).  If
            the SupplementalGroupsPolicy feature is enabled, the
            supplementalGroupsPolicy field determines whether these are in addition
            to or instead of any group memberships defined in the container image.
            If unspecified, no additional groups are added, though group memberships
            defined in the container image may still be used, depending on the
            supplementalGroupsPolicy field.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("supplemental_groups", value)

        def supplemental_groups_policy(self, value: Optional[str], /) -> Self:
            """
            Defines how supplemental groups of the first container processes are calculated.
            Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
            (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
            and the container runtime must implement support for this feature.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("supplemental_groups_policy", value)

        @overload
        def sysctls(
            self, value_or_callback: List[Sysctl], /
        ) -> "SecurityContextModel4.Builder": ...

        @overload
        def sysctls(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Sysctl, Sysctl.Builder]],
                GenericListBuilder[Sysctl, Sysctl.Builder] | List[Sysctl],
            ],
            /,
        ) -> "SecurityContextModel4.Builder": ...

        @overload
        def sysctls(self, value_or_callback: Never = ...) -> ListBuilderContext[Sysctl.Builder]: ...

        def sysctls(self, value_or_callback=None, /):
            """
            Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
            sysctls (by the container runtime) might fail to launch.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Sysctl.Builder]()
                context._parent_builder = self
                context._field_name = "sysctls"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sysctl.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("sysctls", value)

        @overload
        def windows_options(
            self, value_or_callback: Optional[WindowsOptions], /
        ) -> "SecurityContextModel4.Builder": ...

        @overload
        def windows_options(
            self,
            value_or_callback: Callable[
                [WindowsOptions.Builder], WindowsOptions.Builder | WindowsOptions
            ],
            /,
        ) -> "SecurityContextModel4.Builder": ...

        @overload
        def windows_options(
            self, value_or_callback: Never = ...
        ) -> "WindowsOptions.BuilderContext": ...

        def windows_options(self, value_or_callback=None, /):
            """
            The Windows specific settings applied to all containers.
            If unspecified, the options within a container's SecurityContext will be used.
            If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
            Note that this field cannot be set when spec.os.name is linux.
            """
            if self._in_context and value_or_callback is None:
                context = WindowsOptions.BuilderContext()
                context._parent_builder = self
                context._field_name = "windows_options"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WindowsOptions.builder())
                if isinstance(output, WindowsOptions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("windows_options", value)

    class BuilderContext(BuilderContextBase["SecurityContextModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecurityContextModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecurityContextModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecurityContextModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecurityContextModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    app_armor_profile: Annotated[Optional[AppArmorProfile], Field(alias="appArmorProfile")] = None
    """
    appArmorProfile is the AppArmor options to use by the containers in this pod.
    Note that this field cannot be set when spec.os.name is windows.
    """
    fs_group: Annotated[Optional[int], Field(alias="fsGroup")] = None
    """
    A special supplemental group that applies to all containers in a pod.
    Some volume types allow the Kubelet to change the ownership of that volume
    to be owned by the pod:

    1. The owning GID will be the FSGroup
    2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
    3. The permission bits are OR'd with rw-rw----

    If unset, the Kubelet will not modify the ownership and permissions of any volume.
    Note that this field cannot be set when spec.os.name is windows.
    """
    fs_group_change_policy: Annotated[Optional[str], Field(alias="fsGroupChangePolicy")] = None
    """
    fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
    before being exposed inside Pod. This field will only apply to
    volume types which support fsGroup based ownership(and permissions).
    It will have no effect on ephemeral volume types such as: secret, configmaps
    and emptydir.
    Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
    Note that this field cannot be set when spec.os.name is windows.
    """
    run_as_group: Annotated[Optional[int], Field(alias="runAsGroup")] = None
    """
    The GID to run the entrypoint of the container process.
    Uses runtime default if unset.
    May also be set in SecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence
    for that container.
    Note that this field cannot be set when spec.os.name is windows.
    """
    run_as_non_root: Annotated[Optional[bool], Field(alias="runAsNonRoot")] = None
    """
    Indicates that the container must run as a non-root user.
    If true, the Kubelet will validate the image at runtime to ensure that it
    does not run as UID 0 (root) and fail to start the container if it does.
    If unset or false, no such validation will be performed.
    May also be set in SecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    """
    run_as_user: Annotated[Optional[int], Field(alias="runAsUser")] = None
    """
    The UID to run the entrypoint of the container process.
    Defaults to user specified in image metadata if unspecified.
    May also be set in SecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence
    for that container.
    Note that this field cannot be set when spec.os.name is windows.
    """
    se_linux_change_policy: Annotated[Optional[str], Field(alias="seLinuxChangePolicy")] = None
    """
    seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
    It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
    Valid values are "MountOption" and "Recursive".

    "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
    This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.

    "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
    This requires all Pods that share the same volume to use the same SELinux label.
    It is not possible to share the same volume among privileged and unprivileged Pods.
    Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
    whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
    CSIDriver instance. Other volumes are always re-labelled recursively.
    "MountOption" value is allowed only when SELinuxMount feature gate is enabled.

    If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
    If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
    and "Recursive" for all other volumes.

    This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.

    All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
    Note that this field cannot be set when spec.os.name is windows.
    """
    se_linux_options: Annotated[Optional[SeLinuxOptions], Field(alias="seLinuxOptions")] = None
    """
    The SELinux context to be applied to all containers.
    If unspecified, the container runtime will allocate a random SELinux context for each
    container.  May also be set in SecurityContext.  If set in
    both SecurityContext and PodSecurityContext, the value specified in SecurityContext
    takes precedence for that container.
    Note that this field cannot be set when spec.os.name is windows.
    """
    seccomp_profile: Annotated[Optional[SeccompProfile], Field(alias="seccompProfile")] = None
    """
    The seccomp options to use by the containers in this pod.
    Note that this field cannot be set when spec.os.name is windows.
    """
    supplemental_groups: Annotated[Optional[List[int]], Field(alias="supplementalGroups")] = None
    """
    A list of groups applied to the first process run in each container, in
    addition to the container's primary GID and fsGroup (if specified).  If
    the SupplementalGroupsPolicy feature is enabled, the
    supplementalGroupsPolicy field determines whether these are in addition
    to or instead of any group memberships defined in the container image.
    If unspecified, no additional groups are added, though group memberships
    defined in the container image may still be used, depending on the
    supplementalGroupsPolicy field.
    Note that this field cannot be set when spec.os.name is windows.
    """
    supplemental_groups_policy: Annotated[
        Optional[str], Field(alias="supplementalGroupsPolicy")
    ] = None
    """
    Defines how supplemental groups of the first container processes are calculated.
    Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
    (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
    and the container runtime must implement support for this feature.
    Note that this field cannot be set when spec.os.name is windows.
    """
    sysctls: Optional[List[Sysctl]] = None
    """
    Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
    sysctls (by the container runtime) might fail to launch.
    Note that this field cannot be set when spec.os.name is windows.
    """
    windows_options: Annotated[Optional[WindowsOptions], Field(alias="windowsOptions")] = None
    """
    The Windows specific settings applied to all containers.
    If unspecified, the options within a container's SecurityContext will be used.
    If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
    Note that this field cannot be set when spec.os.name is linux.
    """


class SizeLimitModel7(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def build(self) -> "SizeLimitModel7":
            value = cast(int, self._value)
            return SizeLimitModel7(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    sizeLimit is the total amount of local storage required for this EmptyDir volume.
    The size limit is also applicable for memory medium.
    The maximum usage on memory medium EmptyDir would be the minimum value between
    the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    The default is nil which means that the limit is undefined.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    """

    class BuilderContext(BuilderContextBase["SizeLimitModel7.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SizeLimitModel7.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SizeLimitModel7."""
        return cls.BuilderContext()


class SizeLimitModel8(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def build(self) -> "SizeLimitModel8":
            value = cast(str, self._value)
            return SizeLimitModel8(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    sizeLimit is the total amount of local storage required for this EmptyDir volume.
    The size limit is also applicable for memory medium.
    The maximum usage on memory medium EmptyDir would be the minimum value between
    the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    The default is nil which means that the limit is undefined.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    """

    class BuilderContext(BuilderContextBase["SizeLimitModel8.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SizeLimitModel8.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SizeLimitModel8."""
        return cls.BuilderContext()


class LimitsModel31(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel31":
            value = cast(int, self._value)
            return LimitsModel31(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel31.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel31.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel31."""
        return cls.BuilderContext()


class LimitsModel32(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel32":
            value = cast(str, self._value)
            return LimitsModel32(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel32.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel32.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel32."""
        return cls.BuilderContext()


class RequestsModel31(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel31":
            value = cast(int, self._value)
            return RequestsModel31(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel31.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel31.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel31."""
        return cls.BuilderContext()


class RequestsModel32(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel32":
            value = cast(str, self._value)
            return RequestsModel32(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel32.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel32.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel32."""
        return cls.BuilderContext()


class ResourcesModel6(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourcesModel6"]:
            return ResourcesModel6

        def build(self) -> "ResourcesModel6":
            return ResourcesModel6(**self._attrs)

        def limits(
            self, value: Optional[Dict[str, Union[LimitsModel31, LimitsModel32]]], /
        ) -> Self:
            """
            Limits describes the maximum amount of compute resources allowed.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            return self._set("limits", value)

        def requests(
            self, value: Optional[Dict[str, Union[RequestsModel31, RequestsModel32]]], /
        ) -> Self:
            """
            Requests describes the minimum amount of compute resources required.
            If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
            otherwise to an implementation-defined value. Requests cannot exceed Limits.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            return self._set("requests", value)

    class BuilderContext(BuilderContextBase["ResourcesModel6.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourcesModel6.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourcesModel6."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourcesModel6", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourcesModel6.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    limits: Optional[Dict[str, Union[LimitsModel31, LimitsModel32]]] = None
    """
    Limits describes the maximum amount of compute resources allowed.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """
    requests: Optional[Dict[str, Union[RequestsModel31, RequestsModel32]]] = None
    """
    Requests describes the minimum amount of compute resources required.
    If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    otherwise to an implementation-defined value. Requests cannot exceed Limits.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """


class LimitsModel33(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel33":
            value = cast(int, self._value)
            return LimitsModel33(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel33.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel33.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel33."""
        return cls.BuilderContext()


class LimitsModel34(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel34":
            value = cast(str, self._value)
            return LimitsModel34(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel34.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel34.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel34."""
        return cls.BuilderContext()


class RequestsModel33(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel33":
            value = cast(int, self._value)
            return RequestsModel33(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel33.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel33.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel33."""
        return cls.BuilderContext()


class RequestsModel34(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel34":
            value = cast(str, self._value)
            return RequestsModel34(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel34.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel34.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel34."""
        return cls.BuilderContext()


class AllocatedResourcesModel3(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "AllocatedResourcesModel3":
            value = cast(int, self._value)
            return AllocatedResourcesModel3(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["AllocatedResourcesModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllocatedResourcesModel3.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllocatedResourcesModel3."""
        return cls.BuilderContext()


class AllocatedResourcesModel4(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "AllocatedResourcesModel4":
            value = cast(str, self._value)
            return AllocatedResourcesModel4(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["AllocatedResourcesModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllocatedResourcesModel4.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllocatedResourcesModel4."""
        return cls.BuilderContext()


class CapacityModel3(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "CapacityModel3":
            value = cast(int, self._value)
            return CapacityModel3(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["CapacityModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CapacityModel3.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CapacityModel3."""
        return cls.BuilderContext()


class CapacityModel4(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "CapacityModel4":
            value = cast(str, self._value)
            return CapacityModel4(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["CapacityModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CapacityModel4.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CapacityModel4."""
        return cls.BuilderContext()


class ConditionModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConditionModel3"]:
            return ConditionModel3

        def build(self) -> "ConditionModel3":
            return ConditionModel3(**self._attrs)

        def last_probe_time(self, value: Optional[datetime], /) -> Self:
            """
            lastProbeTime is the time we probed the condition.
            """
            return self._set("last_probe_time", value)

        def last_transition_time(self, value: Optional[datetime], /) -> Self:
            """
            lastTransitionTime is the time the condition transitioned from one status to another.
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            message is the human-readable message indicating details about last transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            reason is a unique, this should be a short, machine understandable string that gives the reason
            for condition's last transition. If it reports "Resizing" that means the underlying
            persistent volume is being resized.
            """
            return self._set("reason", value)

        def status(self, value: str, /) -> Self:
            """
            Status is the status of the condition.
            Can be True, False, Unknown.
            More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type is the type of the condition.
            More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["ConditionModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConditionModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConditionModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConditionModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConditionModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_probe_time: Annotated[Optional[datetime], Field(alias="lastProbeTime")] = None
    """
    lastProbeTime is the time we probed the condition.
    """
    last_transition_time: Annotated[Optional[datetime], Field(alias="lastTransitionTime")] = None
    """
    lastTransitionTime is the time the condition transitioned from one status to another.
    """
    message: Optional[str] = None
    """
    message is the human-readable message indicating details about last transition.
    """
    reason: Optional[str] = None
    """
    reason is a unique, this should be a short, machine understandable string that gives the reason
    for condition's last transition. If it reports "Resizing" that means the underlying
    persistent volume is being resized.
    """
    status: str
    """
    Status is the status of the condition.
    Can be True, False, Unknown.
    More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=state%20of%20pvc-,conditions.status,-(string)%2C%20required
    """
    type: str
    """
    Type is the type of the condition.
    More info: https://kubernetes.io/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/#:~:text=set%20to%20%27ResizeStarted%27.-,PersistentVolumeClaimCondition,-contains%20details%20about
    """


class VolumeClaimTemplateModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VolumeClaimTemplateModel4"]:
            return VolumeClaimTemplateModel4

        def build(self) -> "VolumeClaimTemplateModel4":
            return VolumeClaimTemplateModel4(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[Metadata], /
        ) -> "VolumeClaimTemplateModel4.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[[Metadata.Builder], Metadata.Builder | Metadata],
            /,
        ) -> "VolumeClaimTemplateModel4.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "Metadata.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            """
            EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
            """
            if self._in_context and value_or_callback is None:
                context = Metadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Metadata.builder())
                if isinstance(output, Metadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[Spec], /
        ) -> "VolumeClaimTemplateModel4.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Callable[[Spec.Builder], Spec.Builder | Spec], /
        ) -> "VolumeClaimTemplateModel4.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "Spec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            """
            Defines the desired characteristics of a volume requested by a pod author.
            More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
            """
            if self._in_context and value_or_callback is None:
                context = Spec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Spec.builder())
                if isinstance(output, Spec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[Status], /
        ) -> "VolumeClaimTemplateModel4.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[[Status.Builder], Status.Builder | Status],
            /,
        ) -> "VolumeClaimTemplateModel4.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "Status.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            """
            Deprecated: this field is never set.
            """
            if self._in_context and value_or_callback is None:
                context = Status.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Status.builder())
                if isinstance(output, Status.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["VolumeClaimTemplateModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VolumeClaimTemplateModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VolumeClaimTemplateModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VolumeClaimTemplateModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VolumeClaimTemplateModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[str] = None
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[Metadata] = None
    """
    EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
    """
    spec: Optional[Spec] = None
    """
    Defines the desired characteristics of a volume requested by a pod author.
    More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
    """
    status: Optional[Status] = None
    """
    Deprecated: this field is never set.
    """


class TopologySpreadConstraintModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TopologySpreadConstraintModel1"]:
            return TopologySpreadConstraintModel1

        def build(self) -> "TopologySpreadConstraintModel1":
            return TopologySpreadConstraintModel1(**self._attrs)

        @overload
        def label_selector(
            self, value_or_callback: Optional[LabelSelector], /
        ) -> "TopologySpreadConstraintModel1.Builder": ...

        @overload
        def label_selector(
            self,
            value_or_callback: Callable[
                [LabelSelector.Builder], LabelSelector.Builder | LabelSelector
            ],
            /,
        ) -> "TopologySpreadConstraintModel1.Builder": ...

        @overload
        def label_selector(
            self, value_or_callback: Never = ...
        ) -> "LabelSelector.BuilderContext": ...

        def label_selector(self, value_or_callback=None, /):
            """
            LabelSelector is used to find matching pods.
            Pods that match this label selector are counted to determine the number of pods
            in their corresponding topology domain.
            """
            if self._in_context and value_or_callback is None:
                context = LabelSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "label_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LabelSelector.builder())
                if isinstance(output, LabelSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("label_selector", value)

        def match_label_keys(self, value: Optional[List[str]], /) -> Self:
            """
            MatchLabelKeys is a set of pod label keys to select the pods over which
            spreading will be calculated. The keys are used to lookup values from the
            incoming pod labels, those key-value labels are ANDed with labelSelector
            to select the group of existing pods over which spreading will be calculated
            for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
            MatchLabelKeys cannot be set when LabelSelector isn't set.
            Keys that don't exist in the incoming pod labels will
            be ignored. A null or empty list means only match against labelSelector.

            This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
            """
            return self._set("match_label_keys", value)

        def max_skew(self, value: int, /) -> Self:
            """
            MaxSkew describes the degree to which pods may be unevenly distributed.
            When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
            between the number of matching pods in the target topology and the global minimum.
            The global minimum is the minimum number of matching pods in an eligible domain
            or zero if the number of eligible domains is less than MinDomains.
            For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
            labelSelector spread as 2/2/1:
            In this case, the global minimum is 1.
            | zone1 | zone2 | zone3 |
            |  P P  |  P P  |   P   |
            - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
            scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
            violate MaxSkew(1).
            - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
            When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
            to topologies that satisfy it.
            It's a required field. Default value is 1 and 0 is not allowed.
            """
            return self._set("max_skew", value)

        def min_domains(self, value: Optional[int], /) -> Self:
            """
            MinDomains indicates a minimum number of eligible domains.
            When the number of eligible domains with matching topology keys is less than minDomains,
            Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
            And when the number of eligible domains with matching topology keys equals or greater than minDomains,
            this value has no effect on scheduling.
            As a result, when the number of eligible domains is less than minDomains,
            scheduler won't schedule more than maxSkew Pods to those domains.
            If value is nil, the constraint behaves as if MinDomains is equal to 1.
            Valid values are integers greater than 0.
            When value is not nil, WhenUnsatisfiable must be DoNotSchedule.

            For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
            labelSelector spread as 2/2/2:
            | zone1 | zone2 | zone3 |
            |  P P  |  P P  |  P P  |
            The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
            In this situation, new pod with the same labelSelector cannot be scheduled,
            because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
            it will violate MaxSkew.
            """
            return self._set("min_domains", value)

        def node_affinity_policy(self, value: Optional[str], /) -> Self:
            """
            NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
            when calculating pod topology spread skew. Options are:
            - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
            - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.

            If this value is nil, the behavior is equivalent to the Honor policy.
            This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
            """
            return self._set("node_affinity_policy", value)

        def node_taints_policy(self, value: Optional[str], /) -> Self:
            """
            NodeTaintsPolicy indicates how we will treat node taints when calculating
            pod topology spread skew. Options are:
            - Honor: nodes without taints, along with tainted nodes for which the incoming pod
            has a toleration, are included.
            - Ignore: node taints are ignored. All nodes are included.

            If this value is nil, the behavior is equivalent to the Ignore policy.
            This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
            """
            return self._set("node_taints_policy", value)

        def topology_key(self, value: str, /) -> Self:
            """
            TopologyKey is the key of node labels. Nodes that have a label with this key
            and identical values are considered to be in the same topology.
            We consider each <key, value> as a "bucket", and try to put balanced number
            of pods into each bucket.
            We define a domain as a particular instance of a topology.
            Also, we define an eligible domain as a domain whose nodes meet the requirements of
            nodeAffinityPolicy and nodeTaintsPolicy.
            e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
            And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
            It's a required field.
            """
            return self._set("topology_key", value)

        def when_unsatisfiable(self, value: str, /) -> Self:
            """
            WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
            the spread constraint.
            - DoNotSchedule (default) tells the scheduler not to schedule it.
            - ScheduleAnyway tells the scheduler to schedule the pod in any location,
              but giving higher precedence to topologies that would help reduce the
              skew.
            A constraint is considered "Unsatisfiable" for an incoming pod
            if and only if every possible node assignment for that pod would violate
            "MaxSkew" on some topology.
            For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
            labelSelector spread as 3/1/1:
            | zone1 | zone2 | zone3 |
            | P P P |   P   |   P   |
            If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
            to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
            MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
            won't make it *more* imbalanced.
            It's a required field.
            """
            return self._set("when_unsatisfiable", value)

    class BuilderContext(BuilderContextBase["TopologySpreadConstraintModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TopologySpreadConstraintModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TopologySpreadConstraintModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TopologySpreadConstraintModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TopologySpreadConstraintModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    label_selector: Annotated[Optional[LabelSelector], Field(alias="labelSelector")] = None
    """
    LabelSelector is used to find matching pods.
    Pods that match this label selector are counted to determine the number of pods
    in their corresponding topology domain.
    """
    match_label_keys: Annotated[Optional[List[str]], Field(alias="matchLabelKeys")] = None
    """
    MatchLabelKeys is a set of pod label keys to select the pods over which
    spreading will be calculated. The keys are used to lookup values from the
    incoming pod labels, those key-value labels are ANDed with labelSelector
    to select the group of existing pods over which spreading will be calculated
    for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
    MatchLabelKeys cannot be set when LabelSelector isn't set.
    Keys that don't exist in the incoming pod labels will
    be ignored. A null or empty list means only match against labelSelector.

    This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
    """
    max_skew: Annotated[int, Field(alias="maxSkew")]
    """
    MaxSkew describes the degree to which pods may be unevenly distributed.
    When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
    between the number of matching pods in the target topology and the global minimum.
    The global minimum is the minimum number of matching pods in an eligible domain
    or zero if the number of eligible domains is less than MinDomains.
    For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
    labelSelector spread as 2/2/1:
    In this case, the global minimum is 1.
    | zone1 | zone2 | zone3 |
    |  P P  |  P P  |   P   |
    - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
    scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
    violate MaxSkew(1).
    - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
    When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
    to topologies that satisfy it.
    It's a required field. Default value is 1 and 0 is not allowed.
    """
    min_domains: Annotated[Optional[int], Field(alias="minDomains")] = None
    """
    MinDomains indicates a minimum number of eligible domains.
    When the number of eligible domains with matching topology keys is less than minDomains,
    Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
    And when the number of eligible domains with matching topology keys equals or greater than minDomains,
    this value has no effect on scheduling.
    As a result, when the number of eligible domains is less than minDomains,
    scheduler won't schedule more than maxSkew Pods to those domains.
    If value is nil, the constraint behaves as if MinDomains is equal to 1.
    Valid values are integers greater than 0.
    When value is not nil, WhenUnsatisfiable must be DoNotSchedule.

    For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
    labelSelector spread as 2/2/2:
    | zone1 | zone2 | zone3 |
    |  P P  |  P P  |  P P  |
    The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
    In this situation, new pod with the same labelSelector cannot be scheduled,
    because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
    it will violate MaxSkew.
    """
    node_affinity_policy: Annotated[Optional[str], Field(alias="nodeAffinityPolicy")] = None
    """
    NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
    when calculating pod topology spread skew. Options are:
    - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
    - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.

    If this value is nil, the behavior is equivalent to the Honor policy.
    This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
    """
    node_taints_policy: Annotated[Optional[str], Field(alias="nodeTaintsPolicy")] = None
    """
    NodeTaintsPolicy indicates how we will treat node taints when calculating
    pod topology spread skew. Options are:
    - Honor: nodes without taints, along with tainted nodes for which the incoming pod
    has a toleration, are included.
    - Ignore: node taints are ignored. All nodes are included.

    If this value is nil, the behavior is equivalent to the Ignore policy.
    This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
    """
    topology_key: Annotated[str, Field(alias="topologyKey")]
    """
    TopologyKey is the key of node labels. Nodes that have a label with this key
    and identical values are considered to be in the same topology.
    We consider each <key, value> as a "bucket", and try to put balanced number
    of pods into each bucket.
    We define a domain as a particular instance of a topology.
    Also, we define an eligible domain as a domain whose nodes meet the requirements of
    nodeAffinityPolicy and nodeTaintsPolicy.
    e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
    And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
    It's a required field.
    """
    when_unsatisfiable: Annotated[str, Field(alias="whenUnsatisfiable")]
    """
    WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
    the spread constraint.
    - DoNotSchedule (default) tells the scheduler not to schedule it.
    - ScheduleAnyway tells the scheduler to schedule the pod in any location,
      but giving higher precedence to topologies that would help reduce the
      skew.
    A constraint is considered "Unsatisfiable" for an incoming pod
    if and only if every possible node assignment for that pod would violate
    "MaxSkew" on some topology.
    For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
    labelSelector spread as 3/1/1:
    | zone1 | zone2 | zone3 |
    | P P P |   P   |   P   |
    If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
    to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
    MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
    won't make it *more* imbalanced.
    It's a required field.
    """


class TracingConfigModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TracingConfigModel1"]:
            return TracingConfigModel1

        def build(self) -> "TracingConfigModel1":
            return TracingConfigModel1(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["TracingConfigModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TracingConfigModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TracingConfigModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TracingConfigModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TracingConfigModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class SecretRefModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretRefModel4"]:
            return SecretRefModel4

        def build(self) -> "SecretRefModel4":
            return SecretRefModel4(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["SecretRefModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretRefModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretRefModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretRefModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRefModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """


class ConfigMapModel6(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapModel6"]:
            return ConfigMapModel6

        def build(self) -> "ConfigMapModel6":
            return ConfigMapModel6(**self._attrs)

        def default_mode(self, value: Optional[int], /) -> Self:
            """
            defaultMode is optional: mode bits used to set permissions on created files by default.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            Defaults to 0644.
            Directories within the path are not affected by this setting.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("default_mode", value)

        @overload
        def items(self, value_or_callback: List[ItemModel7], /) -> "ConfigMapModel6.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel7, ItemModel7.Builder]],
                GenericListBuilder[ItemModel7, ItemModel7.Builder] | List[ItemModel7],
            ],
            /,
        ) -> "ConfigMapModel6.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel7.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items if unspecified, each key-value pair in the Data field of the referenced
            ConfigMap will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the ConfigMap,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel7.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel7.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional specify whether the ConfigMap or its keys must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapModel6.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapModel6.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapModel6."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapModel6", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapModel6.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_mode: Annotated[Optional[int], Field(alias="defaultMode")] = None
    """
    defaultMode is optional: mode bits used to set permissions on created files by default.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    Defaults to 0644.
    Directories within the path are not affected by this setting.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    items: Optional[List[ItemModel7]] = None
    """
    items if unspecified, each key-value pair in the Data field of the referenced
    ConfigMap will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the ConfigMap,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    optional specify whether the ConfigMap or its keys must be defined
    """


class DivisorModel19(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel19":
            value = cast(int, self._value)
            return DivisorModel19(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel19.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel19.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel19."""
        return cls.BuilderContext()


class DivisorModel20(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel20":
            value = cast(str, self._value)
            return DivisorModel20(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel20.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel20.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel20."""
        return cls.BuilderContext()


class ItemModel8(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ItemModel8"]:
            return ItemModel8

        def build(self) -> "ItemModel8":
            return ItemModel8(**self._attrs)

        @overload
        def field_ref(self, value_or_callback: Optional[FieldRef], /) -> "ItemModel8.Builder": ...

        @overload
        def field_ref(
            self,
            value_or_callback: Callable[[FieldRef.Builder], FieldRef.Builder | FieldRef],
            /,
        ) -> "ItemModel8.Builder": ...

        @overload
        def field_ref(self, value_or_callback: Never = ...) -> "FieldRef.BuilderContext": ...

        def field_ref(self, value_or_callback=None, /):
            """
            Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
            """
            if self._in_context and value_or_callback is None:
                context = FieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FieldRef.builder())
                if isinstance(output, FieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("field_ref", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            Optional: mode bits used to set permissions on this file, must be an octal value
            between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
            """
            return self._set("path", value)

        @overload
        def resource_field_ref(
            self, value_or_callback: Optional[ResourceFieldRef], /
        ) -> "ItemModel8.Builder": ...

        @overload
        def resource_field_ref(
            self,
            value_or_callback: Callable[
                [ResourceFieldRef.Builder], ResourceFieldRef.Builder | ResourceFieldRef
            ],
            /,
        ) -> "ItemModel8.Builder": ...

        @overload
        def resource_field_ref(
            self, value_or_callback: Never = ...
        ) -> "ResourceFieldRef.BuilderContext": ...

        def resource_field_ref(self, value_or_callback=None, /):
            """
            Selects a resource of the container: only resources limits and requests
            (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceFieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource_field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceFieldRef.builder())
                if isinstance(output, ResourceFieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_field_ref", value)

    class BuilderContext(BuilderContextBase["ItemModel8.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ItemModel8.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ItemModel8."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ItemModel8", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ItemModel8.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    field_ref: Annotated[Optional[FieldRef], Field(alias="fieldRef")] = None
    """
    Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
    """
    mode: Optional[int] = None
    """
    Optional: mode bits used to set permissions on this file, must be an octal value
    between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    """
    resource_field_ref: Annotated[Optional[ResourceFieldRef], Field(alias="resourceFieldRef")] = (
        None
    )
    """
    Selects a resource of the container: only resources limits and requests
    (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    """


class DownwardApiModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DownwardApiModel3"]:
            return DownwardApiModel3

        def build(self) -> "DownwardApiModel3":
            return DownwardApiModel3(**self._attrs)

        def default_mode(self, value: Optional[int], /) -> Self:
            """
            Optional: mode bits to use on created files by default. Must be a
            Optional: mode bits used to set permissions on created files by default.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            Defaults to 0644.
            Directories within the path are not affected by this setting.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("default_mode", value)

        @overload
        def items(self, value_or_callback: List[ItemModel8], /) -> "DownwardApiModel3.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel8, ItemModel8.Builder]],
                GenericListBuilder[ItemModel8, ItemModel8.Builder] | List[ItemModel8],
            ],
            /,
        ) -> "DownwardApiModel3.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel8.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            Items is a list of downward API volume file
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel8.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel8.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

    class BuilderContext(BuilderContextBase["DownwardApiModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DownwardApiModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DownwardApiModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DownwardApiModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DownwardApiModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_mode: Annotated[Optional[int], Field(alias="defaultMode")] = None
    """
    Optional: mode bits to use on created files by default. Must be a
    Optional: mode bits used to set permissions on created files by default.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    Defaults to 0644.
    Directories within the path are not affected by this setting.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    items: Optional[List[ItemModel8]] = None
    """
    Items is a list of downward API volume file
    """


class SizeLimitModel9(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def build(self) -> "SizeLimitModel9":
            value = cast(int, self._value)
            return SizeLimitModel9(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    sizeLimit is the total amount of local storage required for this EmptyDir volume.
    The size limit is also applicable for memory medium.
    The maximum usage on memory medium EmptyDir would be the minimum value between
    the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    The default is nil which means that the limit is undefined.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    """

    class BuilderContext(BuilderContextBase["SizeLimitModel9.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SizeLimitModel9.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SizeLimitModel9."""
        return cls.BuilderContext()


class SizeLimitModel10(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            sizeLimit is the total amount of local storage required for this EmptyDir volume.
            The size limit is also applicable for memory medium.
            The maximum usage on memory medium EmptyDir would be the minimum value between
            the SizeLimit specified here and the sum of memory limits of all containers in a pod.
            The default is nil which means that the limit is undefined.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
            """
            self._value = value
            return self

        def build(self) -> "SizeLimitModel10":
            value = cast(str, self._value)
            return SizeLimitModel10(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    sizeLimit is the total amount of local storage required for this EmptyDir volume.
    The size limit is also applicable for memory medium.
    The maximum usage on memory medium EmptyDir would be the minimum value between
    the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    The default is nil which means that the limit is undefined.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    """

    class BuilderContext(BuilderContextBase["SizeLimitModel10.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SizeLimitModel10.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SizeLimitModel10."""
        return cls.BuilderContext()


class LimitsModel35(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel35":
            value = cast(int, self._value)
            return LimitsModel35(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel35.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel35.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel35."""
        return cls.BuilderContext()


class LimitsModel36(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel36":
            value = cast(str, self._value)
            return LimitsModel36(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel36.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel36.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel36."""
        return cls.BuilderContext()


class RequestsModel35(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel35":
            value = cast(int, self._value)
            return RequestsModel35(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel35.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel35.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel35."""
        return cls.BuilderContext()


class RequestsModel36(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel36":
            value = cast(str, self._value)
            return RequestsModel36(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel36.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel36.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel36."""
        return cls.BuilderContext()


class VolumeClaimTemplateModel5(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VolumeClaimTemplateModel5"]:
            return VolumeClaimTemplateModel5

        def build(self) -> "VolumeClaimTemplateModel5":
            return VolumeClaimTemplateModel5(**self._attrs)

        def metadata(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            May contain labels and annotations that will be copied into the PVC
            when creating it. No other fields are allowed and will be rejected during
            validation.
            """
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Spec, /) -> "VolumeClaimTemplateModel5.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Callable[[Spec.Builder], Spec.Builder | Spec], /
        ) -> "VolumeClaimTemplateModel5.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "Spec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            """
            The specification for the PersistentVolumeClaim. The entire content is
            copied unchanged into the PVC that gets created from this
            template. The same fields as in a PersistentVolumeClaim
            are also valid here.
            """
            if self._in_context and value_or_callback is None:
                context = Spec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Spec.builder())
                if isinstance(output, Spec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["VolumeClaimTemplateModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VolumeClaimTemplateModel5.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VolumeClaimTemplateModel5."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VolumeClaimTemplateModel5", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VolumeClaimTemplateModel5.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    metadata: Optional[Dict[str, Any]] = None
    """
    May contain labels and annotations that will be copied into the PVC
    when creating it. No other fields are allowed and will be rejected during
    validation.
    """
    spec: Spec
    """
    The specification for the PersistentVolumeClaim. The entire content is
    copied unchanged into the PVC that gets created from this
    template. The same fields as in a PersistentVolumeClaim
    are also valid here.
    """


class ItemModel9(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ItemModel9"]:
            return ItemModel9

        def build(self) -> "ItemModel9":
            return ItemModel9(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key is the key to project.
            """
            return self._set("key", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            mode is Optional: mode bits used to set permissions on this file.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            path is the relative path of the file to map the key to.
            May not be an absolute path.
            May not contain the path element '..'.
            May not start with the string '..'.
            """
            return self._set("path", value)

    class BuilderContext(BuilderContextBase["ItemModel9.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ItemModel9.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ItemModel9."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ItemModel9", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ItemModel9.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key is the key to project.
    """
    mode: Optional[int] = None
    """
    mode is Optional: mode bits used to set permissions on this file.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    path is the relative path of the file to map the key to.
    May not be an absolute path.
    May not contain the path element '..'.
    May not start with the string '..'.
    """


class ConfigMapModel7(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapModel7"]:
            return ConfigMapModel7

        def build(self) -> "ConfigMapModel7":
            return ConfigMapModel7(**self._attrs)

        @overload
        def items(self, value_or_callback: List[ItemModel9], /) -> "ConfigMapModel7.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel9, ItemModel9.Builder]],
                GenericListBuilder[ItemModel9, ItemModel9.Builder] | List[ItemModel9],
            ],
            /,
        ) -> "ConfigMapModel7.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel9.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items if unspecified, each key-value pair in the Data field of the referenced
            ConfigMap will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the ConfigMap,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel9.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel9.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional specify whether the ConfigMap or its keys must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapModel7.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapModel7.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapModel7."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapModel7", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapModel7.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    items: Optional[List[ItemModel9]] = None
    """
    items if unspecified, each key-value pair in the Data field of the referenced
    ConfigMap will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the ConfigMap,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    optional specify whether the ConfigMap or its keys must be defined
    """


class DivisorModel21(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel21":
            value = cast(int, self._value)
            return DivisorModel21(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel21.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel21.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel21."""
        return cls.BuilderContext()


class DivisorModel22(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel22":
            value = cast(str, self._value)
            return DivisorModel22(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel22.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel22.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel22."""
        return cls.BuilderContext()


class ItemModel10(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ItemModel10"]:
            return ItemModel10

        def build(self) -> "ItemModel10":
            return ItemModel10(**self._attrs)

        @overload
        def field_ref(self, value_or_callback: Optional[FieldRef], /) -> "ItemModel10.Builder": ...

        @overload
        def field_ref(
            self,
            value_or_callback: Callable[[FieldRef.Builder], FieldRef.Builder | FieldRef],
            /,
        ) -> "ItemModel10.Builder": ...

        @overload
        def field_ref(self, value_or_callback: Never = ...) -> "FieldRef.BuilderContext": ...

        def field_ref(self, value_or_callback=None, /):
            """
            Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
            """
            if self._in_context and value_or_callback is None:
                context = FieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FieldRef.builder())
                if isinstance(output, FieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("field_ref", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            Optional: mode bits used to set permissions on this file, must be an octal value
            between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
            """
            return self._set("path", value)

        @overload
        def resource_field_ref(
            self, value_or_callback: Optional[ResourceFieldRef], /
        ) -> "ItemModel10.Builder": ...

        @overload
        def resource_field_ref(
            self,
            value_or_callback: Callable[
                [ResourceFieldRef.Builder], ResourceFieldRef.Builder | ResourceFieldRef
            ],
            /,
        ) -> "ItemModel10.Builder": ...

        @overload
        def resource_field_ref(
            self, value_or_callback: Never = ...
        ) -> "ResourceFieldRef.BuilderContext": ...

        def resource_field_ref(self, value_or_callback=None, /):
            """
            Selects a resource of the container: only resources limits and requests
            (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceFieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource_field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceFieldRef.builder())
                if isinstance(output, ResourceFieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_field_ref", value)

    class BuilderContext(BuilderContextBase["ItemModel10.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ItemModel10.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ItemModel10."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ItemModel10", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ItemModel10.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    field_ref: Annotated[Optional[FieldRef], Field(alias="fieldRef")] = None
    """
    Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
    """
    mode: Optional[int] = None
    """
    Optional: mode bits used to set permissions on this file, must be an octal value
    between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    """
    resource_field_ref: Annotated[Optional[ResourceFieldRef], Field(alias="resourceFieldRef")] = (
        None
    )
    """
    Selects a resource of the container: only resources limits and requests
    (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    """


class DownwardApiModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DownwardApiModel4"]:
            return DownwardApiModel4

        def build(self) -> "DownwardApiModel4":
            return DownwardApiModel4(**self._attrs)

        @overload
        def items(self, value_or_callback: List[ItemModel10], /) -> "DownwardApiModel4.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel10, ItemModel10.Builder]],
                GenericListBuilder[ItemModel10, ItemModel10.Builder] | List[ItemModel10],
            ],
            /,
        ) -> "DownwardApiModel4.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel10.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            Items is a list of DownwardAPIVolume file
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel10.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel10.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

    class BuilderContext(BuilderContextBase["DownwardApiModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DownwardApiModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DownwardApiModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DownwardApiModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DownwardApiModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    items: Optional[List[ItemModel10]] = None
    """
    Items is a list of DownwardAPIVolume file
    """


class ItemModel11(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ItemModel11"]:
            return ItemModel11

        def build(self) -> "ItemModel11":
            return ItemModel11(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key is the key to project.
            """
            return self._set("key", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            mode is Optional: mode bits used to set permissions on this file.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            path is the relative path of the file to map the key to.
            May not be an absolute path.
            May not contain the path element '..'.
            May not start with the string '..'.
            """
            return self._set("path", value)

    class BuilderContext(BuilderContextBase["ItemModel11.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ItemModel11.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ItemModel11."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ItemModel11", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ItemModel11.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key is the key to project.
    """
    mode: Optional[int] = None
    """
    mode is Optional: mode bits used to set permissions on this file.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    path is the relative path of the file to map the key to.
    May not be an absolute path.
    May not contain the path element '..'.
    May not start with the string '..'.
    """


class SecretModel6(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretModel6"]:
            return SecretModel6

        def build(self) -> "SecretModel6":
            return SecretModel6(**self._attrs)

        @overload
        def items(self, value_or_callback: List[ItemModel11], /) -> "SecretModel6.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel11, ItemModel11.Builder]],
                GenericListBuilder[ItemModel11, ItemModel11.Builder] | List[ItemModel11],
            ],
            /,
        ) -> "SecretModel6.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel11.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items if unspecified, each key-value pair in the Data field of the referenced
            Secret will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the Secret,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel11.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel11.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional field specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["SecretModel6.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretModel6.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretModel6."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretModel6", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretModel6.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    items: Optional[List[ItemModel11]] = None
    """
    items if unspecified, each key-value pair in the Data field of the referenced
    Secret will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the Secret,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    optional field specify whether the Secret or its key must be defined
    """


class SecretModel7(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretModel7"]:
            return SecretModel7

        def build(self) -> "SecretModel7":
            return SecretModel7(**self._attrs)

        def default_mode(self, value: Optional[int], /) -> Self:
            """
            defaultMode is Optional: mode bits used to set permissions on created files by default.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values
            for mode bits. Defaults to 0644.
            Directories within the path are not affected by this setting.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("default_mode", value)

        @overload
        def items(self, value_or_callback: List[ItemModel11], /) -> "SecretModel7.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel11, ItemModel11.Builder]],
                GenericListBuilder[ItemModel11, ItemModel11.Builder] | List[ItemModel11],
            ],
            /,
        ) -> "SecretModel7.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel11.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items If unspecified, each key-value pair in the Data field of the referenced
            Secret will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the Secret,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel11.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel11.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional field specify whether the Secret or its keys must be defined
            """
            return self._set("optional", value)

        def secret_name(self, value: Optional[str], /) -> Self:
            """
            secretName is the name of the secret in the pod's namespace to use.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
            """
            return self._set("secret_name", value)

    class BuilderContext(BuilderContextBase["SecretModel7.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretModel7.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretModel7."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretModel7", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretModel7.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_mode: Annotated[Optional[int], Field(alias="defaultMode")] = None
    """
    defaultMode is Optional: mode bits used to set permissions on created files by default.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values
    for mode bits. Defaults to 0644.
    Directories within the path are not affected by this setting.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    items: Optional[List[ItemModel11]] = None
    """
    items If unspecified, each key-value pair in the Data field of the referenced
    Secret will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the Secret,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    optional: Optional[bool] = None
    """
    optional field specify whether the Secret or its keys must be defined
    """
    secret_name: Annotated[Optional[str], Field(alias="secretName")] = None
    """
    secretName is the name of the secret in the pod's namespace to use.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
    """


class ConfigMapModel8(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapModel8"]:
            return ConfigMapModel8

        def build(self) -> "ConfigMapModel8":
            return ConfigMapModel8(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key to select.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the ConfigMap or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapModel8.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapModel8.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapModel8."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapModel8", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapModel8.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key to select.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the ConfigMap or its key must be defined
    """


class SecretModel8(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretModel8"]:
            return SecretModel8

        def build(self) -> "SecretModel8":
            return SecretModel8(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["SecretModel8.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretModel8.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretModel8."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretModel8", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretModel8.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class TlsConfigModel10(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsConfigModel10"]:
            return TlsConfigModel10

        def build(self) -> "TlsConfigModel10":
            return TlsConfigModel10(**self._attrs)

        @overload
        def cert(self, value_or_callback: Optional[Cert], /) -> "TlsConfigModel10.Builder": ...

        @overload
        def cert(
            self, value_or_callback: Callable[[Cert.Builder], Cert.Builder | Cert], /
        ) -> "TlsConfigModel10.Builder": ...

        @overload
        def cert(self, value_or_callback: Never = ...) -> "Cert.BuilderContext": ...

        def cert(self, value_or_callback=None, /):
            """
            Secret or ConfigMap containing the TLS certificate for the web server.

            Either `keySecret` or `keyFile` must be defined.

            It is mutually exclusive with `certFile`.
            """
            if self._in_context and value_or_callback is None:
                context = Cert.BuilderContext()
                context._parent_builder = self
                context._field_name = "cert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cert.builder())
                if isinstance(output, Cert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cert", value)

        def cert_file(self, value: Optional[str], /) -> Self:
            """
            Path to the TLS certificate file in the container for the web server.

            Either `keySecret` or `keyFile` must be defined.

            It is mutually exclusive with `cert`.
            """
            return self._set("cert_file", value)

        def cipher_suites(self, value: Optional[List[str]], /) -> Self:
            """
            List of supported cipher suites for TLS versions up to TLS 1.2.

            If not defined, the Go default cipher suites are used.
            Available cipher suites are documented in the Go documentation:
            https://golang.org/pkg/crypto/tls/#pkg-constants
            """
            return self._set("cipher_suites", value)

        @overload
        def client_ca(
            self, value_or_callback: Optional[ClientCa], /
        ) -> "TlsConfigModel10.Builder": ...

        @overload
        def client_ca(
            self,
            value_or_callback: Callable[[ClientCa.Builder], ClientCa.Builder | ClientCa],
            /,
        ) -> "TlsConfigModel10.Builder": ...

        @overload
        def client_ca(self, value_or_callback: Never = ...) -> "ClientCa.BuilderContext": ...

        def client_ca(self, value_or_callback=None, /):
            """
            Secret or ConfigMap containing the CA certificate for client certificate
            authentication to the server.

            It is mutually exclusive with `clientCAFile`.
            """
            if self._in_context and value_or_callback is None:
                context = ClientCa.BuilderContext()
                context._parent_builder = self
                context._field_name = "client_ca"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClientCa.builder())
                if isinstance(output, ClientCa.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("client_ca", value)

        def client_auth_type(self, value: Optional[str], /) -> Self:
            """
            The server policy for client TLS authentication.

            For more detail on clientAuth options:
            https://golang.org/pkg/crypto/tls/#ClientAuthType
            """
            return self._set("client_auth_type", value)

        def client_ca_file(self, value: Optional[str], /) -> Self:
            """
            Path to the CA certificate file for client certificate authentication to
            the server.

            It is mutually exclusive with `client_ca`.
            """
            return self._set("client_ca_file", value)

        def curve_preferences(self, value: Optional[List[str]], /) -> Self:
            """
            Elliptic curves that will be used in an ECDHE handshake, in preference
            order.

            Available curves are documented in the Go documentation:
            https://golang.org/pkg/crypto/tls/#CurveID
            """
            return self._set("curve_preferences", value)

        def key_file(self, value: Optional[str], /) -> Self:
            """
            Path to the TLS private key file in the container for the web server.

            If defined, either `cert` or `certFile` must be defined.

            It is mutually exclusive with `keySecret`.
            """
            return self._set("key_file", value)

        @overload
        def key_secret(
            self, value_or_callback: Optional[KeySecret], /
        ) -> "TlsConfigModel10.Builder": ...

        @overload
        def key_secret(
            self,
            value_or_callback: Callable[[KeySecret.Builder], KeySecret.Builder | KeySecret],
            /,
        ) -> "TlsConfigModel10.Builder": ...

        @overload
        def key_secret(self, value_or_callback: Never = ...) -> "KeySecret.BuilderContext": ...

        def key_secret(self, value_or_callback=None, /):
            """
            Secret containing the TLS private key for the web server.

            Either `cert` or `certFile` must be defined.

            It is mutually exclusive with `keyFile`.
            """
            if self._in_context and value_or_callback is None:
                context = KeySecret.BuilderContext()
                context._parent_builder = self
                context._field_name = "key_secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KeySecret.builder())
                if isinstance(output, KeySecret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("key_secret", value)

        def max_version(self, value: Optional[str], /) -> Self:
            """
            Maximum TLS version that is acceptable.
            """
            return self._set("max_version", value)

        def min_version(self, value: Optional[str], /) -> Self:
            """
            Minimum TLS version that is acceptable.
            """
            return self._set("min_version", value)

        def prefer_server_cipher_suites(self, value: Optional[bool], /) -> Self:
            """
            Controls whether the server selects the client's most preferred cipher
            suite, or the server's most preferred cipher suite.

            If true then the server's preference, as expressed in
            the order of elements in cipherSuites, is used.
            """
            return self._set("prefer_server_cipher_suites", value)

    class BuilderContext(BuilderContextBase["TlsConfigModel10.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsConfigModel10.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsConfigModel10."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsConfigModel10", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsConfigModel10.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cert: Optional[Cert] = None
    """
    Secret or ConfigMap containing the TLS certificate for the web server.

    Either `keySecret` or `keyFile` must be defined.

    It is mutually exclusive with `certFile`.
    """
    cert_file: Annotated[Optional[str], Field(alias="certFile")] = None
    """
    Path to the TLS certificate file in the container for the web server.

    Either `keySecret` or `keyFile` must be defined.

    It is mutually exclusive with `cert`.
    """
    cipher_suites: Annotated[Optional[List[str]], Field(alias="cipherSuites")] = None
    """
    List of supported cipher suites for TLS versions up to TLS 1.2.

    If not defined, the Go default cipher suites are used.
    Available cipher suites are documented in the Go documentation:
    https://golang.org/pkg/crypto/tls/#pkg-constants
    """
    client_ca: Optional[ClientCa] = None
    """
    Secret or ConfigMap containing the CA certificate for client certificate
    authentication to the server.

    It is mutually exclusive with `clientCAFile`.
    """
    client_auth_type: Annotated[Optional[str], Field(alias="clientAuthType")] = None
    """
    The server policy for client TLS authentication.

    For more detail on clientAuth options:
    https://golang.org/pkg/crypto/tls/#ClientAuthType
    """
    client_ca_file: Annotated[Optional[str], Field(alias="clientCAFile")] = None
    """
    Path to the CA certificate file for client certificate authentication to
    the server.

    It is mutually exclusive with `client_ca`.
    """
    curve_preferences: Annotated[Optional[List[str]], Field(alias="curvePreferences")] = None
    """
    Elliptic curves that will be used in an ECDHE handshake, in preference
    order.

    Available curves are documented in the Go documentation:
    https://golang.org/pkg/crypto/tls/#CurveID
    """
    key_file: Annotated[Optional[str], Field(alias="keyFile")] = None
    """
    Path to the TLS private key file in the container for the web server.

    If defined, either `cert` or `certFile` must be defined.

    It is mutually exclusive with `keySecret`.
    """
    key_secret: Annotated[Optional[KeySecret], Field(alias="keySecret")] = None
    """
    Secret containing the TLS private key for the web server.

    Either `cert` or `certFile` must be defined.

    It is mutually exclusive with `keyFile`.
    """
    max_version: Annotated[Optional[str], Field(alias="maxVersion")] = None
    """
    Maximum TLS version that is acceptable.
    """
    min_version: Annotated[Optional[str], Field(alias="minVersion")] = None
    """
    Minimum TLS version that is acceptable.
    """
    prefer_server_cipher_suites: Annotated[
        Optional[bool], Field(alias="preferServerCipherSuites")
    ] = None
    """
    Controls whether the server selects the client's most preferred cipher
    suite, or the server's most preferred cipher suite.

    If true then the server's preference, as expressed in
    the order of elements in cipherSuites, is used.
    """


class WebModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WebModel1"]:
            return WebModel1

        def build(self) -> "WebModel1":
            return WebModel1(**self._attrs)

        @overload
        def http_config(
            self, value_or_callback: Optional[HttpConfigModel], /
        ) -> "WebModel1.Builder": ...

        @overload
        def http_config(
            self,
            value_or_callback: Callable[
                [HttpConfigModel.Builder], HttpConfigModel.Builder | HttpConfigModel
            ],
            /,
        ) -> "WebModel1.Builder": ...

        @overload
        def http_config(
            self, value_or_callback: Never = ...
        ) -> "HttpConfigModel.BuilderContext": ...

        def http_config(self, value_or_callback=None, /):
            """
            Defines HTTP parameters for web server.
            """
            if self._in_context and value_or_callback is None:
                context = HttpConfigModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpConfigModel.builder())
                if isinstance(output, HttpConfigModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_config", value)

        @overload
        def tls_config(
            self, value_or_callback: Optional[TlsConfigModel10], /
        ) -> "WebModel1.Builder": ...

        @overload
        def tls_config(
            self,
            value_or_callback: Callable[
                [TlsConfigModel10.Builder], TlsConfigModel10.Builder | TlsConfigModel10
            ],
            /,
        ) -> "WebModel1.Builder": ...

        @overload
        def tls_config(
            self, value_or_callback: Never = ...
        ) -> "TlsConfigModel10.BuilderContext": ...

        def tls_config(self, value_or_callback=None, /):
            """
            Defines the TLS parameters for HTTPS.
            """
            if self._in_context and value_or_callback is None:
                context = TlsConfigModel10.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsConfigModel10.builder())
                if isinstance(output, TlsConfigModel10.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls_config", value)

    class BuilderContext(BuilderContextBase["WebModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WebModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WebModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WebModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WebModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    http_config: Annotated[Optional[HttpConfigModel], Field(alias="httpConfig")] = None
    """
    Defines HTTP parameters for web server.
    """
    tls_config: Annotated[Optional[TlsConfigModel10], Field(alias="tlsConfig")] = None
    """
    Defines the TLS parameters for HTTPS.
    """


class ThanosRulerSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ThanosRulerSpec"]:
            return ThanosRulerSpec

        def build(self) -> "ThanosRulerSpec":
            return ThanosRulerSpec(**self._attrs)

        @overload
        def additional_args(
            self, value_or_callback: List[AdditionalArg], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def additional_args(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AdditionalArg, AdditionalArg.Builder]],
                GenericListBuilder[AdditionalArg, AdditionalArg.Builder] | List[AdditionalArg],
            ],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def additional_args(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[AdditionalArg.Builder]: ...

        def additional_args(self, value_or_callback=None, /):
            """
            AdditionalArgs allows setting additional arguments for the ThanosRuler container.
            It is intended for e.g. activating hidden flags which are not supported by
            the dedicated configuration options yet. The arguments are passed as-is to the
            ThanosRuler container which may cause issues if they are invalid or not supported
            by the given ThanosRuler version.
            In case of an argument conflict (e.g. an argument which is already set by the
            operator itself) or when providing an invalid argument the reconciliation will
            fail and an error will be logged.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AdditionalArg.Builder]()
                context._parent_builder = self
                context._field_name = "additional_args"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AdditionalArg.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("additional_args", value)

        @overload
        def affinity(
            self, value_or_callback: Optional[Affinity], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def affinity(
            self,
            value_or_callback: Callable[[Affinity.Builder], Affinity.Builder | Affinity],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def affinity(self, value_or_callback: Never = ...) -> "Affinity.BuilderContext": ...

        def affinity(self, value_or_callback=None, /):
            """
            If specified, the pod's scheduling constraints.
            """
            if self._in_context and value_or_callback is None:
                context = Affinity.BuilderContext()
                context._parent_builder = self
                context._field_name = "affinity"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Affinity.builder())
                if isinstance(output, Affinity.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("affinity", value)

        def alert_drop_labels(self, value: Optional[List[str]], /) -> Self:
            """
            Configures the label names which should be dropped in Thanos Ruler
            alerts.

            The replica label `thanos_ruler_replica` will always be dropped from the alerts.
            """
            return self._set("alert_drop_labels", value)

        def alert_query_url(self, value: Optional[str], /) -> Self:
            """
            The external Query URL the Thanos Ruler will set in the 'Source' field
            of all alerts.
            Maps to the '--alert.query-url' CLI arg.
            """
            return self._set("alert_query_url", value)

        def alert_relabel_config_file(self, value: Optional[str], /) -> Self:
            """
            Configures the path to the alert relabeling configuration file.

            Alert relabel configuration must have the form as specified in the
            official Prometheus documentation:
            https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs

            The operator performs no validation of the configuration file.

            This field takes precedence over `alertRelabelConfig`.
            """
            return self._set("alert_relabel_config_file", value)

        @overload
        def alert_relabel_configs(
            self, value_or_callback: Optional[AlertRelabelConfigs], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def alert_relabel_configs(
            self,
            value_or_callback: Callable[
                [AlertRelabelConfigs.Builder],
                AlertRelabelConfigs.Builder | AlertRelabelConfigs,
            ],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def alert_relabel_configs(
            self, value_or_callback: Never = ...
        ) -> "AlertRelabelConfigs.BuilderContext": ...

        def alert_relabel_configs(self, value_or_callback=None, /):
            """
            Configures alert relabeling in Thanos Ruler.

            Alert relabel configuration must have the form as specified in the
            official Prometheus documentation:
            https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs

            The operator performs no validation of the configuration.

            `alertRelabelConfigFile` takes precedence over this field.
            """
            if self._in_context and value_or_callback is None:
                context = AlertRelabelConfigs.BuilderContext()
                context._parent_builder = self
                context._field_name = "alert_relabel_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AlertRelabelConfigs.builder())
                if isinstance(output, AlertRelabelConfigs.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("alert_relabel_configs", value)

        @overload
        def alertmanagers_config(
            self, value_or_callback: Optional[AlertmanagersConfig], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def alertmanagers_config(
            self,
            value_or_callback: Callable[
                [AlertmanagersConfig.Builder],
                AlertmanagersConfig.Builder | AlertmanagersConfig,
            ],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def alertmanagers_config(
            self, value_or_callback: Never = ...
        ) -> "AlertmanagersConfig.BuilderContext": ...

        def alertmanagers_config(self, value_or_callback=None, /):
            """
            Configures the list of Alertmanager endpoints to send alerts to.

            The configuration format is defined at https://thanos.io/tip/components/rule.md/#alertmanager.

            It requires Thanos >= v0.10.0.

            The operator performs no validation of the configuration.

            This field takes precedence over `alertmanagersUrl`.
            """
            if self._in_context and value_or_callback is None:
                context = AlertmanagersConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "alertmanagers_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AlertmanagersConfig.builder())
                if isinstance(output, AlertmanagersConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("alertmanagers_config", value)

        def alertmanagers_url(self, value: Optional[List[str]], /) -> Self:
            """
            Configures the list of Alertmanager endpoints to send alerts to.

            For Thanos >= v0.10.0, it is recommended to use `alertmanagersConfig` instead.

            `alertmanagersConfig` takes precedence over this field.
            """
            return self._set("alertmanagers_url", value)

        @overload
        def containers(
            self, value_or_callback: List[Container], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def containers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Container, Container.Builder]],
                GenericListBuilder[Container, Container.Builder] | List[Container],
            ],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def containers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Container.Builder]: ...

        def containers(self, value_or_callback=None, /):
            """
            Containers allows injecting additional containers or modifying operator generated
            containers. This can be used to allow adding an authentication proxy to a ThanosRuler pod or
            to change the behavior of an operator generated container. Containers described here modify
            an operator generated container if they share the same name and modifications are done via a
            strategic merge patch. The current container names are: `thanos-ruler` and `config-reloader`.
            Overriding containers is entirely outside the scope of what the maintainers will support and by doing
            so, you accept that this behaviour may break at any time without notice.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Container.Builder]()
                context._parent_builder = self
                context._field_name = "containers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Container.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("containers", value)

        @overload
        def dns_config(
            self, value_or_callback: Optional[DnsConfig], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def dns_config(
            self,
            value_or_callback: Callable[[DnsConfig.Builder], DnsConfig.Builder | DnsConfig],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def dns_config(self, value_or_callback: Never = ...) -> "DnsConfig.BuilderContext": ...

        def dns_config(self, value_or_callback=None, /):
            """
            Defines the DNS configuration for the pods.
            """
            if self._in_context and value_or_callback is None:
                context = DnsConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "dns_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DnsConfig.builder())
                if isinstance(output, DnsConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("dns_config", value)

        def dns_policy(
            self,
            value: Optional[Literal["ClusterFirstWithHostNet", "ClusterFirst", "Default", "None"]],
            /,
        ) -> Self:
            """
            Defines the DNS policy for the pods.
            """
            return self._set("dns_policy", value)

        def enforced_namespace_label(self, value: Optional[str], /) -> Self:
            """
            EnforcedNamespaceLabel enforces adding a namespace label of origin for each alert
            and metric that is user created. The label value will always be the namespace of the object that is
            being created.
            """
            return self._set("enforced_namespace_label", value)

        def evaluation_interval(self, value: Optional[str], /) -> Self:
            """
            Interval between consecutive evaluations.
            """
            return self._set("evaluation_interval", value)

        @overload
        def excluded_from_enforcement(
            self, value_or_callback: List[ExcludedFromEnforcement], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def excluded_from_enforcement(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ExcludedFromEnforcement, ExcludedFromEnforcement.Builder]],
                GenericListBuilder[ExcludedFromEnforcement, ExcludedFromEnforcement.Builder]
                | List[ExcludedFromEnforcement],
            ],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def excluded_from_enforcement(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ExcludedFromEnforcement.Builder]: ...

        def excluded_from_enforcement(self, value_or_callback=None, /):
            """
            List of references to PrometheusRule objects
            to be excluded from enforcing a namespace label of origin.
            Applies only if enforcedNamespaceLabel set to true.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ExcludedFromEnforcement.Builder]()
                context._parent_builder = self
                context._field_name = "excluded_from_enforcement"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ExcludedFromEnforcement.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("excluded_from_enforcement", value)

        def external_prefix(self, value: Optional[str], /) -> Self:
            """
            The external URL the Thanos Ruler instances will be available under. This is
            necessary to generate correct URLs. This is necessary if Thanos Ruler is not
            served from root of a DNS name.
            """
            return self._set("external_prefix", value)

        @overload
        def grpc_server_tls_config(
            self, value_or_callback: Optional[GrpcServerTlsConfig], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def grpc_server_tls_config(
            self,
            value_or_callback: Callable[
                [GrpcServerTlsConfig.Builder],
                GrpcServerTlsConfig.Builder | GrpcServerTlsConfig,
            ],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def grpc_server_tls_config(
            self, value_or_callback: Never = ...
        ) -> "GrpcServerTlsConfig.BuilderContext": ...

        def grpc_server_tls_config(self, value_or_callback=None, /):
            """
            GRPCServerTLSConfig configures the gRPC server from which Thanos Querier reads
            recorded rule data.
            Note: Currently only the CAFile, CertFile, and KeyFile fields are supported.
            Maps to the '--grpc-server-tls-*' CLI args.
            """
            if self._in_context and value_or_callback is None:
                context = GrpcServerTlsConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "grpc_server_tls_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GrpcServerTlsConfig.builder())
                if isinstance(output, GrpcServerTlsConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("grpc_server_tls_config", value)

        @overload
        def host_aliases(
            self, value_or_callback: List[HostAliase], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def host_aliases(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[HostAliase, HostAliase.Builder]],
                GenericListBuilder[HostAliase, HostAliase.Builder] | List[HostAliase],
            ],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def host_aliases(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[HostAliase.Builder]: ...

        def host_aliases(self, value_or_callback=None, /):
            """
            Pods' hostAliases configuration
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[HostAliase.Builder]()
                context._parent_builder = self
                context._field_name = "host_aliases"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HostAliase.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("host_aliases", value)

        def image(self, value: Optional[str], /) -> Self:
            """
            Thanos container image URL.
            """
            return self._set("image", value)

        def image_pull_policy(
            self, value: Optional[Literal["", "Always", "Never", "IfNotPresent"]], /
        ) -> Self:
            """
            Image pull policy for the 'thanos', 'init-config-reloader' and 'config-reloader' containers.
            See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
            """
            return self._set("image_pull_policy", value)

        @overload
        def image_pull_secrets(
            self, value_or_callback: List[ImagePullSecret], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def image_pull_secrets(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ImagePullSecret, ImagePullSecret.Builder]],
                GenericListBuilder[ImagePullSecret, ImagePullSecret.Builder]
                | List[ImagePullSecret],
            ],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def image_pull_secrets(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ImagePullSecret.Builder]: ...

        def image_pull_secrets(self, value_or_callback=None, /):
            """
            An optional list of references to secrets in the same namespace
            to use for pulling thanos images from registries
            see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ImagePullSecret.Builder]()
                context._parent_builder = self
                context._field_name = "image_pull_secrets"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImagePullSecret.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("image_pull_secrets", value)

        @overload
        def init_containers(
            self, value_or_callback: List[InitContainer], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def init_containers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[InitContainer, InitContainer.Builder]],
                GenericListBuilder[InitContainer, InitContainer.Builder] | List[InitContainer],
            ],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def init_containers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[InitContainer.Builder]: ...

        def init_containers(self, value_or_callback=None, /):
            """
            InitContainers allows adding initContainers to the pod definition. Those can be used to e.g.
            fetch secrets for injection into the ThanosRuler configuration from external sources. Any
            errors during the execution of an initContainer will lead to a restart of the Pod.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
            Using initContainers for any use case other then secret fetching is entirely outside the scope
            of what the maintainers will support and by doing so, you accept that this behaviour may break
            at any time without notice.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[InitContainer.Builder]()
                context._parent_builder = self
                context._field_name = "init_containers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitContainer.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_containers", value)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Configures the external label pairs of the ThanosRuler resource.

            A default replica label `thanos_ruler_replica` will be always added as a
            label with the value of the pod's name.
            """
            return self._set("labels", value)

        def listen_local(self, value: Optional[bool], /) -> Self:
            """
            ListenLocal makes the Thanos ruler listen on loopback, so that it
            does not bind against the Pod IP.
            """
            return self._set("listen_local", value)

        def log_format(self, value: Optional[Literal["", "logfmt", "json"]], /) -> Self:
            """
            Log format for ThanosRuler to be configured with.
            """
            return self._set("log_format", value)

        def log_level(
            self, value: Optional[Literal["", "debug", "info", "warn", "error"]], /
        ) -> Self:
            """
            Log level for ThanosRuler to be configured with.
            """
            return self._set("log_level", value)

        def min_ready_seconds(self, value: Optional[int], /) -> Self:
            """
            Minimum number of seconds for which a newly created pod should be ready
            without any of its container crashing for it to be considered available.
            Defaults to 0 (pod will be considered available as soon as it is ready)
            This is an alpha field from kubernetes 1.22 until 1.24 which requires enabling the StatefulSetMinReadySeconds feature gate.
            """
            return self._set("min_ready_seconds", value)

        def node_selector(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Define which Nodes the Pods are scheduled on.
            """
            return self._set("node_selector", value)

        @overload
        def object_storage_config(
            self, value_or_callback: Optional[ObjectStorageConfig], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def object_storage_config(
            self,
            value_or_callback: Callable[
                [ObjectStorageConfig.Builder],
                ObjectStorageConfig.Builder | ObjectStorageConfig,
            ],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def object_storage_config(
            self, value_or_callback: Never = ...
        ) -> "ObjectStorageConfig.BuilderContext": ...

        def object_storage_config(self, value_or_callback=None, /):
            """
            Configures object storage.

            The configuration format is defined at https://thanos.io/tip/thanos/storage.md/#configuring-access-to-object-storage

            The operator performs no validation of the configuration.

            `objectStorageConfigFile` takes precedence over this field.
            """
            if self._in_context and value_or_callback is None:
                context = ObjectStorageConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "object_storage_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ObjectStorageConfig.builder())
                if isinstance(output, ObjectStorageConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("object_storage_config", value)

        def object_storage_config_file(self, value: Optional[str], /) -> Self:
            """
            Configures the path of the object storage configuration file.

            The configuration format is defined at https://thanos.io/tip/thanos/storage.md/#configuring-access-to-object-storage

            The operator performs no validation of the configuration file.

            This field takes precedence over `objectStorageConfig`.
            """
            return self._set("object_storage_config_file", value)

        def paused(self, value: Optional[bool], /) -> Self:
            """
            When a ThanosRuler deployment is paused, no actions except for deletion
            will be performed on the underlying objects.
            """
            return self._set("paused", value)

        @overload
        def pod_metadata(
            self, value_or_callback: Optional[PodMetadata], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def pod_metadata(
            self,
            value_or_callback: Callable[[PodMetadata.Builder], PodMetadata.Builder | PodMetadata],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def pod_metadata(self, value_or_callback: Never = ...) -> "PodMetadata.BuilderContext": ...

        def pod_metadata(self, value_or_callback=None, /):
            """
            PodMetadata configures labels and annotations which are propagated to the ThanosRuler pods.

            The following items are reserved and cannot be overridden:
            * "app.kubernetes.io/name" label, set to "thanos-ruler".
            * "app.kubernetes.io/managed-by" label, set to "prometheus-operator".
            * "app.kubernetes.io/instance" label, set to the name of the ThanosRuler instance.
            * "thanos-ruler" label, set to the name of the ThanosRuler instance.
            * "kubectl.kubernetes.io/default-container" annotation, set to "thanos-ruler".
            """
            if self._in_context and value_or_callback is None:
                context = PodMetadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "pod_metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodMetadata.builder())
                if isinstance(output, PodMetadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("pod_metadata", value)

        def port_name(self, value: Optional[str], /) -> Self:
            """
            Port name used for the pods and governing service.
            Defaults to `web`.
            """
            return self._set("port_name", value)

        def priority_class_name(self, value: Optional[str], /) -> Self:
            """
            Priority class assigned to the Pods
            """
            return self._set("priority_class_name", value)

        @overload
        def prometheus_rules_excluded_from_enforce(
            self, value_or_callback: List[PrometheusRulesExcludedFromEnforce], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def prometheus_rules_excluded_from_enforce(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        PrometheusRulesExcludedFromEnforce,
                        PrometheusRulesExcludedFromEnforce.Builder,
                    ]
                ],
                GenericListBuilder[
                    PrometheusRulesExcludedFromEnforce,
                    PrometheusRulesExcludedFromEnforce.Builder,
                ]
                | List[PrometheusRulesExcludedFromEnforce],
            ],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def prometheus_rules_excluded_from_enforce(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PrometheusRulesExcludedFromEnforce.Builder]: ...

        def prometheus_rules_excluded_from_enforce(self, value_or_callback=None, /):
            """
            PrometheusRulesExcludedFromEnforce - list of Prometheus rules to be excluded from enforcing
            of adding namespace labels. Works only if enforcedNamespaceLabel set to true.
            Make sure both ruleNamespace and ruleName are set for each pair
            Deprecated: use excludedFromEnforcement instead.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PrometheusRulesExcludedFromEnforce.Builder]()
                context._parent_builder = self
                context._field_name = "prometheus_rules_excluded_from_enforce"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PrometheusRulesExcludedFromEnforce.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("prometheus_rules_excluded_from_enforce", value)

        @overload
        def query_config(
            self, value_or_callback: Optional[QueryConfig], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def query_config(
            self,
            value_or_callback: Callable[[QueryConfig.Builder], QueryConfig.Builder | QueryConfig],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def query_config(self, value_or_callback: Never = ...) -> "QueryConfig.BuilderContext": ...

        def query_config(self, value_or_callback=None, /):
            """
            Configures the list of Thanos Query endpoints from which to query metrics.

            The configuration format is defined at https://thanos.io/tip/components/rule.md/#query-api

            It requires Thanos >= v0.11.0.

            The operator performs no validation of the configuration.

            This field takes precedence over `queryEndpoints`.
            """
            if self._in_context and value_or_callback is None:
                context = QueryConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "query_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(QueryConfig.builder())
                if isinstance(output, QueryConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("query_config", value)

        def query_endpoints(self, value: Optional[List[str]], /) -> Self:
            """
            Configures the list of Thanos Query endpoints from which to query metrics.

            For Thanos >= v0.11.0, it is recommended to use `queryConfig` instead.

            `queryConfig` takes precedence over this field.
            """
            return self._set("query_endpoints", value)

        def replicas(self, value: Optional[int], /) -> Self:
            """
            Number of thanos ruler instances to deploy.
            """
            return self._set("replicas", value)

        @overload
        def resources(
            self, value_or_callback: Optional[ResourcesModel5], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[
                [ResourcesModel5.Builder], ResourcesModel5.Builder | ResourcesModel5
            ],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "ResourcesModel5.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            Resources defines the resource requirements for single Pods.
            If not provided, no requests/limits will be set
            """
            if self._in_context and value_or_callback is None:
                context = ResourcesModel5.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourcesModel5.builder())
                if isinstance(output, ResourcesModel5.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def retention(self, value: Optional[str], /) -> Self:
            """
            Time duration ThanosRuler shall retain data for. Default is '24h',
            and must match the regular expression `[0-9]+(ms|s|m|h|d|w|y)` (milliseconds seconds minutes hours days weeks years).
            """
            return self._set("retention", value)

        def route_prefix(self, value: Optional[str], /) -> Self:
            """
            The route prefix ThanosRuler registers HTTP handlers for. This allows thanos UI to be served on a sub-path.
            """
            return self._set("route_prefix", value)

        @overload
        def rule_namespace_selector(
            self, value_or_callback: Optional[RuleNamespaceSelector], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def rule_namespace_selector(
            self,
            value_or_callback: Callable[
                [RuleNamespaceSelector.Builder],
                RuleNamespaceSelector.Builder | RuleNamespaceSelector,
            ],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def rule_namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "RuleNamespaceSelector.BuilderContext": ...

        def rule_namespace_selector(self, value_or_callback=None, /):
            """
            Namespaces to be selected for Rules discovery. If unspecified, only
            the same namespace as the ThanosRuler object is in is used.
            """
            if self._in_context and value_or_callback is None:
                context = RuleNamespaceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "rule_namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RuleNamespaceSelector.builder())
                if isinstance(output, RuleNamespaceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("rule_namespace_selector", value)

        @overload
        def rule_selector(
            self, value_or_callback: Optional[RuleSelector], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def rule_selector(
            self,
            value_or_callback: Callable[
                [RuleSelector.Builder], RuleSelector.Builder | RuleSelector
            ],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def rule_selector(
            self, value_or_callback: Never = ...
        ) -> "RuleSelector.BuilderContext": ...

        def rule_selector(self, value_or_callback=None, /):
            """
            PrometheusRule objects to be selected for rule evaluation. An empty
            label selector matches all objects. A null label selector matches no
            objects.
            """
            if self._in_context and value_or_callback is None:
                context = RuleSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "rule_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RuleSelector.builder())
                if isinstance(output, RuleSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("rule_selector", value)

        @overload
        def security_context(
            self, value_or_callback: Optional[SecurityContextModel4], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def security_context(
            self,
            value_or_callback: Callable[
                [SecurityContextModel4.Builder],
                SecurityContextModel4.Builder | SecurityContextModel4,
            ],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def security_context(
            self, value_or_callback: Never = ...
        ) -> "SecurityContextModel4.BuilderContext": ...

        def security_context(self, value_or_callback=None, /):
            """
            SecurityContext holds pod-level security attributes and common container settings.
            This defaults to the default PodSecurityContext.
            """
            if self._in_context and value_or_callback is None:
                context = SecurityContextModel4.BuilderContext()
                context._parent_builder = self
                context._field_name = "security_context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecurityContextModel4.builder())
                if isinstance(output, SecurityContextModel4.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("security_context", value)

        def service_account_name(self, value: Optional[str], /) -> Self:
            """
            ServiceAccountName is the name of the ServiceAccount to use to run the
            Thanos Ruler Pods.
            """
            return self._set("service_account_name", value)

        @overload
        def storage(self, value_or_callback: Optional[Storage], /) -> "ThanosRulerSpec.Builder": ...

        @overload
        def storage(
            self,
            value_or_callback: Callable[[Storage.Builder], Storage.Builder | Storage],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def storage(self, value_or_callback: Never = ...) -> "Storage.BuilderContext": ...

        def storage(self, value_or_callback=None, /):
            """
            Storage spec to specify how storage shall be used.
            """
            if self._in_context and value_or_callback is None:
                context = Storage.BuilderContext()
                context._parent_builder = self
                context._field_name = "storage"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Storage.builder())
                if isinstance(output, Storage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("storage", value)

        @overload
        def tolerations(
            self, value_or_callback: List[Toleration], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def tolerations(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Toleration, Toleration.Builder]],
                GenericListBuilder[Toleration, Toleration.Builder] | List[Toleration],
            ],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def tolerations(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Toleration.Builder]: ...

        def tolerations(self, value_or_callback=None, /):
            """
            If specified, the pod's tolerations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Toleration.Builder]()
                context._parent_builder = self
                context._field_name = "tolerations"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Toleration.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("tolerations", value)

        @overload
        def topology_spread_constraints(
            self, value_or_callback: List[TopologySpreadConstraintModel1], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def topology_spread_constraints(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        TopologySpreadConstraintModel1,
                        TopologySpreadConstraintModel1.Builder,
                    ]
                ],
                GenericListBuilder[
                    TopologySpreadConstraintModel1,
                    TopologySpreadConstraintModel1.Builder,
                ]
                | List[TopologySpreadConstraintModel1],
            ],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def topology_spread_constraints(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[TopologySpreadConstraintModel1.Builder]: ...

        def topology_spread_constraints(self, value_or_callback=None, /):
            """
            If specified, the pod's topology spread constraints.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[TopologySpreadConstraintModel1.Builder]()
                context._parent_builder = self
                context._field_name = "topology_spread_constraints"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TopologySpreadConstraintModel1.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("topology_spread_constraints", value)

        @overload
        def tracing_config(
            self, value_or_callback: Optional[TracingConfigModel1], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def tracing_config(
            self,
            value_or_callback: Callable[
                [TracingConfigModel1.Builder],
                TracingConfigModel1.Builder | TracingConfigModel1,
            ],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def tracing_config(
            self, value_or_callback: Never = ...
        ) -> "TracingConfigModel1.BuilderContext": ...

        def tracing_config(self, value_or_callback=None, /):
            """
            Configures tracing.

            The configuration format is defined at https://thanos.io/tip/thanos/tracing.md/#configuration

            This is an *experimental feature*, it may change in any upcoming release
            in a breaking way.

            The operator performs no validation of the configuration.

            `tracingConfigFile` takes precedence over this field.
            """
            if self._in_context and value_or_callback is None:
                context = TracingConfigModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "tracing_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TracingConfigModel1.builder())
                if isinstance(output, TracingConfigModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tracing_config", value)

        def tracing_config_file(self, value: Optional[str], /) -> Self:
            """
            Configures the path of the tracing configuration file.

            The configuration format is defined at https://thanos.io/tip/thanos/tracing.md/#configuration

            This is an *experimental feature*, it may change in any upcoming release
            in a breaking way.

            The operator performs no validation of the configuration file.

            This field takes precedence over `tracingConfig`.
            """
            return self._set("tracing_config_file", value)

        def version(self, value: Optional[str], /) -> Self:
            """
            Version of Thanos to be deployed.
            """
            return self._set("version", value)

        @overload
        def volume_mounts(
            self, value_or_callback: List[VolumeMount], /
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def volume_mounts(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[VolumeMount, VolumeMount.Builder]],
                GenericListBuilder[VolumeMount, VolumeMount.Builder] | List[VolumeMount],
            ],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def volume_mounts(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[VolumeMount.Builder]: ...

        def volume_mounts(self, value_or_callback=None, /):
            """
            VolumeMounts allows configuration of additional VolumeMounts on the output StatefulSet definition.
            VolumeMounts specified will be appended to other VolumeMounts in the ruler container,
            that are generated as a result of StorageSpec objects.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[VolumeMount.Builder]()
                context._parent_builder = self
                context._field_name = "volume_mounts"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VolumeMount.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("volume_mounts", value)

        @overload
        def volumes(self, value_or_callback: List[Volume], /) -> "ThanosRulerSpec.Builder": ...

        @overload
        def volumes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Volume, Volume.Builder]],
                GenericListBuilder[Volume, Volume.Builder] | List[Volume],
            ],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def volumes(self, value_or_callback: Never = ...) -> ListBuilderContext[Volume.Builder]: ...

        def volumes(self, value_or_callback=None, /):
            """
            Volumes allows configuration of additional volumes on the output StatefulSet definition. Volumes specified will
            be appended to other volumes that are generated as a result of StorageSpec objects.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Volume.Builder]()
                context._parent_builder = self
                context._field_name = "volumes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Volume.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("volumes", value)

        @overload
        def web(self, value_or_callback: Optional[WebModel1], /) -> "ThanosRulerSpec.Builder": ...

        @overload
        def web(
            self,
            value_or_callback: Callable[[WebModel1.Builder], WebModel1.Builder | WebModel1],
            /,
        ) -> "ThanosRulerSpec.Builder": ...

        @overload
        def web(self, value_or_callback: Never = ...) -> "WebModel1.BuilderContext": ...

        def web(self, value_or_callback=None, /):
            """
            Defines the configuration of the ThanosRuler web server.
            """
            if self._in_context and value_or_callback is None:
                context = WebModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "web"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WebModel1.builder())
                if isinstance(output, WebModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("web", value)

    class BuilderContext(BuilderContextBase["ThanosRulerSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ThanosRulerSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ThanosRulerSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ThanosRulerSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ThanosRulerSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    additional_args: Annotated[Optional[List[AdditionalArg]], Field(alias="additionalArgs")] = None
    """
    AdditionalArgs allows setting additional arguments for the ThanosRuler container.
    It is intended for e.g. activating hidden flags which are not supported by
    the dedicated configuration options yet. The arguments are passed as-is to the
    ThanosRuler container which may cause issues if they are invalid or not supported
    by the given ThanosRuler version.
    In case of an argument conflict (e.g. an argument which is already set by the
    operator itself) or when providing an invalid argument the reconciliation will
    fail and an error will be logged.
    """
    affinity: Optional[Affinity] = None
    """
    If specified, the pod's scheduling constraints.
    """
    alert_drop_labels: Annotated[Optional[List[str]], Field(alias="alertDropLabels")] = None
    """
    Configures the label names which should be dropped in Thanos Ruler
    alerts.

    The replica label `thanos_ruler_replica` will always be dropped from the alerts.
    """
    alert_query_url: Annotated[Optional[str], Field(alias="alertQueryUrl")] = None
    """
    The external Query URL the Thanos Ruler will set in the 'Source' field
    of all alerts.
    Maps to the '--alert.query-url' CLI arg.
    """
    alert_relabel_config_file: Annotated[Optional[str], Field(alias="alertRelabelConfigFile")] = (
        None
    )
    """
    Configures the path to the alert relabeling configuration file.

    Alert relabel configuration must have the form as specified in the
    official Prometheus documentation:
    https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs

    The operator performs no validation of the configuration file.

    This field takes precedence over `alertRelabelConfig`.
    """
    alert_relabel_configs: Annotated[
        Optional[AlertRelabelConfigs], Field(alias="alertRelabelConfigs")
    ] = None
    """
    Configures alert relabeling in Thanos Ruler.

    Alert relabel configuration must have the form as specified in the
    official Prometheus documentation:
    https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs

    The operator performs no validation of the configuration.

    `alertRelabelConfigFile` takes precedence over this field.
    """
    alertmanagers_config: Annotated[
        Optional[AlertmanagersConfig], Field(alias="alertmanagersConfig")
    ] = None
    """
    Configures the list of Alertmanager endpoints to send alerts to.

    The configuration format is defined at https://thanos.io/tip/components/rule.md/#alertmanager.

    It requires Thanos >= v0.10.0.

    The operator performs no validation of the configuration.

    This field takes precedence over `alertmanagersUrl`.
    """
    alertmanagers_url: Annotated[Optional[List[str]], Field(alias="alertmanagersUrl")] = None
    """
    Configures the list of Alertmanager endpoints to send alerts to.

    For Thanos >= v0.10.0, it is recommended to use `alertmanagersConfig` instead.

    `alertmanagersConfig` takes precedence over this field.
    """
    containers: Optional[List[Container]] = None
    """
    Containers allows injecting additional containers or modifying operator generated
    containers. This can be used to allow adding an authentication proxy to a ThanosRuler pod or
    to change the behavior of an operator generated container. Containers described here modify
    an operator generated container if they share the same name and modifications are done via a
    strategic merge patch. The current container names are: `thanos-ruler` and `config-reloader`.
    Overriding containers is entirely outside the scope of what the maintainers will support and by doing
    so, you accept that this behaviour may break at any time without notice.
    """
    dns_config: Annotated[Optional[DnsConfig], Field(alias="dnsConfig")] = None
    """
    Defines the DNS configuration for the pods.
    """
    dns_policy: Annotated[
        Optional[Literal["ClusterFirstWithHostNet", "ClusterFirst", "Default", "None"]],
        Field(alias="dnsPolicy"),
    ] = None
    """
    Defines the DNS policy for the pods.
    """
    enforced_namespace_label: Annotated[Optional[str], Field(alias="enforcedNamespaceLabel")] = None
    """
    EnforcedNamespaceLabel enforces adding a namespace label of origin for each alert
    and metric that is user created. The label value will always be the namespace of the object that is
    being created.
    """
    evaluation_interval: Annotated[
        Optional[str],
        Field(
            alias="evaluationInterval",
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$",
        ),
    ] = "15s"
    """
    Interval between consecutive evaluations.
    """
    excluded_from_enforcement: Annotated[
        Optional[List[ExcludedFromEnforcement]], Field(alias="excludedFromEnforcement")
    ] = None
    """
    List of references to PrometheusRule objects
    to be excluded from enforcing a namespace label of origin.
    Applies only if enforcedNamespaceLabel set to true.
    """
    external_prefix: Annotated[Optional[str], Field(alias="externalPrefix")] = None
    """
    The external URL the Thanos Ruler instances will be available under. This is
    necessary to generate correct URLs. This is necessary if Thanos Ruler is not
    served from root of a DNS name.
    """
    grpc_server_tls_config: Annotated[
        Optional[GrpcServerTlsConfig], Field(alias="grpcServerTlsConfig")
    ] = None
    """
    GRPCServerTLSConfig configures the gRPC server from which Thanos Querier reads
    recorded rule data.
    Note: Currently only the CAFile, CertFile, and KeyFile fields are supported.
    Maps to the '--grpc-server-tls-*' CLI args.
    """
    host_aliases: Annotated[Optional[List[HostAliase]], Field(alias="hostAliases")] = None
    """
    Pods' hostAliases configuration
    """
    image: Optional[str] = None
    """
    Thanos container image URL.
    """
    image_pull_policy: Annotated[
        Optional[Literal["", "Always", "Never", "IfNotPresent"]],
        Field(alias="imagePullPolicy"),
    ] = None
    """
    Image pull policy for the 'thanos', 'init-config-reloader' and 'config-reloader' containers.
    See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
    """
    image_pull_secrets: Annotated[
        Optional[List[ImagePullSecret]], Field(alias="imagePullSecrets")
    ] = None
    """
    An optional list of references to secrets in the same namespace
    to use for pulling thanos images from registries
    see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
    """
    init_containers: Annotated[Optional[List[InitContainer]], Field(alias="initContainers")] = None
    """
    InitContainers allows adding initContainers to the pod definition. Those can be used to e.g.
    fetch secrets for injection into the ThanosRuler configuration from external sources. Any
    errors during the execution of an initContainer will lead to a restart of the Pod.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
    Using initContainers for any use case other then secret fetching is entirely outside the scope
    of what the maintainers will support and by doing so, you accept that this behaviour may break
    at any time without notice.
    """
    labels: Optional[Dict[str, str]] = None
    """
    Configures the external label pairs of the ThanosRuler resource.

    A default replica label `thanos_ruler_replica` will be always added as a
    label with the value of the pod's name.
    """
    listen_local: Annotated[Optional[bool], Field(alias="listenLocal")] = None
    """
    ListenLocal makes the Thanos ruler listen on loopback, so that it
    does not bind against the Pod IP.
    """
    log_format: Annotated[Optional[Literal["", "logfmt", "json"]], Field(alias="logFormat")] = None
    """
    Log format for ThanosRuler to be configured with.
    """
    log_level: Annotated[
        Optional[Literal["", "debug", "info", "warn", "error"]], Field(alias="logLevel")
    ] = None
    """
    Log level for ThanosRuler to be configured with.
    """
    min_ready_seconds: Annotated[Optional[int], Field(alias="minReadySeconds")] = None
    """
    Minimum number of seconds for which a newly created pod should be ready
    without any of its container crashing for it to be considered available.
    Defaults to 0 (pod will be considered available as soon as it is ready)
    This is an alpha field from kubernetes 1.22 until 1.24 which requires enabling the StatefulSetMinReadySeconds feature gate.
    """
    node_selector: Annotated[Optional[Dict[str, str]], Field(alias="nodeSelector")] = None
    """
    Define which Nodes the Pods are scheduled on.
    """
    object_storage_config: Annotated[
        Optional[ObjectStorageConfig], Field(alias="objectStorageConfig")
    ] = None
    """
    Configures object storage.

    The configuration format is defined at https://thanos.io/tip/thanos/storage.md/#configuring-access-to-object-storage

    The operator performs no validation of the configuration.

    `objectStorageConfigFile` takes precedence over this field.
    """
    object_storage_config_file: Annotated[Optional[str], Field(alias="objectStorageConfigFile")] = (
        None
    )
    """
    Configures the path of the object storage configuration file.

    The configuration format is defined at https://thanos.io/tip/thanos/storage.md/#configuring-access-to-object-storage

    The operator performs no validation of the configuration file.

    This field takes precedence over `objectStorageConfig`.
    """
    paused: Optional[bool] = None
    """
    When a ThanosRuler deployment is paused, no actions except for deletion
    will be performed on the underlying objects.
    """
    pod_metadata: Annotated[Optional[PodMetadata], Field(alias="podMetadata")] = None
    """
    PodMetadata configures labels and annotations which are propagated to the ThanosRuler pods.

    The following items are reserved and cannot be overridden:
    * "app.kubernetes.io/name" label, set to "thanos-ruler".
    * "app.kubernetes.io/managed-by" label, set to "prometheus-operator".
    * "app.kubernetes.io/instance" label, set to the name of the ThanosRuler instance.
    * "thanos-ruler" label, set to the name of the ThanosRuler instance.
    * "kubectl.kubernetes.io/default-container" annotation, set to "thanos-ruler".
    """
    port_name: Annotated[Optional[str], Field(alias="portName")] = "web"
    """
    Port name used for the pods and governing service.
    Defaults to `web`.
    """
    priority_class_name: Annotated[Optional[str], Field(alias="priorityClassName")] = None
    """
    Priority class assigned to the Pods
    """
    prometheus_rules_excluded_from_enforce: Annotated[
        Optional[List[PrometheusRulesExcludedFromEnforce]],
        Field(alias="prometheusRulesExcludedFromEnforce"),
    ] = None
    """
    PrometheusRulesExcludedFromEnforce - list of Prometheus rules to be excluded from enforcing
    of adding namespace labels. Works only if enforcedNamespaceLabel set to true.
    Make sure both ruleNamespace and ruleName are set for each pair
    Deprecated: use excludedFromEnforcement instead.
    """
    query_config: Annotated[Optional[QueryConfig], Field(alias="queryConfig")] = None
    """
    Configures the list of Thanos Query endpoints from which to query metrics.

    The configuration format is defined at https://thanos.io/tip/components/rule.md/#query-api

    It requires Thanos >= v0.11.0.

    The operator performs no validation of the configuration.

    This field takes precedence over `queryEndpoints`.
    """
    query_endpoints: Annotated[Optional[List[str]], Field(alias="queryEndpoints")] = None
    """
    Configures the list of Thanos Query endpoints from which to query metrics.

    For Thanos >= v0.11.0, it is recommended to use `queryConfig` instead.

    `queryConfig` takes precedence over this field.
    """
    replicas: Optional[int] = None
    """
    Number of thanos ruler instances to deploy.
    """
    resources: Optional[ResourcesModel5] = None
    """
    Resources defines the resource requirements for single Pods.
    If not provided, no requests/limits will be set
    """
    retention: Annotated[
        Optional[str],
        Field(
            pattern="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"
        ),
    ] = "24h"
    """
    Time duration ThanosRuler shall retain data for. Default is '24h',
    and must match the regular expression `[0-9]+(ms|s|m|h|d|w|y)` (milliseconds seconds minutes hours days weeks years).
    """
    route_prefix: Annotated[Optional[str], Field(alias="routePrefix")] = None
    """
    The route prefix ThanosRuler registers HTTP handlers for. This allows thanos UI to be served on a sub-path.
    """
    rule_namespace_selector: Annotated[
        Optional[RuleNamespaceSelector], Field(alias="ruleNamespaceSelector")
    ] = None
    """
    Namespaces to be selected for Rules discovery. If unspecified, only
    the same namespace as the ThanosRuler object is in is used.
    """
    rule_selector: Annotated[Optional[RuleSelector], Field(alias="ruleSelector")] = None
    """
    PrometheusRule objects to be selected for rule evaluation. An empty
    label selector matches all objects. A null label selector matches no
    objects.
    """
    security_context: Annotated[Optional[SecurityContextModel4], Field(alias="securityContext")] = (
        None
    )
    """
    SecurityContext holds pod-level security attributes and common container settings.
    This defaults to the default PodSecurityContext.
    """
    service_account_name: Annotated[Optional[str], Field(alias="serviceAccountName")] = None
    """
    ServiceAccountName is the name of the ServiceAccount to use to run the
    Thanos Ruler Pods.
    """
    storage: Optional[Storage] = None
    """
    Storage spec to specify how storage shall be used.
    """
    tolerations: Optional[List[Toleration]] = None
    """
    If specified, the pod's tolerations.
    """
    topology_spread_constraints: Annotated[
        Optional[List[TopologySpreadConstraintModel1]],
        Field(alias="topologySpreadConstraints"),
    ] = None
    """
    If specified, the pod's topology spread constraints.
    """
    tracing_config: Annotated[Optional[TracingConfigModel1], Field(alias="tracingConfig")] = None
    """
    Configures tracing.

    The configuration format is defined at https://thanos.io/tip/thanos/tracing.md/#configuration

    This is an *experimental feature*, it may change in any upcoming release
    in a breaking way.

    The operator performs no validation of the configuration.

    `tracingConfigFile` takes precedence over this field.
    """
    tracing_config_file: Annotated[Optional[str], Field(alias="tracingConfigFile")] = None
    """
    Configures the path of the tracing configuration file.

    The configuration format is defined at https://thanos.io/tip/thanos/tracing.md/#configuration

    This is an *experimental feature*, it may change in any upcoming release
    in a breaking way.

    The operator performs no validation of the configuration file.

    This field takes precedence over `tracingConfig`.
    """
    version: Optional[str] = None
    """
    Version of Thanos to be deployed.
    """
    volume_mounts: Annotated[Optional[List[VolumeMount]], Field(alias="volumeMounts")] = None
    """
    VolumeMounts allows configuration of additional VolumeMounts on the output StatefulSet definition.
    VolumeMounts specified will be appended to other VolumeMounts in the ruler container,
    that are generated as a result of StorageSpec objects.
    """
    volumes: Optional[List[Volume]] = None
    """
    Volumes allows configuration of additional volumes on the output StatefulSet definition. Volumes specified will
    be appended to other volumes that are generated as a result of StorageSpec objects.
    """
    web: Optional[WebModel1] = None
    """
    Defines the configuration of the ThanosRuler web server.
    """


class ConditionModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConditionModel4"]:
            return ConditionModel4

        def build(self) -> "ConditionModel4":
            return ConditionModel4(**self._attrs)

        def last_transition_time(self, value: datetime, /) -> Self:
            """
            lastTransitionTime is the time of the last update to the current status property.
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Human-readable message indicating details for the condition's last transition.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration represents the .metadata.generation that the
            condition was set based upon. For instance, if `.metadata.generation` is
            currently 12, but the `.status.conditions[].observedGeneration` is 9, the
            condition is out of date with respect to the current state of the
            instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            Reason for the condition's last transition.
            """
            return self._set("reason", value)

        def status(self, value: str, /) -> Self:
            """
            Status of the condition.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of the condition being reported.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["ConditionModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConditionModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConditionModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConditionModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConditionModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[datetime, Field(alias="lastTransitionTime")]
    """
    lastTransitionTime is the time of the last update to the current status property.
    """
    message: Optional[str] = None
    """
    Human-readable message indicating details for the condition's last transition.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration represents the .metadata.generation that the
    condition was set based upon. For instance, if `.metadata.generation` is
    currently 12, but the `.status.conditions[].observedGeneration` is 9, the
    condition is out of date with respect to the current state of the
    instance.
    """
    reason: Optional[str] = None
    """
    Reason for the condition's last transition.
    """
    status: Annotated[str, Field(min_length=1)]
    """
    Status of the condition.
    """
    type: Annotated[str, Field(min_length=1)]
    """
    Type of the condition being reported.
    """


class ThanosRulerStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ThanosRulerStatus"]:
            return ThanosRulerStatus

        def build(self) -> "ThanosRulerStatus":
            return ThanosRulerStatus(**self._attrs)

        def available_replicas(self, value: int, /) -> Self:
            """
            Total number of available pods (ready for at least minReadySeconds)
            targeted by this ThanosRuler deployment.
            """
            return self._set("available_replicas", value)

        @overload
        def conditions(
            self, value_or_callback: List[ConditionModel4], /
        ) -> "ThanosRulerStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ConditionModel4, ConditionModel4.Builder]],
                GenericListBuilder[ConditionModel4, ConditionModel4.Builder]
                | List[ConditionModel4],
            ],
            /,
        ) -> "ThanosRulerStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ConditionModel4.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            The current state of the ThanosRuler object.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ConditionModel4.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConditionModel4.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def paused(self, value: bool, /) -> Self:
            """
            Represents whether any actions on the underlying managed objects are
            being performed. Only delete actions will be performed.
            """
            return self._set("paused", value)

        def replicas(self, value: int, /) -> Self:
            """
            Total number of non-terminated pods targeted by this ThanosRuler deployment
            (their labels match the selector).
            """
            return self._set("replicas", value)

        def unavailable_replicas(self, value: int, /) -> Self:
            """
            Total number of unavailable pods targeted by this ThanosRuler deployment.
            """
            return self._set("unavailable_replicas", value)

        def updated_replicas(self, value: int, /) -> Self:
            """
            Total number of non-terminated pods targeted by this ThanosRuler deployment
            that have the desired version spec.
            """
            return self._set("updated_replicas", value)

    class BuilderContext(BuilderContextBase["ThanosRulerStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ThanosRulerStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ThanosRulerStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ThanosRulerStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ThanosRulerStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    available_replicas: Annotated[int, Field(alias="availableReplicas")]
    """
    Total number of available pods (ready for at least minReadySeconds)
    targeted by this ThanosRuler deployment.
    """
    conditions: Optional[List[ConditionModel4]] = None
    """
    The current state of the ThanosRuler object.
    """
    paused: bool
    """
    Represents whether any actions on the underlying managed objects are
    being performed. Only delete actions will be performed.
    """
    replicas: int
    """
    Total number of non-terminated pods targeted by this ThanosRuler deployment
    (their labels match the selector).
    """
    unavailable_replicas: Annotated[int, Field(alias="unavailableReplicas")]
    """
    Total number of unavailable pods targeted by this ThanosRuler deployment.
    """
    updated_replicas: Annotated[int, Field(alias="updatedReplicas")]
    """
    Total number of non-terminated pods targeted by this ThanosRuler deployment
    that have the desired version spec.
    """


class Alertmanager(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Alertmanager"]:
            return Alertmanager

        def build(self) -> "Alertmanager":
            return Alertmanager(**self._attrs)

        def api_version(self, value: Optional[Literal["monitoring.coreos.com/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Alertmanager"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Alertmanager.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Alertmanager.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: AlertmanagerSpec, /) -> "Alertmanager.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [AlertmanagerSpec.Builder], AlertmanagerSpec.Builder | AlertmanagerSpec
            ],
            /,
        ) -> "Alertmanager.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "AlertmanagerSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AlertmanagerSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AlertmanagerSpec.builder())
                if isinstance(output, AlertmanagerSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[AlertmanagerStatus], /
        ) -> "Alertmanager.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [AlertmanagerStatus.Builder],
                AlertmanagerStatus.Builder | AlertmanagerStatus,
            ],
            /,
        ) -> "Alertmanager.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "AlertmanagerStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AlertmanagerStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AlertmanagerStatus.builder())
                if isinstance(output, AlertmanagerStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Alertmanager.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Alertmanager.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Alertmanager."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Alertmanager", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Alertmanager.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["monitoring.coreos.com/v1"]], Field(alias="apiVersion")
    ] = "monitoring.coreos.com/v1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Alertmanager"]] = "Alertmanager"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: AlertmanagerSpec
    status: Optional[AlertmanagerStatus] = None


class PodMonitor(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodMonitor"]:
            return PodMonitor

        def build(self) -> "PodMonitor":
            return PodMonitor(**self._attrs)

        def api_version(self, value: Optional[Literal["monitoring.coreos.com/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["PodMonitor"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "PodMonitor.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "PodMonitor.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: PodMonitorSpec, /) -> "PodMonitor.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [PodMonitorSpec.Builder], PodMonitorSpec.Builder | PodMonitorSpec
            ],
            /,
        ) -> "PodMonitor.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "PodMonitorSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PodMonitorSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodMonitorSpec.builder())
                if isinstance(output, PodMonitorSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["PodMonitor.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodMonitor.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodMonitor."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodMonitor", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodMonitor.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["monitoring.coreos.com/v1"]], Field(alias="apiVersion")
    ] = "monitoring.coreos.com/v1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["PodMonitor"]] = "PodMonitor"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: PodMonitorSpec


class Probe(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Probe"]:
            return Probe

        def build(self) -> "Probe":
            return Probe(**self._attrs)

        def api_version(self, value: Optional[Literal["monitoring.coreos.com/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Probe"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Probe.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Probe.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: ProbeSpec, /) -> "Probe.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[ProbeSpec.Builder], ProbeSpec.Builder | ProbeSpec],
            /,
        ) -> "Probe.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ProbeSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ProbeSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProbeSpec.builder())
                if isinstance(output, ProbeSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["Probe.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Probe.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Probe."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Probe", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Probe.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["monitoring.coreos.com/v1"]], Field(alias="apiVersion")
    ] = "monitoring.coreos.com/v1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Probe"]] = "Probe"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: ProbeSpec


class Prometheus(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Prometheus"]:
            return Prometheus

        def build(self) -> "Prometheus":
            return Prometheus(**self._attrs)

        def api_version(self, value: Optional[Literal["monitoring.coreos.com/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Prometheus"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Prometheus.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Prometheus.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: PrometheusSpec, /) -> "Prometheus.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [PrometheusSpec.Builder], PrometheusSpec.Builder | PrometheusSpec
            ],
            /,
        ) -> "Prometheus.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "PrometheusSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PrometheusSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PrometheusSpec.builder())
                if isinstance(output, PrometheusSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[PrometheusStatus], /
        ) -> "Prometheus.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [PrometheusStatus.Builder], PrometheusStatus.Builder | PrometheusStatus
            ],
            /,
        ) -> "Prometheus.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "PrometheusStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PrometheusStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PrometheusStatus.builder())
                if isinstance(output, PrometheusStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Prometheus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Prometheus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Prometheus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Prometheus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Prometheus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["monitoring.coreos.com/v1"]], Field(alias="apiVersion")
    ] = "monitoring.coreos.com/v1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Prometheus"]] = "Prometheus"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: PrometheusSpec
    status: Optional[PrometheusStatus] = None


class PrometheusRule(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PrometheusRule"]:
            return PrometheusRule

        def build(self) -> "PrometheusRule":
            return PrometheusRule(**self._attrs)

        def api_version(self, value: Optional[Literal["monitoring.coreos.com/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["PrometheusRule"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "PrometheusRule.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "PrometheusRule.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: PrometheusRuleSpec, /) -> "PrometheusRule.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [PrometheusRuleSpec.Builder],
                PrometheusRuleSpec.Builder | PrometheusRuleSpec,
            ],
            /,
        ) -> "PrometheusRule.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "PrometheusRuleSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PrometheusRuleSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PrometheusRuleSpec.builder())
                if isinstance(output, PrometheusRuleSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["PrometheusRule.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PrometheusRule.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PrometheusRule."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PrometheusRule", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PrometheusRule.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["monitoring.coreos.com/v1"]], Field(alias="apiVersion")
    ] = "monitoring.coreos.com/v1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["PrometheusRule"]] = "PrometheusRule"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: PrometheusRuleSpec


class ServiceMonitor(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceMonitor"]:
            return ServiceMonitor

        def build(self) -> "ServiceMonitor":
            return ServiceMonitor(**self._attrs)

        def api_version(self, value: Optional[Literal["monitoring.coreos.com/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ServiceMonitor"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ServiceMonitor.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ServiceMonitor.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: ServiceMonitorSpec, /) -> "ServiceMonitor.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ServiceMonitorSpec.Builder],
                ServiceMonitorSpec.Builder | ServiceMonitorSpec,
            ],
            /,
        ) -> "ServiceMonitor.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ServiceMonitorSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ServiceMonitorSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceMonitorSpec.builder())
                if isinstance(output, ServiceMonitorSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["ServiceMonitor.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceMonitor.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceMonitor."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceMonitor", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceMonitor.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["monitoring.coreos.com/v1"]], Field(alias="apiVersion")
    ] = "monitoring.coreos.com/v1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ServiceMonitor"]] = "ServiceMonitor"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: ServiceMonitorSpec


class ThanosRuler(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ThanosRuler"]:
            return ThanosRuler

        def build(self) -> "ThanosRuler":
            return ThanosRuler(**self._attrs)

        def api_version(self, value: Optional[Literal["monitoring.coreos.com/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ThanosRuler"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ThanosRuler.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ThanosRuler.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: ThanosRulerSpec, /) -> "ThanosRuler.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ThanosRulerSpec.Builder], ThanosRulerSpec.Builder | ThanosRulerSpec
            ],
            /,
        ) -> "ThanosRuler.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ThanosRulerSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ThanosRulerSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ThanosRulerSpec.builder())
                if isinstance(output, ThanosRulerSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ThanosRulerStatus], /
        ) -> "ThanosRuler.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ThanosRulerStatus.Builder],
                ThanosRulerStatus.Builder | ThanosRulerStatus,
            ],
            /,
        ) -> "ThanosRuler.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "ThanosRulerStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ThanosRulerStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ThanosRulerStatus.builder())
                if isinstance(output, ThanosRulerStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["ThanosRuler.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ThanosRuler.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ThanosRuler."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ThanosRuler", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ThanosRuler.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["monitoring.coreos.com/v1"]], Field(alias="apiVersion")
    ] = "monitoring.coreos.com/v1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ThanosRuler"]] = "ThanosRuler"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: ThanosRulerSpec
    status: Optional[ThanosRulerStatus] = None
