# edpm/engine/generators/cmake_generator.py

import os
import json

from edpm.engine.env_gen import CmakeSet, CmakeModulePath


class CmakeGenerator:
    def __init__(self, plan, lock):
        self.plan = plan
        self.lock = lock

    ############################
    # 1) Toolchain
    ############################
    def build_toolchain_text(self) -> str:
        """
        Return purely EDPM-generated lines for a .cmake toolchain file
        (no merging).
        """
        lines = []
        lines.append("# Automatically generated by EDPM\n")
        lines.append("# Do not edit by hand!\n\n")

        # Maybe gather environment or special CMakeSet actions
        global_env = self.plan.get_global_env_actions()
        for act in global_env:
            if hasattr(act, 'gen_cmake_line'):
                lines.append(act.gen_cmake_line() + "\n")

        # Then for each installed dependency:
        for dep_name in sorted(self.lock.get_all_dependencies()):
            dep_data = self.lock.get_dependency(dep_name)
            ipath = dep_data.get("install_path", "")
            if not ipath or not os.path.isdir(ipath):
                continue

            dep_obj = self.plan.find_dependency(dep_name)
            if not dep_obj:
                continue

            placeholders = {"install_dir": ipath}
            env_actions = dep_obj.env_block().parse(placeholders)
            for act in env_actions:
                if hasattr(act, 'gen_cmake_line'):
                    lines.append(act.gen_cmake_line() + "\n")

        return "".join(lines)

    def save_toolchain_with_infile(self, in_file: str, out_file: str):
        """
        If in_file is None => just write build_toolchain_text() to out_file
        Otherwise read in_file, look for '{{{EDPM-GENERATOR-CONTENT}}}' insertion
        """
        edpm_text = self.build_toolchain_text()
        if in_file is None:
            self._write_text(out_file, edpm_text)
            return

        with open(in_file, "r", encoding="utf-8") as f:
            original_lines = f.readlines()

        marker = "{{{EDPM-GENERATOR-CONTENT}}}"
        inserted = False
        new_lines = []
        for line in original_lines:
            if marker in line:
                new_lines.append(edpm_text)
                inserted = True
            else:
                new_lines.append(line)

        if not inserted:
            new_lines.append("\n# EDPM content appended:\n")
            new_lines.append(edpm_text)

        merged_text = "".join(new_lines)
        self._write_text(out_file, merged_text)

    ############################
    # 2) CMakePresets
    ############################
    def build_presets_json(self) -> str:
        """
        Build purely EDPM-based CMakePresets (in JSON),
        taking into account any CMake-related environment actions like:
          - CmakeSet(name, value)
          - CmakeModulePath(path)

        Return as a JSON string.
        """

        # 1) Construct a minimal skeleton
        preset = {
            "version": 3,
            "cmakeMinimumRequired": { "major": 3, "minor": 21 },
            "configurePresets": [
                {
                    "name": "edpm",
                    "displayName": "EDPM-based config",
                    "generator": "Unix Makefiles",
                    "cacheVariables": {}
                }
            ]
        }

        # A local ref to the cacheVariables dict for convenience
        cache_vars = preset["configurePresets"][0]["cacheVariables"]

        # 2) Gather all environment manipulations from:
        #    2.1 global environment
        global_env_actions = self.plan.get_global_env_actions()
        #    2.2 each installed package environment
        installed_deps = self.lock.get_all_dependencies()

        # We'll collect them all, then process in one pass
        all_actions = []
        # - Global
        all_actions.extend(global_env_actions)

        # - Per installed package
        for dep_name in sorted(installed_deps):
            dep_data = self.lock.get_dependency(dep_name)
            ipath = dep_data.get("install_path", "")
            if not ipath or not os.path.isdir(ipath):
                continue  # skip not-installed or invalid path

            dep_obj = self.plan.find_dependency(dep_name)
            if dep_obj:
                # parse environment
                placeholders = {"install_dir": ipath}
                env_block = dep_obj.env_block()
                env_actions = env_block.parse(placeholders)
                all_actions.extend(env_actions)

        # 3) Process the environment manipulations relevant to CMake Presets
        #    We'll accumulate:
        #      - normal variables from CmakeSet
        #      - a list of paths from CmakeModulePath
        #    Then combine them at the end.
        # Example approach for CMAKE_MODULE_PATH or CMAKE_PREFIX_PATH:
        cmodule_paths = []  # to store list of strings for CMAKE_MODULE_PATH
        # You might do the same for CMAKE_PREFIX_PATH or any other variables you wish.

        for act in all_actions:
            # If it's a "CmakeSet"
            if isinstance(act, CmakeSet):
                # We treat act.name as the variable name, act.value as the path or value
                # In the CMakePresets.json format, it typically looks like:
                #   "FOO_DIR": { "value": "/some/path", "type": "STRING" }
                cache_vars[act.name] = {
                    "value": act.value,
                    "type": "STRING"
                }

            # If it's a "CmakeModulePath"
            elif isinstance(act, CmakeModulePath):
                # We'll gather them for later combination
                cmodule_paths.append(act.value)

            # If you have some "CmakeLine" or other classes, you might skip them or treat them differently,
            # because they are single raw lines suitable for EDPMConfig.cmake (not as easy to map to presets).
            # elif isinstance(act, CmakeLine):
            #     pass

        # 4) If we have multiple paths for CMAKE_MODULE_PATH, combine them with semicolons
        #    Then we also want to append ${CMAKE_MODULE_PATH} at the end or beginning.
        #    For example, we do:
        if cmodule_paths:
            combined_cmodule_path = ";".join(cmodule_paths) + ";${CMAKE_MODULE_PATH}"
            cache_vars["CMAKE_MODULE_PATH"] = {
                "value": combined_cmodule_path,
                "type": "STRING"
            }

        # 5) Now we have the "preset" structure with "cacheVariables" set up from EDPM environment manipulations.
        return json.dumps(preset, indent=2)

    def save_presets_with_infile(self, in_file: str, out_file: str):
        """
        If in_file is None => write build_presets_json() to out_file
        If in_file is not None => parse the JSON, then merge EDPM-based stuff
        """
        edpm_json_str = self.build_presets_json()
        edpm_data = json.loads(edpm_json_str)

        if in_file is None:
            # no merging
            self._write_text(out_file, edpm_json_str)
            return

        # read & parse existing
        with open(in_file, "r", encoding="utf-8") as f:
            try:
                original_data = json.load(f)
            except json.JSONDecodeError:
                # fallback if invalid
                original_data = {}

        # We do a naive "merge" approach. For example, we might:
        # - ensure original_data["version"] = edpm_data["version"] if not present
        # - ensure original_data["configurePresets"] exists
        # - For each 'configurePresets', we either merge or replace.
        #   In practice you can get fancy or keep it simple.

        # Minimal example of merging EDPM's "configurePresets" into "original_data".
        # We'll look for a preset named "edpm" in original, or append if missing.
        edpm_preset = None
        if "configurePresets" in edpm_data:
            # we assume there's only 1 in this example
            edpm_preset = edpm_data["configurePresets"][0]
        else:
            edpm_preset = None

        if "configurePresets" not in original_data:
            original_data["configurePresets"] = []

        # see if there's an existing "edpm" preset
        found_index = None
        for i, existing_preset in enumerate(original_data["configurePresets"]):
            if existing_preset.get("name") == "edpm":
                found_index = i
                break

        if edpm_preset:
            if found_index is not None:
                # We overwrite or merge
                original_data["configurePresets"][found_index] = edpm_preset
            else:
                # append
                original_data["configurePresets"].append(edpm_preset)

        # version
        original_data["version"] = edpm_data.get("version", 3)
        original_data["cmakeMinimumRequired"] = edpm_data.get("cmakeMinimumRequired", {"major":3,"minor":21})

        # now write back
        final_json = json.dumps(original_data, indent=2)
        self._write_text(out_file, final_json)

    def _write_text(self, filename, text):
        os.makedirs(os.path.dirname(filename), exist_ok=True)
        with open(filename, "w", encoding="utf-8") as f:
            f.write(text)
