# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/extensions/common/ratelimit/v3/ratelimit.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import List

import betterproto

from .....type import v3 as ____type_v3__


class XRateLimitHeadersRfcVersion(betterproto.Enum):
    """Defines the version of the standard to use for X-RateLimit headers."""

    OFF = 0
    """X-RateLimit headers disabled."""

    DRAFT_VERSION_03 = 1
    """
    Use `draft RFC Version 03 <https://tools.ietf.org/id/draft-polli-ratelimit-
    headers-03.html>`_ where 3 headers will be added: * ``X-RateLimit-Limit`` -
    indicates the request-quota associated to the   client in the current time-
    window followed by the description of the   quota policy. The value is
    returned by the maximum tokens of the token bucket. * ``X-RateLimit-
    Remaining`` - indicates the remaining requests in the   current time-
    window. The value is returned by the remaining tokens in the token bucket.
    * ``X-RateLimit-Reset`` - indicates the number of seconds until reset of
    the current time-window. The value is returned by the remaining fill
    interval of the token bucket.
    """


class VhRateLimitsOptions(betterproto.Enum):
    OVERRIDE = 0
    """
    Use the virtual host rate limits unless the route has a rate limit policy.
    """

    INCLUDE = 1
    """
    Use the virtual host rate limits even if the route has a rate limit policy.
    """

    IGNORE = 2
    """
    Ignore the virtual host rate limits even if the route does not have a rate
    limit policy.
    """


@dataclass(eq=False, repr=False)
class RateLimitDescriptor(betterproto.Message):
    """
    A RateLimitDescriptor is a list of hierarchical entries that are used by
    the service to determine the final rate limit key and overall allowed
    limit. Here are some examples of how they might be used for the domain
    "envoy". .. code-block:: cpp   ["authenticated": "false"],
    ["remote_address": "10.0.0.1"] What it does: Limits all unauthenticated
    traffic for the IP address 10.0.0.1. The configuration supplies a default
    limit for the *remote_address* key. If there is a desire to raise the limit
    for 10.0.0.1 or block it entirely it can be specified directly in the
    configuration. .. code-block:: cpp   ["authenticated": "false"], ["path":
    "/foo/bar"] What it does: Limits all unauthenticated traffic globally for a
    specific path (or prefix if configured that way in the service). .. code-
    block:: cpp   ["authenticated": "false"], ["path": "/foo/bar"],
    ["remote_address": "10.0.0.1"] What it does: Limits unauthenticated traffic
    to a specific path for a specific IP address. Like (1) we can raise/block
    specific IP addresses if we want with an override configuration. .. code-
    block:: cpp   ["authenticated": "true"], ["client_id": "foo"] What it does:
    Limits all traffic for an authenticated client "foo" .. code-block:: cpp
    ["authenticated": "true"], ["client_id": "foo"], ["path": "/foo/bar"] What
    it does: Limits traffic to a specific path for an authenticated client
    "foo" The idea behind the API is that (1)/(2)/(3) and (4)/(5) can be sent
    in 1 request if desired. This enables building complex application
    scenarios with a generic backend. Optionally the descriptor can contain a
    limit override under a "limit" key, that specifies the number of requests
    per unit to use instead of the number configured in the rate limiting
    service.
    """

    entries: List["RateLimitDescriptorEntry"] = betterproto.message_field(1)
    """Descriptor entries."""

    limit: "RateLimitDescriptorRateLimitOverride" = betterproto.message_field(2)
    """Optional rate limit override to supply to the ratelimit service."""


@dataclass(eq=False, repr=False)
class RateLimitDescriptorEntry(betterproto.Message):
    key: str = betterproto.string_field(1)
    """Descriptor key."""

    value: str = betterproto.string_field(2)
    """Descriptor value."""


@dataclass(eq=False, repr=False)
class RateLimitDescriptorRateLimitOverride(betterproto.Message):
    """
    Override rate limit to apply to this descriptor instead of the limit
    configured in the rate limit service. See :ref:`rate limit override
    <config_http_filters_rate_limit_rate_limit_override>` for more information.
    """

    requests_per_unit: int = betterproto.uint32_field(1)
    """The number of requests per unit of time."""

    unit: "____type_v3__.RateLimitUnit" = betterproto.enum_field(2)
    """The unit of time."""


@dataclass(eq=False, repr=False)
class LocalRateLimitDescriptor(betterproto.Message):
    entries: List["RateLimitDescriptorEntry"] = betterproto.message_field(1)
    """Descriptor entries."""

    token_bucket: "____type_v3__.TokenBucket" = betterproto.message_field(2)
    """Token Bucket algorithm for local ratelimiting."""


@dataclass(eq=False, repr=False)
class LocalClusterRateLimit(betterproto.Message):
    """
    Configuration used to enable local cluster level rate limiting where the
    token buckets will be shared across all the Envoy instances in the local
    cluster. A share will be calculated based on the membership of the local
    cluster dynamically and the configuration. When the limiter refilling the
    token bucket, the share will be applied. By default, the token bucket will
    be shared evenly. See :ref:`local cluster name
    <envoy_v3_api_field_config.bootstrap.v3.ClusterManager.local_cluster_name>`
    for more context about local cluster.
    """

    pass
