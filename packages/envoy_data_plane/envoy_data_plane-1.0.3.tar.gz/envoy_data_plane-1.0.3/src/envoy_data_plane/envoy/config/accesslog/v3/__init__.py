# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/config/accesslog/v3/accesslog.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    List,
    Optional,
)

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf

from ....data.accesslog import v3 as ___data_accesslog_v3__
from ....type import v3 as ___type_v3__
from ....type.matcher import v3 as ___type_matcher_v3__
from ...core import v3 as __core_v3__
from ...route import v3 as __route_v3__


class ComparisonFilterOp(betterproto.Enum):
    EQ = 0
    """="""

    GE = 1
    """>="""

    LE = 2
    """<="""


class GrpcStatusFilterStatus(betterproto.Enum):
    OK = 0
    CANCELED = 1
    UNKNOWN = 2
    INVALID_ARGUMENT = 3
    DEADLINE_EXCEEDED = 4
    NOT_FOUND = 5
    ALREADY_EXISTS = 6
    PERMISSION_DENIED = 7
    RESOURCE_EXHAUSTED = 8
    FAILED_PRECONDITION = 9
    ABORTED = 10
    OUT_OF_RANGE = 11
    UNIMPLEMENTED = 12
    INTERNAL = 13
    UNAVAILABLE = 14
    DATA_LOSS = 15
    UNAUTHENTICATED = 16


@dataclass(eq=False, repr=False)
class AccessLog(betterproto.Message):
    name: str = betterproto.string_field(1)
    """The name of the access log extension configuration."""

    filter: "AccessLogFilter" = betterproto.message_field(2)
    """
    Filter which is used to determine if the access log needs to be written.
    """

    typed_config: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(
        4, group="config_type"
    )


@dataclass(eq=False, repr=False)
class AccessLogFilter(betterproto.Message):
    """[#next-free-field: 14]"""

    status_code_filter: "StatusCodeFilter" = betterproto.message_field(
        1, group="filter_specifier"
    )
    """Status code filter."""

    duration_filter: "DurationFilter" = betterproto.message_field(
        2, group="filter_specifier"
    )
    """Duration filter."""

    not_health_check_filter: "NotHealthCheckFilter" = betterproto.message_field(
        3, group="filter_specifier"
    )
    """Not health check filter."""

    traceable_filter: "TraceableFilter" = betterproto.message_field(
        4, group="filter_specifier"
    )
    """Traceable filter."""

    runtime_filter: "RuntimeFilter" = betterproto.message_field(
        5, group="filter_specifier"
    )
    """Runtime filter."""

    and_filter: "AndFilter" = betterproto.message_field(6, group="filter_specifier")
    """And filter."""

    or_filter: "OrFilter" = betterproto.message_field(7, group="filter_specifier")
    """Or filter."""

    header_filter: "HeaderFilter" = betterproto.message_field(
        8, group="filter_specifier"
    )
    """Header filter."""

    response_flag_filter: "ResponseFlagFilter" = betterproto.message_field(
        9, group="filter_specifier"
    )
    """Response flag filter."""

    grpc_status_filter: "GrpcStatusFilter" = betterproto.message_field(
        10, group="filter_specifier"
    )
    """gRPC status filter."""

    extension_filter: "ExtensionFilter" = betterproto.message_field(
        11, group="filter_specifier"
    )
    """
    Extension filter. [#extension-category:
    envoy.access_loggers.extension_filters]
    """

    metadata_filter: "MetadataFilter" = betterproto.message_field(
        12, group="filter_specifier"
    )
    """Metadata Filter"""

    log_type_filter: "LogTypeFilter" = betterproto.message_field(
        13, group="filter_specifier"
    )
    """Log Type Filter"""


@dataclass(eq=False, repr=False)
class ComparisonFilter(betterproto.Message):
    """Filter on an integer comparison."""

    op: "ComparisonFilterOp" = betterproto.enum_field(1)
    """Comparison operator."""

    value: "__core_v3__.RuntimeUInt32" = betterproto.message_field(2)
    """Value to compare against."""


@dataclass(eq=False, repr=False)
class StatusCodeFilter(betterproto.Message):
    """Filters on HTTP response/status code."""

    comparison: "ComparisonFilter" = betterproto.message_field(1)
    """Comparison."""


@dataclass(eq=False, repr=False)
class DurationFilter(betterproto.Message):
    """
    Filters based on the duration of the request or stream, in milliseconds.
    For end of stream access logs, the total duration of the stream will be
    used. For :ref:`periodic access logs<arch_overview_access_log_periodic>`,
    the duration of the stream at the time of log recording will be used.
    """

    comparison: "ComparisonFilter" = betterproto.message_field(1)
    """Comparison."""


@dataclass(eq=False, repr=False)
class NotHealthCheckFilter(betterproto.Message):
    """
    Filters for requests that are not health check requests. A health check
    request is marked by the health check filter.
    """

    pass


@dataclass(eq=False, repr=False)
class TraceableFilter(betterproto.Message):
    """
    Filters for requests that are traceable. See the tracing overview for more
    information on how a request becomes traceable.
    """

    pass


@dataclass(eq=False, repr=False)
class RuntimeFilter(betterproto.Message):
    """Filters for random sampling of requests."""

    runtime_key: str = betterproto.string_field(1)
    """
    Runtime key to get an optional overridden numerator for use in the
    ``percent_sampled`` field. If found in runtime, this value will replace the
    default numerator.
    """

    percent_sampled: "___type_v3__.FractionalPercent" = betterproto.message_field(2)
    """
    The default sampling percentage. If not specified, defaults to 0% with
    denominator of 100.
    """

    use_independent_randomness: bool = betterproto.bool_field(3)
    """
    By default, sampling pivots on the header :ref:`x-request-
    id<config_http_conn_man_headers_x-request-id>` being present. If
    :ref:`x-request-id<config_http_conn_man_headers_x-request-id>` is present,
    the filter will consistently sample across multiple hosts based on the
    runtime key value and the value extracted from :ref:`x-request-
    id<config_http_conn_man_headers_x-request-id>`. If it is missing, or
    ``use_independent_randomness`` is set to true, the filter will randomly
    sample based on the runtime key value alone. ``use_independent_randomness``
    can be used for logging kill switches within complex nested :ref:`AndFilter
    <envoy_v3_api_msg_config.accesslog.v3.AndFilter>` and :ref:`OrFilter
    <envoy_v3_api_msg_config.accesslog.v3.OrFilter>` blocks that are easier to
    reason about from a probability perspective (i.e., setting to true will
    cause the filter to behave like an independent random variable when
    composed within logical operator filters).
    """


@dataclass(eq=False, repr=False)
class AndFilter(betterproto.Message):
    """
    Performs a logical “and” operation on the result of each filter in filters.
    Filters are evaluated sequentially and if one of them returns false, the
    filter returns false immediately.
    """

    filters: List["AccessLogFilter"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class OrFilter(betterproto.Message):
    """
    Performs a logical “or” operation on the result of each individual filter.
    Filters are evaluated sequentially and if one of them returns true, the
    filter returns true immediately.
    """

    filters: List["AccessLogFilter"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class HeaderFilter(betterproto.Message):
    """Filters requests based on the presence or value of a request header."""

    header: "__route_v3__.HeaderMatcher" = betterproto.message_field(1)
    """
    Only requests with a header which matches the specified HeaderMatcher will
    pass the filter check.
    """


@dataclass(eq=False, repr=False)
class ResponseFlagFilter(betterproto.Message):
    """
    Filters requests that received responses with an Envoy response flag set. A
    list of the response flags can be found in the access log formatter
    :ref:`documentation<config_access_log_format_response_flags>`.
    """

    flags: List[str] = betterproto.string_field(1)
    """
    Only responses with the any of the flags listed in this field will be
    logged. This field is optional. If it is not specified, then any response
    flag will pass the filter check.
    """


@dataclass(eq=False, repr=False)
class GrpcStatusFilter(betterproto.Message):
    """
    Filters gRPC requests based on their response status. If a gRPC status is
    not provided, the filter will infer the status from the HTTP status code.
    """

    statuses: List["GrpcStatusFilterStatus"] = betterproto.enum_field(1)
    """
    Logs only responses that have any one of the gRPC statuses in this field.
    """

    exclude: bool = betterproto.bool_field(2)
    """
    If included and set to true, the filter will instead block all responses
    with a gRPC status or inferred gRPC status enumerated in statuses, and
    allow all other responses.
    """


@dataclass(eq=False, repr=False)
class MetadataFilter(betterproto.Message):
    """
    Filters based on matching dynamic metadata. If the matcher path and key
    correspond to an existing key in dynamic metadata, the request is logged
    only if the matcher value is equal to the metadata value. If the matcher
    path and key *do not* correspond to an existing key in dynamic metadata,
    the request is logged only if match_if_key_not_found is "true" or unset.
    """

    matcher: "___type_matcher_v3__.MetadataMatcher" = betterproto.message_field(1)
    """
    Matcher to check metadata for specified value. For example, to match on the
    access_log_hint metadata, set the filter to "envoy.common" and the path to
    "access_log_hint", and the value to "true".
    """

    match_if_key_not_found: Optional[bool] = betterproto.message_field(
        2, wraps=betterproto.TYPE_BOOL
    )
    """
    Default result if the key does not exist in dynamic metadata: if unset or
    true, then log; if false, then don't log.
    """


@dataclass(eq=False, repr=False)
class LogTypeFilter(betterproto.Message):
    """Filters based on access log type."""

    types: List["___data_accesslog_v3__.AccessLogType"] = betterproto.enum_field(1)
    """
    Logs only records which their type is one of the types defined in this
    field.
    """

    exclude: bool = betterproto.bool_field(2)
    """
    If this field is set to true, the filter will instead block all records
    with a access log type in types field, and allow all other records.
    """


@dataclass(eq=False, repr=False)
class ExtensionFilter(betterproto.Message):
    """Extension filter is statically registered at runtime."""

    name: str = betterproto.string_field(1)
    """
    The name of the filter implementation to instantiate. The name must match a
    statically registered filter.
    """

    typed_config: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(
        3, group="config_type"
    )
