# -*- coding: utf-8 -*-
"""DBHL_20250226_00.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FbqA_ZLjuLgq9-yxVWcm-pD0jg-TSc4f

# DebugHelper
デバッグ作業をサポートする。


```
2025/01/18 DebugHelper2をpip化するために作成
2025/01/19 flg_debugをなくすための修正
2025/02/11 0.2.1 CheckpointManager追加
2025/02/12 0.2.2 log_step改良。実行中のクラスとメソッドを表示するようにした。
2025/02/13 0.2.3 what_do_you_do を追加。コマンドの実行を選択できるようにした。
2025/02/14 0.2.4 what_do_you_do 改良。戻り値関係。
2025/02/14 0.2.5 what_do_you_do 改良。表示方法。
2025/02/14 0.2.7 what_do_you_do 改良。ログファイル作成機能、タイムスタンプ機能
2025/02/15 0.2.8 ログファイル作成機能改良。ログファイル名にタイムスタンプを入れる。
2025/02/15 0.2.9 log_stepバグ修正。整理のため、ログファイルストック数を5つに制限する。
2025/02/15 0.2.10 log_step 改良。引数charで冒頭文字の幅を広げる。
2025/02/16 0.2.11 log_step 改良。戻り値関係。
2025/02/16 0.2.12 run_command 改良。ログを出力。
2025/02/17 0.2.13 run_command 改良。subprocessを利用するようにする。
2025/02/17 0.2.14 run_command 改良。booleanだけでなく、numericも返す。
2025/02/18 0.2.15 run_command 改良。stdoutをログファイルに書き出すようにする。
2025/02/18 0.3.00 run_command 改良。stderrもログファイルに書き出すようにする。
2025/02/23 1.0.0 2つ以上のインスタンスにDebugHelperを設置しても、問題なくログを出力できるようにした。
2025/02/23 1.0.1 ログ出力先修正
2025/02/26 1.0.2 仮想環境からの出力でもログにするようにした。
```

# DebugHelper

## 1. 初期設定
"""

# @title a. 初期値設定{"form-width":"400px"}
# @markdown Log_folder, Log_file(デバッグログを記録)
log_folder = "/content/drive/MyDrive/log"  # @param {type:"string"}
log_file_stdout = ""  # @param {type:"string", "placeholder":"何も入力しなければタイムスタンプになります"}
log_file_stderr = ""  # @param {type:"string", "placeholder":"何も入力しなければタイムスタンプになります"}

# @title b. GDrive接続
from google.colab import drive
drive.mount('/content/drive')

"""## 2. モジュール定義"""

# @title a. DebugHelper 定義{"form-width":"400px"}
import os
import sys
import inspect
import subprocess
import threading
from datetime import datetime
from pathlib import Path

class DebugHelper:
    def __init__(self, instance_name="default", default_log_folder=log_folder):
        """チェックリストやログ管理を行うクラス（各インスタンスで独立した状態を持つ）"""
        self.instance_name = instance_name
        self.debug = True
        self.entries = []  # 記録するエントリ一覧
        self.wNo = 1
        self.silent_mode = False  # デフォルトは False（対話モード）

        # 汎用ログファイル設定
        self.log_to_file = False
        self.log_file_path = None
        # 標準出力・標準エラー用ログファイル設定
        self.log_to_file_stdout = False
        self.log_file_path_stdout = None
        self.log_to_file_stderr = False
        self.log_file_path_stderr = None

        self.timestamp = False  # タイムスタンプ有効化

        # デフォルトログフォルダの設定（引数がなければローカルの "logs" フォルダを利用）
        if default_log_folder is None:
            self.default_log_folder = Path("logs")
        else:
            self.default_log_folder = Path(default_log_folder)
        self.default_log_folder.mkdir(parents=True, exist_ok=True)

    def enable_debug(self):
        self.debug = True

    def disable_debug(self):
        self.debug = False

    def enable_silent_mode(self):
        self.silent_mode = True

    def disable_silent_mode(self):
        self.silent_mode = False

    def prune_log_files(self, log_file_path, max_files=5):
        # 指定されたディレクトリ内の *.log ファイルを最新 max_files 個以外削除する
        log_path = log_file_path.parent
        self.debug_print(f"log_path: {log_path}")
        files = list(log_path.glob("*.log"))
        if len(files) <= max_files:
            return
        files.sort(key=lambda f: f.stat().st_mtime)
        for f in files[:-max_files]:
            try:
                f.unlink()
                print(f"Deleted old log file: {f}")
            except Exception as e:
                print(f"Error deleting {f}: {e}")

    def enable_log_to_file_stdout(self, log_file_path=None):
        """標準出力のログファイルへの出力を有効にする（インスタンスごとに独立したパスを使用）"""
        if log_file_path is None:
            # デフォルトのログフォルダを利用
            log_file_path = self.default_log_folder
        else:
            log_file_path = Path(log_file_path)
        self.log_to_file_stdout = True
        self.log_file_path_stdout = log_file_path
        if self.log_file_path_stdout.is_dir():
            # filename = "Stdout_Rec_" + datetime.now().strftime("%Y_%m_%d_%H_%M_%S") + ".log"
            filename = f"Stdout_Rec_{self.instance_name}_{datetime.now().strftime('%Y_%m_%d_%H_%M_%S_%f')}.log"
            self.log_file_path_stdout = self.log_file_path_stdout / filename
            self.prune_log_files(self.log_file_path_stdout)
        elif self.log_file_path_stdout.is_file():
            pass
        else:
            self.debug_print(f"⚠️ ログファイルパス (stdout) が不正です: {self.log_file_path_stdout}")
            sys.exit(1)
        self.debug_print(f"✅ [{self.instance_name}] 標準出力ログファイル出力を有効化: {self.log_file_path_stdout}")

    def enable_log_to_file_stderr(self, log_file_path=None):
        """標準エラー出力のログファイルへの出力を有効にする（インスタンスごとに独立したパスを使用）"""
        if log_file_path is None:
            log_file_path = self.default_log_folder
        else:
            log_file_path = Path(log_file_path)
        self.log_to_file_stderr = True
        self.log_file_path_stderr = log_file_path
        if self.log_file_path_stderr.is_dir():
            #filename = "Stderr_Rec_" + datetime.now().strftime("%Y_%m_%d_%H_%M_%S") + ".log"
            filename = f"Stderr_Rec_{self.instance_name}_{datetime.now().strftime('%Y_%m_%d_%H_%M_%S_%f')}.log"
            self.log_file_path_stderr = self.log_file_path_stderr / filename
            self.prune_log_files(self.log_file_path_stderr)
        elif self.log_file_path_stderr.is_file():
            pass
        else:
            self.debug_print(f"⚠️ ログファイルパス (stderr) が不正です: {self.log_file_path_stderr}")
            sys.exit(1)
        self.debug_print(f"✅ [{self.instance_name}] 標準エラーログファイル出力を有効化: {self.log_file_path_stderr}")

    def disable_log_to_file(self):
        self.log_to_file = False
        self.log_to_file_stdout = False
        self.log_to_file_stderr = False
        self.debug_print("🛑 ログファイル出力を無効化")

    def enable_timestamp(self):
        self.timestamp = True

    def disable_timestamp(self):
        self.timestamp = False

    def start_step(self, step_name):
        print(f"🔹 チェック開始: {step_name}")
        self.entries.append({"ステップ": step_name, "内容": "進行中", "結果": "⚠️ 進行中"})

    def add_step(self, step_key, description):
        if step_key not in self.entries:
            self.entries.append({
                "ステップ": step_key,
                "処理内容": description,
                "結果": "未実行"
            })
        else:
            print(f"⚠️ 手順 {step_key} はすでに登録済みです。")

    def complete_step(self, step_name, success=True):
        for entry in self.entries:
            if entry.get("ステップ") == step_name:
                entry["結果"] = "✅ 成功" if success else "❌ 失敗"
                return
        print(f"⚠️ ステップ `{step_name}` が見つかりません")

    def debug_print(self, *args, end="\n", back=0):
        cls_name, method_name = self.get_current_method_info(back=back)
        timestamp_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S") if self.timestamp else ""
        message = f"{timestamp_str} [{cls_name}.{method_name}] " + " ".join(map(str, args))
        print(message, end=end)

        # stdout用ログファイルへ書き込み（各インスタンスごと）
        if self.log_to_file_stdout and self.log_file_path_stdout:
            try:
                with open(self.log_file_path_stdout, "a", encoding="utf-8") as log_file:
                    log_file.write(message + end)
            except Exception as e:
                print(f"ログファイル書き込みエラー (stdout): {e}")

    def log_step(self, *args, end="\n", success=None, char=None, back=0):
        if char is None:
            if success is True:
                full_message = "✅ " + " ".join(map(str, args))
            elif success is False:
                full_message = "❌ " + " ".join(map(str, args))
            else:
                full_message = "🔹 " + " ".join(map(str, args))
        else:
            full_message = char + " " + " ".join(map(str, args))
        self.debug_print(full_message, end=end, back=back+1)

    def what_do_you_do(self, message, command):
        length = 100
        self.debug_print("\n" + "=" * length, back=1)
        mode_msg = "Silent mode: 即実行" if self.silent_mode else "Action mode: コマンド入力"
        self.debug_print(f"\n🔹🔹🔹🔹🔹 No.{self.wNo} {mode_msg} 🔹🔹🔹🔹🔹\n" + "-" * length, back=1)
        self.wNo += 1
        self.debug_print(f"\n🎮説明\n{message}", back=1)
        self.debug_print(f"\n🤔アクション\n{command}\n" + "-" * length, back=1)
        if not self.silent_mode:
            self.debug_print("\n📠コマンド\n1️⃣ 実行する 2️⃣ やめておく 3️⃣ コマンドを変更する 4️⃣ ここで中断", back=1)
            choice = input("\n🔹 どうする？ (1/2/3/4): ").strip()
            if choice == "1":
                pass
            elif choice == "2":
                self.debug_print("\n🛑 操作をキャンセルしました。", back=1)
                return None, None
            elif choice == "3":
                command = input("\n💬 新しいコマンドを入力してください: ").strip()
            elif choice == "4":
                self.debug_print("\n👋 中断します。", back=1)
                sys.exit(1)
            else:
                self.debug_print("\n⚠️ 無効な選択肢です", back=1)
                return None, None
        self.debug_print(f"\n🚀 実行中:\n{command}", back=1)
        try:
            result = subprocess.run(command, shell=True, capture_output=True, text=True)
            self.debug_print("\n✅ コマンド実行完了\n" + "-" * length, back=1)
            self.debug_print(f"\nstdout:\n{result.stdout}", back=1)
            self.debug_print(f"\nstderr:\n{result.stderr}\n" + "=" * length + "\n\n\n", back=1)
            return result.stdout, result.stderr
        except Exception as e:
            self.debug_print(f"\n❌ コマンド実行中にエラー: {e}", back=1)
            return None, None

    def get_current_method_info(self, back=0):
        frame = inspect.currentframe()
        for _ in range(2 + back):
            if frame is None or frame.f_back is None:
                break
            frame = frame.f_back
        method_name = frame.f_code.co_name if frame else "Unknown"
        cls_name = None
        if frame and 'self' in frame.f_locals:
            cls_name = frame.f_locals['self'].__class__.__name__
        return cls_name, method_name

    def add_entry(self, category, description, success=None):
        status = "✅ 成功" if success is True else "❌ 失敗" if success is False else "⚠️ 未判定"
        entry = {"カテゴリ": category, "処理内容": description, "結果": status}
        self.entries.append(entry)

    def display(self):
        """チェックリストをコンソールとstdout用ログファイルに表示する"""
        output_lines = []
        output_lines.append("\n🔹 **チェックリスト** 🔹")
        for idx, entry in enumerate(self.entries, start=1):
            category = entry.get("カテゴリ", entry.get("ステップ", "不明"))
            description = entry.get("処理内容", entry.get("内容", "説明なし"))
            result = entry.get("結果", "⚠️ 未判定")
            line = f"Step {idx}: [{category}] {description} → {result}"
            output_lines.append(line)

        for line in output_lines:
            print(line)

        if self.log_to_file_stdout and self.log_file_path_stdout:
            try:
                with open(self.log_file_path_stdout, "a", encoding="utf-8") as f:
                    for line in output_lines:
                        f.write(line + "\n")
            except Exception as e:
                self.debug_print(f"stdoutログファイルへの出力エラー: {e}")

    def export_log(self):
        """チェックリストをstdout用ログファイルに出力する"""
        if not self.log_file_path_stdout:
            self.debug_print("⚠️ stdoutログファイルパスが設定されていません。", back=1)
            return
        try:
            with open(self.log_file_path_stdout, "w", encoding="utf-8") as f:
                for idx, entry in enumerate(self.entries, start=1):
                    category = entry.get("カテゴリ", entry.get("ステップ", "不明"))
                    description = entry.get("処理内容", entry.get("内容", "説明なし"))
                    result = entry.get("結果", "⚠️ 未判定")
                    f.write(f"Step {idx}: [{category}] {description} → {result}\n")
            print(f"✅ チェックリストを {self.log_file_path_stdout} に保存しました。")
        except Exception as e:
            self.debug_print(f"stdoutログファイルへの保存エラー: {e}", back=1)

    def clear(self):
        self.entries = []
        self.debug_print("✅ チェックリストをリセットしました。", back=1)


    def run_command(self, command, timeout=900, back=1, stdout=False, stderr=False, env=None):
        """
        シェルコマンドをリアルタイムで実行し、コンソールとそれぞれのログファイルに出力する。

        Args:
            command (str): 実行するシェルコマンド
            timeout (int): タイムアウト時間（秒）
            back (int): ログ出力のオフセット
            stdout (bool): True の場合、標準出力をキャプチャする
            stderr (bool): True の場合、標準エラー出力をキャプチャする
            env (dict): サブプロセスで使用する環境変数。Noneの場合は、os.environ.copy() が使われる。

        Returns:
            tuple: (終了コード, 標準出力 (str or None), 標準エラー出力 (str or None))
        """
        self.log_step(f"コマンド実行: {command}", success=None, back=back)
        stdout_data, stderr_data = [], []

        def monitor_output(stream, log_func, capture_list, log_file):
            try:
                for line in iter(stream.readline, ''):
                    log_func(line)
                    sys.stdout.flush()
                    capture_list.append(line)
                    if log_file:
                        log_file.write(line)
                        log_file.flush()
            except Exception as e:
                self.log_step(f"ストリーム処理中エラー: {str(e)}", success=False, back=back, char="💥")

        try:
            # envが指定されていなければ、現在の環境変数をコピー
            if env is None:
                env = os.environ.copy()

            process = subprocess.Popen(
                command,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                bufsize=1,
                env=env
            )

            if self.log_to_file_stdout and self.log_file_path_stdout:
                log_file_stdout = open(self.log_file_path_stdout, "a", encoding="utf-8")
            else:
                log_file_stdout = None

            if self.log_to_file_stderr and self.log_file_path_stderr:
                log_file_stderr = open(self.log_file_path_stderr, "a", encoding="utf-8")
            else:
                log_file_stderr = None

            stdout_thread = threading.Thread(target=monitor_output, args=(process.stdout, sys.stdout.write, stdout_data, log_file_stdout))
            stderr_thread = threading.Thread(target=monitor_output, args=(process.stderr, sys.stderr.write, stderr_data, log_file_stderr))

            stdout_thread.start()
            stderr_thread.start()

            process.wait(timeout=timeout)
            stdout_thread.join()
            stderr_thread.join()

            if log_file_stdout:
                log_file_stdout.close()
            if log_file_stderr:
                log_file_stderr.close()

            stdout_result = ''.join(stdout_data) if stdout else None
            stderr_result = ''.join(stderr_data) if stderr else None

            if process.returncode == 0:
                self.log_step(f"コマンド成功: {command} (コード: {process.returncode})", success=True, back=back)
            else:
                self.log_step(f"コマンド失敗: {command} (コード: {process.returncode})", success=False, back=back)

            return process.returncode, stdout_result, stderr_result

        except subprocess.TimeoutExpired:
            self.log_step(f"⏳ タイムアウト: {command}", char="⚠️", back=back)
            return -1, None, None
        except Exception as e:
            self.log_step(f"💥 実行エラー: {command}\n{str(e)}", success=False, back=back)
            return -2, None, None

"""## 2. テスト"""

# @title a. テスト {"form-width":"400px"}
class TestClass:
    def __init__(self):
        self.debugger = DebugHelper()
        self.debugger.debug_print("TestClassのコンストラクタが呼ばれました。")
        self.debugger.log_step("TestClassのコンストラクタが呼ばれました。", success=True)
        self.debugger.add_entry("テストクラス", "TestClassのコンストラクタが呼ばれました。", success=True)
        self.debugger.add_step("テストクラス", "TestClassのコンストラクタが呼ばれました。")
        self.debugger.display()
        self.debugger.export_log()
        self.debugger.clear()


    def test_method(self):
        self.debugger.enable_log_to_file_stdout()
        self.debugger.enable_log_to_file_stderr()
        self.debugger.enable_timestamp()
        self.debugger.enable_silent_mode()
        self.debugger.log_step("にゃにゃにゃふ", char = "🐈")
        self.debugger.log_step("にゃにゃにゃふ", char = "🐈", back = 1)
        self.debugger.add_entry("テストメソッド", "test_methodが呼ばれました。", success=True)
        # self.debugger.what_do_you_do("バカめ!!!", "echo バカめバカめバカめ!!!")
        self.debugger.disable_silent_mode()
        # self.debugger.what_do_you_do("そうはいくか!!!!", "echo ちぇすとぉぉぉぉ!!!")
        self.debugger.run_command( "ls -l" )
        result, stdout, stderr = self.debugger.run_command("nvcc --version", stdout = True, stderr = True)
        print( f"result : {result}")
        print( f"stdout : {stdout}")
        print( f"stderr : {stderr}")
        if not result:
            for line in stdout.split("\n"):
                if "release" in line:
                    version = line.split(",")[1].strip().split(" ")[1]
                    self.debugger.log_step(f"CUDA バージョン検出: {version}", success=True)
                    break



if __name__ == "__main__":
    tc1 = TestClass()
    tc1.test_method()